<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://livescript.net"

    >livescript (v1.5.0)</a>
</h1>
<h4>LiveScript is a language which compiles to JavaScript. It has a straightforward mapping to JavaScript and allows you to write expressive code devoid of repetitive boilerplate. While LiveScript adds many features to assist in functional style programming, </h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript">module livescript</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.addListener">
            function <span class="apidocSignatureSpan">livescript.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast">
            function <span class="apidocSignatureSpan">livescript.</span>ast
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.asObj">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.asObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.toSlice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.toSlice
            <span class="apidocSignatureSpan">(o, base, symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileConditional
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileDestructuring
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileMinMax
            <span class="apidocSignatureSpan">(o, left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileSplice
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileSpread
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendArr">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.rendArr
            <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendObj">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.rendObj
            <span class="apidocSignatureSpan">(o, nodes, rite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.unfoldAssign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileAnyInstanceOf
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileChain">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileChain
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileCompose
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileConcat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileDeepEq
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileExistence
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileJoin
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMethod
            <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMinMax
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMod">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMod
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compilePartial
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePow">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compilePow
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRegexEquals
            <span class="apidocSignatureSpan">(o, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRemove
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRepeat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileSplit
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileXor">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileXor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.getDefault">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.getDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invertIt">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.invertIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.mapOp">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.mapOp
            <span class="apidocSignatureSpan">(op)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.xorChildren
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.add">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.chomp">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.chomp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileExpressions
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileRoot">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileRoot
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileWithDeclarations
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.neck">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.neck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.pipe">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.pipe
            <span class="apidocSignatureSpan">(target, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.prepend">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.prepend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.toJSON">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Box">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Box
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Call
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.makeReturn
            <span class="apidocSignatureSpan">(ret)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Case
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.compileCase">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.compileCase
            <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.add">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.autoCompare
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.cacheReference
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandBind">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandBind
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandSlice
            <span class="apidocSignatureSpan">(o, assign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandSplat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandStar">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandStar
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandVivify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.flipIt">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.flipIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getCall">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.getCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isSimpleAccess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isStatement
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unfoldAssign
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Class
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype.compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype.ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.CopyL">
            function <span class="apidocSignatureSpan">livescript.</span>ast.CopyL
            <span class="apidocSignatureSpan">(a, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Decl">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Decl
            <span class="apidocSignatureSpan">(type, nodes, lno)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Existence
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For">
            function <span class="apidocSignatureSpan">livescript.</span>ast.For
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.addBody">
            function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileParams">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.compileParams
            <span class="apidocSignatureSpan">(o, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.named">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.named
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.traverseChildren
            <span class="apidocSignatureSpan">(arg$, xscope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileExpression">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileExpression
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileStatement">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileStatement
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileAssign">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.compileAssign
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In">
            function <span class="apidocSignatureSpan">livescript.</span>ast.In
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.In.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS">
            function <span class="apidocSignatureSpan">livescript.</span>ast.JS
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.compile
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.L">
            function <span class="apidocSignatureSpan">livescript.</span>ast.L
            <span class="apidocSignatureSpan">(a, b, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isWhat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isWhat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Obj
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.toSlice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype.toSlice
            <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isComplex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.unparen">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.unparen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.compileAccessor
            <span class="apidocSignatureSpan">(o, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.compileDescriptor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Require
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Require.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Return.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Slice
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Splat
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype.compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype.makeReturn
            <span class="apidocSignatureSpan">(makeReturnArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Super.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype.getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileAsFunc
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compilePluck
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileSpread
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.getAccessors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Util
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Util.prototype.compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Vars
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Vars.prototype.compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addBody">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addGuard">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addGuard
            <span class="apidocSignatureSpan">(guard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addObjComp">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addObjComp
            <span class="apidocSignatureSpan">(objComp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileBody">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.compileBody
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeComprehension">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.makeComprehension
            <span class="apidocSignatureSpan">(toAdd, loops)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Yield
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.fromJSON">
            function <span class="apidocSignatureSpan">livescript.</span>ast.fromJSON
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.parse">
            function <span class="apidocSignatureSpan">livescript.</span>ast.parse
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.command">
            function <span class="apidocSignatureSpan">livescript.</span>command
            <span class="apidocSignatureSpan">(args, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.compile">
            function <span class="apidocSignatureSpan">livescript.</span>compile
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.emit">
            function <span class="apidocSignatureSpan">livescript.</span>emit
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.eventNames">
            function <span class="apidocSignatureSpan">livescript.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.getMaxListeners">
            function <span class="apidocSignatureSpan">livescript.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.go">
            function <span class="apidocSignatureSpan">livescript.</span>go
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lex">
            function <span class="apidocSignatureSpan">livescript.</span>lex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.listenerCount">
            function <span class="apidocSignatureSpan">livescript.</span>listenerCount
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.listeners">
            function <span class="apidocSignatureSpan">livescript.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.load">
            function <span class="apidocSignatureSpan">livescript.</span>load
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.node">
            function <span class="apidocSignatureSpan">livescript.</span>node
            <span class="apidocSignatureSpan">(LiveScript)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.on">
            function <span class="apidocSignatureSpan">livescript.</span>on
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.once">
            function <span class="apidocSignatureSpan">livescript.</span>once
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.prependListener">
            function <span class="apidocSignatureSpan">livescript.</span>prependListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.prependOnceListener">
            function <span class="apidocSignatureSpan">livescript.</span>prependOnceListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.removeAllListeners">
            function <span class="apidocSignatureSpan">livescript.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.removeListener">
            function <span class="apidocSignatureSpan">livescript.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.run">
            function <span class="apidocSignatureSpan">livescript.</span>run
            <span class="apidocSignatureSpan">(code, options, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.setMaxListeners">
            function <span class="apidocSignatureSpan">livescript.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.stab">
            function <span class="apidocSignatureSpan">livescript.</span>stab
            <span class="apidocSignatureSpan">(code, callback, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens">
            function <span class="apidocSignatureSpan">livescript.</span>tokens
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens.rewrite">
            function <span class="apidocSignatureSpan">livescript.</span>tokens.rewrite
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Arr.superclass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Assign.superclass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.In.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Literal.superclass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Require.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Return.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Super.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Util.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Vars.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>lexer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.addListener">module livescript.addListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.addListener.addListener">
            function <span class="apidocSignatureSpan">livescript.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast">module livescript.ast</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.ast">
            function <span class="apidocSignatureSpan">livescript.</span>ast
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Block
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Box">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Box
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Call
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Case
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Class
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.CopyL">
            function <span class="apidocSignatureSpan">livescript.ast.</span>CopyL
            <span class="apidocSignatureSpan">(a, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Decl">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Decl
            <span class="apidocSignatureSpan">(type, nodes, lno)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For">
            function <span class="apidocSignatureSpan">livescript.ast.</span>For
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If">
            function <span class="apidocSignatureSpan">livescript.ast.</span>If
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Import
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In">
            function <span class="apidocSignatureSpan">livescript.ast.</span>In
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Index
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS">
            function <span class="apidocSignatureSpan">livescript.ast.</span>JS
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Key
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.L">
            function <span class="apidocSignatureSpan">livescript.ast.</span>L
            <span class="apidocSignatureSpan">(a, b, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Label
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Require
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Try
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Util
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Var
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While">
            function <span class="apidocSignatureSpan">livescript.ast.</span>While
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.fromJSON">
            function <span class="apidocSignatureSpan">livescript.ast.</span>fromJSON
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.parse">
            function <span class="apidocSignatureSpan">livescript.ast.</span>parse
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr">module livescript.ast.Arr</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.Arr">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>compile
            <span class="apidocSignatureSpan">(o, items, deepEq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.maybe">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>maybe
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.wrap">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>wrap
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Arr.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype">module livescript.ast.Arr.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.asObj">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>asObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>constructor
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.toSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>toSlice
            <span class="apidocSignatureSpan">(o, base, symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype.asObj">module livescript.ast.Arr.prototype.asObj</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.asObj.asObj">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>asObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype.compile">module livescript.ast.Arr.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype.isArray">module livescript.ast.Arr.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype.toSlice">module livescript.ast.Arr.prototype.toSlice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.toSlice.toSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>toSlice
            <span class="apidocSignatureSpan">(o, base, symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.superclass.prototype">module livescript.ast.Arr.superclass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.named">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>named
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign">module livescript.ast.Assign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.Assign">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Assign.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype">module livescript.ast.Assign.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileConditional
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileDestructuring
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileMinMax
            <span class="apidocSignatureSpan">(o, left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSplice
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSpread
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>constructor
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendArr">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendArr
            <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendObj">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendObj
            <span class="apidocSignatureSpan">(o, nodes, rite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.assigns">module livescript.ast.Assign.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileConditional">module livescript.ast.Assign.prototype.compileConditional</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional.compileConditional">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileConditional
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileDestructuring">module livescript.ast.Assign.prototype.compileDestructuring</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring.compileDestructuring">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileDestructuring
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileMinMax">module livescript.ast.Assign.prototype.compileMinMax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileMinMax
            <span class="apidocSignatureSpan">(o, left, right)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileNode">module livescript.ast.Assign.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileSplice">module livescript.ast.Assign.prototype.compileSplice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice.compileSplice">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSplice
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileSpread">module livescript.ast.Assign.prototype.compileSpread</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread.compileSpread">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSpread
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.isArray">module livescript.ast.Assign.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.isCallable">module livescript.ast.Assign.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.isRegex">module livescript.ast.Assign.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.isString">module livescript.ast.Assign.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.rendArr">module livescript.ast.Assign.prototype.rendArr</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendArr.rendArr">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendArr
            <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.rendObj">module livescript.ast.Assign.prototype.rendObj</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendObj.rendObj">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendObj
            <span class="apidocSignatureSpan">(o, nodes, rite)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.show">module livescript.ast.Assign.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.unfoldAssign">module livescript.ast.Assign.prototype.unfoldAssign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.unfoldSoak">module livescript.ast.Assign.prototype.unfoldSoak</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.superclass.prototype">module livescript.ast.Assign.superclass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.addElse">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>addElse
            <span class="apidocSignatureSpan">($else)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.anaphorize">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>anaphorize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>assigns
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.cache">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>cache
            <span class="apidocSignatureSpan">(o, once, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.carp">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>carp
            <span class="apidocSignatureSpan">(msg, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compile
            <span class="apidocSignatureSpan">(options, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileBlock">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileBlock
            <span class="apidocSignatureSpan">(o, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileClosure">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileClosure
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileLoopReference">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileLoopReference
            <span class="apidocSignatureSpan">(o, name, ret, safeAccess)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileSpreadOver">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileSpreadOver
            <span class="apidocSignatureSpan">(o, list, transform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.delegate">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>delegate
            <span class="apidocSignatureSpan">(names, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.eachChild">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>eachChild
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.expandSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>expandSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getAccessors">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getAccessors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getCall">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getDefault">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invertCheck">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invertCheck
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isMatcher">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isMatcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(ref, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>ripName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.stringify">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>stringify
            <span class="apidocSignatureSpan">(space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toJSON">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toString
            <span class="apidocSignatureSpan">(idt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.traverseChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>traverseChildren
            <span class="apidocSignatureSpan">(fn, xscope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unparen">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unparen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary">module livescript.ast.Binary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.Binary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Binary.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype">module livescript.ast.Binary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileAnyInstanceOf
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileChain">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileChain
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileCompose
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileConcat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileDeepEq
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileExistence
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileJoin
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMethod
            <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMinMax
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMod">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMod
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePartial
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePow">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePow
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRegexEquals
            <span class="apidocSignatureSpan">(o, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRemove
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRepeat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileSplit
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileXor">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileXor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>constructor
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.getDefault">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>getDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invertIt">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invertIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.mapOp">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>mapOp
            <span class="apidocSignatureSpan">(op)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>xorChildren
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileAnyInstanceOf">module livescript.ast.Binary.prototype.compileAnyInstanceOf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf.compileAnyInstanceOf">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileAnyInstanceOf
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileChain">module livescript.ast.Binary.prototype.compileChain</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileChain.compileChain">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileChain
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileCompose">module livescript.ast.Binary.prototype.compileCompose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose.compileCompose">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileCompose
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileConcat">module livescript.ast.Binary.prototype.compileConcat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat.compileConcat">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileConcat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileDeepEq">module livescript.ast.Binary.prototype.compileDeepEq</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq.compileDeepEq">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileDeepEq
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileExistence">module livescript.ast.Binary.prototype.compileExistence</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence.compileExistence">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileExistence
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileJoin">module livescript.ast.Binary.prototype.compileJoin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin.compileJoin">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileJoin
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMethod">module livescript.ast.Binary.prototype.compileMethod</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod.compileMethod">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMethod
            <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMinMax">module livescript.ast.Binary.prototype.compileMinMax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMinMax
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMod">module livescript.ast.Binary.prototype.compileMod</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMod.compileMod">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMod
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileNode">module livescript.ast.Binary.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compilePartial">module livescript.ast.Binary.prototype.compilePartial</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial.compilePartial">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePartial
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compilePow">module livescript.ast.Binary.prototype.compilePow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePow.compilePow">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePow
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRegexEquals">module livescript.ast.Binary.prototype.compileRegexEquals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals.compileRegexEquals">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRegexEquals
            <span class="apidocSignatureSpan">(o, arg$)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRemove">module livescript.ast.Binary.prototype.compileRemove</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove.compileRemove">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRemove
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRepeat">module livescript.ast.Binary.prototype.compileRepeat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat.compileRepeat">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRepeat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileSplit">module livescript.ast.Binary.prototype.compileSplit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit.compileSplit">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileSplit
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileXor">module livescript.ast.Binary.prototype.compileXor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileXor.compileXor">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileXor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.getDefault">module livescript.ast.Binary.prototype.getDefault</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.getDefault.getDefault">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>getDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.invert">module livescript.ast.Binary.prototype.invert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invert.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.invertIt">module livescript.ast.Binary.prototype.invertIt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invertIt.invertIt">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invertIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.isArray">module livescript.ast.Binary.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.isCallable">module livescript.ast.Binary.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.isString">module livescript.ast.Binary.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.mapOp">module livescript.ast.Binary.prototype.mapOp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.mapOp.mapOp">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>mapOp
            <span class="apidocSignatureSpan">(op)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.show">module livescript.ast.Binary.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.xorChildren">module livescript.ast.Binary.prototype.xorChildren</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren.xorChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>xorChildren
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block">module livescript.ast.Block</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.Block">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Block
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Block.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Block.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype">module livescript.ast.Block.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.add">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.chomp">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>chomp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileExpressions
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileRoot">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileRoot
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileWithDeclarations
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>constructor
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.neck">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>neck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.pipe">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>pipe
            <span class="apidocSignatureSpan">(target, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.prepend">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>prepend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.toJSON">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.add">module livescript.ast.Block.prototype.add</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.add.add">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.chomp">module livescript.ast.Block.prototype.chomp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.chomp.chomp">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>chomp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.compile">module livescript.ast.Block.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.compileExpressions">module livescript.ast.Block.prototype.compileExpressions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions.compileExpressions">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileExpressions
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.compileRoot">module livescript.ast.Block.prototype.compileRoot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileRoot.compileRoot">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileRoot
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.compileWithDeclarations">module livescript.ast.Block.prototype.compileWithDeclarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations.compileWithDeclarations">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileWithDeclarations
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.getJump">module livescript.ast.Block.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.isArray">module livescript.ast.Block.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.isCallable">module livescript.ast.Block.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.isComplex">module livescript.ast.Block.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.isRegex">module livescript.ast.Block.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.isString">module livescript.ast.Block.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.makeReturn">module livescript.ast.Block.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.neck">module livescript.ast.Block.prototype.neck</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.neck.neck">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>neck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.pipe">module livescript.ast.Block.prototype.pipe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.pipe.pipe">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>pipe
            <span class="apidocSignatureSpan">(target, type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.prepend">module livescript.ast.Block.prototype.prepend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.prepend.prepend">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>prepend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.toJSON">module livescript.ast.Block.prototype.toJSON</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.toJSON.toJSON">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.unwrap">module livescript.ast.Block.prototype.unwrap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.unwrap.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Box">module livescript.ast.Box</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Box.Box">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Box
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Call">module livescript.ast.Call</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.Call">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Call
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.back">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>back
            <span class="apidocSignatureSpan">(params, node, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.block">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>block
            <span class="apidocSignatureSpan">(fun, args, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.let">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>let
            <span class="apidocSignatureSpan">(args, body, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.make">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>make
            <span class="apidocSignatureSpan">(callee, args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Call.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Call.prototype">module livescript.ast.Call.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>constructor
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Call.prototype.compile">module livescript.ast.Call.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Call.prototype.show">module livescript.ast.Call.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade">module livescript.ast.Cascade</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.Cascade">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Cascade.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype">module livescript.ast.Cascade.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>constructor
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(ret)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.compileNode">module livescript.ast.Cascade.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.getJump">module livescript.ast.Cascade.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.isArray">module livescript.ast.Cascade.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.isCallable">module livescript.ast.Cascade.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.isRegex">module livescript.ast.Cascade.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.isString">module livescript.ast.Cascade.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.makeReturn">module livescript.ast.Cascade.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(ret)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.show">module livescript.ast.Cascade.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case">module livescript.ast.Case</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.Case">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Case
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Case.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Case.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case.prototype">module livescript.ast.Case.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.compileCase">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>compileCase
            <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>constructor
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case.prototype.compileCase">module livescript.ast.Case.prototype.compileCase</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.compileCase.compileCase">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>compileCase
            <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case.prototype.isCallable">module livescript.ast.Case.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case.prototype.makeReturn">module livescript.ast.Case.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain">module livescript.ast.Chain</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.Chain">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Chain.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype">module livescript.ast.Chain.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.add">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>autoCompare
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>cacheReference
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>constructor
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandBind">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandBind
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSlice
            <span class="apidocSignatureSpan">(o, assign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSplat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandStar">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandStar
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandVivify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.flipIt">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>flipIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getCall">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isSimpleAccess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isStatement
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.add">module livescript.ast.Chain.prototype.add</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.add.add">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.assigns">module livescript.ast.Chain.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.autoCompare">module livescript.ast.Chain.prototype.autoCompare</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare.autoCompare">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>autoCompare
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.cacheReference">module livescript.ast.Chain.prototype.cacheReference</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference.cacheReference">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>cacheReference
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.compileNode">module livescript.ast.Chain.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.expandBind">module livescript.ast.Chain.prototype.expandBind</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandBind.expandBind">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandBind
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.expandSlice">module livescript.ast.Chain.prototype.expandSlice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice.expandSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSlice
            <span class="apidocSignatureSpan">(o, assign)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.expandSplat">module livescript.ast.Chain.prototype.expandSplat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat.expandSplat">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSplat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.expandStar">module livescript.ast.Chain.prototype.expandStar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandStar.expandStar">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandStar
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.expandVivify">module livescript.ast.Chain.prototype.expandVivify</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify.expandVivify">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandVivify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.flipIt">module livescript.ast.Chain.prototype.flipIt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.flipIt.flipIt">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>flipIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.getCall">module livescript.ast.Chain.prototype.getCall</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getCall.getCall">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.getJump">module livescript.ast.Chain.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isArray">module livescript.ast.Chain.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isAssignable">module livescript.ast.Chain.prototype.isAssignable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isCallable">module livescript.ast.Chain.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isComplex">module livescript.ast.Chain.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isRegex">module livescript.ast.Chain.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isSimpleAccess">module livescript.ast.Chain.prototype.isSimpleAccess</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess.isSimpleAccess">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isSimpleAccess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isStatement">module livescript.ast.Chain.prototype.isStatement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isStatement.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isStatement
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isString">module livescript.ast.Chain.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.makeReturn">module livescript.ast.Chain.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.unfoldAssign">module livescript.ast.Chain.prototype.unfoldAssign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.unfoldSoak">module livescript.ast.Chain.prototype.unfoldSoak</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.unwrap">module livescript.ast.Chain.prototype.unwrap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unwrap.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.varName">module livescript.ast.Chain.prototype.varName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.varName.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Class">module livescript.ast.Class</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.Class">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Class
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Class.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Class.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Class.prototype">module livescript.ast.Class.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>constructor
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Class.prototype.compile">module livescript.ast.Class.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Class.prototype.ripName">module livescript.ast.Class.prototype.ripName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.ripName.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.CopyL">module livescript.ast.CopyL</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.CopyL.CopyL">
            function <span class="apidocSignatureSpan">livescript.ast.</span>CopyL
            <span class="apidocSignatureSpan">(a, node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Decl">module livescript.ast.Decl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Decl.Decl">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Decl
            <span class="apidocSignatureSpan">(type, nodes, lno)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence">module livescript.ast.Existence</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.Existence">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Existence.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence.prototype">module livescript.ast.Existence.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence.prototype.compileNode">module livescript.ast.Existence.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence.prototype.invert">module livescript.ast.Existence.prototype.invert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.invert.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence.prototype.show">module livescript.ast.Existence.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For">module livescript.ast.For</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.For">
            function <span class="apidocSignatureSpan">livescript.ast.</span>For
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.For.</span>superclass
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.For.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For.prototype">module livescript.ast.For.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.addBody">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>aSource</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For.prototype.addBody">module livescript.ast.For.prototype.addBody</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.addBody.addBody">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For.prototype.compileNode">module livescript.ast.For.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For.prototype.show">module livescript.ast.For.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun">module livescript.ast.Fun</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.Fun">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Fun.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype">module livescript.ast.Fun.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileParams">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileParams
            <span class="apidocSignatureSpan">(o, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>constructor
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.named">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>named
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>traverseChildren
            <span class="apidocSignatureSpan">(arg$, xscope)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.compileNode">module livescript.ast.Fun.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.compileParams">module livescript.ast.Fun.prototype.compileParams</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileParams.compileParams">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileParams
            <span class="apidocSignatureSpan">(o, scope)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.isStatement">module livescript.ast.Fun.prototype.isStatement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.isStatement.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.makeReturn">module livescript.ast.Fun.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.named">module livescript.ast.Fun.prototype.named</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.named.named">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>named
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.ripName">module livescript.ast.Fun.prototype.ripName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.ripName.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.show">module livescript.ast.Fun.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.traverseChildren">module livescript.ast.Fun.prototype.traverseChildren</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren.traverseChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>traverseChildren
            <span class="apidocSignatureSpan">(arg$, xscope)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If">module livescript.ast.If</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.If">
            function <span class="apidocSignatureSpan">livescript.ast.</span>If
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.If.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.If.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o, parent, name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.If.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype">module livescript.ast.If.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileExpression">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileExpression
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileStatement">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileStatement
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>constructor
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>aTargets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>aSource</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.compileExpression">module livescript.ast.If.prototype.compileExpression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileExpression.compileExpression">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileExpression
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.compileNode">module livescript.ast.If.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.compileStatement">module livescript.ast.If.prototype.compileStatement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileStatement.compileStatement">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileStatement
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.getJump">module livescript.ast.If.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.isArray">module livescript.ast.If.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.isCallable">module livescript.ast.If.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.isRegex">module livescript.ast.If.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.isString">module livescript.ast.If.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.makeReturn">module livescript.ast.If.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.show">module livescript.ast.If.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import">module livescript.ast.Import</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.Import">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Import
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Import.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Import.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype">module livescript.ast.Import.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileAssign
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>constructor
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.compileAssign">module livescript.ast.Import.prototype.compileAssign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileAssign.compileAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileAssign
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.compileNode">module livescript.ast.Import.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.isArray">module livescript.ast.Import.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.isCallable">module livescript.ast.Import.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.show">module livescript.ast.Import.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.unfoldSoak">module livescript.ast.Import.prototype.unfoldSoak</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.In">module livescript.ast.In</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.In">
            function <span class="apidocSignatureSpan">livescript.ast.</span>In
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.In.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.In.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.In.prototype">module livescript.ast.In.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>constructor
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.In.prototype.compileNode">module livescript.ast.In.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index">module livescript.ast.Index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.Index">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Index
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Index.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Index.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype">module livescript.ast.Index.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>constructor
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype.compile">module livescript.ast.Index.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype.isComplex">module livescript.ast.Index.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype.show">module livescript.ast.Index.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype.varName">module livescript.ast.Index.prototype.varName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.varName.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS">module livescript.ast.JS</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.JS">
            function <span class="apidocSignatureSpan">livescript.ast.</span>JS
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.JS.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.JS.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS.prototype">module livescript.ast.JS.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>compile
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>constructor
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS.prototype.compile">module livescript.ast.JS.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>compile
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS.prototype.isCallable">module livescript.ast.JS.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS.prototype.show">module livescript.ast.JS.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump">module livescript.ast.Jump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.Jump">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.extended">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>extended
            <span class="apidocSignatureSpan">(sub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.return">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.throw">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Jump.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype">module livescript.ast.Jump.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>constructor
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype.compileNode">module livescript.ast.Jump.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype.getJump">module livescript.ast.Jump.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype.makeReturn">module livescript.ast.Jump.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype.show">module livescript.ast.Jump.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key">module livescript.ast.Key</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.Key">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Key
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Key.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Key.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype">module livescript.ast.Key.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype.assigns">module livescript.ast.Key.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype.compile">module livescript.ast.Key.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype.isComplex">module livescript.ast.Key.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype.show">module livescript.ast.Key.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype.varName">module livescript.ast.Key.prototype.varName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.varName.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.L">module livescript.ast.L</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.L.L">
            function <span class="apidocSignatureSpan">livescript.ast.</span>L
            <span class="apidocSignatureSpan">(a, b, node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label">module livescript.ast.Label</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.Label">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Label
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Label.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Label.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype">module livescript.ast.Label.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>constructor
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.compileNode">module livescript.ast.Label.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.getJump">module livescript.ast.Label.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.isArray">module livescript.ast.Label.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.isCallable">module livescript.ast.Label.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.makeReturn">module livescript.ast.Label.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.show">module livescript.ast.Label.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal">module livescript.ast.Literal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.Literal">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Literal.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype">module livescript.ast.Literal.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isWhat">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isWhat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.compile">module livescript.ast.Literal.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isCallable">module livescript.ast.Literal.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isComplex">module livescript.ast.Literal.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isEmpty">module livescript.ast.Literal.prototype.isEmpty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isRegex">module livescript.ast.Literal.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isString">module livescript.ast.Literal.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isWhat">module livescript.ast.Literal.prototype.isWhat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isWhat.isWhat">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isWhat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.makeReturn">module livescript.ast.Literal.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.maybeKey">module livescript.ast.Literal.prototype.maybeKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.varName">module livescript.ast.Literal.prototype.varName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.varName.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.superclass.prototype">module livescript.ast.Literal.superclass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Obj">module livescript.ast.Obj</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.Obj">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>compile
            <span class="apidocSignatureSpan">(o, items, deepEq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Obj.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Obj.prototype">module livescript.ast.Obj.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.asObj">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>asObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>constructor
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.toSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>toSlice
            <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Obj.prototype.compileNode">module livescript.ast.Obj.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Obj.prototype.toSlice">module livescript.ast.Obj.prototype.toSlice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.toSlice.toSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>toSlice
            <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens">module livescript.ast.Parens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.Parens">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Parens.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype">module livescript.ast.Parens.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isComplex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.unparen">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>unparen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.compile">module livescript.ast.Parens.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.isComplex">module livescript.ast.Parens.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isComplex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.isRegex">module livescript.ast.Parens.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.isString">module livescript.ast.Parens.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.show">module livescript.ast.Parens.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.unparen">module livescript.ast.Parens.prototype.unparen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.unparen.unparen">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>unparen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop">module livescript.ast.Prop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.Prop">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Prop.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype">module livescript.ast.Prop.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileAccessor
            <span class="apidocSignatureSpan">(o, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileDescriptor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>constructor
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype.assigns">module livescript.ast.Prop.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype.compileAccessor">module livescript.ast.Prop.prototype.compileAccessor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor.compileAccessor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileAccessor
            <span class="apidocSignatureSpan">(o, key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype.compileDescriptor">module livescript.ast.Prop.prototype.compileDescriptor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor.compileDescriptor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileDescriptor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype.show">module livescript.ast.Prop.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Require">module livescript.ast.Require</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.Require">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Require
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Require.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Require.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Require.prototype">module livescript.ast.Require.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>constructor
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Require.prototype.compile">module livescript.ast.Require.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Return">module livescript.ast.Return</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.Return">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.extended">
            function <span class="apidocSignatureSpan">livescript.ast.Return.</span>extended
            <span class="apidocSignatureSpan">(sub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Return.</span>superclass
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.throw">
            function <span class="apidocSignatureSpan">livescript.ast.Return.</span>throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Return.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Return.prototype">module livescript.ast.Return.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Return.prototype.compileNode">module livescript.ast.Return.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Slice">module livescript.ast.Slice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.Slice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Slice.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Slice.prototype">module livescript.ast.Slice.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>constructor
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Slice.prototype.compileNode">module livescript.ast.Slice.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Slice.prototype.show">module livescript.ast.Slice.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Splat">module livescript.ast.Splat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.Splat">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.compileArray">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>compileArray
            <span class="apidocSignatureSpan">(o, list, apply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Splat.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Splat.prototype">module livescript.ast.Splat.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isComplex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Splat.prototype.assigns">module livescript.ast.Splat.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Splat.prototype.compile">module livescript.ast.Splat.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.StepSlice">module livescript.ast.StepSlice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.StepSlice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.</span>superclass
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.StepSlice.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.StepSlice.prototype">module livescript.ast.StepSlice.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(makeReturnArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.StepSlice.prototype.compileNode">module livescript.ast.StepSlice.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.StepSlice.prototype.makeReturn">module livescript.ast.StepSlice.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(makeReturnArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Super">module livescript.ast.Super</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.Super">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Super.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Super.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Super.prototype">module livescript.ast.Super.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Super.prototype.compile">module livescript.ast.Super.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch">module livescript.ast.Switch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.Switch">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Switch.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype">module livescript.ast.Switch.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>constructor
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>aTargets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>aSource</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype.compileNode">module livescript.ast.Switch.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype.getJump">module livescript.ast.Switch.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype.isCallable">module livescript.ast.Switch.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype.makeReturn">module livescript.ast.Switch.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype.show">module livescript.ast.Switch.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Throw">module livescript.ast.Throw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.Throw">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.extended">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>extended
            <span class="apidocSignatureSpan">(sub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>superclass
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Throw.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Throw.prototype">module livescript.ast.Throw.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Throw.prototype.compileNode">module livescript.ast.Throw.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Throw.prototype.getJump">module livescript.ast.Throw.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try">module livescript.ast.Try</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.Try">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Try
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Try.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Try.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype">module livescript.ast.Try.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>constructor
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype.compileNode">module livescript.ast.Try.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype.getJump">module livescript.ast.Try.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype.isCallable">module livescript.ast.Try.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype.makeReturn">module livescript.ast.Try.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype.show">module livescript.ast.Try.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary">module livescript.ast.Unary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.Unary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Unary.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype">module livescript.ast.Unary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileAsFunc
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compilePluck
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileSpread
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>constructor
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>getAccessors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.compileAsFunc">module livescript.ast.Unary.prototype.compileAsFunc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc.compileAsFunc">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileAsFunc
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.compileNode">module livescript.ast.Unary.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.compilePluck">module livescript.ast.Unary.prototype.compilePluck</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck.compilePluck">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compilePluck
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.compileSpread">module livescript.ast.Unary.prototype.compileSpread</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread.compileSpread">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileSpread
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.getAccessors">module livescript.ast.Unary.prototype.getAccessors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors.getAccessors">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>getAccessors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.invert">module livescript.ast.Unary.prototype.invert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.invert.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.isArray">module livescript.ast.Unary.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.isCallable">module livescript.ast.Unary.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.isString">module livescript.ast.Unary.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.show">module livescript.ast.Unary.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.unfoldSoak">module livescript.ast.Unary.prototype.unfoldSoak</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Util">module livescript.ast.Util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.Util">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Util
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.Extends">
            function <span class="apidocSignatureSpan">livescript.ast.Util.</span>Extends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Util.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Util.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Util.prototype">module livescript.ast.Util.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>constructor
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Util.prototype.compile">module livescript.ast.Util.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var">module livescript.ast.Var</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.Var">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Var
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Var.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Var.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype">module livescript.ast.Var.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype.assigns">module livescript.ast.Var.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype.compile">module livescript.ast.Var.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype.maybeKey">module livescript.ast.Var.prototype.maybeKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.maybeKey.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype.varName">module livescript.ast.Var.prototype.varName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.varName.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Vars">module livescript.ast.Vars</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.Vars">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Vars.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Vars.prototype">module livescript.ast.Vars.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>constructor
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Vars.prototype.compile">module livescript.ast.Vars.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While">module livescript.ast.While</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.While">
            function <span class="apidocSignatureSpan">livescript.ast.</span>While
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.While.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.While.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype">module livescript.ast.While.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addBody">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addGuard">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addGuard
            <span class="apidocSignatureSpan">(guard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addObjComp">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addObjComp
            <span class="apidocSignatureSpan">(objComp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileBody">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileBody
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>constructor
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeComprehension">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeComprehension
            <span class="apidocSignatureSpan">(toAdd, loops)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>aTargets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>aSource</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.addBody">module livescript.ast.While.prototype.addBody</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addBody.addBody">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.addGuard">module livescript.ast.While.prototype.addGuard</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addGuard.addGuard">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addGuard
            <span class="apidocSignatureSpan">(guard)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.addObjComp">module livescript.ast.While.prototype.addObjComp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addObjComp.addObjComp">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addObjComp
            <span class="apidocSignatureSpan">(objComp)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.compileBody">module livescript.ast.While.prototype.compileBody</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileBody.compileBody">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileBody
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.compileNode">module livescript.ast.While.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.getJump">module livescript.ast.While.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.makeComprehension">module livescript.ast.While.prototype.makeComprehension</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeComprehension.makeComprehension">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeComprehension
            <span class="apidocSignatureSpan">(toAdd, loops)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.makeReturn">module livescript.ast.While.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.show">module livescript.ast.While.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield">module livescript.ast.Yield</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.Yield">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Yield.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield.prototype">module livescript.ast.Yield.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>constructor
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield.prototype.compileNode">module livescript.ast.Yield.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield.prototype.isCallable">module livescript.ast.Yield.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield.prototype.show">module livescript.ast.Yield.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.fromJSON">module livescript.ast.fromJSON</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.fromJSON.fromJSON">
            function <span class="apidocSignatureSpan">livescript.ast.</span>fromJSON
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.parse">module livescript.ast.parse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.parse.parse">
            function <span class="apidocSignatureSpan">livescript.ast.</span>parse
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.command">module livescript.command</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.command.command">
            function <span class="apidocSignatureSpan">livescript.</span>command
            <span class="apidocSignatureSpan">(args, arg$)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.compile">module livescript.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.compile.compile">
            function <span class="apidocSignatureSpan">livescript.</span>compile
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.emit">module livescript.emit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.emit.emit">
            function <span class="apidocSignatureSpan">livescript.</span>emit
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.eventNames">module livescript.eventNames</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.eventNames.eventNames">
            function <span class="apidocSignatureSpan">livescript.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.getMaxListeners">module livescript.getMaxListeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.getMaxListeners.getMaxListeners">
            function <span class="apidocSignatureSpan">livescript.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.go">module livescript.go</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.go.go">
            function <span class="apidocSignatureSpan">livescript.</span>go
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.lex">module livescript.lex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lex.lex">
            function <span class="apidocSignatureSpan">livescript.</span>lex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.lexer">module livescript.lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.able">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>able
            <span class="apidocSignatureSpan">(call)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.addInterpolated">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>addInterpolated
            <span class="apidocSignatureSpan">(parts, nlines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.adi">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>adi
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.carp">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>carp
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.checkConsistency">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>checkConsistency
            <span class="apidocSignatureSpan">(camel, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.countLines">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>countLines
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.dedent">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>dedent
            <span class="apidocSignatureSpan">(debt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doBackslash">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doBackslash
            <span class="apidocSignatureSpan">(code, lastIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doCase">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doCase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doComment">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doComment
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doHeredoc">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doHeredoc
            <span class="apidocSignatureSpan">(code, index, q)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doHeregex">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doHeregex
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doID">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doID
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doJS">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doJS
            <span class="apidocSignatureSpan">(code, lastIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doLine">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doLine
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doLiteral">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doLiteral
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doNumber">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doNumber
            <span class="apidocSignatureSpan">(code, lastIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doRegex">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doRegex
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doSpace">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doSpace
            <span class="apidocSignatureSpan">(code, lastIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doString">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doString
            <span class="apidocSignatureSpan">(code, index, q)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.dotcat">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>dotcat
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.fget">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>fget
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.forange">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>forange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.fset">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>fset
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.hasOwn">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>hasOwn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.indent">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>indent
            <span class="apidocSignatureSpan">(delta)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.interpolate">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>interpolate
            <span class="apidocSignatureSpan">(str, idx, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.lex">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>lex
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.newline">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>newline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.pair">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>pair
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.parameters">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>parameters
            <span class="apidocSignatureSpan">(arrow, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.regex">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>regex
            <span class="apidocSignatureSpan">(body, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.rewrite">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>rewrite
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.string">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>string
            <span class="apidocSignatureSpan">(q, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.strnum">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>strnum
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.token">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>token
            <span class="apidocSignatureSpan">(tag, value, callable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.tokenize">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>tokenize
            <span class="apidocSignatureSpan">(code, o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.unline">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>unline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.validate">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>validate
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">livescript.lexer.</span>dent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.lexer.</span>identifiers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.listenerCount">module livescript.listenerCount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.listenerCount.listenerCount">
            function <span class="apidocSignatureSpan">livescript.</span>listenerCount
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.listeners">module livescript.listeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.listeners.listeners">
            function <span class="apidocSignatureSpan">livescript.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.load">module livescript.load</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.load.load">
            function <span class="apidocSignatureSpan">livescript.</span>load
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.node">module livescript.node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.node.node">
            function <span class="apidocSignatureSpan">livescript.</span>node
            <span class="apidocSignatureSpan">(LiveScript)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.once">module livescript.once</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.once.once">
            function <span class="apidocSignatureSpan">livescript.</span>once
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.options">module livescript.options</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.options.generateHelp">
            function <span class="apidocSignatureSpan">livescript.options.</span>generateHelp
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.options.generateHelpForOption">
            function <span class="apidocSignatureSpan">livescript.options.</span>generateHelpForOption
            <span class="apidocSignatureSpan">(optionName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.options.parse">
            function <span class="apidocSignatureSpan">livescript.options.</span>parse
            <span class="apidocSignatureSpan">(input, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.options.parseArgv">
            function <span class="apidocSignatureSpan">livescript.options.</span>parseArgv
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.parser">module livescript.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.parser.Parser">
            function <span class="apidocSignatureSpan">livescript.parser.</span>Parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.parser.main">
            function <span class="apidocSignatureSpan">livescript.parser.</span>main
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.parser.parse">
            function <span class="apidocSignatureSpan">livescript.parser.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>parser</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.prependListener">module livescript.prependListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.prependListener.prependListener">
            function <span class="apidocSignatureSpan">livescript.</span>prependListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.prependOnceListener">module livescript.prependOnceListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.prependOnceListener.prependOnceListener">
            function <span class="apidocSignatureSpan">livescript.</span>prependOnceListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.removeAllListeners">module livescript.removeAllListeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.removeAllListeners.removeAllListeners">
            function <span class="apidocSignatureSpan">livescript.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.removeListener">module livescript.removeListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.removeListener.removeListener">
            function <span class="apidocSignatureSpan">livescript.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.run">module livescript.run</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.run.run">
            function <span class="apidocSignatureSpan">livescript.</span>run
            <span class="apidocSignatureSpan">(code, options, arg$)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.setMaxListeners">module livescript.setMaxListeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.setMaxListeners.setMaxListeners">
            function <span class="apidocSignatureSpan">livescript.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.stab">module livescript.stab</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.stab.stab">
            function <span class="apidocSignatureSpan">livescript.</span>stab
            <span class="apidocSignatureSpan">(code, callback, filename)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.tokens">module livescript.tokens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens.tokens">
            function <span class="apidocSignatureSpan">livescript.</span>tokens
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens.rewrite">
            function <span class="apidocSignatureSpan">livescript.tokens.</span>rewrite
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.tokens.rewrite">module livescript.tokens.rewrite</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens.rewrite.rewrite">
            function <span class="apidocSignatureSpan">livescript.tokens.</span>rewrite
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.util">module livescript.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.util.nameFromPath">
            function <span class="apidocSignatureSpan">livescript.util.</span>nameFromPath
            <span class="apidocSignatureSpan">(modulePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.util.stripString">
            function <span class="apidocSignatureSpan">livescript.util.</span>stripString
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript" id="apidoc.module.livescript">module livescript</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.addListener" id="apidoc.element.livescript.addListener">
        function <span class="apidocSignatureSpan">livescript.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast" id="apidoc.element.livescript.ast">
        function <span class="apidocSignatureSpan">livescript.</span>ast
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast = function (it){
  return parser.parse(typeof it === &#x27;string&#x27; ? lexer.lex(it) : it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    raw: o.lex
  });
  if (o.lex || o.tokens) {
    printTokens(t.tokens);
    throw null;
  }
  LiveScript.emit(&#x27;parse&#x27;, t);
  t.ast = LiveScript.<span class="apidocCodeKeywordSpan">ast</span>(t.tokens);
  say(o.json
    ? t.ast.stringify(2)
    : &#x27;&#x27;.trim.call(t.ast));
  throw null;
}
json = o.json || /\.json\.ls$/.test(filename);
run = o.run || o.eval;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr" id="apidoc.element.livescript.ast.Arr">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.asObj" id="apidoc.element.livescript.ast.Arr.prototype.asObj">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.asObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Arr.prototype.asObj = function (){
  var i, item;
  return Obj((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
      i = i$;
      item = ref$[i$];
      results$.push(Prop(Literal(i), item));
    }
    return results$;
  }.call(this)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.compile" id="apidoc.element.livescript.ast.Arr.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Arr.prototype.compile = function (o){
  var items, code;
  items = this.items;
  if (!items.length) {
    return sn(this, &#x27;[]&#x27;);
  }
  if (!snEmpty(code = Splat.compileArray(o, items))) {
    return this.newed
      ? sn(this, &#x22;(&#x22;, code, &#x22;)&#x22;)
      : sn(this, code);
  }
  return sn(null, sn(this, &#x22;[&#x22;), List.compile(o, items, this.deepEq), sn(this, &#x22;]&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.isArray" id="apidoc.element.livescript.ast.Arr.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.toSlice" id="apidoc.element.livescript.ast.Arr.prototype.toSlice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.toSlice
        <span class="apidocSignatureSpan">(o, base, symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Arr.prototype.toSlice = function (o, base, symbol){
  var items, ref$, ref, i$, len$, i, item, splat, chain;
  items = this.items;
  if (items.length &#x3e; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    item = items[i$];
    if (splat = item instanceof Splat) {
      item = item.it;
    }
    if (item.isEmpty()) {
      continue;
    }
    chain = Chain(base, [Index(item, symbol)]);
    items[i] = splat ? Splat(chain) : chain;
    base = ref;
  }
  chain || this.carp(&#x27;empty slice&#x27;);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign" id="apidoc.element.livescript.ast.Assign">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || &#x27;=&#x27;;
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += &#x27;&#x27;;
  this$[rite instanceof Node ? &#x27;right&#x27; : &#x27;unaries&#x27;] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.assigns" id="apidoc.element.livescript.ast.Assign.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.assigns = function (it){
  return this.left.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional" id="apidoc.element.livescript.ast.Assign.prototype.compileConditional">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileConditional
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileConditional = function (o, left){
  var lefts, morph;
  if (left instanceof Var &#x26;&#x26; in$(this.logic, [&#x27;?&#x27;]) &#x26;&#x26; this.op === &#x27;=&#x27;) {
    o.scope.declare(left.value, left);
  }
  lefts = Chain(left).cacheReference(o);
  o.level += LEVEL_OP &#x3c; o.level;
  morph = Binary(this.logic, lefts[0], (this.logic = false, this.left = lefts[1], this));
  return sn(this, (morph[&#x27;void&#x27;] = this[&#x27;void&#x27;], morph).compileNode(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring" id="apidoc.element.livescript.ast.Assign.prototype.compileDestructuring">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileDestructuring
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileDestructuring = function (o, left){
  var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
  items = left.items, len = items.length;
  ret = o.level &#x26;&#x26; !this[&#x27;void&#x27;];
  rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
  if (that = left.name) {
    cache = sn(this, that, &#x22; = &#x22;, rite);
    o.scope.declare(rite = that, left);
  } else if ((ret || len &#x3e; 1) &#x26;&#x26; (!ID.test(rite.toString()) || left.assigns(rite.toString()))) {
    cache = sn(this, rref = o.scope.temporary(), &#x22; = &#x22;, rite);
    rite = rref;
  }
  if (rite.toString() === &#x27;arguments&#x27; &#x26;&#x26; !ret) {
    destructureArgs = true;
    if (!(left instanceof Arr)) {
      this.carp(&#x27;arguments can only destructure to array&#x27;);
    }
  }
  list = this[&#x22;rend&#x22; + left.constructor.displayName](o, items, rite, destructureArgs);
  if (rref) {
    o.scope.free(rref);
  }
  if (cache) {
    list.unshift(cache);
  }
  if (ret || !list.length) {
    list.push(rite);
  }
  code = [];
  sep = destructureArgs ? &#x27;; &#x27; : &#x27;, &#x27;;
  for (i$ = 0, len$ = list.length; i$ &#x3c; len$; ++i$) {
    item = list[i$];
    code.push(item, sep);
  }
  code.pop();
  if (list.length &#x3c; 2 || o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax" id="apidoc.element.livescript.ast.Assign.prototype.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileMinMax
        <span class="apidocSignatureSpan">(o, left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileMinMax = function (o, left, right){
  var lefts, rites, test, put, ref$;
  lefts = Chain(left).cacheReference(o);
  rites = right.cache(o, true);
  test = Binary(this.op.replace(&#x27;?&#x27;, &#x27;&#x27;), lefts[0], rites[0]);
  put = Assign(lefts[1], rites[1], &#x27;:=&#x27;);
  if (this[&#x27;void&#x27;] || !o.level) {
    return Parens(Binary(&#x27;||&#x27;, test, put)).compile(o);
  }
  ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
  return sn(this, If(test, left).addElse(put).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileNode" id="apidoc.element.livescript.ast.Assign.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileNode = function (o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &#x26;&#x26; this.op === &#x27;=&#x27;) {
    return this.compileSplice(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
    left instanceof List || this.left.carp(&#x27;invalid splat&#x27;);
    return this.compileSpread(o, left);
  }
  if (!this.right) {
    left.isAssignable() || left.carp(&#x27;invalid unary assign&#x27;);
    ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
    for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ &#x3c; len$; ++i$) {
      op = ref$[i$];
      this.right = Unary(op, this.right);
    }
  }
  if (left.isEmpty()) {
    return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
  }
  if (left.getDefault()) {
    this.right = Binary(left.op, this.right, left.second);
    left = left.first;
  }
  if (left.items) {
    return this.compileDestructuring(o, left);
  }
  left.isAssignable() || left.carp(&#x27;invalid assign&#x27;);
  if (this.logic) {
    return this.compileConditional(o, left);
  }
  op = this.op, right = this.right;
  if (op === &#x27;&#x3c;?=&#x27; || op === &#x27;&#x3e;?=&#x27;) {
    return this.compileMinMax(o, left, right);
  }
  if ((op === &#x27;**=&#x27; || op === &#x27;^=&#x27; || op === &#x27;%%=&#x27; || op === &#x27;++=&#x27; || op === &#x27;|&#x3e;=&#x27;) || op === &#x27;*=&#x27; &#x26;&#x26; right.isString() || (op === &#x27;-=&#x27; ||
op === &#x27;/=&#x27;) &#x26;&#x26; right.isMatcher()) {
    ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
    right = Binary(op.slice(0, -1), reft, right);
    op = &#x27;:=&#x27;;
  }
  if (op === &#x27;.&#x26;.=&#x27; || op === &#x27;.|.=&#x27; || op === &#x27;.^.=&#x27; || op === &#x27;.&#x3c;&#x3c;.=&#x27; || op === &#x27;.&#x3e;&#x3e;.=&#x27; || op === &#x27;.&#x3e;&#x3e;&#x3e;.=&#x27;) {
    op = op.slice(1, -2) + &#x27;=&#x27;;
  }
  (right = right.unparen()).ripName(left = left.unwrap());
  sign = sn(this.opLoc, &#x22; &#x22;, op.replace(&#x27;:&#x27;, &#x27;&#x27;), &#x22; &#x22;);
  name = (left.front = true, left).compile(o, LEVEL_LIST);
  if (lvar = left instanceof Var) {
    if (op === &#x27;=&#x27;) {
      o.scope.declare(name.toString(), left, this[&#x27;const&#x27;] || !this.defParam &#x26;&#x26; o[&#x27;const&#x27;] &#x26;&#x26; &#x27;$&#x27; !== name.toString().slice(-1));
    } else if (that = o.scope.checkReadOnly(name.toString())) {
      left.carp(&#x22;assignment to &#x22; + that + &#x22; \&#x22;&#x22; + name + &#x22;\&#x22;&#x22;, ReferenceError);
    }
  }
  if (left instanceof Chain &#x26;&#x26; right instanceof Fun) {
    protoSplit = name.toString().split(&#x27;.prototype.&#x27;);
    dotSplit = name.toString().split(&#x27;.&#x27;);
    if (protoSplit.length &#x3e; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &#x3e; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join(&#x27;&#x27;);
    }
  }
  code = !o.level &#x26;&#x26; right instanceof While &#x26;&#x26; !right[&#x27;else&#x27;] &#x26;&#x26; (lvar || left instanceof Chain &#x26;&#x26; left.isSimpleAccess())
    ? (empty = right.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;, [res = o.scope.temporary(&#x27;res&#x27;), &#x22; = &#x22; + empty + &#x22;;\n&#x22; + this.tab, right.makeReturn(
res).compile(o), &#x22;\n&#x22; + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &#x3e; LEVEL_LIST) {
    code = [&#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice" id="apidoc.element.livescript.ast.Assign.prototype.compileSplice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileSplice
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileSplice = function (o){
  var ref$, fromExpNode, fromExp, rightNode, right, toExp;
  ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
  ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
  toExp = Binary(&#x27;-&#x27;, this.left.to, fromExp);
  return sn(this, Block([Chain(Var(util(&#x27;splice&#x27;))).add(Index(Key(&#x27;apply&#x27;), &#x27;.&#x27;, true)).add(Call([this.left.target, Chain(Arr([fromExpNode
, toExp])).add(Index(Key(&#x27;concat&#x27;), &#x27;.&#x27;, true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread" id="apidoc.element.livescript.ast.Assign.prototype.compileSpread">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileSpread
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileSpread = function (o, left){
  var that, ref$, rite, rref, this$ = this;
  ref$ = (that = this.unaries)
    ? [that, that]
    : left.items.length &#x3c;= 1
      ? [ref$ = this.right, ref$]
      : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
  return this.compileSpreadOver(o, left, function(it){
    var result;
    result = constructor(it, rite, this$.op, this$.logic);
    rite = rref;
    return result;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isArray" id="apidoc.element.livescript.ast.Assign.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.isArray = function (){
  switch (this.op) {
  case &#x27;=&#x27;:
  case &#x27;:=&#x27;:
    return this.right &#x26;&#x26; this.right.isArray();
  case &#x27;/=&#x27;:
    return this.right &#x26;&#x26; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isCallable" id="apidoc.element.livescript.ast.Assign.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isRegex" id="apidoc.element.livescript.ast.Assign.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isString" id="apidoc.element.livescript.ast.Assign.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.isString = function (){
  switch (this.op) {
  case &#x27;=&#x27;:
  case &#x27;:=&#x27;:
  case &#x27;+=&#x27;:
  case &#x27;*=&#x27;:
    return this.right &#x26;&#x26; this.right.isString();
  case &#x27;-=&#x27;:
    return this.right &#x26;&#x26; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendArr" id="apidoc.element.livescript.ast.Assign.prototype.rendArr">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.rendArr
        <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.rendArr = function (o, nodes, rite, destructureArgs){
  var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
  function argsSlice(begin, end){
    return new For({
      ref: true,
      from: begin,
      op: &#x27;til&#x27;,
      to: end
    }).makeComprehension(Chain(Var(&#x27;arguments&#x27;)).add(Index(Literal(&#x27;..&#x27;))), []);
  }
  ret = [];
  for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = nodes[i$];
    if (node.isEmpty()) {
      continue;
    }
    if (node instanceof Splat) {
      len &#x26;&#x26; node.carp(&#x27;multiple splat in an assignment&#x27;);
      skip = (node = node.it).isEmpty();
      if (i + 1 === (len = nodes.length)) {
        if (skip) {
          break;
        }
        if (destructureArgs) {
          val = argsSlice(Literal(i), Chain(Var(&#x27;arguments&#x27;)).add(Index(Key(&#x27;length&#x27;))));
        } else {
          val = Arr.wrap(JS(util(&#x27;slice&#x27;) + &#x27;.call(&#x27; + rite + (i ? &#x22;, &#x22; + i + &#x22;)&#x22; : &#x27;)&#x27;)));
        }
      } else {
        val = ivar = rite + &#x22;.length - &#x22; + (len - i - 1);
        if (skip &#x26;&#x26; i + 2 === len) {
          continue;
        }
        start = i + 1;
        (this.temps || (this.temps = [])).push(ivar = o.scope.temporary(&#x27;i&#x27;));
        val = (fn$());
      }
    } else {
      (inc = ivar) &#x26;&#x26; start &#x3c; i &#x26;&#x26; (inc += &#x22; + &#x22; + (i - start));
      val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
    }
    if (node instanceof Assign) {
      node = Binary(node.op, node.left, node.right, node.logic || true);
    }
    if (destructureArgs) {
      if (!(node instanceof Var) &#x26;&#x26; val instanceof For) {
        (this.temps || (this.temps = [])).push(tmp = o.scope.temporary(&#x27;ref&#x27;));
        vtmp = Var(tmp);
        ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
      } else {
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
      }
    } else {
      ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_PAREN));
    }
  }
  return ret;
  function fn$(){
    switch (false) {
    case !skip:
      return Arr.wrap(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;) ? &#x22; + i + &#x22; : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;)&#x22;));
    case !destructureArgs:
      return argsSlice(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;) ? &#x22; + i + &#x22; : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;)&#x22;), Var(ivar));
    default:
      return Arr.wrap(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;)\ ? &#x22; + util(&#x27;slice&#x27;) + &#x22;.call(&#x22; + rite + &#x22;, &#x22; + i + &#x22;, &#x22; + ivar + &#x22;)\ : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;, [])&#x22;));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendObj" id="apidoc.element.livescript.ast.Assign.prototype.rendObj">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.rendObj
        <span class="apidocSignatureSpan">(o, nodes, rite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.rendObj = function (o, nodes, rite){
  var i$, len$, node, splat, logic, ref$, key, val, rcache, results$ = [];
  for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
    node = nodes[i$];
    if (splat = node instanceof Splat) {
      node = node.it;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Parens) {
      ref$ = Chain(node.it).cacheReference(o), node = ref$[0], key = ref$[1];
    } else if (node instanceof Prop) {
      node = (key = node.key, node).val;
    } else {
      key = node;
    }
    if (node instanceof Key) {
      node = CopyL(node, Var(node.name));
    }
    if (logic) {
      node = (logic.first = node, logic);
    }
    val = Chain(rcache || (rcache = Var(rite)), [Index(key.maybeKey())]);
    if (splat) {
      val = Import(Obj(), val);
    }
    results$.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_PAREN));
  }
  return results$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.show" id="apidoc.element.livescript.ast.Assign.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.show = function (){
  return [void 8].concat(this.unaries).reverse().join(&#x27; &#x27;) + [this.logic] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Assign.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.unfoldAssign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.unfoldAssign = function (){
  return this.access &#x26;&#x26; this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Assign.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.unfoldSoak = function (o){
  var that, ref$, ref1$, rite, temps;
  if (this.left instanceof Existence) {
    if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
      rite = this.right;
      rite = Assign(this.right = Var(that), rite);
    } else {
      ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
    }
    return ref$ = If(Existence(rite), this), ref$.temps = temps, ref$.cond = this.cond, ref$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref$;
  }
  return If.unfoldSoak(o, this, &#x27;left&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary" id="apidoc.element.livescript.ast.Binary">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === &#x27;String&#x27;) {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== &#x27;=&#x27;:
        return &#x27;?&#x27;;
      default:
        return &#x27;=&#x27;;
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if (&#x27;=&#x27; === op.charAt(op.length - 1) &#x26;&#x26; ((ref$ = op.charAt(op.length - 2)) !== &#x27;=&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3c;&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3e;&#x27; &#x26;&#x26; ref$ !== &#x27;!&#x27;)) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case &#x27;in&#x27;:
      return new In(first, second);
    case &#x27;with&#x27;:
      return new Import(Unary(&#x27;^^&#x27;, first), second, false);
    case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
    case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
      return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
    case &#x27;&#x3c;|&#x27;:
      return Block(first).pipe(second, op);
    case &#x27;|&#x3e;&#x27;:
      return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
    case &#x27;.&#x27;:
    case &#x27;.~&#x27;:
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf" id="apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileAnyInstanceOf
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileAnyInstanceOf = function (o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary(&#x27;instanceof&#x27;, sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    item = items[i$];
    test = Binary(&#x27;||&#x27;, test, Binary(&#x27;instanceof&#x27;, ref, item));
  }
  return sn(this, Parens(test).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileChain" id="apidoc.element.livescript.ast.Binary.prototype.compileChain">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileChain
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileChain = function (o){
  var code, level, ref$, sub;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
  ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
  code.push(&#x22; &#x22;, this.op, &#x22; &#x22;, sub.compile(o, level), &#x22; &#x26;&#x26; &#x22;, this.second.compile(o, LEVEL_OP));
  if (o.level &#x3c;= LEVEL_OP) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose" id="apidoc.element.livescript.ast.Binary.prototype.compileCompose">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileCompose
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileCompose = function (o){
  var op, functions, x;
  op = this.op;
  functions = [this.first];
  x = this.second;
  while (x instanceof Binary &#x26;&#x26; x.op === op &#x26;&#x26; !x.partial) {
    functions.push(x.first);
    x = x.second;
  }
  functions.push(x);
  if (op === &#x27;&#x3c;&#x3c;&#x27;) {
    functions.reverse();
  }
  return sn(this, Chain(Var(util(&#x27;compose&#x27;))).add(Call(functions)).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat" id="apidoc.element.livescript.ast.Binary.prototype.compileConcat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileConcat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileConcat = function (o){
  var f;
  f = function(x){
    switch (false) {
    case !(x instanceof Binary &#x26;&#x26; x.op === &#x27;++&#x27;):
      return f(x.first).concat(f(x.second));
    default:
      return [x];
    }
  };
  return sn(null, Chain(this.first).add(CopyL(this, Index(Key(&#x27;concat&#x27;), &#x27;.&#x27;, true))).add(Call(f(this.second))).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq" id="apidoc.element.livescript.ast.Binary.prototype.compileDeepEq">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileDeepEq
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileDeepEq = function (o){
  var ref$, negate, i$, len$, x, r;
  if ((ref$ = this.op) === &#x27;&#x3e;==&#x27; || ref$ === &#x27;&#x3e;&#x3e;=&#x27;) {
    ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
    this.op = this.op === &#x27;&#x3e;==&#x27; ? &#x27;&#x3c;==&#x27; : &#x27;&#x3c;&#x3c;=&#x27;;
  }
  if (this.op === &#x27;!==&#x27;) {
    this.op = &#x27;===&#x27;;
    negate = true;
  }
  for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ &#x3c; len$; ++i$) {
    x = ref$[i$];
    if (x instanceof Obj || x instanceof Arr) {
      x.deepEq = true;
    }
  }
  r = Chain(Var(util(&#x27;deepEq&#x27;))).add(Call([this.first, this.second, Literal(&#x22;&#x27;&#x22; + this.op + &#x22;&#x27;&#x22;)]));
  return sn(this, (negate ? Unary(&#x27;!&#x27;, r) : r).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence" id="apidoc.element.livescript.ast.Binary.prototype.compileExistence">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileExistence
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileExistence = function (o){
  var x;
  if (this[&#x27;void&#x27;] || !o.level) {
    x = Binary(&#x27;&#x26;&#x26;&#x27;, Existence(this.first, true), this.second);
    return (x[&#x27;void&#x27;] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin" id="apidoc.element.livescript.ast.Binary.prototype.compileJoin">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileJoin
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileJoin = function (it){
  return this.compileMethod(it, &#x27;Array&#x27;, &#x27;join&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod" id="apidoc.element.livescript.ast.Binary.prototype.compileMethod">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMethod
        <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileMethod = function (o, klass, method, arg){
  var args;
  args = [this.second].concat(arg || []);
  if (this.first[&#x22;is&#x22; + klass]()) {
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + &#x27;.call&#x27;), args).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax" id="apidoc.element.livescript.ast.Binary.prototype.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMinMax
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileMinMax = function (o){
  var lefts, rites, x;
  lefts = this.first.cache(o, true);
  rites = this.second.cache(o, true);
  x = Binary(this.op.charAt(), lefts[0], rites[0]);
  return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMod" id="apidoc.element.livescript.ast.Binary.prototype.compileMod">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMod
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileMod = function (o){
  var ref, code;
  ref = o.scope.temporary();
  code = [sn(this, &#x22;(((&#x22;), this.first.compile(o), sn(this, &#x22;) % (&#x22;), sn(this, ref, &#x22; = &#x22;), this.second.compile(o), sn(this, &#x22;) + &#x22;,
ref, &#x22;) % &#x22;, ref, &#x22;)&#x22;)];
  o.scope.free(ref);
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileNode" id="apidoc.element.livescript.ast.Binary.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileNode = function (o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.compilePartial(o);
  }
  switch (this.op) {
  case &#x27;?&#x27;:
    return this.compileExistence(o);
  case &#x27;*&#x27;:
    if (this.second.isString()) {
      return this.compileJoin(o);
    }
    if (this.first.isString() || this.first.isArray()) {
      return this.compileRepeat(o);
    }
    break;
  case &#x27;-&#x27;:
    if (this.second.isMatcher()) {
      return this.compileRemove(o);
    }
    break;
  case &#x27;/&#x27;:
    if (this.second.isMatcher()) {
      return this.compileSplit(o);
    }
    break;
  case &#x27;**&#x27;:
  case &#x27;^&#x27;:
    return this.compilePow(o);
  case &#x27;&#x3c;?&#x27;:
  case &#x27;&#x3e;?&#x27;:
    return this.compileMinMax(o);
  case &#x27;&#x3c;&#x3c;&#x27;:
  case &#x27;&#x3e;&#x3e;&#x27;:
    return this.compileCompose(o);
  case &#x27;++&#x27;:
    return this.compileConcat(o);
  case &#x27;%%&#x27;:
    return this.compileMod(o);
  case &#x27;xor&#x27;:
    return this.compileXor(o);
  case &#x27;&#x26;&#x26;&#x27;:
  case &#x27;||&#x27;:
    if (top = this[&#x27;void&#x27;] || !o.level) {
      this.second[&#x27;void&#x27;] = true;
    }
    if (top || this.cond) {
      this.first.cond = true;
      this.second.cond = true;
    }
    break;
  case &#x27;instanceof&#x27;:
    rite = this.second.expandSlice(o).unwrap(), items = rite.items;
    if (rite instanceof Arr) {
      if (items[1]) {
        return this.compileAnyInstanceOf(o, items);
      }
      this.second = items[0] || rite;
    }
    this.second.isCallable() || this.second.carp(&#x27;invalid instanceof operand&#x27;);
    break;
  case &#x27;====&#x27;:
  case &#x27;!===&#x27;:
    this.op = this.op.slice(0, 3);
    // fallthrough
  case &#x27;&#x3c;==&#x27;:
  case &#x27;&#x3e;==&#x27;:
  case &#x27;&#x3c;&#x3c;=&#x27;:
  case &#x27;&#x3e;&#x3e;=&#x27;:
    return this.compileDeepEq(o);
  default:
    if (COMPARER.test(this.op)) {
      if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
        return it.isRegex();
      })) {
        return this.compileRegexEquals(o, that);
      }
      if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26;&#x26; this.first.isWhat() !== this
.second.isWhat()) {
        if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
          console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#x22; == &#x22; +
this.second.value);
        }
      }
    }
    if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), &#x22; &#x22;, this.mapOp(this.op), &#x22; &#x22;, this.second.compile(o, level)];
  if (o.level &#x3c;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial" id="apidoc.element.livescript.ast.Binary.prototype.compilePartial">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compilePartial
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compilePartial = function (o){
  var vit, x, y;
  vit = Var(&#x27;it&#x27;);
  switch (false) {
  case !(this.first == null &#x26;&#x26; this.second == null):
    x = Var(&#x27;x$&#x27;);
    y = Var(&#x27;y$&#x27;);
    return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));
  case this.first == null:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), &#x22;)&#x22;);
  default:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePow" id="apidoc.element.livescript.ast.Binary.prototype.compilePow">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compilePow
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compilePow = function (o){
  return sn(null, Call.make(CopyL(this, JS(&#x27;Math.pow&#x27;)), [this.first, this.second]).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals" id="apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRegexEquals
        <span class="apidocSignatureSpan">(o, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileRegexEquals = function (o, arg$){
  var regex, target, method;
  regex = arg$[0], target = arg$[1];
  if (this.op === &#x27;===&#x27;) {
    method = this.wasInverted ? &#x27;test&#x27; : &#x27;exec&#x27;;
    return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
  } else {
    return sn(this, Unary(&#x27;!&#x27;, Chain(regex).add(Index(Key(&#x27;test&#x27;))).add(Call([target]))).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove" id="apidoc.element.livescript.ast.Binary.prototype.compileRemove">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRemove
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileRemove = function (it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;replace&#x27;, JS(&#x22;&#x27;&#x27;&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat" id="apidoc.element.livescript.ast.Binary.prototype.compileRepeat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRepeat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileRepeat = function (o){
  var x, n, items, arr, arrCode, refs, i$, len$, i, item, ref$, q;
  x = this.first, n = this.second;
  items = (x = x.expandSlice(o).unwrap()).items;
  arr = x.isArray() &#x26;&#x26; &#x27;Array&#x27;;
  if (items &#x26;&#x26; !snEmpty(arrCode = Splat.compileArray(o, items))) {
    x = JS(arrCode);
    items = null;
  }
  if (arr &#x26;&#x26; !items || !(n instanceof Literal &#x26;&#x26; n.value &#x3c; 0x20)) {
    return sn(this, Call.make(Util(&#x27;repeat&#x27; + (arr || &#x27;String&#x27;)), [x, n]).compile(o));
  }
  n = +n.value;
  if (1 &#x3c;= n &#x26;&#x26; n &#x3c; 2) {
    return sn(this, x.compile(o));
  }
  if (items) {
    if (n &#x3c; 1) {
      return sn(this, Block(items).add(JS(&#x27;[]&#x27;)).compile(o));
    }
    refs = [];
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      item = items[i$];
      ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
    }
    items.push((ref$ = JS(), ref$.compile = function(){
      return sn.apply(null, [this].concat(slice$.call((repeatArray$([&#x22;, &#x22;, List.compile(o, refs)], n - 1)).slice(1))));
    }, ref$));
    return sn(this, x.compile(o));
  } else if (x instanceof Literal) {
    return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + &#x22;&#x22;, n) + q);
  } else {
    if (n &#x3c; 1) {
      return sn(this, Block(x.it).add(JS(&#x22;&#x27;&#x27;&#x22;)).compile(o));
    }
    x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(&#x22; + &#x22; + refs[1], n - 1);
    if (o.level &#x3c; LEVEL_OP + PREC[&#x27;+&#x27;]) {
      return sn(this, x);
    } else {
      return sn(this, &#x22;(&#x22;, x, &#x22;)&#x22;);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit" id="apidoc.element.livescript.ast.Binary.prototype.compileSplit">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileSplit
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileSplit = function (it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;split&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileXor" id="apidoc.element.livescript.ast.Binary.prototype.compileXor">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileXor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileXor = function (o){
  var left, right;
  left = Chain(this.first).cacheReference(o);
  right = Chain(this.second).cacheReference(o);
  return sn(this, Binary(&#x27;&#x26;&#x26;&#x27;, Binary(&#x27;!==&#x27;, Unary(&#x27;!&#x27;, left[0]), Unary(&#x27;!&#x27;, right[0])), Parens(Binary(&#x27;||&#x27;, left[1], right[1]))).
compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.getDefault" id="apidoc.element.livescript.ast.Binary.prototype.getDefault">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.getDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.getDefault = function (){
  switch (this.op) {
  case &#x27;?&#x27;:
  case &#x27;||&#x27;:
  case &#x27;&#x26;&#x26;&#x27;:
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invert" id="apidoc.element.livescript.ast.Binary.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.invert = function (){
  var that;
  if (that = !COMPARER.test(this.second.op) &#x26;&#x26; INVERSIONS[this.op]) {
    this.op = that;
    this.wasInverted = true;
    return this;
  }
  return Unary(&#x27;!&#x27;, Parens(this), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invertIt" id="apidoc.element.livescript.ast.Binary.prototype.invertIt">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.invertIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.invertIt = function (){
  this.inverted = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isArray" id="apidoc.element.livescript.ast.Binary.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.isArray = function (){
  switch (this.op) {
  case &#x27;*&#x27;:
    return this.first.isArray();
  case &#x27;/&#x27;:
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isCallable" id="apidoc.element.livescript.ast.Binary.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.isCallable = function (){
  var ref$;
  return this.partial || ((ref$ = this.op) === &#x27;&#x26;&#x26;&#x27; || ref$ === &#x27;||&#x27; || ref$ === &#x27;?&#x27; || ref$ === &#x27;&#x3c;&#x3c;&#x27; || ref$ === &#x27;&#x3e;&#x3e;&#x27;) &#x26;&#x26; this.
first.isCallable() &#x26;&#x26; this.second.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isString" id="apidoc.element.livescript.ast.Binary.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.isString = function (){
  switch (this.op) {
  case &#x27;+&#x27;:
  case &#x27;*&#x27;:
    return this.first.isString() || this.second.isString();
  case &#x27;-&#x27;:
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.mapOp" id="apidoc.element.livescript.ast.Binary.prototype.mapOp">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.mapOp
        <span class="apidocSignatureSpan">(op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.mapOp = function (op){
  var that;
  switch (false) {
  case !(that = op.match(/\.([&#x26;\|\^]|&#x3c;&#x3c;|&#x3e;&#x3e;&#x3e;?)\./)):
    return that[1];
  case op !== &#x27;of&#x27;:
    return &#x27;in&#x27;;
  default:
    return op;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.show" id="apidoc.element.livescript.ast.Binary.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.show = function (){
  return this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren" id="apidoc.element.livescript.ast.Binary.prototype.xorChildren">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.xorChildren
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.xorChildren = function (test){
  var ref$, ref1$, first;
  if (!(!(ref$ = first = test(this.first)) !== !(ref1$ = test(this.second)) &#x26;&#x26; (ref$ || ref1$))) {
    return false;
  }
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block" id="apidoc.element.livescript.ast.Block">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if (&#x27;length&#x27; in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.add" id="apidoc.element.livescript.ast.Block.prototype.add">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.add = function (it){
  var that, ref$;
  it = it.unparen();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
  default:
    this.lines.push(it);
    if (that = (ref$ = it.back, delete it.back, ref$)) {
      this.back = that;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.chomp" id="apidoc.element.livescript.ast.Block.prototype.chomp">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.chomp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.chomp = function (){
  var lines, i, that;
  lines = this.lines;
  i = lines.length;
  while (that = lines[--i]) {
    if (!that.comment) {
      break;
    }
  }
  lines.length = i + 1;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compile" id="apidoc.element.livescript.ast.Block.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.compile = function (o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &#x26;&#x26; (level = o.level);
  if (level) {
    return this.compileExpressions(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
    if (snEmpty(code = (node.front = true, node).compile(o, level))) {
      continue;
    }
    codes.push(tab);
    codes.push(code);
    node.isStatement() || codes.push(node.terminator);
    codes.push(&#x27;\n&#x27;);
  }
  codes.pop();
  return sn.apply(null, [null].concat(slice$.call(codes)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions" id="apidoc.element.livescript.ast.Block.prototype.compileExpressions">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileExpressions
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.compileExpressions = function (o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
      lines.splice(i--, 1);
    }
  }
  if (!lines.length) {
    lines.push(Literal(&#x27;void&#x27;));
  }
  lines[0].front = this.front;
  lines[lines.length - 1][&#x27;void&#x27;] = this[&#x27;void&#x27;];
  if (!lines[1]) {
    return lines[0].compile(o, level);
  }
  code = [];
  last = lines.pop();
  for (i$ = 0, len$ = lines.length; i$ &#x3c; len$; ++i$) {
    node = lines[i$];
    code.push((node[&#x27;void&#x27;] = true, node).compile(o, LEVEL_PAREN), &#x27;, &#x27;);
  }
  code.push(last.compile(o, LEVEL_PAREN));
  if (level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileRoot" id="apidoc.element.livescript.ast.Block.prototype.compileRoot">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileRoot
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.compileRoot = function (options){
  var o, that, ref$, bare, prefix, ref1$, code, result;
  o = (import$({
    level: LEVEL_TOP,
    scope: this.scope = Scope.root = new Scope
  }, options));
  if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
    this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
  }
  delete o.filename;
  o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? &#x27;&#x27; : TAB;
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations" id="apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileWithDeclarations
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.compileWithDeclarations = function (o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
  if (i = this.neck()) {
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), &#x22;\n&#x22;];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.emit(post, o.indent) : post]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.getJump" id="apidoc.element.livescript.ast.Block.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.getJump = function (it){
  var i$, ref$, len$, node, that;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (that = node.getJump(it)) {
      return that;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isArray" id="apidoc.element.livescript.ast.Block.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isCallable" id="apidoc.element.livescript.ast.Block.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isComplex" id="apidoc.element.livescript.ast.Block.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.isComplex = function (){
  var ref$;
  return this.lines.length &#x3e; 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isRegex" id="apidoc.element.livescript.ast.Block.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isString" id="apidoc.element.livescript.ast.Block.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.makeReturn" id="apidoc.element.livescript.ast.Block.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.makeReturn = function (){
  var that, ref$, key$, ref1$;
  this.chomp();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &#x26;&#x26; !that.it) {
      --this.lines.length;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.neck" id="apidoc.element.livescript.ast.Block.prototype.neck">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.neck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.neck = function (){
  var pos, i$, ref$, len$, x;
  pos = 0;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    x = ref$[i$];
    if (!(x.comment || x instanceof Literal)) {
      break;
    }
    ++pos;
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.pipe" id="apidoc.element.livescript.ast.Block.prototype.pipe">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.pipe
        <span class="apidocSignatureSpan">(target, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.pipe = function (target, type){
  var args;
  args = type === &#x27;|&#x3e;&#x27; ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== &#x27;Array&#x27;) {
    args = [args];
  }
  switch (type) {
  case &#x27;|&#x3e;&#x27;:
    this.lines.push(Call.make(target, args, {
      pipe: true
    }));
    break;
  case &#x27;&#x3c;|&#x27;:
    this.lines.push(Call.make(this.lines.pop(), args));
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.prepend" id="apidoc.element.livescript.ast.Block.prototype.prepend">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.prepend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.prepend = function (){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(slice$.call(arguments)));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.toJSON" id="apidoc.element.livescript.ast.Block.prototype.toJSON">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.toJSON = function (){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.unwrap" id="apidoc.element.livescript.ast.Block.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.unwrap = function (){
  if (this.lines.length === 1) {
    return this.lines[0];
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Box" id="apidoc.element.livescript.ast.Box">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Box
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Box = function (v){
  if (typeof v === &#x22;object&#x22;) {
    return v;
  } else {
    return new v.constructor(v);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call" id="apidoc.element.livescript.ast.Call">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Call
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &#x26;&#x26; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = &#x27;.call&#x27;;
      args[0] = Literal(&#x27;this&#x27;);
      args[1] = Splat(Literal(&#x27;arguments&#x27;));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === &#x27;_&#x27;) {
        args[i] = Chain(Literal(&#x27;void&#x27;));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.compile" id="apidoc.element.livescript.ast.Call.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Call.prototype.compile = function (o){
  var code, i$, ref$, len$, i, a;
  code = [sn(this, this.method || &#x27;&#x27;, &#x27;(&#x27;) + (this.pipe ? &#x22;\n&#x22; + o.indent : &#x27;&#x27;)];
  for (i$ = 0, len$ = (ref$ = this.args).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    a = ref$[i$];
    code.push(i ? &#x27;, &#x27; : &#x27;&#x27;, a.compile(o, LEVEL_LIST));
  }
  code.push(sn(this, &#x27;)&#x27;));
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.show" id="apidoc.element.livescript.ast.Call.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Call.prototype.show = function (){
  return [this[&#x27;new&#x27;]] + [this.method] + [this.soak ? &#x27;?&#x27; : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade" id="apidoc.element.livescript.ast.Cascade">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode" id="apidoc.element.livescript.ast.Cascade.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.compileNode = function (o){
  var level, input, output, prog1, ref, ref$, code, out;
  level = o.level;
  input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
  if (prog1 &#x26;&#x26; (&#x27;ret&#x27; in this || level &#x26;&#x26; !this[&#x27;void&#x27;])) {
    output.add((ref$ = Literal(&#x27;..&#x27;), ref$.cascadee = true, ref$));
  }
  if (&#x27;ret&#x27; in this) {
    output = output.makeReturn(this.ret);
  }
  if (ref) {
    prog1 || (output = Assign(Var(ref), output));
  } else {
    ref = o.scope.temporary(&#x27;x&#x27;);
  }
  if (input instanceof Cascade) {
    input.ref = ref;
  } else {
    input &#x26;&#x26; (input = Assign(Var(ref), input));
  }
  o.level &#x26;&#x26; (o.level = LEVEL_PAREN);
  code = [input.compile(o)];
  out = Block(output).compile((o.ref = new String(ref), o));
  if (prog1 === &#x27;cascade&#x27; &#x26;&#x26; !o.ref.erred) {
    this.carp(&#x22;unreferred cascadee&#x22;);
  }
  if (!level) {
    return sn.apply(null, [null].concat(slice$.call(code), [input.terminator, &#x22;\n&#x22;, out]));
  }
  code.push(&#x22;, &#x22;, out);
  if (level &#x3e; LEVEL_PAREN) {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.getJump" id="apidoc.element.livescript.ast.Cascade.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.getJump = function (it){
  return this.output.getJump(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isArray" id="apidoc.element.livescript.ast.Cascade.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable" id="apidoc.element.livescript.ast.Cascade.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex" id="apidoc.element.livescript.ast.Cascade.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isString" id="apidoc.element.livescript.ast.Cascade.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn" id="apidoc.element.livescript.ast.Cascade.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.makeReturn
        <span class="apidocSignatureSpan">(ret)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.makeReturn = function (ret){
  this.ret = ret;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.show" id="apidoc.element.livescript.ast.Cascade.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.show = function (){
  return this.prog1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case" id="apidoc.element.livescript.ast.Case">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Case
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.compileCase" id="apidoc.element.livescript.ast.Case.prototype.compileCase">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.compileCase
        <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Case.prototype.compileCase = function (o, tab, nobr, bool, type, target){
  var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
  tests = [];
  for (i$ = 0, len$ = (ref$ = this.tests).length; i$ &#x3c; len$; ++i$) {
    test = ref$[i$];
    test = test.expandSlice(o).unwrap();
    if (test instanceof Arr &#x26;&#x26; type !== &#x27;match&#x27;) {
      for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ &#x3c; len1$; ++j$) {
        t = ref1$[j$];
        tests.push(t);
      }
    } else {
      tests.push(test);
    }
  }
  tests.length || tests.push(Literal(&#x27;void&#x27;));
  if (type === &#x27;match&#x27;) {
    for (i$ = 0, len$ = tests.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      test = tests[i$];
      tar = Chain(target).add(Index(Literal(i), &#x27;.&#x27;, true));
      tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
    }
  }
  if (bool) {
    binary = type === &#x27;match&#x27; ? &#x27;&#x26;&#x26;&#x27; : &#x27;||&#x27;;
    t = tests[0];
    i = 0;
    while (that = tests[++i]) {
      t = Binary(binary, t, that);
    }
    tests = [(this.t = t, this.aSource = &#x27;t&#x27;, this.aTargets = [&#x27;body&#x27;], this).anaphorize().invert()];
  }
  code = [];
  for (i$ = 0, len$ = tests.length; i$ &#x3c; len$; ++i$) {
    t = tests[i$];
    code.push(tab, sn(t, &#x22;case &#x22;, t.compile(o, LEVEL_PAREN), &#x22;:\n&#x22;));
  }
  lines = this.body.lines;
  last = lines[lines.length - 1];
  if (ft = (last != null ? last.value : void 8) === &#x27;fallthrough&#x27;) {
    lines[lines.length - 1] = JS(&#x27;// fallthrough&#x27;);
  }
  o.indent = tab += TAB;
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(bodyCode, &#x27;\n&#x27;);
  }
  if (!(nobr || ft || last instanceof Jump)) {
    code.push(tab + &#x27;break;\n&#x27;);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.isCallable" id="apidoc.element.livescript.ast.Case.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Case.prototype.isCallable = function (){
  return this.body.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.makeReturn" id="apidoc.element.livescript.ast.Case.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Case.prototype.makeReturn = function (){
  var ref$, ref1$;
  if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== &#x27;fallthrough&#x27;) {
    (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain" id="apidoc.element.livescript.ast.Chain">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &#x26;&#x26; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.add" id="apidoc.element.livescript.ast.Chain.prototype.add">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.add = function (it){
  var last, ref$, index, ref1$, bi, logics, call, f;
  if (this.tails.length) {
    last = (ref$ = this.tails)[ref$.length - 1];
    if (last instanceof Call &#x26;&#x26; ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 &#x26;&#x26; it.args.length === 1) {
      index = last.partialized[0].head.value;
      delete last.partialized;
      last.args[index] = it.args[0];
      return this;
    }
  }
  if (this.head instanceof Existence) {
    ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
    it.soak = true;
  }
  this.tails.push(it);
  bi = this.head instanceof Parens &#x26;&#x26; this.head.it instanceof Binary &#x26;&#x26; !this.head.it.partial
    ? this.head.it
    : this.head instanceof Binary &#x26;&#x26; !this.head.partial ? this.head : void 8;
  if (this.head instanceof Super) {
    if (!this.head.called &#x26;&#x26; it instanceof Call &#x26;&#x26; !it.method) {
      it.method = &#x27;.call&#x27;;
      it.args.unshift(Literal(&#x27;this&#x27;));
      this.head.called = true;
    } else if (!this.tails[1] &#x26;&#x26; ((ref1$ = it.key) != null ? ref1$.name : void 8) === &#x27;prototype&#x27;) {
      this.head.sproto = true;
    }
  } else if (it instanceof Call &#x26;&#x26; this.tails.length === 1 &#x26;&#x26; bi &#x26;&#x26; in$(bi.op, logics = [&#x27;&#x26;&#x26;&#x27;, &#x27;||&#x27;, &#x27;xor&#x27;])) {
    call = it;
    f = function(x, key){
      var y;
      y = x[key];
      if (y instanceof Binary &#x26;&#x26; in$(y.op, logics)) {
        f(y, &#x27;first&#x27;);
        return f(y, &#x27;second&#x27;);
      } else {
        return x[key] = Chain(y).autoCompare(call.args);
      }
    };
    f(bi, &#x27;first&#x27;);
    f(bi, &#x27;second&#x27;);
    return bi;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.assigns" id="apidoc.element.livescript.ast.Chain.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.assigns = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare" id="apidoc.element.livescript.ast.Chain.prototype.autoCompare">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.autoCompare
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.autoCompare = function (target){
  var test;
  test = this.head;
  switch (false) {
  case !(test instanceof Literal):
    return Binary(&#x27;===&#x27;, test, target[0]);
  case !(test instanceof Unary &#x26;&#x26; test.it instanceof Literal):
    return Binary(&#x27;===&#x27;, test, target[0]);
  case !(test instanceof Arr || test instanceof Obj):
    return Binary(&#x27;====&#x27;, test, target[0]);
  case !(test instanceof Var &#x26;&#x26; test.value === &#x27;_&#x27;):
    return Literal(&#x27;true&#x27;);
  default:
    return this.add(Call(target)) || [];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference" id="apidoc.element.livescript.ast.Chain.prototype.cacheReference">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.cacheReference
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.cacheReference = function (o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.unwrap().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
    base = Chain(Assign(Var(ref), base));
    bref = (ref$ = Var(ref), ref$.temp = true, ref$);
  }
  if (!name) {
    return [base, bref];
  }
  if (name.isComplex()) {
    ref = o.scope.temporary(&#x27;key&#x27;);
    name = Index(Assign(Var(ref), name.key));
    nref = Index((ref$ = Var(ref), ref$.temp = true, ref$));
  }
  return [base.add(name), Chain(bref || base.head, [nref || name])];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.compileNode" id="apidoc.element.livescript.ast.Chain.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.compileNode = function (o){
  var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
  if (this.flip) {
    util(&#x27;flip&#x27;);
    util(&#x27;curry&#x27;);
  }
  head = this.head, tails = this.tails;
  head.front = this.front;
  head.newed = this.newed;
  if (!tails.length) {
    return head.compile(o);
  }
  if (that = this.unfoldAssign(o)) {
    return that.compile(o);
  }
  for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
    t = tails[i$];
    if (t.partialized) {
      hasPartial = true;
      break;
    }
  }
  if (hasPartial) {
    util(&#x27;slice&#x27;);
    pre = [];
    rest = [];
    for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
      t = tails[i$];
      broken = broken || t.partialized != null;
      if (broken) {
        rest.push(t);
      } else {
        pre.push(t);
      }
    }
    if (rest != null) {
      partial = rest[0], post = slice$.call(rest, 1);
    }
    this.tails = pre;
    context = pre.length
      ? Chain(head, slice$.call(pre, 0, -1))
      : Literal(&#x27;this&#x27;);
    return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial
.partialized)])])), post).compile(o);
  }
  if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
    this.carp(&#x27;invalid callee&#x27;);
  }
  this.expandSlice(o);
  this.expandVivify();
  this.expandBind(o);
  this.expandSplat(o);
  this.expandStar(o);
  if (this.splattedNewArgs) {
    idt = o.indent + TAB;
    func = Chain(this.head, tails.slice(0, -1));
    return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22;var child = new ctor
, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
  }
  if (!this.tails.length) {
    return this.head.compile(o);
  }
  base = [this.head.compile(o, LEVEL_CALL)];
  news = [];
  rest = [];
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    t = ref$[i$];
    if (t[&#x27;new&#x27;]) {
      news.push(&#x27;new &#x27;);
    }
    rest.push(t.compile(o));
  }
  if (&#x27;.&#x27; === rest.join(&#x22;&#x22;).charAt(0) &#x26;&#x26; SIMPLENUM.test(base[0].toString())) {
    base.push(&#x27; &#x27;);
  }
  return sn.apply(null, [null].concat(slice$.call(news), slice$.call(base), slice$.call(rest)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandBind" id="apidoc.element.livescript.ast.Chain.prototype.expandBind">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandBind
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.expandBind = function (o){
  var tails, i, that, obj, key, call;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.symbol !== &#x27;.~&#x27;) {
      continue;
    }
    that.symbol = &#x27;&#x27;;
    obj = Chain(this.head, tails.splice(0, i)).unwrap();
    key = tails.shift().key;
    call = Call.make(Util(&#x27;bind&#x27;), [obj, (key.reserved = true, key)]);
    this.head = this.newed ? Parens(call, true) : call;
    i = -1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice" id="apidoc.element.livescript.ast.Chain.prototype.expandSlice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandSlice
        <span class="apidocSignatureSpan">(o, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.expandSlice = function (o, assign){
  var tails, i, tail, ref$, x;
  tails = this.tails;
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &#x26;&#x26; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp(&#x27;calling a slice&#x27;);
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat" id="apidoc.element.livescript.ast.Chain.prototype.expandSplat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandSplat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.expandSplat = function (o){
  var tails, i, call, args, ctx, ref$;
  tails = this.tails;
  i = -1;
  while (call = tails[++i]) {
    if (!(args = call.args)) {
      continue;
    }
    ctx = call.method === &#x27;.call&#x27; &#x26;&#x26; (args = args.concat()).shift();
    if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
      continue;
    }
    if (call[&#x27;new&#x27;]) {
      this.splattedNewArgs = args;
    } else {
      if (!ctx &#x26;&#x26; tails[i - 1] instanceof Index) {
        ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
        i = 0;
      }
      call.method = &#x27;.apply&#x27;;
      call.args = [ctx || Literal(&#x27;null&#x27;), JS(args)];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandStar" id="apidoc.element.livescript.ast.Chain.prototype.expandStar">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandStar
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.expandStar = function (o){
  var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.args || that.stars || that.key instanceof Key) {
      continue;
    }
    stars = that.stars = [];
    that.eachChild(seek);
    if (!stars.length) {
      continue;
    }
    ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
    value = Chain(ref, [Index(Key(&#x27;length&#x27;))]).compile(o);
    for (i$ = 0, len$ = stars.length; i$ &#x3c; len$; ++i$) {
      star = stars[i$];
      star.value = value;
      star.isAssignable = YES;
    }
    this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
    if (temps) {
      o.scope.free(temps[0]);
    }
    i = -1;
  }
  function seek(it){
    if (it.value === &#x27;*&#x27;) {
      stars.push(it);
    } else if (!(it instanceof Index)) {
      it.eachChild(seek);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify" id="apidoc.element.livescript.ast.Chain.prototype.expandVivify">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandVivify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.expandVivify = function (){
  var tails, i, that, ref$, ref1$;
  tails = this.tails;
  i = 0;
  while (i &#x3c; tails.length) {
    if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
      this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), &#x27;=&#x27;, &#x27;||&#x27;);
      i = 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.flipIt" id="apidoc.element.livescript.ast.Chain.prototype.flipIt">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.flipIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.flipIt = function (){
  this.flip = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getCall" id="apidoc.element.livescript.ast.Chain.prototype.getCall">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.getCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.getCall = function (){
  var tail, ref$;
  return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call &#x26;&#x26; tail;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getJump" id="apidoc.element.livescript.ast.Chain.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.getJump = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isArray" id="apidoc.element.livescript.ast.Chain.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isArray = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.isArray();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable" id="apidoc.element.livescript.ast.Chain.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isAssignable = function (){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.isAssignable();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isCallable" id="apidoc.element.livescript.ast.Chain.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isCallable = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return !((ref$ = that.key) != null &#x26;&#x26; ref$.items);
  } else {
    return this.head.isCallable();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isComplex" id="apidoc.element.livescript.ast.Chain.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isComplex = function (){
  return this.tails.length || this.head.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isRegex" id="apidoc.element.livescript.ast.Chain.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isRegex = function (){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess" id="apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isSimpleAccess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isSimpleAccess = function (){
  return this.tails.length === 1 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !this.tails[0].isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isStatement" id="apidoc.element.livescript.ast.Chain.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isStatement
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isStatement = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isString" id="apidoc.element.livescript.ast.Chain.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn" id="apidoc.element.livescript.ast.Chain.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.makeReturn = function (){
  var ref$;
  if (this.tails.length) {
    return superclass.prototype.makeReturn.apply(this, arguments);
  } else {
    return (ref$ = this.head).makeReturn.apply(ref$, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Chain.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unfoldAssign
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.unfoldAssign = function (o){
  var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
  if (that = this.head.unfoldAssign(o)) {
    (ref$ = that.right.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    index = ref$[i$];
    if (op = index.assign) {
      index.assign = &#x27;&#x27;;
      left = Chain(this.head, this.tails.splice(0, i)).expandSlice(o).unwrap();
      if (left instanceof Arr) {
        lefts = left.items;
        rites = (this.head = Arr()).items;
        for (j$ = 0, len1$ = lefts.length; j$ &#x3c; len1$; ++j$) {
          i = j$;
          node = lefts[j$];
          ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
        }
      } else {
        ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
      }
      if (op === &#x27;=&#x27;) {
        op = &#x27;:=&#x27;;
      }
      return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Chain.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.unfoldSoak = function (o){
  var that, ref$, i$, len$, i, node, ref1$, bust, test;
  if (that = this.head.unfoldSoak(o)) {
    (ref$ = that.then.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = ref$[i$];
    if (ref1$ = node.soak, delete node.soak, ref1$) {
      bust = Chain(this.head, this.tails.splice(0, i));
      if (node.assign &#x26;&#x26; !bust.isAssignable()) {
        node.carp(&#x27;invalid accessign&#x27;);
      }
      if (i &#x26;&#x26; (node.assign || node instanceof Call)) {
        ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
        if (bust instanceof Chain) {
          (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
          bust = bust.head;
        }
        this.head = bust;
      } else {
        ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
      }
      test = node instanceof Call
        ? JS(&#x22;typeof &#x22; + test.compile(o, LEVEL_OP) + &#x22; == &#x27;function&#x27;&#x22;)
        : Existence(test);
      return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unwrap" id="apidoc.element.livescript.ast.Chain.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.unwrap = function (){
  if (this.tails.length) {
    return this;
  } else {
    return this.head;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.varName" id="apidoc.element.livescript.ast.Chain.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.varName = function (){
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class" id="apidoc.element.livescript.ast.Class">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Class
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.compile" id="apidoc.element.livescript.ast.Class.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype.compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Class.prototype.compile = function (o, level){
  var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj
, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
  fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
  CopyL(this, fun);
  boundFuncs = [];
  curriedBoundFuncs = [];
  decl = title != null ? title.varName() : void 8;
  name = decl || this.name;
  if (ID.test(name || &#x27;&#x27;)) {
    fun.cname = name;
  } else {
    name = &#x27;constructor&#x27;;
  }
  proto = Var(&#x27;prototype&#x27;);
  vname = fun.proto = Var(fun.bound = name);
  ctorName = &#x27;constructor$$&#x27;;
  importProtoObj = function(node, i){
    var j, prop, key, i$, ref$, len$, v;
    j = 0;
    for (; j &#x3c; node.items.length; j++) {
      prop = node.items[j];
      key = prop.key;
      if ((key instanceof Key &#x26;&#x26; key.name === ctorName) || (key instanceof Literal &#x26;&#x26; key.value === &#x22;&#x27;&#x22; + ctorName + &#x22;&#x27;&#x22;)) {
        if (ctor) {
          node.carp(&#x27;redundant constructor&#x27;);
        }
        ctor = prop.val;
        node.items.splice(j--, 1);
        ctorPlace = i;
      }
      if (!(prop.val instanceof Fun || prop.accessor)) {
        continue;
      }
      if (key.isComplex()) {
        key = Var(o.scope.temporary(&#x27;key&#x27;));
        prop.key = Assign(key, prop.key);
      }
      if (prop.val.bound) {
        if (prop.val.curried) {
          curriedBoundFuncs.push(prop.key);
        } else {
          boundFuncs.push(prop.key);
        }
        prop.val.bound = false;
        prop.val.classBound = true;
      }
      for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ &#x3c; len$; ++i$) {
        v = ref$[i$];
        v.meth = key;
      }
    }
    if (node.items.length) {
      return ref$ = Import(Chain(vname).add(Index(Key(&#x27;prototype&#x27;))), node), ref$.proto = true, ref$;
    } else {
      return Literal(&#x27;void&#x27;);
    }
  };
  for (i$ = 0, len$ = lines.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = lines[i$];
    if (node instanceof Obj) {
      lines[i] = importProtoObj(node, i);
    } else if (node instanceof Fun &#x26;&#x26; !node.statement) {
      ctor &#x26;&#x26; node.carp(&#x27;redundant constructor&#x27;);
      ctor = node;
    } else if (node instanceof Assign &#x26;&#x26; node.left instanceof Chain &#x26;&#x26; node.left.head.value === &#x27;this&#x27; &#x26;&#x26; node.right instanceof
Fun) {
      node.right.stat = node.left.tails[0].key;
    } else {
      node.traverseChildren(fn$);
    }
  }
  ctor || (ctor = lines[lines.length] = this.sup
    ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal(&#x27;arguments&#x27;))]))))
    : Fun());
  if (!(ctor instanceof Fun)) {
    lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
    lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat(&#x27;arguments&#x27;, true)]))))));
  }
  ctor.name = name;
  ctor.ctor = true;
  ctor.statement = true;
  for (i$ = 0, len$ = boundFuncs.length; i$ &#x3c; len$; ++i$) {
    f = boundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(f)), Chain(Var(util(&#x27;bind&#x27;))).add(Call([Literal(&#x27;this&#x27;), Literal
(&#x22;&#x27;&#x22; + f.name + &#x22;&#x27;&#x22;), Var(&#x27;prototype&#x27;)]))));
  }
  for (i$ = 0, len$ = curriedBoundFuncs.length; i$ &#x3c; len$; ++i$) {
    f = curriedBoundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(Key(&#x22;_&#x22; + f.name))), Chain(Var(util(&#x27;curry&#x27;))).add(Call([Chain
(Var(&#x27;prototype&#x27;)).add(Index(f)), Var(&#x27;true&#x27;)]))), Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(f)), Chain(Var(util(&#x27;bind&#x27;))).add(Call
([Literal(&#x27;this&#x27;), Literal(&#x22;&#x27;_&#x22; + f.name + &#x22;&#x27;&#x22;)]))));
  }
  lines.push(vname);
  args = [];
  if (that = this.sup) {
    args.push(that);
    imports = Chain(Import(Literal(&#x27;this&#x27;), Var(&#x27;superclass&#x27;)));
    fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key(&#x27;displayName&#x27;))), Literal(&#x22;&#x27;&#x22; + name + &#x22;&#x27;&#x22;)), Literal
(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var(&#x27;superclass&#x27;));
  }
  if (that = this.mixins) {
    res$ = [];
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      args[args.length] = that[i$];
      res$.push(Import(proto, JS(&#x22;arguments[&#x22; + (args.length - 1) + &#x22;]&#x22;), true));
    }
    import ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.ripName" id="apidoc.element.livescript.ast.Class.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype.ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Class.prototype.ripName = function (it){
  this.name = it.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.CopyL" id="apidoc.element.livescript.ast.CopyL">
        function <span class="apidocSignatureSpan">livescript.</span>ast.CopyL
        <span class="apidocSignatureSpan">(a, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.CopyL = function (a, node){
  if (node &#x26;&#x26; typeof node === &#x22;object&#x22;) {
    node.first_line = a.first_line;
    node.first_column = a.first_column;
    node.last_line = a.last_line;
    node.last_column = a.last_column;
    node.line = a.line;
    node.column = a.column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Decl" id="apidoc.element.livescript.ast.Decl">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Decl
        <span class="apidocSignatureSpan">(type, nodes, lno)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Decl = function (type, nodes, lno){
  if (!nodes[0]) {
    throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
  }
  return DECLS[type](nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence" id="apidoc.element.livescript.ast.Existence">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Existence
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.compileNode" id="apidoc.element.livescript.ast.Existence.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Existence.prototype.compileNode = function (o){
  var node, ref$, code, op, eq;
  node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
  code = [node.compile(o, LEVEL_OP + PREC[&#x27;==&#x27;])];
  if (node instanceof Var &#x26;&#x26; !o.scope.check(code.join(&#x22;&#x22;), true)) {
    ref$ = this.negated
      ? [&#x27;||&#x27;, &#x27;=&#x27;]
      : [&#x27;&#x26;&#x26;&#x27;, &#x27;!&#x27;], op = ref$[0], eq = ref$[1];
    code = [&#x22;typeof &#x22;].concat(slice$.call(code), [&#x22; &#x22; + eq + &#x22;= &#x27;undefined&#x27; &#x22; + op + &#x22; &#x22;], slice$.call(code), [&#x22; &#x22; + eq + &#x22;== null
&#x22;]);
  } else {
    code.push(&#x22; &#x22; + (op = this.negated ? &#x27;==&#x27; : &#x27;!=&#x27;) + &#x22; null&#x22;);
  }
  if (o.level &#x3c; LEVEL_OP + PREC[op]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn(this, &#x22;(&#x22;, code, &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.invert" id="apidoc.element.livescript.ast.Existence.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Existence.prototype.invert = function (){
  this.negated = !this.negated;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.show" id="apidoc.element.livescript.ast.Existence.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Existence.prototype.show = function (){
  return this.negated &#x26;&#x26; &#x27;!&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For" id="apidoc.element.livescript.ast.For">
        function <span class="apidocSignatureSpan">livescript.</span>ast.For
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &#x26;&#x26; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &#x3c; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &#x26;&#x26; !this.object) {
    this.carp(&#x27;`for own` requires `of`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.addBody" id="apidoc.element.livescript.ast.For.prototype.addBody">
        function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.For.prototype.addBody = function (body){
  var hasYield, ref$, x$, that, this$ = this;
  hasYield = !!body.traverseChildren(function(child){
    if (child instanceof Yield) {
      return true;
    }
  });
  if (this[&#x27;let&#x27;]) {
    if (ref$ = this.ref, delete this.ref, ref$) {
      this.item = Literal(&#x27;..&#x27;);
    }
    body = Block(Call[&#x27;let&#x27;]((x$ = [], (that = this.index) &#x26;&#x26; x$.push(Assign(Var(that), Literal(&#x27;index$$&#x27;))), (that = this.item) &#x26;&#x26;
x$.push(Assign(that, Literal(&#x27;item$$&#x27;))), x$), body, hasYield));
  }
  superclass.prototype.addBody.call(this, body);
  if (this.guard &#x26;&#x26; this[&#x27;let&#x27;] &#x26;&#x26; (this.index || this.item)) {
    this.body.lines[0][&#x27;if&#x27;].traverseChildren(function(it){
      if (it instanceof Var) {
        if (this$.index &#x26;&#x26; it.value === this$.index) {
          it.value = &#x27;index$$&#x27;;
        }
        if (this$.item &#x26;&#x26; it.value === this$.item.value) {
          it.value = &#x27;item$$&#x27;;
        }
      }
    });
  }
  if (this[&#x27;let&#x27;]) {
    if (hasYield) {
      this.body = Block(Yield(&#x27;yieldfrom&#x27;, body));
    }
    delete this.index;
    delete this.item;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.compileNode" id="apidoc.element.livescript.ast.For.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.For.prototype.compileNode = function (o){
  var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
  o.loop = true;
  temps = this.temps = [];
  if (this.object &#x26;&#x26; this.index) {
    o.scope.declare(idx = this.index);
  } else {
    temps.push(idx = o.scope.temporary(&#x27;i&#x27;));
  }
  if (!this.body) {
    this.addBody(Block(Var(idx)));
  }
  if (!this.object) {
    ref$ = (this.step || Literal(1)).compileLoopReference(o, &#x27;step&#x27;), pvar = ref$[0], step = ref$[1];
    pvar === step || temps.push(pvar);
  }
  if (this.from) {
    if (this.ref) {
      this.item = Var(idx);
    }
    ref$ = this.to.compileLoopReference(o, &#x27;to&#x27;), tvar = ref$[0], tail = ref$[1];
    fvar = this.from.compile(o, LEVEL_LIST);
    vars = idx + &#x22; = &#x22; + fvar;
    if (tail !== tvar) {
      vars += &#x22;, &#x22; + tail;
      temps.push(tvar);
    }
    if (!this.step &#x26;&#x26; +fvar &#x3e; +tvar) {
      pvar = step = -1;
    }
    eq = this.op === &#x27;til&#x27; ? &#x27;&#x27; : &#x27;=&#x27;;
    cond = +pvar
      ? idx + &#x22; &#x22; + &#x27;&#x3c;&#x3e;&#x27;.charAt(pvar &#x3c; 0) + eq + &#x22; &#x22; + tvar
      : pvar + &#x22; &#x3c; 0 ? &#x22; + idx + &#x22; &#x3e;&#x22; + eq + &#x22; &#x22; + tvar + &#x22; : &#x22; + idx + &#x22; &#x3c;&#x22; + eq + &#x22; &#x22; + tvar;
  } else {
    if (this.ref) {
      this.item = Var(o.scope.temporary(&#x27;x&#x27;));
    }
    if (this.item || this.object &#x26;&#x26; this.own || this[&#x27;let&#x27;]) {
      ref$ = this.source.compileLoopReference(o, &#x27;ref&#x27;, !this.object, true), svar = ref$[0], srcPart = ref$[1];
      svar === srcPart || temps.push(svar);
    } else {
      svar = srcPart = this.source.compile(o, LEVEL_PAREN);
    }
    if (!this.object) {
      if (0 &#x3e; pvar &#x26;&#x26; ~~pvar === +pvar) {
        vars = idx + &#x22; = &#x22; + srcPart + &#x22;.length - 1&#x22;;
        cond = idx + &#x22; &#x3e;= 0&#x22;;
      } else {
        temps.push(lvar = o.scope.temporary(&#x27;len&#x27;));
        vars = idx + &#x22; = 0, &#x22; + lvar + &#x22; = &#x22; + srcPart + &#x22;.length&#x22;;
        cond = idx + &#x22; &#x3c; &#x22; + lvar;
      }
    }
  }
  this[&#x27;else&#x27;] &#x26;&#x26; (this.yet = o.scope.temporary(&#x27;yet&#x27;));
  head = [sn(this, &#x27;for (&#x27;)];
  if (this.object) {
    head.push(idx, &#x22; in &#x22;);
  }
  if (that = this.yet) {
    head.push(that, &#x22; = true, &#x22;);
  }
  if (this.object) {
    head.push(srcPart);
  } else {
    step === pvar || (vars += &#x27;, &#x27; + step);
    head.push(vars, &#x22;; &#x22;, cond, &#x22;; &#x22; + (1 == Math.abs(pvar)
      ? (pvar &#x3c; 0 ? &#x27;--&#x27; : &#x27;++&#x27;) + idx
      : idx + (pvar &#x3c; 0
        ? &#x27; -= &#x27; + pvar.toString().slice(1)
        : &#x27; += &#x27; + pvar)));
  }
  this.own &#x26;&#x26; head.push(sn(this, &#x22;) if (&#x22;), o.scope.assign(&#x27;own$&#x27;, &#x27;{}.hasOwnProperty&#x27;), &#x22;.call(&#x22;, svar, &#x22;, &#x22;, idx, &#x22;)&#x22;);
  head.push(sn(this, &#x27;) {&#x27;));
  if (this[&#x27;let&#x27;]) {
    this.body.traverseChildren(function(it){
      switch (it.value) {
      case &#x27;index$$&#x27;:
        it.value = idx;
        break;
      case &#x27;item$$&#x27;:
        it.value = svar + &#x22;[&#x22; + idx + &#x22;]&#x22;;
      }
    });
  }
  o.indent += TAB;
  if (this.index &#x26;&#x26; !this.object) {
    head.push(&#x27;\n&#x27; + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), &#x27;;&#x27;);
  }
  if (this.item &#x26;&#x26; !this.item.isEmpty() &#x26;&#x26; !this.from) {
    head.push(&#x27;\n&#x27; + o.indent, Assign(this.item, JS(svar + &#x22;[&#x22; + idx + &#x22;]&#x22;)).compile(o, LEVEL_TOP), &#x27;;&#x27;);
  }
  if (this.ref) {
    o.ref = this.item.value;
  }
  body = this.compileBody(o);
  if ((this.item || (this.index &#x26;&#x26; !this.object)) &#x26;&#x26; &#x27;}&#x27; === body.toString().charAt(0)) {
    head.push(&#x27;\n&#x27; + this.tab);
  }
  return sn.apply(null, [null].concat(slice$.call(head), [body]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.show" id="apidoc.element.livescript.ast.For.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.For.prototype.show = function (){
  return ((this.kind || []).concat(this.index)).join(&#x27; &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun" id="apidoc.element.livescript.ast.Fun">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &#x26;&#x26; &#x27;this$&#x27;;
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileNode" id="apidoc.element.livescript.ast.Fun.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.compileNode = function (o){
  var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this;
  pscope = o.scope;
  sscope = pscope.shared || pscope;
  scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper &#x26;&#x26; sscope);
  scope.fun = this;
  if (that = this.proto) {
    scope.assign(&#x27;prototype&#x27;, that.compile(o) + &#x22;.prototype&#x22;);
  }
  if (that = this.cname) {
    scope.assign(&#x27;constructor&#x27;, that);
  }
  if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
    o.indent = this.tab = &#x27;&#x27;;
  }
  o.indent += TAB;
  body = this.body, name = this.name, tab = this.tab;
  code = [&#x27;function&#x27;];
  if (this.generator) {
    this.ctor &#x26;&#x26; this.carp(&#x22;a constructor can&#x27;t be a generator&#x22;);
    o.inGenerator = true;
    code.push(&#x27;*&#x27;);
  } else if (!this.wrapper) {
    o.inGenerator = false;
  }
  if (this.bound === &#x27;this$&#x27;) {
    if (this.ctor) {
      scope.assign(&#x27;this$&#x27;, &#x27;this instanceof ctor$ ? this : new ctor$&#x27;);
      body.lines.push(Return(Literal(&#x27;this$&#x27;)));
    } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
      this.bound = that;
    } else {
      sscope.assign(&#x27;this$&#x27;, &#x27;this&#x27;);
    }
  }
  if (this.statement) {
    name || this.carp(&#x27;nameless function declaration&#x27;);
    pscope === o.block.scope || this.carp(&#x27;misplaced function declaration&#x27;);
    this.accessor &#x26;&#x26; this.carp(&#x27;named accessor&#x27;);
    pscope.add(name, &#x27;function&#x27;, this);
  }
  if (this.statement || name &#x26;&#x26; this.labeled) {
    code.push(&#x27; &#x27;, scope.add(name, &#x27;function&#x27;, this));
  }
  this.hushed || this.ctor || this.newed || body.makeReturn();
  code.push(&#x22;(&#x22;, this.compileParams(o, scope), &#x22;)&#x22;);
  code = [sn.apply(null, [this].concat(slice$.call(code)))];
  code.push(&#x22;{&#x22;);
  if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
    code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
  }
  code.push(&#x27;}&#x27;);
  curryCodeCheck = function(){
    if (this$.curried &#x26;&#x26; this$.hasSplats) {
      this$.carp(&#x27;cannot curry a function with a variable number of arguments&#x27;);
    }
    if (this$.curried &#x26;&#x26; this$.params.length &#x3e; 1 &#x26;&#x26; !this$.classBound) {
      if (this$.bound) {
        return [util(&#x27;curry&#x27;), &#x22;((&#x22;].concat(slice$.call(code), [&#x22;), true)&#x22;]);
      } else {
        return [util(&#x27;curry&#x27;), &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
      }
    } else {
      return code;
    }
  };
  if (inLoop) {
    return pscope.assign(pscope.temporary(&#x27;fn&#x27;), sn.apply(null, [null].concat(slice$.call(curryCodeCheck()))));
  }
  if (this.returns) {
    code.push(&#x22;\n&#x22; + tab + &#x22;return &#x22;, name, &#x22;;&#x22;);
  } else if (this.bound &#x26;&#x26; this.ctor) {
    code.push(&#x27; function ctor$(){} ctor$.prototype = prototype;&#x27;);
  }
  code = curryCodeCheck();
  if (this.front &#x26;&#x26; !this.statement) {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileParams" id="apidoc.element.livescript.ast.Fun.prototype.compileParams">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.compileParams
        <span class="apidocSignatureSpan">(o, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.compileParams = function (o, scope){
  var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
  params = this.params, length = params.length, body = this.body;
  for (i$ = params.length - 1; i$ &#x3e;= 0; --i$) {
    p = params[i$];
    if (!(p.isEmpty() || p.filler)) {
      break;
    }
    --params.length;
  }
  for (i$ = 0, len$ = params.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    p = params[i$];
    if (p.left instanceof Splat) {
      p.carp(&#x27;invalid splat&#x27;);
    }
    if (p instanceof Splat) {
      this.hasSplats = true;
      splace = i;
    } else if (p.op === &#x27;=&#x27;) {
      params[i] = Binary(p.logic || &#x27;?&#x27;, p.left, p.right);
    }
  }
  if (splace != null) {
    rest = params.splice(splace, 9e9);
  } else if (this.accessor) {
    if (that = params[1]) {
      that.carp(&#x27;excess accessor parameter&#x27;);
    }
  } else if (!(length || this.wrapper)) {
    if (body.traverseChildren(function(it){
      return it.value === &#x27;it&#x27; || null;
    })) {
      params[0] = Var(&#x27;it&#x27;);
    }
  }
  names = [];
  assigns = [];
  for (i$ = 0, len$ = params.length; i$ &#x3c; len$; ++i$) {
    p = params[i$];
    vr = p;
    if (df = vr.getDefault()) {
      vr = vr.first;
    }
    if (vr.isEmpty()) {
      vr = Var(scope.temporary(&#x27;arg&#x27;));
    } else if (vr.value === &#x27;..&#x27;) {
      vr = Var(o.ref = scope.temporary());
    } else if (!(vr instanceof Var)) {
      unaries = [];
      while (vr instanceof Unary) {
        hasUnary = true;
        unaries.push(vr);
        vr = vr.it;
      }
      v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary(&#x27;arg&#x27;));
      assigns.push(Assign(vr, (fn$())));
      vr = v;
    } else if (df) {
      assigns.push(Assign(vr, p.second, &#x27;=&#x27;, p.op, true));
    }
    names.push(scope.add(vr.value, &#x27;arg&#x27;, p), &#x27;, &#x27;);
  }
  if (rest) {
    while (splace--) {
      rest.unshift(Arr());
    }
    assigns.push(Assign(Arr(rest), Literal(&#x27;arguments&#x27;)));
  }
  if (assigns.length) {
    (ref$ = this.body).prepend.apply(ref$, assigns);
  }
  names.pop();
  return sn.apply(null, [null].concat(slice$.call(names)));
  function fn$(){
    switch (false) {
    case !df:
      return Binary(p.op, v, p.second);
    case !hasUnary:
      return fold(function(x, y){
        y.it = x;
        return y;
      }, v, unaries.reverse());
    default:
      return v;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.isStatement" id="apidoc.element.livescript.ast.Fun.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.isStatement = function (){
  return !!this.statement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn" id="apidoc.element.livescript.ast.Fun.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.makeReturn = function (){
  if (this.statement) {
    return this.returns = true, this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.named" id="apidoc.element.livescript.ast.Fun.prototype.named">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.named
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.named = function (it){
  return this.name = it, this.statement = true, this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.ripName" id="apidoc.element.livescript.ast.Fun.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.ripName = function (it){
  this.name || (this.name = it.varName());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.show" id="apidoc.element.livescript.ast.Fun.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.show = function (){
  var that;
  return [this.name] + [(that = this.bound) ? &#x22;~&#x22; + that : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren" id="apidoc.element.livescript.ast.Fun.prototype.traverseChildren">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.traverseChildren
        <span class="apidocSignatureSpan">(arg$, xscope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.traverseChildren = function (arg$, xscope){
  if (xscope) {
    return superclass.prototype.traverseChildren.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If" id="apidoc.element.livescript.ast.If">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$[&#x27;if&#x27;] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileExpression" id="apidoc.element.livescript.ast.If.prototype.compileExpression">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileExpression
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.compileExpression = function (o){
  var thn, els, code, pad;
  thn = this.then, els = this[&#x27;else&#x27;] || Literal(&#x27;void&#x27;);
  this[&#x27;void&#x27;] &#x26;&#x26; (thn[&#x27;void&#x27;] = els[&#x27;void&#x27;] = true);
  if (!this[&#x27;else&#x27;] &#x26;&#x26; (this.cond || this[&#x27;void&#x27;])) {
    return Parens(Binary(&#x27;&#x26;&#x26;&#x27;, this[&#x27;if&#x27;], thn)).compile(o);
  }
  code = [sn(this, this[&#x27;if&#x27;].compile(o, LEVEL_COND))];
  pad = els.isComplex() ? &#x27;\n&#x27; + (o.indent += TAB) : &#x27; &#x27;;
  code.push(pad + &#x22;&#x22;, sn(thn, &#x22;? &#x22;), thn.compile(o, LEVEL_LIST), pad + &#x22;&#x22;, sn(els, &#x22;: &#x22;), els.compile(o, LEVEL_LIST));
  if (o.level &#x3c; LEVEL_COND) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, &#x22;(&#x22;, code, &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileNode" id="apidoc.element.livescript.ast.If.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.compileNode = function (o){
  if (this.un) {
    this[&#x27;if&#x27;] = this[&#x27;if&#x27;].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.compileStatement(o);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileStatement" id="apidoc.element.livescript.ast.If.prototype.compileStatement">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileStatement
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.compileStatement = function (o){
  var code, els;
  code = [sn(this, &#x22;if (&#x22;, this[&#x27;if&#x27;].compile(o, LEVEL_PAREN), &#x22;) &#x22;)];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
  if (!(els = this[&#x27;else&#x27;])) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  return sn.apply(null, [null].concat(
    slice$.call(code), [
      sn(els, &#x27; else &#x27;), els instanceof constructor
        ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
        : this.compileBlock(o, els)
    ]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.getJump" id="apidoc.element.livescript.ast.If.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.getJump = function (it){
  var ref$;
  return this.then.getJump(it) || ((ref$ = this[&#x27;else&#x27;]) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isArray" id="apidoc.element.livescript.ast.If.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isCallable" id="apidoc.element.livescript.ast.If.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isRegex" id="apidoc.element.livescript.ast.If.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isString" id="apidoc.element.livescript.ast.If.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.makeReturn" id="apidoc.element.livescript.ast.If.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.makeReturn = function (){
  var ref$;
  this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
  if (this[&#x27;else&#x27;] != null) {
    this[&#x27;else&#x27;] = (ref$ = this[&#x27;else&#x27;]).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.show" id="apidoc.element.livescript.ast.If.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.show = function (){
  return this.un &#x26;&#x26; &#x27;!&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import" id="apidoc.element.livescript.ast.Import">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileAssign" id="apidoc.element.livescript.ast.Import.prototype.compileAssign">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.compileAssign
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.compileAssign = function (o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
    return this.left.compile(o);
  }
  top = !o.level;
  if (this.proto || (items.length &#x3c; 2 &#x26;&#x26; (top || this[&#x27;void&#x27;] || items[0] instanceof Splat))) {
    reft = this.left;
    if (reft.isComplex()) {
      reft = Parens(reft);
    }
  } else {
    ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
  }
  ref$ = top
    ? [&#x27;;&#x27;, &#x27;\n&#x27; + this.tab]
    : [&#x27;,&#x27;, &#x27; &#x27;], delim = ref$[0], space = ref$[1];
  delim += space;
  code = this.temps
    ? [left.compile(o, LEVEL_PAREN), delim]
    : [];
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    i &#x26;&#x26; code.push(com ? space : delim);
    if (com = node.comment) {
      code.push(node.compile(o));
      continue;
    }
    if (node instanceof Splat) {
      code.push(Import(reft, node.it).compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (dyna = node instanceof Parens) {
      ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
    } else if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        if (key instanceof Key) {
          key = JS(&#x22;&#x27;&#x22; + key.name + &#x22;&#x27;&#x22;);
        }
        code.push(&#x22;Object.defineProperty(&#x22;, reft.compile(o, LEVEL_LIST), &#x22;, &#x22;, key.compile(o, LEVEL_LIST), &#x22;, &#x22;, node.compileDescriptor
(o), &#x22;)&#x22;);
        continue;
      }
    } else {
      key = val = node;
    }
    dyna || (key = key.maybeKey());
    logic &#x26;&#x26; (val = (logic.first = val, logic));
    code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
  }
  if (top) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  this[&#x27;void&#x27;] || node instanceof Splat || code.push(com ? &#x27; &#x27; : &#x27;, &#x27;, reft.compile(o, LEVEL_PAREN));
  if (o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileNode" id="apidoc.element.livescript.ast.Import.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.compileNode = function (o){
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.compileAssign(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util(&#x22;import&#x22; + (this.all || &#x27;&#x27;)), [this.left, right])).compileNode(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isArray" id="apidoc.element.livescript.ast.Import.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isCallable" id="apidoc.element.livescript.ast.Import.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.show" id="apidoc.element.livescript.ast.Import.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.show = function (){
  return this.all;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Import.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.unfoldSoak = function (o){
  var left, value, ref$, temps;
  left = this.left;
  if (left instanceof Existence &#x26;&#x26; !left.negated) {
    if ((left = left.it) instanceof Var) {
      value = (this.left = left).value;
      if (!o.scope.check(value, true)) {
        left = JS(&#x22;typeof &#x22; + value + &#x22; != &#x27;undefined&#x27; &#x26;&#x26; &#x22; + value);
      }
    } else {
      ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
    }
    return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref$;
  }
  return If.unfoldSoak(o, this, &#x27;left&#x27;) || (this[&#x27;void&#x27;] || !o.level) &#x26;&#x26; If.unfoldSoak(o, this, &#x27;right&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In" id="apidoc.element.livescript.ast.In">
        function <span class="apidocSignatureSpan">livescript.</span>ast.In
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.compileNode" id="apidoc.element.livescript.ast.In.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.In.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.In.prototype.compileNode = function (o){
  var array, items, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
  items = (array = this.array.expandSlice(o).unwrap()).items;
  if (!(array instanceof Arr) || items.length &#x3c; 2) {
    return sn(this, this.negated ? &#x27;!&#x27; : &#x27;&#x27;, util(&#x27;in&#x27;), &#x22;(&#x22;, this.item.compile(o, LEVEL_LIST), &#x22;, &#x22;, array.compile(o, LEVEL_LIST
), &#x22;)&#x22;);
  }
  code = [];
  ref$ = this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
  ref$ = this.negated
    ? [&#x27; !== &#x27;, &#x27; &#x26;&#x26; &#x27;]
    : [&#x27; === &#x27;, &#x27; || &#x27;], cmp = ref$[0], cnj = ref$[1];
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    test = items[i$];
    if (code.length &#x3e; 0) {
      code.push(cnj);
    }
    if (test instanceof Splat) {
      code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
      if (!(i || sub === ref)) {
        code = [&#x22;(&#x22; + sub + &#x22;, &#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
      }
    } else {
      code.push(i || sub === ref
        ? ref
        : &#x22;(&#x22; + sub + &#x22;)&#x22;, cmp, test.compile(o, LEVEL_OP + PREC[&#x27;==&#x27;]));
    }
  }
  sub === ref || o.scope.free(ref);
  if (o.level &#x3c; LEVEL_OP + PREC[&#x27;||&#x27;]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index" id="apidoc.element.livescript.ast.Index">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = &#x27;.&#x27;);
  if (init &#x26;&#x26; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case &#x27;[]&#x27;:
    this$.vivify = Arr;
    break;
  case &#x27;{}&#x27;:
    this$.vivify = Obj;
    break;
  default:
    if (&#x27;=&#x27; === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.compile" id="apidoc.element.livescript.ast.Index.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Index.prototype.compile = function (o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
    return sn(this, &#x22;[&#x22;, code, &#x22;]&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.isComplex" id="apidoc.element.livescript.ast.Index.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Index.prototype.isComplex = function (){
  return this.key.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.show" id="apidoc.element.livescript.ast.Index.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Index.prototype.show = function (){
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.varName" id="apidoc.element.livescript.ast.Index.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Index.prototype.varName = function (){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS" id="apidoc.element.livescript.ast.JS">
        function <span class="apidocSignatureSpan">livescript.</span>ast.JS
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.compile" id="apidoc.element.livescript.ast.JS.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.compile
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.JS.prototype.compile = function (it){
  return sn(this, snSafe(this.literal
    ? entab(this.code, it.indent)
    : this.code));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.isCallable" id="apidoc.element.livescript.ast.JS.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.JS.prototype.isCallable = function (){
  return !this.comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.show" id="apidoc.element.livescript.ast.JS.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.JS.prototype.show = function (){
  if (this.comment) {
    return this.code;
  } else {
    return &#x22;`&#x22; + this.code + &#x22;`&#x22;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump" id="apidoc.element.livescript.ast.Jump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.compileNode" id="apidoc.element.livescript.ast.Jump.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Jump.prototype.compileNode = function (o){
  var that, ref$;
  if (that = this.label) {
    in$(that, (ref$ = o.labels) != null
      ? ref$
      : o.labels = []) || this.carp(&#x22;unknown label \&#x22;&#x22; + that + &#x22;\&#x22;&#x22;);
  } else {
    o[this.verb] || this.carp(&#x22;stray &#x22; + this.verb);
  }
  return sn(this, this.show() + &#x27;;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.getJump" id="apidoc.element.livescript.ast.Jump.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Jump.prototype.getJump = function (ctx){
  var that, ref$;
  ctx || (ctx = {});
  if (!ctx[this.verb]) {
    return this;
  }
  if (that = this.label) {
    return !in$(that, (ref$ = ctx.labels) != null
      ? ref$
      : ctx.labels = []) &#x26;&#x26; this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn" id="apidoc.element.livescript.ast.Jump.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.show" id="apidoc.element.livescript.ast.Jump.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Jump.prototype.show = function (){
  var that;
  return (this.verb || &#x27;&#x27;) + ((that = this.label) ? &#x27; &#x27; + that : &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key" id="apidoc.element.livescript.ast.Key">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = &#x27;&#x27; + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.assigns" id="apidoc.element.livescript.ast.Key.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Key.prototype.assigns = function (it){
  return it === this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.compile" id="apidoc.element.livescript.ast.Key.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Key.prototype.compile = function (){
  return sn(this, this.show());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.isComplex" id="apidoc.element.livescript.ast.Key.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.show" id="apidoc.element.livescript.ast.Key.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Key.prototype.show = function (){
  if (this.reserved) {
    return &#x22;&#x27;&#x22; + this.name + &#x22;&#x27;&#x22;;
  } else {
    return this.name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.varName" id="apidoc.element.livescript.ast.Key.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Key.prototype.varName = function (){
  var name;
  name = this.name;
  if (this.reserved || (name === &#x27;arguments&#x27; || name === &#x27;eval&#x27;)) {
    return &#x22;$&#x22; + name;
  } else {
    return name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.L" id="apidoc.element.livescript.ast.L">
        function <span class="apidocSignatureSpan">livescript.</span>ast.L
        <span class="apidocSignatureSpan">(a, b, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.L = function (a, b, node){
  if (node &#x26;&#x26; typeof node === &#x22;object&#x22;) {
    node.first_line = a.first_line + 1;
    node.first_column = a.first_column;
    node.last_line = b.last_line + 1;
    node.last_column = b.last_column;
    node.line = a.first_line + 1;
    node.column = a.first_column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label" id="apidoc.element.livescript.ast.Label">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || &#x27;_&#x27;;
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &#x26;&#x26; it || it.calling &#x26;&#x26; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.compileNode" id="apidoc.element.livescript.ast.Label.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.compileNode = function (o){
  var label, it, labels;
  label = this.label, it = this.it;
  labels = o.labels = slice$.call(o.labels || []);
  if (in$(label, labels)) {
    this.carp(&#x22;duplicate label \&#x22;&#x22; + label + &#x22;\&#x22;&#x22;);
  }
  labels.push(label);
  it.isStatement() || (it = Block(it));
  return sn(null, sn(this, label, &#x22;: &#x22;), it instanceof Block
    ? (o.indent += TAB, this.compileBlock(o, it))
    : it.compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.getJump" id="apidoc.element.livescript.ast.Label.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.getJump = function (ctx){
  var ref$;
  ctx || (ctx = {});
  ((ref$ = ctx.labels) != null
    ? ref$
    : ctx.labels = []).push(this.label);
  return this.it.getJump((ctx[&#x27;break&#x27;] = true, ctx));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isArray" id="apidoc.element.livescript.ast.Label.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isCallable" id="apidoc.element.livescript.ast.Label.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.makeReturn" id="apidoc.element.livescript.ast.Label.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.makeReturn = function (){
  var ref$;
  this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.show" id="apidoc.element.livescript.ast.Label.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.show = function (){
  return this.label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal" id="apidoc.element.livescript.ast.Literal">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + &#x22;&#x22;, true);
  }
  if (value === &#x27;super&#x27;) {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.compile" id="apidoc.element.livescript.ast.Literal.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.compile = function (o, level){
  var val, ref$;
  level == null &#x26;&#x26; (level = o.level);
  switch (val = this.value + &#x22;&#x22;) {
  case &#x27;this&#x27;:
    return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
  case &#x27;void&#x27;:
    if (!level) {
      return sn(this, &#x27;&#x27;);
    }
    val += &#x27; 8&#x27;;
    // fallthrough
  case &#x27;null&#x27;:
    if (level === LEVEL_CALL) {
      this.carp(&#x27;invalid use of &#x27; + this.value);
    }
    break;
  case &#x27;on&#x27;:
  case &#x27;yes&#x27;:
    val = &#x27;true&#x27;;
    break;
  case &#x27;off&#x27;:
  case &#x27;no&#x27;:
    val = &#x27;false&#x27;;
    break;
  case &#x27;*&#x27;:
    this.carp(&#x27;stray star&#x27;);
    break;
  case &#x27;..&#x27;:
    if (!(val = o.ref)) {
      this.carp(&#x27;stray reference&#x27;);
    }
    this.cascadee || (val.erred = true);
    break;
  case &#x27;debugger&#x27;:
    if (level) {
      return sn(this, &#x22;(function(){ debugger; }())&#x22;);
    }
  }
  return sn(this, snSafe(val));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isCallable" id="apidoc.element.livescript.ast.Literal.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isCallable = function (){
  var ref$;
  return (ref$ = this.value) === &#x27;this&#x27; || ref$ === &#x27;eval&#x27; || ref$ === &#x27;..&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isComplex" id="apidoc.element.livescript.ast.Literal.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isComplex = function (){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty" id="apidoc.element.livescript.ast.Literal.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isEmpty = function (){
  var ref$;
  return (ref$ = this.value) === &#x27;void&#x27; || ref$ === &#x27;null&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isRegex" id="apidoc.element.livescript.ast.Literal.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isRegex = function (){
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isString" id="apidoc.element.livescript.ast.Literal.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isString = function (){
  return 0 &#x3c;= &#x27;\&#x27;&#x22;&#x27;.indexOf((this.value + &#x22;&#x22;).charAt());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isWhat" id="apidoc.element.livescript.ast.Literal.prototype.isWhat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isWhat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isWhat = function (){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
  default:

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn" id="apidoc.element.livescript.ast.Literal.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.makeReturn = function (it){
  if (!it &#x26;&#x26; this.value === &#x27;debugger&#x27;) {
    return this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey" id="apidoc.element.livescript.ast.Literal.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.maybeKey = function (){
  if (ID.test(this.value)) {
    return Key(this.value);
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.varName" id="apidoc.element.livescript.ast.Literal.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.varName = function (){
  if (/^\w+$/.test(this.value)) {
    return &#x27;$&#x27; + this.value;
  } else {
    return &#x27;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj" id="apidoc.element.livescript.ast.Obj">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Obj
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.compileNode" id="apidoc.element.livescript.ast.Obj.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Obj.prototype.compileNode = function (o){
  var items, code, idt, dic, i$, len$, i, node, logic, rest, ref$, multi, key, val;
  items = this.items;
  if (!items.length) {
    return sn(this, this.front ? &#x27;({})&#x27; : &#x27;{}&#x27;);
  }
  code = [];
  idt = &#x27;\n&#x27; + (o.indent += TAB);
  dic = {};
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      code.push(idt, node.compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Splat || (node.key || node) instanceof Parens) {
      rest = items.slice(i);
      break;
    }
    if (logic) {
      if (node instanceof Prop) {
        node.val = (logic.first = node.val, logic);
      } else {
        node = Prop(node, (logic.first = node, logic));
      }
    }
    if (this.deepEq &#x26;&#x26; node instanceof Prop) {
      if (node.val instanceof Var &#x26;&#x26; node.val.value === &#x27;_&#x27;) {
        node.val = Obj([Prop(Key(&#x27;__placeholder__&#x27;), Literal(true))]);
      } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
        node.val.deepEq = true;
      }
    }
    if (multi) {
      code.push(&#x27;,&#x27;);
    } else {
      multi = true;
    }
    code.push(idt);
    if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        code.push(node.compileAccessor(o, key = key.compile(o)));
      } else {
        val.ripName(key);
        code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
      }
    } else {
      code.push(key = node.compile(o), &#x22;: &#x22;, key);
    }
    ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
    if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
      node.carp(&#x22;duplicate property \&#x22;&#x22; + key + &#x22;\&#x22;&#x22;);
    }
  }
  if (code.join(&#x22;&#x22;)) {
    code.push(&#x27;\n&#x27; + this.tab);
  }
  code = sn.apply(null, [null, sn(this, &#x22;{&#x22;)].concat(slice$.call(code), [sn(this, &#x22;}&#x22;)]));
  rest &#x26;&#x26; (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
  if (this.front &#x26;&#x26; &#x27;{&#x27; === code.toString().charAt()) {
    return sn(null, &#x22;(&#x22;, code, &#x22;)&#x22;);
  } else {
    return code;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.toSlice" id="apidoc.element.livescript.ast.Obj.prototype.toSlice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype.toSlice
        <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Obj.prototype.toSlice = function (o, base, symbol, assign){
  var items, ref$, ref, temps, i$, len$, i, node, name, chain, logic, key, val;
  items = this.items;
  if (items.length &#x3e; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      continue;
    }
    if (node instanceof Prop || node instanceof Splat) {
      node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
    } else {
      if (logic = node.getDefault()) {
        node = node.first;
      }
      if (node instanceof Parens) {
        ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
        if (assign) {
          ref$ = [node, key], key = ref$[0], node = ref$[1];
        }
        key = Parens(key);
      } else {
        key = node;
      }
      val = chain = Chain(base, [Index(node.maybeKey(), symbol)]);
      if (logic) {
        val = (logic.first = val, logic);
      }
      items[i] = Prop(key, val);
    }
    base = ref;
  }
  chain || this.carp(&#x27;empty slice&#x27;);
  if (temps) {
    (chain.head = Var(temps[0])).temp = true;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens" id="apidoc.element.livescript.ast.Parens">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.compile" id="apidoc.element.livescript.ast.Parens.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.compile = function (o, level){
  var it;
  level == null &#x26;&#x26; (level = o.level);
  it = this.it;
  it.cond || (it.cond = this.cond), it[&#x27;void&#x27;] || (it[&#x27;void&#x27;] = this[&#x27;void&#x27;]);
  if (this.calling &#x26;&#x26; (!level || this[&#x27;void&#x27;])) {
    it.head.hushed = true;
  }
  if (!(this.keep || this.newed || level &#x3e;= LEVEL_OP + PREC[it.op])) {
    return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
  }
  if (it.isStatement()) {
    return it.compileClosure(o);
  } else {
    return sn(null, sn(this.lb, &#x22;(&#x22;), it.compile(o, LEVEL_PAREN), sn(this.rb, &#x22;)&#x22;));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isComplex" id="apidoc.element.livescript.ast.Parens.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isComplex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.isComplex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isRegex" id="apidoc.element.livescript.ast.Parens.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isString" id="apidoc.element.livescript.ast.Parens.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.isString = function (){
  return this.string || this.it.isString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.show" id="apidoc.element.livescript.ast.Parens.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.show = function (){
  return this.string &#x26;&#x26; &#x27;&#x22;&#x22;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.unparen" id="apidoc.element.livescript.ast.Parens.prototype.unparen">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.unparen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.unparen = function (){
  if (this.keep) {
    return this;
  } else {
    return this.it.unparen();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop" id="apidoc.element.livescript.ast.Prop">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === &#x27;...&#x27;) {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
    }
    this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.assigns" id="apidoc.element.livescript.ast.Prop.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Prop.prototype.assigns = function (it){
  var ref$;
  return typeof (ref$ = this.val).assigns == &#x27;function&#x27; ? ref$.assigns(it) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor" id="apidoc.element.livescript.ast.Prop.prototype.compileAccessor">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.compileAccessor
        <span class="apidocSignatureSpan">(o, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Prop.prototype.compileAccessor = function (o, key){
  var funs, code, i$, len$, fun;
  funs = this.val;
  if (funs[1] &#x26;&#x26; funs[0].params.length + funs[1].params.length !== 1) {
    funs[0].carp(&#x27;invalid accessor parameter&#x27;);
  }
  code = [];
  for (i$ = 0, len$ = funs.length; i$ &#x3c; len$; ++i$) {
    fun = funs[i$];
    fun.accessor = true;
    code.push(fun.x, &#x22;et &#x22;, key, fun.compile(o, LEVEL_LIST).toString().slice(8), &#x27;,\n&#x27; + o.indent);
  }
  code.pop();
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor" id="apidoc.element.livescript.ast.Prop.prototype.compileDescriptor">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.compileDescriptor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Prop.prototype.compileDescriptor = function (o){
  var obj, i$, ref$, len$, fun;
  obj = Obj();
  for (i$ = 0, len$ = (ref$ = this.val).length; i$ &#x3c; len$; ++i$) {
    fun = ref$[i$];
    obj.items.push(Prop(Key(fun.x + &#x27;et&#x27;), fun));
  }
  obj.items.push(Prop(Key(&#x27;configurable&#x27;), Literal(true)));
  obj.items.push(Prop(Key(&#x27;enumerable&#x27;), Literal(true)));
  return obj.compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.show" id="apidoc.element.livescript.ast.Prop.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Prop.prototype.show = function (){
  return this.accessor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require" id="apidoc.element.livescript.ast.Require">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Require
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require.prototype.compile" id="apidoc.element.livescript.ast.Require.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Require.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Require.prototype.compile = function (o){
  var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
  getValue = function(item, throwError){
    switch (false) {
    case !(item instanceof Key):
      return item.name;
    case !(item instanceof Var):
      return item.value;
    case !(item instanceof Literal):
      return item.value;
    default:
      if (throwError) {
        return this$.carp(&#x27;invalid require! argument&#x27;);
      } else {
        return item;
      }
    }
  };
  processItem = function(item){
    var ref$, asg, value, asgValue, toAsg, main;
    ref$ = (function(){
      switch (false) {
      case !(item instanceof Prop):
        return [item.val, item.key];
      default:
        return [item, item];
      }
    }()), asg = ref$[0], value = ref$[1];
    asgValue = getValue(asg);
    toAsg = toString$.call(asgValue).slice(8, -1) === &#x27;String&#x27; ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
    value = stripString(getValue(value, true));
    main = Chain(CopyL(this, Var(&#x27;require&#x27;))).add(Call([Literal(&#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22;)]));
    return sn(item, Assign(toAsg, main).compile(o));
  };
  if (this.body.items != null) {
    code = [];
    for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ &#x3c; len$; ++i$) {
      item = ref$[i$];
      code.push(processItem(item), &#x22;;\n&#x22; + o.indent);
    }
    code.pop();
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, processItem(this.body));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return" id="apidoc.element.livescript.ast.Return">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &#x26;&#x26; it.value !== &#x27;void&#x27;) {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.compileNode" id="apidoc.element.livescript.ast.Return.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Return.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Return.prototype.compileNode = function (o){
  var that;
  return sn.apply(null, [this, &#x22;return&#x22;].concat(
    (that = this.it)
      ? [&#x27; &#x27;, that.compile(o, LEVEL_PAREN)]
      : [], [&#x22;;&#x22;]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice" id="apidoc.element.livescript.ast.Slice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Slice
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &#x26;&#x26; (this$.from = Literal(0));
  if (this$.to &#x26;&#x26; this$.type === &#x27;to&#x27;) {
    this$.to = Binary(&#x27;+&#x27;, this$.to, Literal(&#x27;1&#x27;));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.compileNode" id="apidoc.element.livescript.ast.Slice.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Slice.prototype.compileNode = function (o){
  var args;
  if (this.to &#x26;&#x26; this.type === &#x27;to&#x27;) {
    this.to = Binary(&#x27;||&#x27;, this.to, Literal(&#x27;9e9&#x27;));
  }
  args = [this.target, this.from];
  if (this.to) {
    args.push(this.to);
  }
  return Chain(Var(util(&#x27;slice&#x27;))).add(Index(Key(&#x27;call&#x27;), &#x27;.&#x27;, true)).add(Call(args)).compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.show" id="apidoc.element.livescript.ast.Slice.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Slice.prototype.show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat" id="apidoc.element.livescript.ast.Splat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Splat
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.assigns" id="apidoc.element.livescript.ast.Splat.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Splat.prototype.assigns = function (it){
  return this.it.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.compile" id="apidoc.element.livescript.ast.Splat.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype.compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Splat.prototype.compile = function (){
  return this.carp(&#x27;invalid splat&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice" id="apidoc.element.livescript.ast.StepSlice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode" id="apidoc.element.livescript.ast.StepSlice.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.StepSlice.prototype.compileNode = function (o){
  var ref$, sub, ref, temps, code;
  this.index = o.scope.temporary(&#x27;x&#x27;);
  ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
  this.guard = Binary(&#x27;&#x3c;&#x27;, Literal(this.index), Chain(ref).add(Index(Key(&#x27;length&#x27;))));
  this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
  if (this.makeReturnArg != null) {
    this.makeReturn(this.makeReturnArg);
  }
  code = [];
  if (temps) {
    code.push(sub.compile(o), &#x27;;&#x27; + &#x27;\n&#x27; + o.indent);
  }
  code.push(superclass.prototype.compileNode.apply(this, arguments));
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn" id="apidoc.element.livescript.ast.StepSlice.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype.makeReturn
        <span class="apidocSignatureSpan">(makeReturnArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.StepSlice.prototype.makeReturn = function (makeReturnArg){
  this.makeReturnArg = makeReturnArg;
  return superclass.prototype.makeReturn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super" id="apidoc.element.livescript.ast.Super">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.compile" id="apidoc.element.livescript.ast.Super.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Super.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Super.prototype.compile = function (o){
  var scope, that, result, ref$;
  scope = o.scope;
  if (!this.sproto) {
    for (; that = !scope.get(&#x27;superclass&#x27;) &#x26;&#x26; scope.fun; scope = scope.parent) {
      result = that;
      if (that = result.meth) {
        return sn(this, &#x27;superclass.prototype&#x27;, Index(that).compile(o));
      }
      if (that = result.stat) {
        return sn(this, &#x27;superclass&#x27;, Index(that).compile(o));
      }
      if (that = scope.fun.inClass) {
        return sn(this, that, &#x22;.superclass.prototype.&#x22;, scope.fun.name);
      } else if (that = scope.fun.inClassStatic) {
        return sn(this, that, &#x22;.superclass.&#x22;, scope.fun.name);
      }
    }
    if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
      return sn(this, that, &#x22;.superclass&#x22;);
    }
  }
  return sn(this, &#x27;superclass&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch" id="apidoc.element.livescript.ast.Switch">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this[&#x27;default&#x27;] = $default;
  if (type === &#x27;match&#x27;) {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &#x3e; 1) {
        throw &#x22;can&#x27;t have more than one topic in switch statement&#x22;;
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &#x26;&#x26; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &#x26;&#x26; last.tests[0] instanceof Var &#x26;&#x26; last
.tests[0].value === &#x27;_&#x27;) {
    this.cases.pop();
    this[&#x27;default&#x27;] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.compileNode" id="apidoc.element.livescript.ast.Switch.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Switch.prototype.compileNode = function (o){
  var tab, ref$, targetNode, target, topic, t, code, stop, i$, len$, i, c, that;
  tab = this.tab;
  if (this.target) {
    ref$ = Chain(this.target).cacheReference(o), targetNode = ref$[0], target = ref$[1];
  }
  topic = this.type === &#x27;match&#x27;
    ? (t = target
      ? [targetNode]
      : [], Block(t.concat([Literal(&#x27;false&#x27;)])).compile(o, LEVEL_PAREN))
    : !!this.topic &#x26;&#x26; this.anaphorize().compile(o, LEVEL_PAREN);
  code = [sn(this, &#x22;switch (&#x22;, snSafe(topic), &#x22;) {\n&#x22;)];
  stop = this[&#x27;default&#x27;] || this.cases.length - 1;
  o[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    c = ref$[i$];
    code.push(c.compileCase(o, tab, i === stop, this.type === &#x27;match&#x27; || !topic, this.type, target));
  }
  if (this[&#x27;default&#x27;]) {
    o.indent = tab + TAB;
    if (that = this[&#x27;default&#x27;].compile(o, LEVEL_TOP)) {
      code.push(tab + &#x22;default:\n&#x22;, that, &#x22;\n&#x22;);
    }
  }
  return sn.apply(null, [null].concat(slice$.call(code), [tab + &#x27;}&#x27;]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.getJump" id="apidoc.element.livescript.ast.Switch.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Switch.prototype.getJump = function (ctx){
  var i$, ref$, len$, c, that;
  ctx || (ctx = {});
  ctx[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    if (that = c.body.getJump(ctx)) {
      return that;
    }
  }
  return (ref$ = this[&#x27;default&#x27;]) != null ? ref$.getJump(ctx) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.isCallable" id="apidoc.element.livescript.ast.Switch.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Switch.prototype.isCallable = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    if (!c.isCallable()) {
      return false;
    }
  }
  if (this[&#x27;default&#x27;]) {
    return this[&#x27;default&#x27;].isCallable();
  } else {
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn" id="apidoc.element.livescript.ast.Switch.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Switch.prototype.makeReturn = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    c.makeReturn.apply(c, arguments);
  }
  if ((ref$ = this[&#x27;default&#x27;]) != null) {
    ref$.makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.show" id="apidoc.element.livescript.ast.Switch.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Switch.prototype.show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw" id="apidoc.element.livescript.ast.Throw">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.compileNode" id="apidoc.element.livescript.ast.Throw.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Throw.prototype.compileNode = function (o){
  var ref$;
  return sn(this, &#x22;throw &#x22;, ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;null&#x27;, &#x22;;&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.getJump" id="apidoc.element.livescript.ast.Throw.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype.getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try" id="apidoc.element.livescript.ast.Try">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var(&#x27;e&#x27;), Var(&#x27;e$&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.compileNode" id="apidoc.element.livescript.ast.Try.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Try.prototype.compileNode = function (o){
  var code, that;
  o.indent += TAB;
  code = [sn(this, &#x27;try &#x27;), this.compileBlock(o, this.attempt)];
  if (that = this.recovery || !this.ensure &#x26;&#x26; JS(&#x27;&#x27;)) {
    code.push(sn(that, &#x27; catch (e$) &#x27;), this.compileBlock(o, that));
  }
  if (that = this.ensure) {
    code.push(sn(that, &#x27; finally &#x27;), this.compileBlock(o, that));
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.getJump" id="apidoc.element.livescript.ast.Try.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Try.prototype.getJump = function (it){
  var ref$;
  return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.isCallable" id="apidoc.element.livescript.ast.Try.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Try.prototype.isCallable = function (){
  var ref$;
  return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) &#x26;&#x26; this.attempt.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.makeReturn" id="apidoc.element.livescript.ast.Try.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Try.prototype.makeReturn = function (){
  var ref$;
  this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
  if (this.recovery != null) {
    this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.show" id="apidoc.element.livescript.ast.Try.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Try.prototype.show = function (){
  return this.thrown;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary" id="apidoc.element.livescript.ast.Unary">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &#x26;&#x26; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case &#x27;!&#x27;:
      if (flag) {
        break;
      }
      if (it instanceof Fun &#x26;&#x26; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case &#x27;++&#x27;:
    case &#x27;--&#x27;:
      if (flag) {
        this$.post = true;
      }
      break;
    case &#x27;new&#x27;:
      if (it instanceof Existence &#x26;&#x26; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || &#x27;&#x27;).length; i$ &#x3c; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &#x26;&#x26; !node[&#x27;new&#x27;]) {
          if (node.method === &#x27;.call&#x27;) {
            node.args.shift();
          }
          node[&#x27;new&#x27;] = &#x27;new&#x27;;
          node.method = &#x27;&#x27;;
          return it;
        }
      }
      break;
    case &#x27;~&#x27;:
      if (it instanceof Fun &#x26;&#x26; it.statement &#x26;&#x26; !it.bound) {
        return it.bound = &#x27;this$&#x27;, it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc" id="apidoc.element.livescript.ast.Unary.prototype.compileAsFunc">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileAsFunc
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.compileAsFunc = function (o){
  if (this.op === &#x27;!&#x27;) {
    return sn(this, util(&#x27;not&#x27;));
  } else {
    return sn(this, &#x22;(&#x22;, Fun([], Block(Unary(this.op, Chain(Var(&#x27;it&#x27;))))).compile(o), &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileNode" id="apidoc.element.livescript.ast.Unary.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.compileNode = function (o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
    it.cond = true;
    break;
  case &#x27;new&#x27;:
    it.isCallable() || it.carp(&#x27;invalid constructor&#x27;);
    break;
  case &#x27;do&#x27;:
    if (o.level === LEVEL_TOP &#x26;&#x26; it instanceof Fun &#x26;&#x26; it.isStatement()) {
      return sn(this, it.compile(o), &#x22; &#x22;, Unary(&#x27;do&#x27;, Var(it.name)).compile(o));
    }
    x = Parens(it instanceof Existence &#x26;&#x26; !it.negated
      ? Chain(it).add(Call())
      : Call.make(it));
    return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
  case &#x27;delete&#x27;:
    if (it instanceof Var || !it.isAssignable()) {
      this.carp(&#x27;invalid delete&#x27;);
    }
    if (o.level &#x26;&#x26; !this[&#x27;void&#x27;]) {
      return this.compilePluck(o);
    }
    break;
  case &#x27;++&#x27;:
  case &#x27;--&#x27;:
    it.isAssignable() || this.carp(&#x27;invalid &#x27; + crement(op));
    if (that = it instanceof Var &#x26;&#x26; o.scope.checkReadOnly(it.value)) {
      this.carp(crement(op) + &#x22; of &#x22; + that + &#x22; \&#x22;&#x22; + it.value + &#x22;\&#x22;&#x22;, ReferenceError);
    }
    if (this.post) {
      it.front = this.front;
    }
    break;
  case &#x27;^^&#x27;:
    return sn(this, util(&#x27;clone&#x27;), &#x22;(&#x22;, it.compile(o, LEVEL_LIST), &#x22;)&#x22;);
  case &#x27;jsdelete&#x27;:
    return sn(this, &#x22;delete &#x22;, it.compile(o, LEVEL_LIST));
  case &#x27;classof&#x27;:
    return sn(this, util(&#x27;toString&#x27;), &#x22;.call(&#x22;, it.compile(o, LEVEL_LIST), &#x22;).slice(8, -1)&#x22;);
  }
  code = [it.compile(o, LEVEL_OP + PREC.unary)];
  if (this.post) {
    code.push(op);
  } else {
    if ((op === &#x27;new&#x27; || op === &#x27;typeof&#x27; || op === &#x27;delete&#x27;) || (op === &#x27;+&#x27; || op === &#x27;-&#x27;) &#x26;&#x26; op === code.join(&#x22;&#x22;).charAt()) {
      op += &#x27; &#x27;;
    }
    code.unshift(op);
  }
  if (o.level &#x3c; LEVEL_CALL) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck" id="apidoc.element.livescript.ast.Unary.prototype.compilePluck">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compilePluck
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.compilePluck = function (o){
  var ref$, get, del, code, ref;
  ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
  code = [ref = o.scope.temporary(), &#x22; = &#x22;, get.compile(o, LEVEL_LIST), &#x22;, delete &#x22;, del.compile(o, LEVEL_LIST), &#x22;, &#x22;, o.scope.free
(ref)];
  if (o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread" id="apidoc.element.livescript.ast.Unary.prototype.compileSpread">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileSpread
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.compileSpread = function (o){
  var it, ops;
  it = this.it;
  ops = [this];
  for (; it instanceof constructor; it = it.it) {
    ops.push(it);
  }
  if (!(it instanceof Splat &#x26;&#x26; (it = it.it.expandSlice(o).unwrap()) instanceof List)) {
    return &#x27;&#x27;;
  }
  return this.compileSpreadOver(o, it, function(node){
    var i$, ref$, op;
    for (i$ = (ref$ = ops).length - 1; i$ &#x3e;= 0; --i$) {
      op = ref$[i$];
      node = constructor(op.op, node, op.post);
    }
    return node;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors" id="apidoc.element.livescript.ast.Unary.prototype.getAccessors">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.getAccessors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.getAccessors = function (){
  var items;
  if (this.op !== &#x27;~&#x27;) {
    return;
  }
  if (this.it instanceof Fun) {
    return [this.it];
  }
  if (this.it instanceof Arr) {
    items = this.it.items;
    if (!items[2] &#x26;&#x26; items[0] instanceof Fun &#x26;&#x26; items[1] instanceof Fun) {
      return items;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.invert" id="apidoc.element.livescript.ast.Unary.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.invert = function (){
  var ref$;
  if (this.op === &#x27;!&#x27; &#x26;&#x26; ((ref$ = this.it.op) === &#x27;!&#x27; || ref$ === &#x27;&#x3c;&#x27; || ref$ === &#x27;&#x3e;&#x27; || ref$ === &#x27;&#x3c;=&#x27; || ref$ === &#x27;&#x3e;=&#x27; || ref$ === &#x27;
of&#x27; || ref$ === &#x27;instanceof&#x27;)) {
    return this.it;
  }
  return constructor(&#x27;!&#x27;, this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isArray" id="apidoc.element.livescript.ast.Unary.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.isArray = function (){
  return this.it instanceof Arr &#x26;&#x26; this.it.items.length || this.it instanceof Chain &#x26;&#x26; this.it.isArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isCallable" id="apidoc.element.livescript.ast.Unary.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.isCallable = function (){
  var ref$;
  return ((ref$ = this.op) === &#x27;do&#x27; || ref$ === &#x27;new&#x27; || ref$ === &#x27;delete&#x27;) || this.it == null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isString" id="apidoc.element.livescript.ast.Unary.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.isString = function (){
  var ref$;
  return (ref$ = this.op) === &#x27;typeof&#x27; || ref$ === &#x27;classof&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.show" id="apidoc.element.livescript.ast.Unary.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.show = function (){
  return [this.post ? &#x27;@&#x27; : void 8] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Unary.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.unfoldSoak = function (o){
  var ref$;
  return ((ref$ = this.op) === &#x27;++&#x27; || ref$ === &#x27;--&#x27; || ref$ === &#x27;delete&#x27;) &#x26;&#x26; this.it != null &#x26;&#x26; If.unfoldSoak(o, this, &#x27;it&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util" id="apidoc.element.livescript.ast.Util">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Util
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.compile" id="apidoc.element.livescript.ast.Util.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Util.prototype.compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Util.prototype.compile = function (){
  return sn(this, util(this.verb));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var" id="apidoc.element.livescript.ast.Var">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.assigns" id="apidoc.element.livescript.ast.Var.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Var.prototype.assigns = function (it){
  return it === this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.compile" id="apidoc.element.livescript.ast.Var.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Var.prototype.compile = function (o){
  return sn(this, this.temp
    ? o.scope.free(this.value)
    : this.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.maybeKey" id="apidoc.element.livescript.ast.Var.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Var.prototype.maybeKey = function (){
  var ref$;
  return ref$ = Key(this.value), ref$.line = this.line, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.varName" id="apidoc.element.livescript.ast.Var.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Var.prototype.varName = function (){
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars" id="apidoc.element.livescript.ast.Vars">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Vars
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.compile" id="apidoc.element.livescript.ast.Vars.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Vars.prototype.compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Vars.prototype.compile = function (o, level){
  var i$, ref$, len$, v, value;
  for (i$ = 0, len$ = (ref$ = this.vars).length; i$ &#x3c; len$; ++i$) {
    v = ref$[i$], value = v.value;
    if (!(v instanceof Var)) {
      v.carp(&#x27;invalid variable declaration&#x27;);
    }
    if (o.scope.check(value)) {
      v.carp(&#x22;redeclaration of \&#x22;&#x22; + value + &#x22;\&#x22;&#x22;);
    }
    o.scope.declare(value, v);
  }
  return sn(this, Literal(&#x27;void&#x27;).compile(o, level));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While" id="apidoc.element.livescript.ast.While">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &#x26;&#x26; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== &#x27;&#x27; + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addBody" id="apidoc.element.livescript.ast.While.prototype.addBody">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.addBody = function (body){
  var top;
  this.body = body;
  if (this.guard) {
    this.body = Block(If(this.guard, this.body));
  }
  top = this.body.lines[0];
  if ((top != null ? top.verb : void 8) === &#x27;continue&#x27; &#x26;&#x26; !top.label) {
    this.body.lines.length = 0;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addGuard" id="apidoc.element.livescript.ast.While.prototype.addGuard">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addGuard
        <span class="apidocSignatureSpan">(guard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.addGuard = function (guard){
  this.guard = guard;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addObjComp" id="apidoc.element.livescript.ast.While.prototype.addObjComp">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addObjComp
        <span class="apidocSignatureSpan">(objComp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.addObjComp = function (objComp){
  this.objComp = objComp != null ? objComp : true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileBody" id="apidoc.element.livescript.ast.While.prototype.compileBody">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.compileBody
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.compileBody = function (o){
  var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ =
this;
  o[&#x27;break&#x27;] = o[&#x27;continue&#x27;] = true;
  lines = this.body.lines, yet = this.yet, tab = this.tab;
  code = [];
  ret = [];
  mid = [];
  empty = this.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;;
  getResultName = function(){
    return _resultName != null
      ? _resultName
      : _resultName = o.scope.temporary(this$.objComp ? &#x27;resultObj&#x27; : &#x27;results&#x27;);
  };
  last = lines != null ? lines[lines.length - 1] : void 8;
  if (!(this.isComprehension || this.inComprehension) || (last != null &#x26;&#x26; last.isComprehension)) {
    hasLoop = false;
    if (last != null) {
      last.traverseChildren(function(it){
        var ref$;
        if (it instanceof Block &#x26;&#x26; (ref$ = it.lines)[ref$.length - 1] instanceof While) {
          hasLoop = true;
        }
      });
    }
    if (this.returns &#x26;&#x26; !this.resVar) {
      this.resVar = res = o.scope.assign(getResultName(), empty);
    }
    if (this.resVar &#x26;&#x26; (last instanceof While || hasLoop)) {
      temp = o.scope.temporary(&#x27;lresult&#x27;);
      lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
        ? Obj()
        : Arr(), &#x27;=&#x27;));
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(temp);
      }
      mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key(&#x27;push&#x27;), &#x27;.&#x27;, true)).add(Call([Chain(Var(temp))])).compile(o), &#x22;;\n&#x22; +
this.tab);
    } else {
      this.hasReturned = true;
      if (this.resVar) {
        this.body.makeReturn(this.resVar);
      }
    }
  }
  if (this.returns) {
    if ((!last instanceof While &#x26;&#x26; !this.hasReturned) || this.isComprehension || this.inComprehension) {
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
      }
    }
    ret.push(&#x22;\n&#x22; + this.tab + &#x22;return &#x22;, res || empty, &#x22;;&#x22;);
    if ((ref$ = this[&#x27;else&#x27;]) != null) {
      ref$.makeReturn();
    }
  }
  yet &#x26;&#x26; lines.unshift(JS(yet + &#x22; = false;&#x22;));
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
  }
  code.push.apply(code, mid);
  code.push(&#x27;}&#x27;);
  if (this.post) {
    code.push(sn(this, &#x22; while (&#x22;), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, &#x22;);&#x22;));
  }
  if (yet) {
    code.push(sn(this, &#x22; if (&#x22;), yet, sn(this, &#x22;) &#x22;), this.compileBlock(o, Block(this[&#x27;else&#x27;])));
    o.scope.free(yet);
  }
  return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileNode" id="apidoc.element.livescript.ast.While.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.compileNode = function (o){
  var test, ref$, head, that;
  o.loop = true;
  this.test &#x26;&#x26; (this.un
    ? this.test = this.test.invert()
    : this.anaphorize());
  if (this.post) {
    return sn(null, sn(this, &#x27;do {&#x27;), this.compileBody((o.indent += TAB, o)));
  }
  test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;&#x27;;
  if (!(this.update || this[&#x27;else&#x27;])) {
    head = !snEmpty(test)
      ? [sn(this, &#x22;while (&#x22;), test]
      : [sn(this, &#x27;for (;;&#x27;)];
  } else {
    head = [sn(this, &#x27;for (&#x27;)];
    if (this[&#x27;else&#x27;]) {
      head.push(this.yet = o.scope.temporary(&#x27;yet&#x27;), &#x22; = true&#x22;);
    }
    head.push(sn(this, &#x22;;&#x22;), test.toString() &#x26;&#x26; &#x27; &#x27;, test, sn(this, &#x22;;&#x22;));
    if (that = this.update) {
      head.push(&#x27; &#x27;, that.compile(o, LEVEL_PAREN));
    }
  }
  return sn.apply(null, [null].concat(slice$.call(head), [sn(this, &#x27;) {&#x27;), this.compileBody((o.indent += TAB, o))]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.getJump" id="apidoc.element.livescript.ast.While.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.getJump = function (ctx){
  var i$, ref$, ref1$, len$, node;
  ctx || (ctx = {});
  ctx[&#x27;continue&#x27;] = true;
  ctx[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.getJump(ctx)) {
      return node;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeComprehension" id="apidoc.element.livescript.ast.While.prototype.makeComprehension">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.makeComprehension
        <span class="apidocSignatureSpan">(toAdd, loops)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.makeComprehension = function (toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().addBody(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeReturn" id="apidoc.element.livescript.ast.While.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.makeReturn = function (it){
  var last, ref$, ref1$, ref2$;
  if (this.hasReturned) {
    return this;
  }
  if (it) {
    if (this.objComp) {
      this.body = Block(this.body.makeReturn(it, true));
    } else {
      if (!(this.body || this.index)) {
        this.addBody(Block(Var(this.index = &#x27;ridx$&#x27;)));
      }
      last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
      if ((this.isComprehension || this.inComprehension) &#x26;&#x26; !(last != null &#x26;&#x26; last.isComprehension)) {
        (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
        if ((ref1$ = this[&#x27;else&#x27;]) != null) {
          ref1$.makeReturn.apply(ref1$, arguments);
        }
        this.hasReturned = true;
      } else {
        this.resVar = it;
        if ((ref2$ = this[&#x27;else&#x27;]) != null) {
          ref2$.makeReturn.apply(ref2$, arguments);
        }
      }
    }
  } else {
    this.getJump() || (this.returns = true);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.show" id="apidoc.element.livescript.ast.While.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.show = function (){
  return [this.un ? &#x27;!&#x27; : void 8, this.post ? &#x27;do&#x27; : void 8].join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield" id="apidoc.element.livescript.ast.Yield">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Yield
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.compileNode" id="apidoc.element.livescript.ast.Yield.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Yield.prototype.compileNode = function (o){
  var code;
  code = [];
  if (this.op === &#x27;yieldfrom&#x27;) {
    code.push(&#x27;yield*&#x27;);
  } else {
    code.push(&#x27;yield&#x27;);
  }
  if (this.it) {
    code.push(&#x22; &#x22; + this.it.compile(o, LEVEL_OP + PREC.unary));
  }
  return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.isCallable" id="apidoc.element.livescript.ast.Yield.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Yield.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.show" id="apidoc.element.livescript.ast.Yield.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Yield.prototype.show = function (){
  if (this.op === &#x27;yieldfrom&#x27;) {
    return &#x27;from&#x27;;
  } else {
    return &#x27;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.fromJSON" id="apidoc.element.livescript.ast.fromJSON">
        function <span class="apidocSignatureSpan">livescript.</span>ast.fromJSON
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
  if (that = it.type) {
    node = clone$(exports[that].prototype);
    for (key in it) {
      val = it[key];
      node[key] = fromJSON(val);
    }
    return node;
  }
  if (it.length != null) {
    for (i$ = 0, len$ = it.length; i$ &#x3c; len$; ++i$) {
      v = it[i$];
      results$.push(fromJSON(v));
    }
    return results$;
  } else {
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.parse" id="apidoc.element.livescript.ast.parse">
        function <span class="apidocSignatureSpan">livescript.</span>ast.parse
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.parse = function (json){
  return exports.fromJSON(JSON.parse(json));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.command" id="apidoc.element.livescript.command">
        function <span class="apidocSignatureSpan">livescript.</span>command
        <span class="apidocSignatureSpan">(args, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">command = function (args, arg$){
  var ref$, say, sayWithTimestamp, warn, die, p, pp, ppp, fileExists, dasherizeVars, startsWith, o, positional, e, validMapValues
, toInsert, that, filename, jsonCallback;
  ref$ = arg$ != null
    ? arg$
    : {}, say = ref$.say, sayWithTimestamp = ref$.sayWithTimestamp, warn = ref$.warn, die = ref$.die;
  say == null &#x26;&#x26; (say = console.log);
  sayWithTimestamp == null &#x26;&#x26; (sayWithTimestamp = util.log);
  warn == null &#x26;&#x26; (warn = console.error);
  die == null &#x26;&#x26; (die = function(message){
    console.error(message);
    process.exit(1);
  });
  p = function(){
    var args, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ &#x3c; to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    each(console.dir, args);
  };
  pp = function(x, showHidden, depth){
    say(util.inspect(x, showHidden, depth, !process.env.NODE_DISABLE_COLORS));
  };
  ppp = function(it){
    pp(it, true, null);
  };
  fileExists = function(path){
    try {
      fs.statSync(path);
      return true;
    } catch (e$) {}
  };
  dasherizeVars = function(str){
    if (/^[a-z]/.exec(str)) {
      return dasherize(str);
    } else {
      return str;
    }
  };
  startsWith = function(str){
    var this$ = this;
    return function(it){
      return it.indexOf(str) === 0;
    };
  };
  try {
    o = parseOptions(args);
    positional = o._;
  } catch (e$) {
    e = e$;
    die(e.message);
  }
  switch (false) {
  case !o.nodejs:
    forkNode();
    break;
  case !o.version:
    say(&#x22;LiveScript version &#x22; + version);
    break;
  case !o.help:
    say(generateHelp({
      interpolate: {
        version: version
      }
    }));
    break;
  default:
    validMapValues = [&#x27;none&#x27;, &#x27;linked&#x27;, &#x27;linked-src&#x27;, &#x27;embedded&#x27;, &#x27;debug&#x27;];
    if (!in$(o.map, validMapValues)) {
      die(&#x22;Option --map must be either: &#x22; + validMapValues.join(&#x27;, &#x27;));
    }
    o.run = !(o.compile || (o.compile = o.output));
    if (args === process.argv) {
      process.argv[0] = process.argv[1];
      toInsert = o.stdin
        ? positional
        : o.run
          ? positional.splice(1, 9e9)
          : [];
      (ref$ = process.argv).splice.apply(ref$, [2, 9e9].concat(slice$.call(toInsert)));
    }
    if (that = o.require) {
      filename = module.filename;
      module.filename = &#x27;.&#x27;;
      each(function(it){
        return global[nameFromPath(it)] = require(it);
      })(
      that);
      module.filename = filename;
    }
    switch (false) {
    case !o.eval:
      jsonCallback = function(input){
        if (o.prelude) {
          import$(global, prelude);
        }
        o.runContext = JSON.parse(input.toString());
        compileScript(&#x27;&#x27;, o.eval);
      };
      if (positional.length &#x26;&#x26; (o.json || /\.json$/.test(positional[0]))) {
        o.json = true;
        fshoot(&#x27;readFile&#x27;, positional[0], jsonCallback);
      } else if (o.json) {
        getStdin(jsonCallback);
      } else {
        compileScript(&#x27;&#x27;, o.eval);
      }
      break;
    case !o.stdin:
      compileStdin();
      break;
    case !positional.length:
      compileScripts();
      break;
    case !require(&#x27;tty&#x27;).isatty(0):
      say(&#x22;LiveScript &#x22; + version + &#x22; - use &#x27;lsc --help&#x27; for more information&#x22;);
      repl();
      break;
    default:
      compileStdin();
    }
  }
  function fshoot(name, arg, callback){
    fs[name](arg, function(e, result){
      if (e) {
        die(e.stack || e);
      }
      callback(result);
    });
  }
  function compileScripts(){
    positional.forEach(function(it){
      walk(it, path.normalize(it), true);
    });
    function walk(source, base, top){
      function work(){
        fshoot(&#x27;readFile&#x27;, source, function(it){
          compileScript(source, it + &#x22;&#x22;, base);
        });
      }
      fs.stat(source, function(e, stats){
        if (e) {
          if (!top || /(?:\.ls|\/)$/.test(source)) {
            die(&#x22;Can&#x27;t find: &#x22; + source);
          }
          walk(source + &#x22;.ls&#x22;, base);
          return;
        }
        if (stats.isDirectory()) {
          if (!o.run) {
            fshoot(&#x27;readdir&#x27;, source, function(it) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.compile" id="apidoc.element.livescript.compile">
        function <span class="apidocSignatureSpan">livescript.</span>compile
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (code, options){
  var result, ast, output, filename, outputFilename, ref$, mapPath, e, that;
  options == null &#x26;&#x26; (options = {});
  options.header == null &#x26;&#x26; (options.header = true);
  try {
    if (options.json) {
      result = Function(exports.compile(code, {
        bare: true,
        run: true,
        print: true
      }))();
      return JSON.stringify(result, null, 2) + &#x22;\n&#x22;;
    } else {
      ast = parser.parse(lexer.lex(code));
      if (options.run &#x26;&#x26; options.print) {
        ast.makeReturn();
      }
      output = ast.compileRoot(options);
      if (options.header) {
        output = new SourceNode(null, null, null, [&#x22;// Generated by LiveScript &#x22; + exports.VERSION + &#x22;\n&#x22;, output]);
      }
      if (options.map &#x26;&#x26; options.map !== &#x27;none&#x27;) {
        filename = options.filename, outputFilename = options.outputFilename;
        if (!filename) {
          filename = &#x22;unnamed-&#x22; + Math.floor(Math.random() * 4294967296).toString(16) + &#x22;.ls&#x22;;
        }
        output.setFile(filename);
        result = output.toStringWithSourceMap();
        if (options.map === &#x27;embedded&#x27;) {
          result.map.setSourceContent(filename, code);
        }
        if ((ref$ = options.map) === &#x27;linked&#x27; || ref$ === &#x27;debug&#x27;) {
          mapPath = outputFilename + &#x22;.map&#x22;;
          result.code += &#x22;\n//# sourceMappingURL=&#x22; + mapPath + &#x22;\n&#x22;;
        } else {
          result.code += &#x22;\n//# sourceMappingURL=data:application/json;base64,&#x22; + new Buffer(result.map.toString()).toString(&#x27;base64
&#x27;) + &#x22;\n&#x22;;
        }
        return result;
      } else {
        return output.toString();
      }
    }
  } catch (e$) {
    e = e$;
    if (that = options.filename) {
      e.message += &#x22;\nat &#x22; + that;
    }
    throw e;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.emit" id="apidoc.element.livescript.emit">
        function <span class="apidocSignatureSpan">livescript.</span>emit
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === &#x27;error&#x27;);

  events = this._events;
  if (events)
    doError = (doError &#x26;&#x26; events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no &#x27;error&#x27; event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event&#x27;);
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit(&#x27;error&#x27;, er);
    } else if (er instanceof Error) {
      throw er; // Unhandled &#x27;error&#x27; event
    } else {
      // At least give some kind of context to the user
      var err = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event. (&#x27; + er + &#x27;)&#x27;);
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  if (domain &#x26;&#x26; this !== process) {
    domain.enter();
    needDomainExit = true;
  }

  var isFn = typeof handler === &#x27;function&#x27;;
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i &#x3c; len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  if (needDomainExit)
    domain.exit();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), &#x22;\n&#x22;];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.<span class="apidocCodeKeywordSpan">emit</span
>(post, o.indent) : post]));
};
Block.prototype.compileExpressions = function(o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.eventNames" id="apidoc.element.livescript.eventNames">
        function <span class="apidocSignatureSpan">livescript.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  return this._eventsCount &#x3e; 0 ? Reflect.ownKeys(this._events) : [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.getMaxListeners" id="apidoc.element.livescript.getMaxListeners">
        function <span class="apidocSignatureSpan">livescript.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMaxListeners() {
  return $getMaxListeners(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.go" id="apidoc.element.livescript.go">
        function <span class="apidocSignatureSpan">livescript.</span>go
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">go = function (){
  var type, sink, i$, ref$, len$, script, that;
  type = /^(?:text\/|application\/)?ls$/i;
  sink = function(error){
    error &#x26;&#x26; setTimeout(function(){
      throw error;
    });
  };
  for (i$ = 0, len$ = (ref$ = document.getElementsByTagName(&#x27;script&#x27;)).length; i$ &#x3c; len$; ++i$) {
    script = ref$[i$];
    if (type.test(script.type)) {
      if (that = script.src) {
        LiveScript.load(that, sink);
      } else {
        LiveScript.stab(script.innerHTML, sink, script.id);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lex" id="apidoc.element.livescript.lex">
        function <span class="apidocSignatureSpan">livescript.</span>lex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lex = function (it){
  return lexer.lex(it, {
    raw: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    stack.length = stack.length - 2 * n;
    vstack.length = vstack.length - n;
    lstack.length = lstack.length - n;
}
_token_stack:
    var lex = function () {
        var token;
        token = lexer.<span class="apidocCodeKeywordSpan">lex</span>() || EOF;
        if (typeof token !== &#x27;number&#x27;) {
            token = self.symbols_[token] || token;
        }
        return token;
    };
var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
while (true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.listenerCount" id="apidoc.element.livescript.listenerCount">
        function <span class="apidocSignatureSpan">livescript.</span>listenerCount
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenerCount(type) {
  const events = this._events;

  if (events) {
    const evlistener = events[type];

    if (typeof evlistener === &#x27;function&#x27;) {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.listeners" id="apidoc.element.livescript.listeners">
        function <span class="apidocSignatureSpan">livescript.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === &#x27;function&#x27;)
      ret = [evlistener];
    else
      ret = arrayClone(evlistener, evlistener.length);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      : t.output.code).trimRight());
  } else {
    writeJS(filename, t.output, t.input, base, json);
  }
} catch (e$) {
  e = e$;
  if (e != null) {
    if (LiveScript.<span class="apidocCodeKeywordSpan">listeners</span>(&#x27;failure&#x27;).length) {
      LiveScript.emit(&#x27;failure&#x27;, e, t);
    } else {
      if (filename) {
        warn(&#x22;Failed at: &#x22; + filename);
      }
      if (!(e instanceof SyntaxError || /^Parse error /.test(e.message))) {
        e = e.stack || e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.load" id="apidoc.element.livescript.load">
        function <span class="apidocSignatureSpan">livescript.</span>load
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (url, callback){
  var xhr;
  xhr = new XMLHttpRequest;
  xhr.open(&#x27;GET&#x27;, url, true);
  if (&#x27;overrideMimeType&#x27; in xhr) {
    xhr.overrideMimeType(&#x27;text/plain&#x27;);
  }
  xhr.onreadystatechange = function(){
    var ref$;
    if (xhr.readyState === 4) {
      if ((ref$ = xhr.status) === 200 || ref$ === 0) {
        LiveScript.stab(xhr.responseText, callback, url);
      } else {
        if (typeof callback == &#x27;function&#x27;) {
          callback(Error(url + &#x22;: &#x22; + xhr.status + &#x22; &#x22; + xhr.statusText));
        }
      }
    }
  };
  xhr.send(null);
  return xhr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.node" id="apidoc.element.livescript.node">
        function <span class="apidocSignatureSpan">livescript.</span>node
        <span class="apidocSignatureSpan">(LiveScript)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">node = function (LiveScript){
  var fs, path, events;
  fs = require(&#x27;fs&#x27;);
  path = require(&#x27;path&#x27;);
  events = require(&#x27;events&#x27;);
  LiveScript.run = function(code, options, arg$){
    var filename, ref$, js, context, main, dirname, e;
    if (options != null) {
      filename = options.filename;
    }
    ref$ = arg$ != null
      ? arg$
      : {}, js = ref$.js, context = ref$.context;
    main = require.main;
    if (filename) {
      dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));
    } else {
      dirname = filename = &#x27;.&#x27;;
    }
    main.paths = main.constructor._nodeModulePaths(dirname);
    main.filename = filename;
    if (!js) {
      code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
    }
    if (context) {
      global.__runContext = context;
      code = &#x22;return (function() {\n&#x22; + code + &#x22;\n}).call(global.__runContext);&#x22;;
    }
    try {
      return main._compile(code, filename);
    } catch (e$) {
      e = e$;
      throw hackTrace(e, code, filename);
    }
  };
  importAll$(LiveScript, events.EventEmitter.prototype);
  require.extensions[&#x27;.ls&#x27;] = function(module, filename){
    var file, js, e;
    file = fs.readFileSync(filename, &#x27;utf8&#x27;);
    js = &#x27;.json.ls&#x27; === filename.substr(-8)
      ? &#x27;module.exports = &#x27; + LiveScript.compile(file, {
        filename: filename,
        json: true
      })
      : LiveScript.compile(file, {
        filename: filename,
        bare: true,
        map: &#x22;embedded&#x22;
      }).code;
    try {
      return module._compile(js, filename);
    } catch (e$) {
      e = e$;
      throw hackTrace(e, js, filename);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.on" id="apidoc.element.livescript.on">
        function <span class="apidocSignatureSpan">livescript.</span>on
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  LiveScript.emit(&#x27;success&#x27;, t);
}
function getStdin(cb){
  var x$, code;
  x$ = process.openStdin();
  code = &#x27;&#x27;;
  x$.<span class="apidocCodeKeywordSpan">on</span>(&#x27;data&#x27;, function(it){
    code += it;
  });
  x$.on(&#x27;end&#x27;, function(){
    cb(code);
  });
  x$.on(&#x27;data&#x27;, function(){
    var ref$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.once" id="apidoc.element.livescript.once">
        function <span class="apidocSignatureSpan">livescript.</span>once
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.on(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.prependListener" id="apidoc.element.livescript.prependListener">
        function <span class="apidocSignatureSpan">livescript.</span>prependListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.prependOnceListener" id="apidoc.element.livescript.prependOnceListener">
        function <span class="apidocSignatureSpan">livescript.</span>prependOnceListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependOnceListener(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.removeAllListeners" id="apidoc.element.livescript.removeAllListeners">
        function <span class="apidocSignatureSpan">livescript.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(type) {
  var listeners, events;

  events = this._events;
  if (!events)
    return this;

  // not listening for removeListener, no need to emit
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i = 0, key; i &#x3c; keys.length; ++i) {
      key = keys[i];
      if (key === &#x27;removeListener&#x27;) continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners(&#x27;removeListener&#x27;);
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === &#x27;function&#x27;) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.removeListener" id="apidoc.element.livescript.removeListener">
        function <span class="apidocSignatureSpan">livescript.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);

  events = this._events;
  if (!events)
    return this;

  list = events[type];
  if (!list)
    return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events[type];
      if (events.removeListener)
        this.emit(&#x27;removeListener&#x27;, type, list.listener || listener);
    }
  } else if (typeof list !== &#x27;function&#x27;) {
    position = -1;

    for (i = list.length; i-- &#x3e; 0;) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position &#x3c; 0)
      return this;

    if (list.length === 1) {
      list[0] = undefined;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }

    if (events.removeListener)
      this.emit(&#x27;removeListener&#x27;, type, originalListener || listener);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.run" id="apidoc.element.livescript.run">
        function <span class="apidocSignatureSpan">livescript.</span>run
        <span class="apidocSignatureSpan">(code, options, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (code, options, arg$){
  var filename, ref$, js, context, main, dirname, e;
  if (options != null) {
    filename = options.filename;
  }
  ref$ = arg$ != null
    ? arg$
    : {}, js = ref$.js, context = ref$.context;
  main = require.main;
  if (filename) {
    dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));
  } else {
    dirname = filename = &#x27;.&#x27;;
  }
  main.paths = main.constructor._nodeModulePaths(dirname);
  main.filename = filename;
  if (!js) {
    code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
  }
  if (context) {
    global.__runContext = context;
    code = &#x22;return (function() {\n&#x22; + code + &#x22;\n}).call(global.__runContext);&#x22;;
  }
  try {
    return main._compile(code, filename);
  } catch (e$) {
    e = e$;
    throw hackTrace(e, code, filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
json = o.json || /\.json\.ls$/.test(filename);
run = o.run || o.eval;
if (run) {
  LiveScript.emit(&#x27;compile&#x27;, t);
  print = json || o.print;
  t.output = LiveScript.compile(t.input, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$.run = run, ref$.print = print
, ref$));
  LiveScript.emit(&#x27;run&#x27;, t);
  t.result = LiveScript.<span class="apidocCodeKeywordSpan">run</span>(o.map === &#x27;none&#x27;
    ? t.output
    : t.output.code, options, {
    js: true,
    context: o.runContext
  });
  switch (false) {
  case !json:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.setMaxListeners" id="apidoc.element.livescript.setMaxListeners">
        function <span class="apidocSignatureSpan">livescript.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners(n) {
  if (typeof n !== &#x27;number&#x27; || n &#x3c; 0 || isNaN(n))
    throw new TypeError(&#x27;&#x22;n&#x22; argument must be a positive number&#x27;);
  this._maxListeners = n;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.stab" id="apidoc.element.livescript.stab">
        function <span class="apidocSignatureSpan">livescript.</span>stab
        <span class="apidocSignatureSpan">(code, callback, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stab = function (code, callback, filename){
  var e;
  try {
    LiveScript.run(code, {
      filename: filename,
      map: &#x27;embedded&#x27;
    });
  } catch (e$) {
    e = e$;
  }
  if (typeof callback == &#x27;function&#x27;) {
    callback(e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.tokens" id="apidoc.element.livescript.tokens">
        function <span class="apidocSignatureSpan">livescript.</span>tokens
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokens = function (code, options){
  return clone$(exports).tokenize(code || &#x27;&#x27;, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
t = {
  input: input,
  options: options
};
try {
  if (o.lex || o.tokens || o.ast) {
    LiveScript.emit(&#x27;lex&#x27;, t);
    t.tokens = LiveScript.<span class="apidocCodeKeywordSpan">tokens</span>(t.input, {
      raw: o.lex
    });
    if (o.lex || o.tokens) {
      printTokens(t.tokens);
      throw null;
    }
    LiveScript.emit(&#x27;parse&#x27;, t);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.tokens.rewrite" id="apidoc.element.livescript.tokens.rewrite">
        function <span class="apidocSignatureSpan">livescript.</span>tokens.rewrite
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokens.rewrite = function (it){
  var ref$;
  it || (it = this.tokens);
  firstPass(it);
  addImplicitIndentation(it);
  rewriteBlockless(it);
  addImplicitParentheses(it);
  addImplicitBraces(it);
  expandLiterals(it);
  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === &#x27;NEWLINE&#x27;) {
    it.shift();
  }
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.addListener" id="apidoc.module.livescript.addListener">module livescript.addListener</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.addListener.addListener" id="apidoc.element.livescript.addListener.addListener">
        function <span class="apidocSignatureSpan">livescript.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast" id="apidoc.module.livescript.ast">module livescript.ast</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.ast" id="apidoc.element.livescript.ast.ast">
        function <span class="apidocSignatureSpan">livescript.</span>ast
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast = function (it){
  return parser.parse(typeof it === &#x27;string&#x27; ? lexer.lex(it) : it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    raw: o.lex
  });
  if (o.lex || o.tokens) {
    printTokens(t.tokens);
    throw null;
  }
  LiveScript.emit(&#x27;parse&#x27;, t);
  t.ast = LiveScript.<span class="apidocCodeKeywordSpan">ast</span>(t.tokens);
  say(o.json
    ? t.ast.stringify(2)
    : &#x27;&#x27;.trim.call(t.ast));
  throw null;
}
json = o.json || /\.json\.ls$/.test(filename);
run = o.run || o.eval;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr" id="apidoc.element.livescript.ast.Arr">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.<span class="apidocCodeKeywordSpan">Arr</span>($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign" id="apidoc.element.livescript.ast.Assign">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || &#x27;=&#x27;;
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += &#x27;&#x27;;
  this$[rite instanceof Node ? &#x27;right&#x27; : &#x27;unaries&#x27;] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Assign</span>($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$
0-1],yy.Box($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary" id="apidoc.element.livescript.ast.Binary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === &#x27;String&#x27;) {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== &#x27;=&#x27;:
        return &#x27;?&#x27;;
      default:
        return &#x27;=&#x27;;
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if (&#x27;=&#x27; === op.charAt(op.length - 1) &#x26;&#x26; ((ref$ = op.charAt(op.length - 2)) !== &#x27;=&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3c;&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3e;&#x27; &#x26;&#x26; ref$ !== &#x27;!&#x27;)) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case &#x27;in&#x27;:
      return new In(first, second);
    case &#x27;with&#x27;:
      return new Import(Unary(&#x27;^^&#x27;, first), second, false);
    case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
    case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
      return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
    case &#x27;&#x3c;|&#x27;:
      return Block(first).pipe(second, op);
    case &#x27;|&#x3e;&#x27;:
      return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
    case &#x27;.&#x27;:
    case &#x27;.~&#x27;:
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Binary</span>($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block" id="apidoc.element.livescript.ast.Block">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Block
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if (&#x27;length&#x27; in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Block</span>());
break;
case 62:
this.$ = yy.L(_$[$0], _$[$0],yy.Block($$[$0]));
break;
case 63: case 172:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Box" id="apidoc.element.livescript.ast.Box">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Box
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Box = function (v){
  if (typeof v === &#x22;object&#x22;) {
    return v;
  } else {
    return new v.constructor(v);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan
">Box</span>($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call" id="apidoc.element.livescript.ast.Call">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Call
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &#x26;&#x26; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = &#x27;.call&#x27;;
      args[0] = Literal(&#x27;this&#x27;);
      args[1] = Splat(Literal(&#x27;arguments&#x27;));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === &#x27;_&#x27;) {
        args[i] = Chain(Literal(&#x27;void&#x27;));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.<span class="apidocCodeKeywordSpan">Call</span>($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call[&#x27;let&#x27;]($$[$0-3], $$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade" id="apidoc.element.livescript.ast.Cascade">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 40:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], yy.Slice({
type: $$[$0-1],
target: $$[$0-4]
      }))));
break;
case 41:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], yy.<span class="apidocCodeKeywordSpan">Cascade</span>($$[$0-1], $$[$
0], &#x27;with&#x27;))));
break;
case 42:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({
kind: $$[$0-2],
source: $$[$0-1],
body: $$[$0],
ref: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case" id="apidoc.element.livescript.ast.Case">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Case
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 201:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-4], $$[$0-5] === &#x27;until&#x27;, $$[$0-2]).addGuard($$[$0]));
break;
case 203:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].concat($$[$0]));
break;
case 206:
this.$ = yy.L(_$[$0-2], _$[$0],[yy.L(_$[$0-2],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">Case</span>($$[$0-1], $$[$0]))]);
break;
case 207:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat(yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))));
break;
case 212:
return this.$
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain" id="apidoc.element.livescript.ast.Chain">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &#x26;&#x26; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Chain</span>(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class" id="apidoc.element.livescript.ast.Class">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Class
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 139:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.Try($$[$0-5], $$[$0-3], yy.L(_$[$0-4],_$[$0-3], $$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 140:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 141:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Class</span>({
        title: $$[$0-3].unwrap(),
        sup: $$[$0-2],
        mixins: $$[$0-1],
        body: $$[$0]
      }));
break;
case 142:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.CopyL" id="apidoc.element.livescript.ast.CopyL">
        function <span class="apidocSignatureSpan">livescript.ast.</span>CopyL
        <span class="apidocSignatureSpan">(a, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CopyL = function (a, node){
  if (node &#x26;&#x26; typeof node === &#x22;object&#x22;) {
    node.first_line = a.first_line;
    node.first_column = a.first_column;
    node.last_line = a.last_line;
    node.last_column = a.last_column;
    node.line = a.line;
    node.column = a.column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Decl" id="apidoc.element.livescript.ast.Decl">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Decl
        <span class="apidocSignatureSpan">(type, nodes, lno)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decl = function (type, nodes, lno){
  if (!nodes[0]) {
    throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
  }
  return DECLS[type](nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.<span class="apidocCodeKeywordSpan">Decl</span>($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27;arguments&#x27; &#x26;&#x26; $$[$0] !== &#
x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence" id="apidoc.element.livescript.ast.Existence">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Existence</span>($$[$0-1].unwrap
()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call[&#x27;let&#x27;]($$[$0-3], $$[$0]))));
break;
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For" id="apidoc.element.livescript.ast.For">
        function <span class="apidocSignatureSpan">livescript.ast.</span>For
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &#x26;&#x26; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &#x3c; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &#x26;&#x26; !this.object) {
    this.carp(&#x27;`for own` requires `of`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 28:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var(&#x27;flip$&#x27;))).add(yy.L(_$[$0-3],_$[$0-3],yy
.Call([$$[$0-3]])))).flipIt().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 29:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">For</span>({
        from: $$[$0-3],
        op: $$[$0-2],
        to: $$[$0-1],
        inComprehension: true
      }))));
break;
case 30:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun" id="apidoc.element.livescript.ast.Fun">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &#x26;&#x26; &#x27;this$&#x27;;
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 113:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]));
break;
case 114:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Existence($$[$0-1].unwrap(), true));
break;
case 115:
this.$ = yy.L(_$[$0-5], _$[$0],yy.<span class="apidocCodeKeywordSpan">Fun</span>($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test
($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
break;
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If" id="apidoc.element.livescript.ast.If">
        function <span class="apidocSignatureSpan">livescript.ast.</span>If
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$[&#x27;if&#x27;] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
case 118:
this.$ = (yy.L(_$[$0-3],_$[$0-2], yy.<span class="apidocCodeKeywordSpan">If</span>($$[$0-2], $$[$0-1], $$[$0-3] === &#x27;unless
&#x27;)).addElse($$[$0]));
break;
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === &#x27;unless&#x27;)));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import" id="apidoc.element.livescript.ast.Import">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Import
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
case 73:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Import</span>(yy.L(_$[$0-2],_$[$0-1], yy.Unary(&#x27;^^&#x27
;, $$[$0-2], {
  prec: &#x27;yy.UNARY&#x27;
})), $$[$0], false));
break;
case 74:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary(&#x27;^^&#x27;, $$[$0-2], {
  prec: &#x27;yy.UNARY&#x27;
})), $$[$0].unwrap(), false));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In" id="apidoc.element.livescript.ast.In">
        function <span class="apidocSignatureSpan">livescript.ast.</span>In
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index" id="apidoc.element.livescript.ast.Index">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Index
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = &#x27;.&#x27;);
  if (init &#x26;&#x26; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case &#x27;[]&#x27;:
    this$.vivify = Arr;
    break;
  case &#x27;{}&#x27;:
    this$.vivify = Obj;
    break;
  default:
    if (&#x27;=&#x27; === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Index</span>($$[$0], $$[$
0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS" id="apidoc.element.livescript.ast.JS">
        function <span class="apidocSignatureSpan">livescript.ast.</span>JS
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 66:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], &#x27;cascade&#x27;));
break;
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">JS</span>($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump" id="apidoc.element.livescript.ast.Jump">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
case 125:
this.$ = yy.L(_$[$0], _$[$0],yy.Jump[$$[$0]]());
break;
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Jump</span>($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.Switch($$[$0-2], $$[$0-1], $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key" id="apidoc.element.livescript.ast.Key">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Key
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = &#x27;&#x27; + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
case 49:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Key</span>($$[$0]));
break;
case 50:
this.$ = yy.L(_$[$0], _$[$0],yy.Literal($$[$0]));
break;
case 51: case 164:
this.$ = yy.L(_$[$0], _$[$0],[]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.L" id="apidoc.element.livescript.ast.L">
        function <span class="apidocSignatureSpan">livescript.ast.</span>L
        <span class="apidocSignatureSpan">(a, b, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">L = function (a, b, node){
  if (node &#x26;&#x26; typeof node === &#x22;object&#x22;) {
    node.first_line = a.first_line + 1;
    node.first_column = a.first_column;
    node.last_line = b.last_line + 1;
    node.last_column = b.last_column;
    node.line = a.first_line + 1;
    node.column = a.first_column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.<span class="apidocCodeKeywordSpan">L</span>(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label" id="apidoc.element.livescript.ast.Label">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Label
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || &#x27;_&#x27;;
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &#x26;&#x26; it || it.calling &#x26;&#x26; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        body: $$[$0]
      }));
break;
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Label</span>($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27;arguments&#x27; &#x26;&#x26; $$[$0] !== &#
x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal" id="apidoc.element.livescript.ast.Literal">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + &#x22;&#x22;, true);
  }
  if (value === &#x27;super&#x27;) {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Literal</span>($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj" id="apidoc.element.livescript.ast.Obj">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ref: true
      }).addBody($$[$0]))));
break;
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.<span class="apidocCodeKeywordSpan">Obj</span>($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).named($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens" id="apidoc.element.livescript.ast.Parens">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 161:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], true)), yy.L(_$[$0-1],_$[$0-1],yy.Literal($$[$0-1] === &#
x27;+&#x27;))));
break;
case 168:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-2]);
break;
case 169:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Parens</span>($$[$0-1].chomp().unwrap(), false, $$[$0-2] === &#
x27;&#x22;&#x27;, yy.L(_$[$0-2],_$[$0-2],{}), yy.L(_$[$0],_$[$0],{})));
break;
case 173: case 209: case 211:
this.$ = yy.L(_$[$0], _$[$0],null);
break;
case 174: case 208: case 210:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop" id="apidoc.element.livescript.ast.Prop">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === &#x27;...&#x27;) {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
    }
    this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Prop</span>(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27
;arguments&#x27; &#x26;&#x26; $$[$0] !== &#x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
case 152:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Literal($$[$0-2])), [yy.L(_$[$0-1],_$[$0], yy.
Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require" id="apidoc.element.livescript.ast.Require">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Require
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Require</span>($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return" id="apidoc.element.livescript.ast.Return">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &#x26;&#x26; it.value !== &#x27;void&#x27;) {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice" id="apidoc.element.livescript.ast.Slice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &#x26;&#x26; (this$.from = Literal(0));
  if (this$.to &#x26;&#x26; this$.type === &#x27;to&#x27;) {
    this$.to = Binary(&#x27;+&#x27;, this$.to, Literal(&#x27;1&#x27;));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        target: $$[$0-7],
        from: yy.Literal(0),
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
case 37:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], yy.<span class="apidocCodeKeywordSpan">Slice</span>({
        type: $$[$0-2],
        target: $$[$0-6],
        from: $$[$0-3],
        to: $$[$0-1]
      }))));
break;
case 38:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat" id="apidoc.element.livescript.ast.Splat">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 54: case 167:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat($$[$0]));
break;
case 55:
this.$ = yy.L(_$[$0-5], _$[$0-2],$$[$0-5].concat($$[$0-2]));
break;
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Splat</span>($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.Block());
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice" id="apidoc.element.livescript.ast.StepSlice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        op: $$[$0-4],
        to: $$[$0-3],
        step: $$[$0-1],
        inComprehension: true
      }))));
break;
case 35:
this.$ = yy.L(_$[$0-8], _$[$0],yy.Chain(yy.L(_$[$0-8],_$[$0], new yy.<span class="apidocCodeKeywordSpan">StepSlice</span>({
        op: $$[$0-4],
        target: $$[$0-8],
        from: $$[$0-5],
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super" id="apidoc.element.livescript.ast.Super">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch" id="apidoc.element.livescript.ast.Switch">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this[&#x27;default&#x27;] = $default;
  if (type === &#x27;match&#x27;) {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &#x3e; 1) {
        throw &#x22;can&#x27;t have more than one topic in switch statement&#x22;;
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &#x26;&#x26; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &#x26;&#x26; last.tests[0] instanceof Var &#x26;&#x26; last
.tests[0].value === &#x27;_&#x27;) {
    this.cases.pop();
    this[&#x27;default&#x27;] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.Jump($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Switch</span>($$[$0-2], $$[$0-1], $$[$0]));
break;
case 129: case 130:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]));
break;
case 131:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw" id="apidoc.element.livescript.ast.Throw">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Throw</span>(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented
&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try" id="apidoc.element.livescript.ast.Try">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Try
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var(&#x27;e&#x27;), Var(&#x27;e$&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 132: case 133:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]));
break;
case 134:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, [], $$[$0]));
break;
case 135:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Try</span>($$[$0]));
break;
case 136:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 137:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.Try($$[$0-4], void 8, yy.L(_$[$0-3],_$[$0-3],$$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary" id="apidoc.element.livescript.ast.Unary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &#x26;&#x26; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case &#x27;!&#x27;:
      if (flag) {
        break;
      }
      if (it instanceof Fun &#x26;&#x26; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case &#x27;++&#x27;:
    case &#x27;--&#x27;:
      if (flag) {
        this$.post = true;
      }
      break;
    case &#x27;new&#x27;:
      if (it instanceof Existence &#x26;&#x26; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || &#x27;&#x27;).length; i$ &#x3c; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &#x26;&#x26; !node[&#x27;new&#x27;]) {
          if (node.method === &#x27;.call&#x27;) {
            node.args.shift();
          }
          node[&#x27;new&#x27;] = &#x27;new&#x27;;
          node.method = &#x27;&#x27;;
          return it;
        }
      }
      break;
    case &#x27;~&#x27;:
      if (it instanceof Fun &#x26;&#x26; it.statement &#x26;&#x26; !it.bound) {
        return it.bound = &#x27;this$&#x27;, it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 21:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-5],yy.Binary($$[$0-5], void 8, $$[$0-3]))));
break;
case 23:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-4]))));
break;
case 24: case 25:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Unary</span>($$[$0-1]))));
break;
case 26:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util" id="apidoc.element.livescript.ast.Util">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Util
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var" id="apidoc.element.livescript.ast.Var">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Var
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Var</span>($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars" id="apidoc.element.livescript.ast.Vars">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While" id="apidoc.element.livescript.ast.While">
        function <span class="apidocSignatureSpan">livescript.ast.</span>While
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &#x26;&#x26; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== &#x27;&#x27; + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === &#x27;unless&#x27;)));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.<span class="apidocCodeKeywordSpan">While</span>($$[$0], $$[$0-1] === &#x27;until&#x27;, true
).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === &#x27;until&#x27;, true).addGuard($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield" id="apidoc.element.livescript.ast.Yield">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 98:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Unary($$[$0-5], yy.Splat(yy.Arr($$[$0-2]))));
break;
case 99:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2])));
break;
case 100:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Yield</span>($$[$0]));
break;
case 101:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Yield($$[$0-1], $$[$0]));
break;
case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 158:
this.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.fromJSON" id="apidoc.element.livescript.ast.fromJSON">
        function <span class="apidocSignatureSpan">livescript.ast.</span>fromJSON
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
  if (that = it.type) {
    node = clone$(exports[that].prototype);
    for (key in it) {
      val = it[key];
      node[key] = fromJSON(val);
    }
    return node;
  }
  if (it.length != null) {
    for (i$ = 0, len$ = it.length; i$ &#x3c; len$; ++i$) {
      v = it[i$];
      results$.push(fromJSON(v));
    }
    return results$;
  } else {
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.<span class="apidocCodeKeywordSpan">fromJSON</span>(JSON.parse(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.parse" id="apidoc.element.livescript.ast.parse">
        function <span class="apidocSignatureSpan">livescript.ast.</span>parse
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (json){
  return exports.fromJSON(JSON.parse(json));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.fromJSON(JSON.<span class="apidocCodeKeywordSpan">parse</span>(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr" id="apidoc.module.livescript.ast.Arr">module livescript.ast.Arr</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.Arr" id="apidoc.element.livescript.ast.Arr.Arr">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.<span class="apidocCodeKeywordSpan">Arr</span>($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.compile" id="apidoc.element.livescript.ast.Arr.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>compile
        <span class="apidocSignatureSpan">(o, items, deepEq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
  case 0:
    return &#x27;&#x27;;
  case 1:
    return items[0].compile(o, LEVEL_LIST);
  }
  indent = o.indent, level = o.level;
  o.indent = indent + TAB;
  o.level = LEVEL_LIST;
  code = [items[i = 0].compile(o)];
  while (that = items[++i]) {
    code.push(&#x27;, &#x27;);
    target = that;
    if (deepEq) {
      if (target instanceof Var &#x26;&#x26; target.value === &#x27;_&#x27;) {
        target = Obj([Prop(Key(&#x27;__placeholder__&#x27;), Literal(true))]);
      } else if (target instanceof Obj || target instanceof Arr) {
        target.deepEq = true;
      }
    }
    code.push(target.compile(o));
  }
  if (~code.join(&#x22;&#x22;).indexOf(&#x27;\n&#x27;)) {
    code = [&#x22;\n&#x22; + o.indent].concat(slice$.call(code), [&#x22;\n&#x22; + indent]);
  }
  o.indent = indent;
  o.level = level;
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.maybe" id="apidoc.element.livescript.ast.Arr.maybe">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>maybe
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybe = function (nodes){
  if (nodes.length === 1 &#x26;&#x26; !(nodes[0] instanceof Splat)) {
    return nodes[0];
  }
  return constructor(nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.<span class="apidocCodeKeywordSpan">maybe</span>($$[$0-2]), yy
.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
case 80:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import($$[$0-2], $$[$0], $$[$0-1] === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;));
break;
case 81:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Import($$[$0-5], yy.Arr.maybe($$[$0-2]), $$[$0-4] === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass" id="apidoc.element.livescript.ast.Arr.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(){
  List.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.wrap" id="apidoc.element.livescript.ast.Arr.wrap">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>wrap
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrap = function (it){
  return constructor([Splat((it.isArray = YES, it))]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (i + 1 === (len = nodes.length)) {
  if (skip) {
    break;
  }
  if (destructureArgs) {
    val = argsSlice(Literal(i), Chain(Var(&#x27;arguments&#x27;)).add(Index(Key(&#x27;length&#x27;))));
  } else {
    val = Arr.<span class="apidocCodeKeywordSpan">wrap</span>(JS(util(&#x27;slice&#x27;) + &#x27;.call(&#x27; + rite + (i ? &#x22
;, &#x22; + i + &#x22;)&#x22; : &#x27;)&#x27;)));
  }
} else {
  val = ivar = rite + &#x22;.length - &#x22; + (len - i - 1);
  if (skip &#x26;&#x26; i + 2 === len) {
    continue;
  }
  start = i + 1;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype" id="apidoc.module.livescript.ast.Arr.prototype">module livescript.ast.Arr.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.asObj" id="apidoc.element.livescript.ast.Arr.prototype.asObj">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>asObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObj = function (){
  var i, item;
  return Obj((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
      i = i$;
      item = ref$[i$];
      results$.push(Prop(Literal(i), item));
    }
    return results$;
  }.call(this)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prototype = extend$((import$(Import, superclass).displayName = &#x27;Import&#x27;, Import), superclass).prototype, constructor
 = Import;
function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.<span class="apidocCodeKeywordSpan">asObj</span>().items));
  }
  return this$;
} function ctor$(){} ctor$.prototype = prototype;
Import.prototype.children = [&#x27;left&#x27;, &#x27;right&#x27;];
Import.prototype.show = function(){
  return this.all;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.compile" id="apidoc.element.livescript.ast.Arr.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var items, code;
  items = this.items;
  if (!items.length) {
    return sn(this, &#x27;[]&#x27;);
  }
  if (!snEmpty(code = Splat.compileArray(o, items))) {
    return this.newed
      ? sn(this, &#x22;(&#x22;, code, &#x22;)&#x22;)
      : sn(this, code);
  }
  return sn(null, sn(this, &#x22;[&#x22;), List.compile(o, items, this.deepEq), sn(this, &#x22;]&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.constructor" id="apidoc.element.livescript.ast.Arr.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>constructor
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.isArray" id="apidoc.element.livescript.ast.Arr.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.toSlice" id="apidoc.element.livescript.ast.Arr.prototype.toSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>toSlice
        <span class="apidocSignatureSpan">(o, base, symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSlice = function (o, base, symbol){
  var items, ref$, ref, i$, len$, i, item, splat, chain;
  items = this.items;
  if (items.length &#x3e; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    item = items[i$];
    if (splat = item instanceof Splat) {
      item = item.it;
    }
    if (item.isEmpty()) {
      continue;
    }
    chain = Chain(base, [Index(item, symbol)]);
    items[i] = splat ? Splat(chain) : chain;
    base = ref;
  }
  chain || this.carp(&#x27;empty slice&#x27;);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &#x26;&#x26; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp(&#x27;calling a slice&#x27;);
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.<span class="apidocCodeKeywordSpan">toSlice</span>(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
};
return Chain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype.asObj" id="apidoc.module.livescript.ast.Arr.prototype.asObj">module livescript.ast.Arr.prototype.asObj</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.asObj.asObj" id="apidoc.element.livescript.ast.Arr.prototype.asObj.asObj">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>asObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObj = function (){
  var i, item;
  return Obj((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
      i = i$;
      item = ref$[i$];
      results$.push(Prop(Literal(i), item));
    }
    return results$;
  }.call(this)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prototype = extend$((import$(Import, superclass).displayName = &#x27;Import&#x27;, Import), superclass).prototype, constructor
 = Import;
function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.<span class="apidocCodeKeywordSpan">asObj</span>().items));
  }
  return this$;
} function ctor$(){} ctor$.prototype = prototype;
Import.prototype.children = [&#x27;left&#x27;, &#x27;right&#x27;];
Import.prototype.show = function(){
  return this.all;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype.compile" id="apidoc.module.livescript.ast.Arr.prototype.compile">module livescript.ast.Arr.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.compile.compile" id="apidoc.element.livescript.ast.Arr.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var items, code;
  items = this.items;
  if (!items.length) {
    return sn(this, &#x27;[]&#x27;);
  }
  if (!snEmpty(code = Splat.compileArray(o, items))) {
    return this.newed
      ? sn(this, &#x22;(&#x22;, code, &#x22;)&#x22;)
      : sn(this, code);
  }
  return sn(null, sn(this, &#x22;[&#x22;), List.compile(o, items, this.deepEq), sn(this, &#x22;]&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype.isArray" id="apidoc.module.livescript.ast.Arr.prototype.isArray">module livescript.ast.Arr.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Arr.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype.toSlice" id="apidoc.module.livescript.ast.Arr.prototype.toSlice">module livescript.ast.Arr.prototype.toSlice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.toSlice.toSlice" id="apidoc.element.livescript.ast.Arr.prototype.toSlice.toSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>toSlice
        <span class="apidocSignatureSpan">(o, base, symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSlice = function (o, base, symbol){
  var items, ref$, ref, i$, len$, i, item, splat, chain;
  items = this.items;
  if (items.length &#x3e; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    item = items[i$];
    if (splat = item instanceof Splat) {
      item = item.it;
    }
    if (item.isEmpty()) {
      continue;
    }
    chain = Chain(base, [Index(item, symbol)]);
    items[i] = splat ? Splat(chain) : chain;
    base = ref;
  }
  chain || this.carp(&#x27;empty slice&#x27;);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &#x26;&#x26; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp(&#x27;calling a slice&#x27;);
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.<span class="apidocCodeKeywordSpan">toSlice</span>(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
};
return Chain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.superclass.prototype" id="apidoc.module.livescript.ast.Arr.superclass.prototype">module livescript.ast.Arr.superclass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.assigns" id="apidoc.element.livescript.ast.Arr.superclass.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.assigns(it)) {
      return true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.constructor" id="apidoc.element.livescript.ast.Arr.superclass.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(){
  List.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.isEmpty" id="apidoc.element.livescript.ast.Arr.superclass.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (){
  return !this.items.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.named" id="apidoc.element.livescript.ast.Arr.superclass.prototype.named">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>named
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">named = function (name){
  this.name = name;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Obj($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).<span class="apidocCodeKeywordSpan">named</span>($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.show" id="apidoc.element.livescript.ast.Arr.superclass.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign" id="apidoc.module.livescript.ast.Assign">module livescript.ast.Assign</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.Assign" id="apidoc.element.livescript.ast.Assign.Assign">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || &#x27;=&#x27;;
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += &#x27;&#x27;;
  this$[rite instanceof Node ? &#x27;right&#x27; : &#x27;unaries&#x27;] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Assign</span>($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$
0-1],yy.Box($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass" id="apidoc.element.livescript.ast.Assign.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype" id="apidoc.module.livescript.ast.Assign.prototype">module livescript.ast.Assign.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.assigns" id="apidoc.element.livescript.ast.Assign.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return this.left.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional" id="apidoc.element.livescript.ast.Assign.prototype.compileConditional">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileConditional
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileConditional = function (o, left){
  var lefts, morph;
  if (left instanceof Var &#x26;&#x26; in$(this.logic, [&#x27;?&#x27;]) &#x26;&#x26; this.op === &#x27;=&#x27;) {
    o.scope.declare(left.value, left);
  }
  lefts = Chain(left).cacheReference(o);
  o.level += LEVEL_OP &#x3c; o.level;
  morph = Binary(this.logic, lefts[0], (this.logic = false, this.left = lefts[1], this));
  return sn(this, (morph[&#x27;void&#x27;] = this[&#x27;void&#x27;], morph).compileNode(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  left = left.first;
}
if (left.items) {
  return this.compileDestructuring(o, left);
}
left.isAssignable() || left.carp(&#x27;invalid assign&#x27;);
if (this.logic) {
  return this.<span class="apidocCodeKeywordSpan">compileConditional</span>(o, left);
}
op = this.op, right = this.right;
if (op === &#x27;&#x3c;?=&#x27; || op === &#x27;&#x3e;?=&#x27;) {
  return this.compileMinMax(o, left, right);
}
if ((op === &#x27;**=&#x27; || op === &#x27;^=&#x27; || op === &#x27;%%=&#x27; || op === &#x27;++=&#x27; || op === &#x27;|&#x3e;=&#
x27;) || op === &#x27;*=&#x27; &#x26;&#x26; right.isString() || (op === &#x27;-=&#x27; || op === &#x27;/=&#x27;) &#x26;&#x26; right
.isMatcher()) {
  ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring" id="apidoc.element.livescript.ast.Assign.prototype.compileDestructuring">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileDestructuring
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDestructuring = function (o, left){
  var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
  items = left.items, len = items.length;
  ret = o.level &#x26;&#x26; !this[&#x27;void&#x27;];
  rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
  if (that = left.name) {
    cache = sn(this, that, &#x22; = &#x22;, rite);
    o.scope.declare(rite = that, left);
  } else if ((ret || len &#x3e; 1) &#x26;&#x26; (!ID.test(rite.toString()) || left.assigns(rite.toString()))) {
    cache = sn(this, rref = o.scope.temporary(), &#x22; = &#x22;, rite);
    rite = rref;
  }
  if (rite.toString() === &#x27;arguments&#x27; &#x26;&#x26; !ret) {
    destructureArgs = true;
    if (!(left instanceof Arr)) {
      this.carp(&#x27;arguments can only destructure to array&#x27;);
    }
  }
  list = this[&#x22;rend&#x22; + left.constructor.displayName](o, items, rite, destructureArgs);
  if (rref) {
    o.scope.free(rref);
  }
  if (cache) {
    list.unshift(cache);
  }
  if (ret || !list.length) {
    list.push(rite);
  }
  code = [];
  sep = destructureArgs ? &#x27;; &#x27; : &#x27;, &#x27;;
  for (i$ = 0, len$ = list.length; i$ &#x3c; len$; ++i$) {
    item = list[i$];
    code.push(item, sep);
  }
  code.pop();
  if (list.length &#x3c; 2 || o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
}
if (left.getDefault()) {
  this.right = Binary(left.op, this.right, left.second);
  left = left.first;
}
if (left.items) {
  return this.<span class="apidocCodeKeywordSpan">compileDestructuring</span>(o, left);
}
left.isAssignable() || left.carp(&#x27;invalid assign&#x27;);
if (this.logic) {
  return this.compileConditional(o, left);
}
op = this.op, right = this.right;
if (op === &#x27;&#x3c;?=&#x27; || op === &#x27;&#x3e;?=&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax" id="apidoc.element.livescript.ast.Assign.prototype.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileMinMax
        <span class="apidocSignatureSpan">(o, left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMinMax = function (o, left, right){
  var lefts, rites, test, put, ref$;
  lefts = Chain(left).cacheReference(o);
  rites = right.cache(o, true);
  test = Binary(this.op.replace(&#x27;?&#x27;, &#x27;&#x27;), lefts[0], rites[0]);
  put = Assign(lefts[1], rites[1], &#x27;:=&#x27;);
  if (this[&#x27;void&#x27;] || !o.level) {
    return Parens(Binary(&#x27;||&#x27;, test, put)).compile(o);
  }
  ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
  return sn(this, If(test, left).addElse(put).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileMinMax</span>(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileNode" id="apidoc.element.livescript.ast.Assign.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &#x26;&#x26; this.op === &#x27;=&#x27;) {
    return this.compileSplice(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
    left instanceof List || this.left.carp(&#x27;invalid splat&#x27;);
    return this.compileSpread(o, left);
  }
  if (!this.right) {
    left.isAssignable() || left.carp(&#x27;invalid unary assign&#x27;);
    ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
    for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ &#x3c; len$; ++i$) {
      op = ref$[i$];
      this.right = Unary(op, this.right);
    }
  }
  if (left.isEmpty()) {
    return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
  }
  if (left.getDefault()) {
    this.right = Binary(left.op, this.right, left.second);
    left = left.first;
  }
  if (left.items) {
    return this.compileDestructuring(o, left);
  }
  left.isAssignable() || left.carp(&#x27;invalid assign&#x27;);
  if (this.logic) {
    return this.compileConditional(o, left);
  }
  op = this.op, right = this.right;
  if (op === &#x27;&#x3c;?=&#x27; || op === &#x27;&#x3e;?=&#x27;) {
    return this.compileMinMax(o, left, right);
  }
  if ((op === &#x27;**=&#x27; || op === &#x27;^=&#x27; || op === &#x27;%%=&#x27; || op === &#x27;++=&#x27; || op === &#x27;|&#x3e;=&#x27;) || op === &#x27;*=&#x27; &#x26;&#x26; right.isString() || (op === &#x27;-=&#x27; ||
op === &#x27;/=&#x27;) &#x26;&#x26; right.isMatcher()) {
    ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
    right = Binary(op.slice(0, -1), reft, right);
    op = &#x27;:=&#x27;;
  }
  if (op === &#x27;.&#x26;.=&#x27; || op === &#x27;.|.=&#x27; || op === &#x27;.^.=&#x27; || op === &#x27;.&#x3c;&#x3c;.=&#x27; || op === &#x27;.&#x3e;&#x3e;.=&#x27; || op === &#x27;.&#x3e;&#x3e;&#x3e;.=&#x27;) {
    op = op.slice(1, -2) + &#x27;=&#x27;;
  }
  (right = right.unparen()).ripName(left = left.unwrap());
  sign = sn(this.opLoc, &#x22; &#x22;, op.replace(&#x27;:&#x27;, &#x27;&#x27;), &#x22; &#x22;);
  name = (left.front = true, left).compile(o, LEVEL_LIST);
  if (lvar = left instanceof Var) {
    if (op === &#x27;=&#x27;) {
      o.scope.declare(name.toString(), left, this[&#x27;const&#x27;] || !this.defParam &#x26;&#x26; o[&#x27;const&#x27;] &#x26;&#x26; &#x27;$&#x27; !== name.toString().slice(-1));
    } else if (that = o.scope.checkReadOnly(name.toString())) {
      left.carp(&#x22;assignment to &#x22; + that + &#x22; \&#x22;&#x22; + name + &#x22;\&#x22;&#x22;, ReferenceError);
    }
  }
  if (left instanceof Chain &#x26;&#x26; right instanceof Fun) {
    protoSplit = name.toString().split(&#x27;.prototype.&#x27;);
    dotSplit = name.toString().split(&#x27;.&#x27;);
    if (protoSplit.length &#x3e; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &#x3e; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join(&#x27;&#x27;);
    }
  }
  code = !o.level &#x26;&#x26; right instanceof While &#x26;&#x26; !right[&#x27;else&#x27;] &#x26;&#x26; (lvar || left instanceof Chain &#x26;&#x26; left.isSimpleAccess())
    ? (empty = right.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;, [res = o.scope.temporary(&#x27;res&#x27;), &#x22; = &#x22; + empty + &#x22;;\n&#x22; + this.tab, right.makeReturn(
res).compile(o), &#x22;\n&#x22; + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &#x3e; LEVEL_LIST) {
    code = [&#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice" id="apidoc.element.livescript.ast.Assign.prototype.compileSplice">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSplice
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSplice = function (o){
  var ref$, fromExpNode, fromExp, rightNode, right, toExp;
  ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
  ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
  toExp = Binary(&#x27;-&#x27;, this.left.to, fromExp);
  return sn(this, Block([Chain(Var(util(&#x27;splice&#x27;))).add(Index(Key(&#x27;apply&#x27;), &#x27;.&#x27;, true)).add(Call([this.left.target, Chain(Arr([fromExpNode
, toExp])).add(Index(Key(&#x27;concat&#x27;), &#x27;.&#x27;, true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Assign.prototype.unfoldAssign = function(){
  return this.access &#x26;&#x26; this;
};
Assign.prototype.compileNode = function(o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &#x26;&#x26; this.op === &#x27;=&#x27;) {
    return this.<span class="apidocCodeKeywordSpan">compileSplice</span>(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread" id="apidoc.element.livescript.ast.Assign.prototype.compileSpread">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSpread
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpread = function (o, left){
  var that, ref$, rite, rref, this$ = this;
  ref$ = (that = this.unaries)
    ? [that, that]
    : left.items.length &#x3c;= 1
      ? [ref$ = this.right, ref$]
      : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
  return this.compileSpreadOver(o, left, function(it){
    var result;
    result = constructor(it, rite, this$.op, this$.logic);
    rite = rref;
    return result;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }[it] + &#x27;crement&#x27;;
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.<span class="apidocCodeKeywordSpan">compileSpread</span>(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
    it.cond = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.constructor" id="apidoc.element.livescript.ast.Assign.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>constructor
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || &#x27;=&#x27;;
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += &#x27;&#x27;;
  this$[rite instanceof Node ? &#x27;right&#x27; : &#x27;unaries&#x27;] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isArray" id="apidoc.element.livescript.ast.Assign.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  switch (this.op) {
  case &#x27;=&#x27;:
  case &#x27;:=&#x27;:
    return this.right &#x26;&#x26; this.right.isArray();
  case &#x27;/=&#x27;:
    return this.right &#x26;&#x26; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isCallable" id="apidoc.element.livescript.ast.Assign.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isRegex" id="apidoc.element.livescript.ast.Assign.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isString" id="apidoc.element.livescript.ast.Assign.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  switch (this.op) {
  case &#x27;=&#x27;:
  case &#x27;:=&#x27;:
  case &#x27;+=&#x27;:
  case &#x27;*=&#x27;:
    return this.right &#x26;&#x26; this.right.isString();
  case &#x27;-=&#x27;:
    return this.right &#x26;&#x26; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendArr" id="apidoc.element.livescript.ast.Assign.prototype.rendArr">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendArr
        <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rendArr = function (o, nodes, rite, destructureArgs){
  var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
  function argsSlice(begin, end){
    return new For({
      ref: true,
      from: begin,
      op: &#x27;til&#x27;,
      to: end
    }).makeComprehension(Chain(Var(&#x27;arguments&#x27;)).add(Index(Literal(&#x27;..&#x27;))), []);
  }
  ret = [];
  for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = nodes[i$];
    if (node.isEmpty()) {
      continue;
    }
    if (node instanceof Splat) {
      len &#x26;&#x26; node.carp(&#x27;multiple splat in an assignment&#x27;);
      skip = (node = node.it).isEmpty();
      if (i + 1 === (len = nodes.length)) {
        if (skip) {
          break;
        }
        if (destructureArgs) {
          val = argsSlice(Literal(i), Chain(Var(&#x27;arguments&#x27;)).add(Index(Key(&#x27;length&#x27;))));
        } else {
          val = Arr.wrap(JS(util(&#x27;slice&#x27;) + &#x27;.call(&#x27; + rite + (i ? &#x22;, &#x22; + i + &#x22;)&#x22; : &#x27;)&#x27;)));
        }
      } else {
        val = ivar = rite + &#x22;.length - &#x22; + (len - i - 1);
        if (skip &#x26;&#x26; i + 2 === len) {
          continue;
        }
        start = i + 1;
        (this.temps || (this.temps = [])).push(ivar = o.scope.temporary(&#x27;i&#x27;));
        val = (fn$());
      }
    } else {
      (inc = ivar) &#x26;&#x26; start &#x3c; i &#x26;&#x26; (inc += &#x22; + &#x22; + (i - start));
      val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
    }
    if (node instanceof Assign) {
      node = Binary(node.op, node.left, node.right, node.logic || true);
    }
    if (destructureArgs) {
      if (!(node instanceof Var) &#x26;&#x26; val instanceof For) {
        (this.temps || (this.temps = [])).push(tmp = o.scope.temporary(&#x27;ref&#x27;));
        vtmp = Var(tmp);
        ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
      } else {
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
      }
    } else {
      ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_PAREN));
    }
  }
  return ret;
  function fn$(){
    switch (false) {
    case !skip:
      return Arr.wrap(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;) ? &#x22; + i + &#x22; : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;)&#x22;));
    case !destructureArgs:
      return argsSlice(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;) ? &#x22; + i + &#x22; : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;)&#x22;), Var(ivar));
    default:
      return Arr.wrap(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;)\ ? &#x22; + util(&#x27;slice&#x27;) + &#x22;.call(&#x22; + rite + &#x22;, &#x22; + i + &#x22;, &#x22; + ivar + &#x22;)\ : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;, [])&#x22;));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendObj" id="apidoc.element.livescript.ast.Assign.prototype.rendObj">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendObj
        <span class="apidocSignatureSpan">(o, nodes, rite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rendObj = function (o, nodes, rite){
  var i$, len$, node, splat, logic, ref$, key, val, rcache, results$ = [];
  for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
    node = nodes[i$];
    if (splat = node instanceof Splat) {
      node = node.it;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Parens) {
      ref$ = Chain(node.it).cacheReference(o), node = ref$[0], key = ref$[1];
    } else if (node instanceof Prop) {
      node = (key = node.key, node).val;
    } else {
      key = node;
    }
    if (node instanceof Key) {
      node = CopyL(node, Var(node.name));
    }
    if (logic) {
      node = (logic.first = node, logic);
    }
    val = Chain(rcache || (rcache = Var(rite)), [Index(key.maybeKey())]);
    if (splat) {
      val = Import(Obj(), val);
    }
    results$.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_PAREN));
  }
  return results$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.show" id="apidoc.element.livescript.ast.Assign.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [void 8].concat(this.unaries).reverse().join(&#x27; &#x27;) + [this.logic] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Assign.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldAssign = function (){
  return this.access &#x26;&#x26; this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Assign.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var that, ref$, ref1$, rite, temps;
  if (this.left instanceof Existence) {
    if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
      rite = this.right;
      rite = Assign(this.right = Var(that), rite);
    } else {
      ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
    }
    return ref$ = If(Existence(rite), this), ref$.temps = temps, ref$.cond = this.cond, ref$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref$;
  }
  return If.unfoldSoak(o, this, &#x27;left&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.assigns" id="apidoc.module.livescript.ast.Assign.prototype.assigns">module livescript.ast.Assign.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Assign.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return this.left.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileConditional" id="apidoc.module.livescript.ast.Assign.prototype.compileConditional">module livescript.ast.Assign.prototype.compileConditional</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional.compileConditional" id="apidoc.element.livescript.ast.Assign.prototype.compileConditional.compileConditional">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileConditional
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileConditional = function (o, left){
  var lefts, morph;
  if (left instanceof Var &#x26;&#x26; in$(this.logic, [&#x27;?&#x27;]) &#x26;&#x26; this.op === &#x27;=&#x27;) {
    o.scope.declare(left.value, left);
  }
  lefts = Chain(left).cacheReference(o);
  o.level += LEVEL_OP &#x3c; o.level;
  morph = Binary(this.logic, lefts[0], (this.logic = false, this.left = lefts[1], this));
  return sn(this, (morph[&#x27;void&#x27;] = this[&#x27;void&#x27;], morph).compileNode(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  left = left.first;
}
if (left.items) {
  return this.compileDestructuring(o, left);
}
left.isAssignable() || left.carp(&#x27;invalid assign&#x27;);
if (this.logic) {
  return this.<span class="apidocCodeKeywordSpan">compileConditional</span>(o, left);
}
op = this.op, right = this.right;
if (op === &#x27;&#x3c;?=&#x27; || op === &#x27;&#x3e;?=&#x27;) {
  return this.compileMinMax(o, left, right);
}
if ((op === &#x27;**=&#x27; || op === &#x27;^=&#x27; || op === &#x27;%%=&#x27; || op === &#x27;++=&#x27; || op === &#x27;|&#x3e;=&#
x27;) || op === &#x27;*=&#x27; &#x26;&#x26; right.isString() || (op === &#x27;-=&#x27; || op === &#x27;/=&#x27;) &#x26;&#x26; right
.isMatcher()) {
  ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileDestructuring" id="apidoc.module.livescript.ast.Assign.prototype.compileDestructuring">module livescript.ast.Assign.prototype.compileDestructuring</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring.compileDestructuring" id="apidoc.element.livescript.ast.Assign.prototype.compileDestructuring.compileDestructuring">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileDestructuring
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDestructuring = function (o, left){
  var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
  items = left.items, len = items.length;
  ret = o.level &#x26;&#x26; !this[&#x27;void&#x27;];
  rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
  if (that = left.name) {
    cache = sn(this, that, &#x22; = &#x22;, rite);
    o.scope.declare(rite = that, left);
  } else if ((ret || len &#x3e; 1) &#x26;&#x26; (!ID.test(rite.toString()) || left.assigns(rite.toString()))) {
    cache = sn(this, rref = o.scope.temporary(), &#x22; = &#x22;, rite);
    rite = rref;
  }
  if (rite.toString() === &#x27;arguments&#x27; &#x26;&#x26; !ret) {
    destructureArgs = true;
    if (!(left instanceof Arr)) {
      this.carp(&#x27;arguments can only destructure to array&#x27;);
    }
  }
  list = this[&#x22;rend&#x22; + left.constructor.displayName](o, items, rite, destructureArgs);
  if (rref) {
    o.scope.free(rref);
  }
  if (cache) {
    list.unshift(cache);
  }
  if (ret || !list.length) {
    list.push(rite);
  }
  code = [];
  sep = destructureArgs ? &#x27;; &#x27; : &#x27;, &#x27;;
  for (i$ = 0, len$ = list.length; i$ &#x3c; len$; ++i$) {
    item = list[i$];
    code.push(item, sep);
  }
  code.pop();
  if (list.length &#x3c; 2 || o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
}
if (left.getDefault()) {
  this.right = Binary(left.op, this.right, left.second);
  left = left.first;
}
if (left.items) {
  return this.<span class="apidocCodeKeywordSpan">compileDestructuring</span>(o, left);
}
left.isAssignable() || left.carp(&#x27;invalid assign&#x27;);
if (this.logic) {
  return this.compileConditional(o, left);
}
op = this.op, right = this.right;
if (op === &#x27;&#x3c;?=&#x27; || op === &#x27;&#x3e;?=&#x27;) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileMinMax" id="apidoc.module.livescript.ast.Assign.prototype.compileMinMax">module livescript.ast.Assign.prototype.compileMinMax</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax.compileMinMax" id="apidoc.element.livescript.ast.Assign.prototype.compileMinMax.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileMinMax
        <span class="apidocSignatureSpan">(o, left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMinMax = function (o, left, right){
  var lefts, rites, test, put, ref$;
  lefts = Chain(left).cacheReference(o);
  rites = right.cache(o, true);
  test = Binary(this.op.replace(&#x27;?&#x27;, &#x27;&#x27;), lefts[0], rites[0]);
  put = Assign(lefts[1], rites[1], &#x27;:=&#x27;);
  if (this[&#x27;void&#x27;] || !o.level) {
    return Parens(Binary(&#x27;||&#x27;, test, put)).compile(o);
  }
  ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
  return sn(this, If(test, left).addElse(put).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileMinMax</span>(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileNode" id="apidoc.module.livescript.ast.Assign.prototype.compileNode">module livescript.ast.Assign.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Assign.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &#x26;&#x26; this.op === &#x27;=&#x27;) {
    return this.compileSplice(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
    left instanceof List || this.left.carp(&#x27;invalid splat&#x27;);
    return this.compileSpread(o, left);
  }
  if (!this.right) {
    left.isAssignable() || left.carp(&#x27;invalid unary assign&#x27;);
    ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
    for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ &#x3c; len$; ++i$) {
      op = ref$[i$];
      this.right = Unary(op, this.right);
    }
  }
  if (left.isEmpty()) {
    return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
  }
  if (left.getDefault()) {
    this.right = Binary(left.op, this.right, left.second);
    left = left.first;
  }
  if (left.items) {
    return this.compileDestructuring(o, left);
  }
  left.isAssignable() || left.carp(&#x27;invalid assign&#x27;);
  if (this.logic) {
    return this.compileConditional(o, left);
  }
  op = this.op, right = this.right;
  if (op === &#x27;&#x3c;?=&#x27; || op === &#x27;&#x3e;?=&#x27;) {
    return this.compileMinMax(o, left, right);
  }
  if ((op === &#x27;**=&#x27; || op === &#x27;^=&#x27; || op === &#x27;%%=&#x27; || op === &#x27;++=&#x27; || op === &#x27;|&#x3e;=&#x27;) || op === &#x27;*=&#x27; &#x26;&#x26; right.isString() || (op === &#x27;-=&#x27; ||
op === &#x27;/=&#x27;) &#x26;&#x26; right.isMatcher()) {
    ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
    right = Binary(op.slice(0, -1), reft, right);
    op = &#x27;:=&#x27;;
  }
  if (op === &#x27;.&#x26;.=&#x27; || op === &#x27;.|.=&#x27; || op === &#x27;.^.=&#x27; || op === &#x27;.&#x3c;&#x3c;.=&#x27; || op === &#x27;.&#x3e;&#x3e;.=&#x27; || op === &#x27;.&#x3e;&#x3e;&#x3e;.=&#x27;) {
    op = op.slice(1, -2) + &#x27;=&#x27;;
  }
  (right = right.unparen()).ripName(left = left.unwrap());
  sign = sn(this.opLoc, &#x22; &#x22;, op.replace(&#x27;:&#x27;, &#x27;&#x27;), &#x22; &#x22;);
  name = (left.front = true, left).compile(o, LEVEL_LIST);
  if (lvar = left instanceof Var) {
    if (op === &#x27;=&#x27;) {
      o.scope.declare(name.toString(), left, this[&#x27;const&#x27;] || !this.defParam &#x26;&#x26; o[&#x27;const&#x27;] &#x26;&#x26; &#x27;$&#x27; !== name.toString().slice(-1));
    } else if (that = o.scope.checkReadOnly(name.toString())) {
      left.carp(&#x22;assignment to &#x22; + that + &#x22; \&#x22;&#x22; + name + &#x22;\&#x22;&#x22;, ReferenceError);
    }
  }
  if (left instanceof Chain &#x26;&#x26; right instanceof Fun) {
    protoSplit = name.toString().split(&#x27;.prototype.&#x27;);
    dotSplit = name.toString().split(&#x27;.&#x27;);
    if (protoSplit.length &#x3e; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &#x3e; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join(&#x27;&#x27;);
    }
  }
  code = !o.level &#x26;&#x26; right instanceof While &#x26;&#x26; !right[&#x27;else&#x27;] &#x26;&#x26; (lvar || left instanceof Chain &#x26;&#x26; left.isSimpleAccess())
    ? (empty = right.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;, [res = o.scope.temporary(&#x27;res&#x27;), &#x22; = &#x22; + empty + &#x22;;\n&#x22; + this.tab, right.makeReturn(
res).compile(o), &#x22;\n&#x22; + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &#x3e; LEVEL_LIST) {
    code = [&#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileSplice" id="apidoc.module.livescript.ast.Assign.prototype.compileSplice">module livescript.ast.Assign.prototype.compileSplice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice.compileSplice" id="apidoc.element.livescript.ast.Assign.prototype.compileSplice.compileSplice">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSplice
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSplice = function (o){
  var ref$, fromExpNode, fromExp, rightNode, right, toExp;
  ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
  ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
  toExp = Binary(&#x27;-&#x27;, this.left.to, fromExp);
  return sn(this, Block([Chain(Var(util(&#x27;splice&#x27;))).add(Index(Key(&#x27;apply&#x27;), &#x27;.&#x27;, true)).add(Call([this.left.target, Chain(Arr([fromExpNode
, toExp])).add(Index(Key(&#x27;concat&#x27;), &#x27;.&#x27;, true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Assign.prototype.unfoldAssign = function(){
  return this.access &#x26;&#x26; this;
};
Assign.prototype.compileNode = function(o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &#x26;&#x26; this.op === &#x27;=&#x27;) {
    return this.<span class="apidocCodeKeywordSpan">compileSplice</span>(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileSpread" id="apidoc.module.livescript.ast.Assign.prototype.compileSpread">module livescript.ast.Assign.prototype.compileSpread</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread.compileSpread" id="apidoc.element.livescript.ast.Assign.prototype.compileSpread.compileSpread">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSpread
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpread = function (o, left){
  var that, ref$, rite, rref, this$ = this;
  ref$ = (that = this.unaries)
    ? [that, that]
    : left.items.length &#x3c;= 1
      ? [ref$ = this.right, ref$]
      : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
  return this.compileSpreadOver(o, left, function(it){
    var result;
    result = constructor(it, rite, this$.op, this$.logic);
    rite = rref;
    return result;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }[it] + &#x27;crement&#x27;;
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.<span class="apidocCodeKeywordSpan">compileSpread</span>(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
    it.cond = true;
    break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.isArray" id="apidoc.module.livescript.ast.Assign.prototype.isArray">module livescript.ast.Assign.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Assign.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  switch (this.op) {
  case &#x27;=&#x27;:
  case &#x27;:=&#x27;:
    return this.right &#x26;&#x26; this.right.isArray();
  case &#x27;/=&#x27;:
    return this.right &#x26;&#x26; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.isCallable" id="apidoc.module.livescript.ast.Assign.prototype.isCallable">module livescript.ast.Assign.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Assign.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.isRegex" id="apidoc.module.livescript.ast.Assign.prototype.isRegex">module livescript.ast.Assign.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Assign.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.isString" id="apidoc.module.livescript.ast.Assign.prototype.isString">module livescript.ast.Assign.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isString.isString" id="apidoc.element.livescript.ast.Assign.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  switch (this.op) {
  case &#x27;=&#x27;:
  case &#x27;:=&#x27;:
  case &#x27;+=&#x27;:
  case &#x27;*=&#x27;:
    return this.right &#x26;&#x26; this.right.isString();
  case &#x27;-=&#x27;:
    return this.right &#x26;&#x26; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.rendArr" id="apidoc.module.livescript.ast.Assign.prototype.rendArr">module livescript.ast.Assign.prototype.rendArr</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendArr.rendArr" id="apidoc.element.livescript.ast.Assign.prototype.rendArr.rendArr">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendArr
        <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rendArr = function (o, nodes, rite, destructureArgs){
  var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
  function argsSlice(begin, end){
    return new For({
      ref: true,
      from: begin,
      op: &#x27;til&#x27;,
      to: end
    }).makeComprehension(Chain(Var(&#x27;arguments&#x27;)).add(Index(Literal(&#x27;..&#x27;))), []);
  }
  ret = [];
  for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = nodes[i$];
    if (node.isEmpty()) {
      continue;
    }
    if (node instanceof Splat) {
      len &#x26;&#x26; node.carp(&#x27;multiple splat in an assignment&#x27;);
      skip = (node = node.it).isEmpty();
      if (i + 1 === (len = nodes.length)) {
        if (skip) {
          break;
        }
        if (destructureArgs) {
          val = argsSlice(Literal(i), Chain(Var(&#x27;arguments&#x27;)).add(Index(Key(&#x27;length&#x27;))));
        } else {
          val = Arr.wrap(JS(util(&#x27;slice&#x27;) + &#x27;.call(&#x27; + rite + (i ? &#x22;, &#x22; + i + &#x22;)&#x22; : &#x27;)&#x27;)));
        }
      } else {
        val = ivar = rite + &#x22;.length - &#x22; + (len - i - 1);
        if (skip &#x26;&#x26; i + 2 === len) {
          continue;
        }
        start = i + 1;
        (this.temps || (this.temps = [])).push(ivar = o.scope.temporary(&#x27;i&#x27;));
        val = (fn$());
      }
    } else {
      (inc = ivar) &#x26;&#x26; start &#x3c; i &#x26;&#x26; (inc += &#x22; + &#x22; + (i - start));
      val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
    }
    if (node instanceof Assign) {
      node = Binary(node.op, node.left, node.right, node.logic || true);
    }
    if (destructureArgs) {
      if (!(node instanceof Var) &#x26;&#x26; val instanceof For) {
        (this.temps || (this.temps = [])).push(tmp = o.scope.temporary(&#x27;ref&#x27;));
        vtmp = Var(tmp);
        ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
      } else {
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
      }
    } else {
      ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_PAREN));
    }
  }
  return ret;
  function fn$(){
    switch (false) {
    case !skip:
      return Arr.wrap(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;) ? &#x22; + i + &#x22; : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;)&#x22;));
    case !destructureArgs:
      return argsSlice(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;) ? &#x22; + i + &#x22; : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;)&#x22;), Var(ivar));
    default:
      return Arr.wrap(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;)\ ? &#x22; + util(&#x27;slice&#x27;) + &#x22;.call(&#x22; + rite + &#x22;, &#x22; + i + &#x22;, &#x22; + ivar + &#x22;)\ : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;, [])&#x22;));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.rendObj" id="apidoc.module.livescript.ast.Assign.prototype.rendObj">module livescript.ast.Assign.prototype.rendObj</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendObj.rendObj" id="apidoc.element.livescript.ast.Assign.prototype.rendObj.rendObj">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendObj
        <span class="apidocSignatureSpan">(o, nodes, rite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rendObj = function (o, nodes, rite){
  var i$, len$, node, splat, logic, ref$, key, val, rcache, results$ = [];
  for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
    node = nodes[i$];
    if (splat = node instanceof Splat) {
      node = node.it;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Parens) {
      ref$ = Chain(node.it).cacheReference(o), node = ref$[0], key = ref$[1];
    } else if (node instanceof Prop) {
      node = (key = node.key, node).val;
    } else {
      key = node;
    }
    if (node instanceof Key) {
      node = CopyL(node, Var(node.name));
    }
    if (logic) {
      node = (logic.first = node, logic);
    }
    val = Chain(rcache || (rcache = Var(rite)), [Index(key.maybeKey())]);
    if (splat) {
      val = Import(Obj(), val);
    }
    results$.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_PAREN));
  }
  return results$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.show" id="apidoc.module.livescript.ast.Assign.prototype.show">module livescript.ast.Assign.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.show.show" id="apidoc.element.livescript.ast.Assign.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [void 8].concat(this.unaries).reverse().join(&#x27; &#x27;) + [this.logic] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.unfoldAssign" id="apidoc.module.livescript.ast.Assign.prototype.unfoldAssign">module livescript.ast.Assign.prototype.unfoldAssign</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign.unfoldAssign" id="apidoc.element.livescript.ast.Assign.prototype.unfoldAssign.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldAssign = function (){
  return this.access &#x26;&#x26; this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.unfoldSoak" id="apidoc.module.livescript.ast.Assign.prototype.unfoldSoak">module livescript.ast.Assign.prototype.unfoldSoak</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak.unfoldSoak" id="apidoc.element.livescript.ast.Assign.prototype.unfoldSoak.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var that, ref$, ref1$, rite, temps;
  if (this.left instanceof Existence) {
    if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
      rite = this.right;
      rite = Assign(this.right = Var(that), rite);
    } else {
      ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
    }
    return ref$ = If(Existence(rite), this), ref$.temps = temps, ref$.cond = this.cond, ref$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref$;
  }
  return If.unfoldSoak(o, this, &#x27;left&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.superclass.prototype" id="apidoc.module.livescript.ast.Assign.superclass.prototype">module livescript.ast.Assign.superclass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.addElse" id="apidoc.element.livescript.ast.Assign.superclass.prototype.addElse">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>addElse
        <span class="apidocSignatureSpan">($else)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addElse = function ($else){
  this[&#x27;else&#x27;] = $else;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compileExistence = function(o){
  var x;
  if (this[&#x27;void&#x27;] || !o.level) {
    x = Binary(&#x27;&#x26;&#x26;&#x27;, Existence(this.first, true), this.second);
    return (x[&#x27;void&#x27;] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).<span class="apidocCodeKeywordSpan">addElse</span>(this.second).compileExpression(o));
};
Binary.prototype.compileAnyInstanceOf = function(o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary(&#x27;instanceof&#x27;, sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    item = items[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.anaphorize" id="apidoc.element.livescript.ast.Assign.superclass.prototype.anaphorize">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>anaphorize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anaphorize = function (){
  var base, name, ref$;
  this.children = this.aTargets;
  if (this.eachChild(hasThat)) {
    if ((base = this)[name = this.aSource] instanceof Existence) {
      base = base[name];
      name = &#x27;it&#x27;;
    }
    if (base[name].value !== &#x27;that&#x27;) {
      base[name] = Assign(Var(&#x27;that&#x27;), base[name]);
    }
  }
  function hasThat(it){
    var that;
    return it.value === &#x27;that&#x27; || ((that = it.aSource)
      ? (that = it[that]) ? hasThat(that) : void 8
      : it.eachChild(hasThat));
  }
  delete this.children;
  return ref$ = this[this.aSource], ref$.cond = true, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this;
};
While.prototype.compileNode = function(o){
  var test, ref$, head, that;
  o.loop = true;
  this.test &#x26;&#x26; (this.un
    ? this.test = this.test.invert()
    : this.<span class="apidocCodeKeywordSpan">anaphorize</span>());
  if (this.post) {
    return sn(null, sn(this, &#x27;do {&#x27;), this.compileBody((o.indent += TAB, o)));
  }
  test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;&#x27;;
  if (!(this.update || this[&#x27;else&#x27;])) {
    head = !snEmpty(test)
      ? [sn(this, &#x22;while (&#x22;), test]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.assigns" id="apidoc.element.livescript.ast.Assign.superclass.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>assigns
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.cache" id="apidoc.element.livescript.ast.Assign.superclass.prototype.cache">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>cache
        <span class="apidocSignatureSpan">(o, once, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (o, once, level){
  var ref$, sub, ref;
  if (!this.isComplex()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
    }
    return [sub, ref.value];
  }
  if (once) {
    return [sub, (ref.temp = true, ref)];
  } else {
    return [sub, ref, [ref.value]];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.unwrap().<span class="apidocCodeKeywordSpan">cache</span>(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.carp" id="apidoc.element.livescript.ast.Assign.superclass.prototype.carp">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>carp
        <span class="apidocSignatureSpan">(msg, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">carp = function (msg, type){
  type == null &#x26;&#x26; (type = SyntaxError);
  throw type(msg + &#x22; on line &#x22; + (this.line || this.traverseChildren(function(it){
    return it.line;
  })));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.getJump()) {
    that.<span class="apidocCodeKeywordSpan">carp</span>(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
  this.traverseChildren(function(it){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compile" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compile
        <span class="apidocSignatureSpan">(options, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.unfoldSoak(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
      o.scope.free(tmp);
    }
  }
  return code;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileBlock" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileBlock">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileBlock
        <span class="apidocSignatureSpan">(o, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileBlock = function (o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    code.push.apply(code, mid);
    code.push(&#x27;}&#x27;);
    if (this.post) {
      code.push(sn(this, &#x22; while (&#x22;), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, &#x22;);&#x22;));
    }
    if (yet) {
      code.push(sn(this, &#x22; if (&#x22;), yet, sn(this, &#x22;) &#x22;), this.<span class="apidocCodeKeywordSpan">compileBlock
</span>(o, Block(this[&#x27;else&#x27;])));
      o.scope.free(yet);
    }
    return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));
  };
  return While;
}(Node));
exports.For = For = (function(superclass){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileClosure" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileClosure">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileClosure
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClosure = function (o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.getJump()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
  this.traverseChildren(function(it){
    switch (it.value) {
    case &#x27;this&#x27;:
      hasThis = true;
      break;
    case &#x27;arguments&#x27;:
      hasArgs = it.value = &#x27;args$&#x27;;
    }
  });
  if (hasThis) {
    call.args.push(Literal(&#x27;this&#x27;));
    call.method = &#x27;.call&#x27;;
  }
  if (hasArgs) {
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.<span class="apidocCodeKeywordSpan">compileClosure</span>(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileLoopReference" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileLoopReference">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileLoopReference
        <span class="apidocSignatureSpan">(o, name, ret, safeAccess)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileLoopReference = function (o, name, ret, safeAccess){
  var ref$, code, asn, tmp;
  if (this instanceof Var &#x26;&#x26; o.scope.check(this.value) || this instanceof Unary &#x26;&#x26; ((ref$ = this.op) === &#x27;+&#x27; || ref$ === &#x27;-&#x27;) &#x26;&#x26; (-
1 / 0 &#x3c; (ref$ = +this.it.value) &#x26;&#x26; ref$ &#x3c; 1 / 0) || this instanceof Literal &#x26;&#x26; !this.isComplex()) {
    code = this.compile(o, LEVEL_PAREN);
    if (safeAccess &#x26;&#x26; !(this instanceof Var)) {
      code = &#x22;(&#x22; + code + &#x22;)&#x22;;
    }
    return [code, code];
  }
  asn = Assign(Var(tmp = o.scope.temporary(name)), this);
  ret || (asn[&#x27;void&#x27;] = true);
  return [tmp, asn.compile(o, ret ? LEVEL_CALL : LEVEL_PAREN)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  temps.push(idx = o.scope.temporary(&#x27;i&#x27;));
}
if (!this.body) {
  this.addBody(Block(Var(idx)));
}
if (!this.object) {
  ref$ = (this.step || Literal(1)).<span class="apidocCodeKeywordSpan">compileLoopReference</span>(o, &#x27;step&#x27;), pvar =
ref$[0], step = ref$[1];
  pvar === step || temps.push(pvar);
}
if (this.from) {
  if (this.ref) {
    this.item = Var(idx);
  }
  ref$ = this.to.compileLoopReference(o, &#x27;to&#x27;), tvar = ref$[0], tail = ref$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileSpreadOver" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileSpreadOver">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileSpreadOver
        <span class="apidocSignatureSpan">(o, list, transform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpreadOver = function (o, list, transform){
  var ob, them, i$, len$, i, node, sp, lat, ref$;
  ob = list instanceof Obj;
  them = list.items;
  for (i$ = 0, len$ = them.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = them[i$];
    if (sp = node instanceof Splat) {
      node = node.it;
    }
    if (ob &#x26;&#x26; !sp) {
      node = node.val;
    }
    node = transform(node);
    if (sp) {
      node = lat = Splat(node);
    }
    if (ob &#x26;&#x26; !sp) {
      them[i].val = node;
    } else {
      them[i] = node;
    }
  }
  if (!lat &#x26;&#x26; (this[&#x27;void&#x27;] || !o.level)) {
    list = (ref$ = Block(ob ? (function(){
      var i$, x$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = them).length; i$ &#x3c; len$; ++i$) {
        x$ = ref$[i$];
        results$.push(x$.val);
      }
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ops = [this];
for (; it instanceof constructor; it = it.it) {
  ops.push(it);
}
if (!(it instanceof Splat &#x26;&#x26; (it = it.it.expandSlice(o).unwrap()) instanceof List)) {
  return &#x27;&#x27;;
}
return this.<span class="apidocCodeKeywordSpan">compileSpreadOver</span>(o, it, function(node){
  var i$, ref$, op;
  for (i$ = (ref$ = ops).length - 1; i$ &#x3e;= 0; --i$) {
    op = ref$[i$];
    node = constructor(op.op, node, op.post);
  }
  return node;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.delegate" id="apidoc.element.livescript.ast.Assign.superclass.prototype.delegate">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>delegate
        <span class="apidocSignatureSpan">(names, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delegate = function (names, fn){
  var i$, len$;
  for (i$ = 0, len$ = names.length; i$ &#x3c; len$; ++i$) {
    (fn$.call(this, names[i$]));
  }
  function fn$(name){
    this[name] = function(it){
      return fn.call(this, name, it);
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return pos;
};
Block.prototype.isComplex = function(){
  var ref$;
  return this.lines.length &#x3e; 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
};
prototype.<span class="apidocCodeKeywordSpan">delegate</span>([&#x27;isCallable&#x27;, &#x27;isArray&#x27;, &#x27;isString&#x27;, &#
x27;isRegex&#x27;], function(it){
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.lines)[ref1$.length - 1]) != null ? ref$[it]() : void 8;
});
Block.prototype.getJump = function(it){
  var i$, ref$, len$, node, that;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.eachChild" id="apidoc.element.livescript.ast.Assign.superclass.prototype.eachChild">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>eachChild
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachChild = function (fn){
  var i$, ref$, len$, name, child, j$, len1$, i, node, that;
  for (i$ = 0, len$ = (ref$ = this.children).length; i$ &#x3c; len$; ++i$) {
    name = ref$[i$];
    if (child = this[name]) {
      if (&#x27;length&#x27; in child) {
        for (j$ = 0, len1$ = child.length; j$ &#x3c; len1$; ++j$) {
          i = j$;
          node = child[j$];
          if (that = fn(node, name, i)) {
            return that;
          }
        }
      } else {
        if ((that = fn(child, name)) != null) {
          return that;
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
      }
    }
  }
},
traverseChildren: function(fn, xscope){
  var this$ = this;
  return this.<span class="apidocCodeKeywordSpan">eachChild</span>(function(node, name, index){
    var ref$;
    return (ref$ = fn(node, this$, name, index)) != null
      ? ref$
      : node.traverseChildren(fn, xscope);
  });
},
anaphorize: function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.expandSlice" id="apidoc.element.livescript.ast.Assign.superclass.prototype.expandSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>expandSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? Chain(head, slice$.call(pre, 0, -1))
    : Literal(&#x27;this&#x27;);
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.<span class="apidocCodeKeywordSpan">expandSlice</span>(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getAccessors" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getAccessors">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getAccessors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function Prop(key, val){
var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
this$.key = key;
this$.val = val;
if (key.value === &#x27;...&#x27;) {
  return Splat(this$.val);
}
if (that = val.<span class="apidocCodeKeywordSpan">getAccessors</span>()) {
  this$.val = that;
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    fun = that[i$];
    fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
  }
  this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getCall" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getCall">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fun.name = node.label;
  fun.labeled = true;
  node = node.it;
}
if (!fun.hushed &#x26;&#x26; (fun.hushed = node.op === &#x27;!&#x27;)) {
  node = node.it;
}
if ((ref$ = node.<span class="apidocCodeKeywordSpan">getCall</span>()) != null) {
  ref$.partialized = null;
}
args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
index = 0;
for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
  a = args[i$];
  if (a.placeholder) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getDefault" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getDefault">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
} else {
  if (logic = node.<span class="apidocCodeKeywordSpan">getDefault</span>()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
      ref$ = [node, key], key = ref$[0], node = ref$[1];
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getJump" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invert" id="apidoc.element.livescript.ast.Assign.superclass.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  return Unary(&#x27;!&#x27;, this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invertCheck" id="apidoc.element.livescript.ast.Assign.superclass.prototype.invertCheck">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invertCheck
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invertCheck = function (it){
  if (it.inverted) {
    return this.invert();
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compilePartial = function(o){
  var vit, x, y;
  vit = Var(&#x27;it&#x27;);
  switch (false) {
  case !(this.first == null &#x26;&#x26; this.second == null):
    x = Var(&#x27;x$&#x27;);
    y = Var(&#x27;y$&#x27;);
    return sn(this, Fun([x, y], Block(Binary(this.op, x, y).<span class="apidocCodeKeywordSpan">invertCheck</span>(this)), false
, true).compile(o));
  case this.first == null:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), &#x22
;)&#x22;);
  default:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), &#x22
;)&#x22;);
  }
};
Binary.prototype.compileRegexEquals = function(o, arg$){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isArray" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isAssignable" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isCallable" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isComplex" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isEmpty" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isMatcher" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isMatcher">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isMatcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isMatcher = function (){
  return this.isString() || this.isRegex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.partial || ((ref$ = this.op) === &#x27;&#x26;&#x26;&#x27; || ref$ === &#x27;||&#x27; || ref$ === &#x27;?&#x27; ||
ref$ === &#x27;&#x3c;&#x3c;&#x27; || ref$ === &#x27;&#x3e;&#x3e;&#x27;) &#x26;&#x26; this.first.isCallable() &#x26;&#x26; this.second
.isCallable();
};
Binary.prototype.isArray = function(){
  switch (this.op) {
  case &#x27;*&#x27;:
    return this.first.isArray();
  case &#x27;/&#x27;:
    return this.second.<span class="apidocCodeKeywordSpan">isMatcher</span>();
  }
};
Binary.prototype.isString = function(){
  switch (this.op) {
  case &#x27;+&#x27;:
  case &#x27;*&#x27;:
    return this.first.isString() || this.second.isString();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isRegex" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isStatement" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isString" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.makeReturn" id="apidoc.element.livescript.ast.Assign.superclass.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(ref, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (ref, obj){
  var items, kv, i, v;
  if (obj) {
    items = this instanceof Arr
      ? (this.items[0] == null || this.items[1] == null &#x26;&#x26; this.carp(&#x27;must specify both key and value for object comprehension&#x27;),
this.items)
      : (kv = &#x27;keyValue$&#x27;, (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &#x3c; len$; ++i$) {
          i = i$;
          v = ref$[i$];
          results$.push(Chain(v).add(Index(Literal(i))));
        }
        return results$;
      }.call(this)));
    return Assign(Chain(Var(ref)).add(Index(items[0], &#x27;.&#x27;, true)), items[1]);
  } else if (ref) {
    return Call.make(JS(ref + &#x27;.push&#x27;), [this]);
  } else {
    return Return(this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.maybeKey" id="apidoc.element.livescript.ast.Assign.superclass.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.ripName" id="apidoc.element.livescript.ast.Assign.superclass.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>ripName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.show" id="apidoc.element.livescript.ast.Assign.superclass.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function String() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.stringify" id="apidoc.element.livescript.ast.Assign.superclass.prototype.stringify">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>stringify
        <span class="apidocSignatureSpan">(space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (space){
  return JSON.stringify(this, null, space);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    genForNode(child);
  }
  debugIndent = debugIndent.slice(0, debugIndent.length - debugIndentStr.length);
  if (valid) {
    return stack.pop();
  }
} else {
  debugOutput += debugIndent + &#x22;&#x22; + JSON.<span class="apidocCodeKeywordSpan">stringify</span>(node) + &#x22;\n&#x22;;
  code += node;
  cur = stack[stack.length - 1];
  if (cur) {
    gen.addMapping({
      source: cur.source,
      original: {
        line: cur.line,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toJSON" id="apidoc.element.livescript.ast.Assign.superclass.prototype.toJSON">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
  return import$({
    type: this.constructor.displayName
  }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toString" id="apidoc.element.livescript.ast.Assign.superclass.prototype.toString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toString
        <span class="apidocSignatureSpan">(idt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.show()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return !node;
}
};
snSafe = function(code){
if (code instanceof SourceNode) {
  return code;
} else {
  return code.<span class="apidocCodeKeywordSpan">toString</span>();
}
};
snRemoveLeft = function(node, count){
var i$, to$, i, child;
for (i$ = 0, to$ = node.children.length; i$ &#x3c; to$; ++i$) {
  i = i$;
  child = node.children[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.traverseChildren" id="apidoc.element.livescript.ast.Assign.superclass.prototype.traverseChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>traverseChildren
        <span class="apidocSignatureSpan">(fn, xscope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseChildren = function (fn, xscope){
  var this$ = this;
  return this.eachChild(function(node, name, index){
    var ref$;
    return (ref$ = fn(node, this$, name, index)) != null
      ? ref$
      : node.traverseChildren(fn, xscope);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.carp(&#x27;inconvertible statement&#x27;);
}
fun = Fun([], Block(this));
call = Call();
if (o.inGenerator) {
  fun.generator = true;
}
this.<span class="apidocCodeKeywordSpan">traverseChildren</span>(function(it){
  switch (it.value) {
  case &#x27;this&#x27;:
    hasThis = true;
    break;
  case &#x27;arguments&#x27;:
    hasArgs = it.value = &#x27;args$&#x27;;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unparen" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unparen">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unparen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Block.prototype.children = [&#x27;lines&#x27;];
Block.prototype.toJSON = function(){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
};
Block.prototype.add = function(it){
  var that, ref$;
  it = it.<span class="apidocCodeKeywordSpan">unparen</span>();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unwrap" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.varName" id="apidoc.element.livescript.ast.Assign.superclass.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function String() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary" id="apidoc.module.livescript.ast.Binary">module livescript.ast.Binary</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.Binary" id="apidoc.element.livescript.ast.Binary.Binary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === &#x27;String&#x27;) {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== &#x27;=&#x27;:
        return &#x27;?&#x27;;
      default:
        return &#x27;=&#x27;;
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if (&#x27;=&#x27; === op.charAt(op.length - 1) &#x26;&#x26; ((ref$ = op.charAt(op.length - 2)) !== &#x27;=&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3c;&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3e;&#x27; &#x26;&#x26; ref$ !== &#x27;!&#x27;)) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case &#x27;in&#x27;:
      return new In(first, second);
    case &#x27;with&#x27;:
      return new Import(Unary(&#x27;^^&#x27;, first), second, false);
    case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
    case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
      return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
    case &#x27;&#x3c;|&#x27;:
      return Block(first).pipe(second, op);
    case &#x27;|&#x3e;&#x27;:
      return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
    case &#x27;.&#x27;:
    case &#x27;.~&#x27;:
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Binary</span>($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.superclass" id="apidoc.element.livescript.ast.Binary.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype" id="apidoc.module.livescript.ast.Binary.prototype">module livescript.ast.Binary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf" id="apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileAnyInstanceOf
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAnyInstanceOf = function (o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary(&#x27;instanceof&#x27;, sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    item = items[i$];
    test = Binary(&#x27;||&#x27;, test, Binary(&#x27;instanceof&#x27;, ref, item));
  }
  return sn(this, Parens(test).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.second.cond = true;
  }
  break;
case &#x27;instanceof&#x27;:
  rite = this.second.expandSlice(o).unwrap(), items = rite.items;
  if (rite instanceof Arr) {
    if (items[1]) {
      return this.<span class="apidocCodeKeywordSpan">compileAnyInstanceOf</span>(o, items);
    }
    this.second = items[0] || rite;
  }
  this.second.isCallable() || this.second.carp(&#x27;invalid instanceof operand&#x27;);
  break;
case &#x27;====&#x27;:
case &#x27;!===&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileChain" id="apidoc.element.livescript.ast.Binary.prototype.compileChain">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileChain
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileChain = function (o){
  var code, level, ref$, sub;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
  ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
  code.push(&#x22; &#x22;, this.op, &#x22; &#x22;, sub.compile(o, level), &#x22; &#x26;&#x26; &#x22;, this.second.compile(o, LEVEL_OP));
  if (o.level &#x3c;= LEVEL_OP) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
        console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#
x22; == &#x22; + this.second.value);
      }
    }
  }
  if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
    return this.<span class="apidocCodeKeywordSpan">compileChain</span>(o);
  }
}
this.first.front = this.front;
code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), &#x22; &#x22;, this.mapOp(this.op), &#x22; &#x22;, this.second.
compile(o, level)];
if (o.level &#x3c;= level) {
  return sn.apply(null, [this].concat(slice$.call(code)));
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose" id="apidoc.element.livescript.ast.Binary.prototype.compileCompose">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileCompose
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileCompose = function (o){
  var op, functions, x;
  op = this.op;
  functions = [this.first];
  x = this.second;
  while (x instanceof Binary &#x26;&#x26; x.op === op &#x26;&#x26; !x.partial) {
    functions.push(x.first);
    x = x.second;
  }
  functions.push(x);
  if (op === &#x27;&#x3c;&#x3c;&#x27;) {
    functions.reverse();
  }
  return sn(this, Chain(Var(util(&#x27;compose&#x27;))).add(Call(functions)).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileCompose</span>(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
case &#x27;xor&#x27;:
  return this.compileXor(o);
case &#x27;&#x26;&#x26;&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat" id="apidoc.element.livescript.ast.Binary.prototype.compileConcat">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileConcat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileConcat = function (o){
  var f;
  f = function(x){
    switch (false) {
    case !(x instanceof Binary &#x26;&#x26; x.op === &#x27;++&#x27;):
      return f(x.first).concat(f(x.second));
    default:
      return [x];
    }
  };
  return sn(null, Chain(this.first).add(CopyL(this, Index(Key(&#x27;concat&#x27;), &#x27;.&#x27;, true))).add(Call(f(this.second))).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileConcat</span>(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
case &#x27;xor&#x27;:
  return this.compileXor(o);
case &#x27;&#x26;&#x26;&#x27;:
case &#x27;||&#x27;:
  if (top = this[&#x27;void&#x27;] || !o.level) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq" id="apidoc.element.livescript.ast.Binary.prototype.compileDeepEq">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileDeepEq
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDeepEq = function (o){
  var ref$, negate, i$, len$, x, r;
  if ((ref$ = this.op) === &#x27;&#x3e;==&#x27; || ref$ === &#x27;&#x3e;&#x3e;=&#x27;) {
    ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
    this.op = this.op === &#x27;&#x3e;==&#x27; ? &#x27;&#x3c;==&#x27; : &#x27;&#x3c;&#x3c;=&#x27;;
  }
  if (this.op === &#x27;!==&#x27;) {
    this.op = &#x27;===&#x27;;
    negate = true;
  }
  for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ &#x3c; len$; ++i$) {
    x = ref$[i$];
    if (x instanceof Obj || x instanceof Arr) {
      x.deepEq = true;
    }
  }
  r = Chain(Var(util(&#x27;deepEq&#x27;))).add(Call([this.first, this.second, Literal(&#x22;&#x27;&#x22; + this.op + &#x22;&#x27;&#x22;)]));
  return sn(this, (negate ? Unary(&#x27;!&#x27;, r) : r).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;!===&#x27;:
  this.op = this.op.slice(0, 3);
  // fallthrough
case &#x27;&#x3c;==&#x27;:
case &#x27;&#x3e;==&#x27;:
case &#x27;&#x3c;&#x3c;=&#x27;:
case &#x27;&#x3e;&#x3e;=&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileDeepEq</span>(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
      return it.isRegex();
    })) {
      return this.compileRegexEquals(o, that);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence" id="apidoc.element.livescript.ast.Binary.prototype.compileExistence">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileExistence
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExistence = function (o){
  var x;
  if (this[&#x27;void&#x27;] || !o.level) {
    x = Binary(&#x27;&#x26;&#x26;&#x27;, Existence(this.first, true), this.second);
    return (x[&#x27;void&#x27;] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Binary.prototype.compileNode = function(o){
var top, rite, items, that, ref$, code, level, this$ = this;
if (this.partial) {
  return this.compilePartial(o);
}
switch (this.op) {
case &#x27;?&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileExistence</span>(o);
case &#x27;*&#x27;:
  if (this.second.isString()) {
    return this.compileJoin(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin" id="apidoc.element.livescript.ast.Binary.prototype.compileJoin">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileJoin
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileJoin = function (it){
  return this.compileMethod(it, &#x27;Array&#x27;, &#x27;join&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.compilePartial(o);
}
switch (this.op) {
case &#x27;?&#x27;:
  return this.compileExistence(o);
case &#x27;*&#x27;:
  if (this.second.isString()) {
    return this.<span class="apidocCodeKeywordSpan">compileJoin</span>(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
  break;
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod" id="apidoc.element.livescript.ast.Binary.prototype.compileMethod">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMethod
        <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMethod = function (o, klass, method, arg){
  var args;
  args = [this.second].concat(arg || []);
  if (this.first[&#x22;is&#x22; + klass]()) {
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + &#x27;.call&#x27;), args).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + &#x27;.call&#x27;), args).compile(o));
  }
};
Binary.prototype.compileJoin = function(it){
  return this.<span class="apidocCodeKeywordSpan">compileMethod</span>(it, &#x27;Array&#x27;, &#x27;join&#x27;);
};
Binary.prototype.compileRemove = function(it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;replace&#x27;, JS(&#x22;&#x27;&#x27;&#x22;));
};
Binary.prototype.compileSplit = function(it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;split&#x27;);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax" id="apidoc.element.livescript.ast.Binary.prototype.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMinMax
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMinMax = function (o){
  var lefts, rites, x;
  lefts = this.first.cache(o, true);
  rites = this.second.cache(o, true);
  x = Binary(this.op.charAt(), lefts[0], rites[0]);
  return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileMinMax</span>(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMod" id="apidoc.element.livescript.ast.Binary.prototype.compileMod">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMod
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMod = function (o){
  var ref, code;
  ref = o.scope.temporary();
  code = [sn(this, &#x22;(((&#x22;), this.first.compile(o), sn(this, &#x22;) % (&#x22;), sn(this, ref, &#x22; = &#x22;), this.second.compile(o), sn(this, &#x22;) + &#x22;,
ref, &#x22;) % &#x22;, ref, &#x22;)&#x22;)];
  o.scope.free(ref);
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileMod</span>(o);
case &#x27;xor&#x27;:
  return this.compileXor(o);
case &#x27;&#x26;&#x26;&#x27;:
case &#x27;||&#x27;:
  if (top = this[&#x27;void&#x27;] || !o.level) {
    this.second[&#x27;void&#x27;] = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileNode" id="apidoc.element.livescript.ast.Binary.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.compilePartial(o);
  }
  switch (this.op) {
  case &#x27;?&#x27;:
    return this.compileExistence(o);
  case &#x27;*&#x27;:
    if (this.second.isString()) {
      return this.compileJoin(o);
    }
    if (this.first.isString() || this.first.isArray()) {
      return this.compileRepeat(o);
    }
    break;
  case &#x27;-&#x27;:
    if (this.second.isMatcher()) {
      return this.compileRemove(o);
    }
    break;
  case &#x27;/&#x27;:
    if (this.second.isMatcher()) {
      return this.compileSplit(o);
    }
    break;
  case &#x27;**&#x27;:
  case &#x27;^&#x27;:
    return this.compilePow(o);
  case &#x27;&#x3c;?&#x27;:
  case &#x27;&#x3e;?&#x27;:
    return this.compileMinMax(o);
  case &#x27;&#x3c;&#x3c;&#x27;:
  case &#x27;&#x3e;&#x3e;&#x27;:
    return this.compileCompose(o);
  case &#x27;++&#x27;:
    return this.compileConcat(o);
  case &#x27;%%&#x27;:
    return this.compileMod(o);
  case &#x27;xor&#x27;:
    return this.compileXor(o);
  case &#x27;&#x26;&#x26;&#x27;:
  case &#x27;||&#x27;:
    if (top = this[&#x27;void&#x27;] || !o.level) {
      this.second[&#x27;void&#x27;] = true;
    }
    if (top || this.cond) {
      this.first.cond = true;
      this.second.cond = true;
    }
    break;
  case &#x27;instanceof&#x27;:
    rite = this.second.expandSlice(o).unwrap(), items = rite.items;
    if (rite instanceof Arr) {
      if (items[1]) {
        return this.compileAnyInstanceOf(o, items);
      }
      this.second = items[0] || rite;
    }
    this.second.isCallable() || this.second.carp(&#x27;invalid instanceof operand&#x27;);
    break;
  case &#x27;====&#x27;:
  case &#x27;!===&#x27;:
    this.op = this.op.slice(0, 3);
    // fallthrough
  case &#x27;&#x3c;==&#x27;:
  case &#x27;&#x3e;==&#x27;:
  case &#x27;&#x3c;&#x3c;=&#x27;:
  case &#x27;&#x3e;&#x3e;=&#x27;:
    return this.compileDeepEq(o);
  default:
    if (COMPARER.test(this.op)) {
      if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
        return it.isRegex();
      })) {
        return this.compileRegexEquals(o, that);
      }
      if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26;&#x26; this.first.isWhat() !== this
.second.isWhat()) {
        if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
          console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#x22; == &#x22; +
this.second.value);
        }
      }
    }
    if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), &#x22; &#x22;, this.mapOp(this.op), &#x22; &#x22;, this.second.compile(o, level)];
  if (o.level &#x3c;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial" id="apidoc.element.livescript.ast.Binary.prototype.compilePartial">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePartial
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePartial = function (o){
  var vit, x, y;
  vit = Var(&#x27;it&#x27;);
  switch (false) {
  case !(this.first == null &#x26;&#x26; this.second == null):
    x = Var(&#x27;x$&#x27;);
    y = Var(&#x27;y$&#x27;);
    return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));
  case this.first == null:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), &#x22;)&#x22;);
  default:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
};
Binary.prototype.compileNode = function(o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.<span class="apidocCodeKeywordSpan">compilePartial</span>(o);
  }
  switch (this.op) {
  case &#x27;?&#x27;:
    return this.compileExistence(o);
  case &#x27;*&#x27;:
    if (this.second.isString()) {
      return this.compileJoin(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePow" id="apidoc.element.livescript.ast.Binary.prototype.compilePow">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePow
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePow = function (o){
  return sn(null, Call.make(CopyL(this, JS(&#x27;Math.pow&#x27;)), [this.first, this.second]).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;/&#x27;:
  if (this.second.isMatcher()) {
    return this.compileSplit(o);
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compilePow</span>(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals" id="apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRegexEquals
        <span class="apidocSignatureSpan">(o, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRegexEquals = function (o, arg$){
  var regex, target, method;
  regex = arg$[0], target = arg$[1];
  if (this.op === &#x27;===&#x27;) {
    method = this.wasInverted ? &#x27;test&#x27; : &#x27;exec&#x27;;
    return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
  } else {
    return sn(this, Unary(&#x27;!&#x27;, Chain(regex).add(Index(Key(&#x27;test&#x27;))).add(Call([target]))).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3e;&#x3e;=&#x27;:
  return this.compileDeepEq(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
      return it.isRegex();
    })) {
      return this.<span class="apidocCodeKeywordSpan">compileRegexEquals</span>(o, that);
    }
    if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
        console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#
x22; == &#x22; + this.second.value);
      }
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove" id="apidoc.element.livescript.ast.Binary.prototype.compileRemove">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRemove
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRemove = function (it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;replace&#x27;, JS(&#x22;&#x27;&#x27;&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
  break;
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
    return this.<span class="apidocCodeKeywordSpan">compileRemove</span>(o);
  }
  break;
case &#x27;/&#x27;:
  if (this.second.isMatcher()) {
    return this.compileSplit(o);
  }
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat" id="apidoc.element.livescript.ast.Binary.prototype.compileRepeat">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRepeat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRepeat = function (o){
  var x, n, items, arr, arrCode, refs, i$, len$, i, item, ref$, q;
  x = this.first, n = this.second;
  items = (x = x.expandSlice(o).unwrap()).items;
  arr = x.isArray() &#x26;&#x26; &#x27;Array&#x27;;
  if (items &#x26;&#x26; !snEmpty(arrCode = Splat.compileArray(o, items))) {
    x = JS(arrCode);
    items = null;
  }
  if (arr &#x26;&#x26; !items || !(n instanceof Literal &#x26;&#x26; n.value &#x3c; 0x20)) {
    return sn(this, Call.make(Util(&#x27;repeat&#x27; + (arr || &#x27;String&#x27;)), [x, n]).compile(o));
  }
  n = +n.value;
  if (1 &#x3c;= n &#x26;&#x26; n &#x3c; 2) {
    return sn(this, x.compile(o));
  }
  if (items) {
    if (n &#x3c; 1) {
      return sn(this, Block(items).add(JS(&#x27;[]&#x27;)).compile(o));
    }
    refs = [];
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      item = items[i$];
      ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
    }
    items.push((ref$ = JS(), ref$.compile = function(){
      return sn.apply(null, [this].concat(slice$.call((repeatArray$([&#x22;, &#x22;, List.compile(o, refs)], n - 1)).slice(1))));
    }, ref$));
    return sn(this, x.compile(o));
  } else if (x instanceof Literal) {
    return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + &#x22;&#x22;, n) + q);
  } else {
    if (n &#x3c; 1) {
      return sn(this, Block(x.it).add(JS(&#x22;&#x27;&#x27;&#x22;)).compile(o));
    }
    x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(&#x22; + &#x22; + refs[1], n - 1);
    if (o.level &#x3c; LEVEL_OP + PREC[&#x27;+&#x27;]) {
      return sn(this, x);
    } else {
      return sn(this, &#x22;(&#x22;, x, &#x22;)&#x22;);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;?&#x27;:
  return this.compileExistence(o);
case &#x27;*&#x27;:
  if (this.second.isString()) {
    return this.compileJoin(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.<span class="apidocCodeKeywordSpan">compileRepeat</span>(o);
  }
  break;
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
    return this.compileRemove(o);
  }
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit" id="apidoc.element.livescript.ast.Binary.prototype.compileSplit">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileSplit
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSplit = function (it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;split&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
    return this.compileRemove(o);
  }
  break;
case &#x27;/&#x27;:
  if (this.second.isMatcher()) {
    return this.<span class="apidocCodeKeywordSpan">compileSplit</span>(o);
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileXor" id="apidoc.element.livescript.ast.Binary.prototype.compileXor">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileXor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileXor = function (o){
  var left, right;
  left = Chain(this.first).cacheReference(o);
  right = Chain(this.second).cacheReference(o);
  return sn(this, Binary(&#x27;&#x26;&#x26;&#x27;, Binary(&#x27;!==&#x27;, Unary(&#x27;!&#x27;, left[0]), Unary(&#x27;!&#x27;, right[0])), Parens(Binary(&#x27;||&#x27;, left[1], right[1]))).
compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
case &#x27;xor&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileXor</span>(o);
case &#x27;&#x26;&#x26;&#x27;:
case &#x27;||&#x27;:
  if (top = this[&#x27;void&#x27;] || !o.level) {
    this.second[&#x27;void&#x27;] = true;
  }
  if (top || this.cond) {
    this.first.cond = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.constructor" id="apidoc.element.livescript.ast.Binary.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>constructor
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === &#x27;String&#x27;) {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== &#x27;=&#x27;:
        return &#x27;?&#x27;;
      default:
        return &#x27;=&#x27;;
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if (&#x27;=&#x27; === op.charAt(op.length - 1) &#x26;&#x26; ((ref$ = op.charAt(op.length - 2)) !== &#x27;=&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3c;&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3e;&#x27; &#x26;&#x26; ref$ !== &#x27;!&#x27;)) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case &#x27;in&#x27;:
      return new In(first, second);
    case &#x27;with&#x27;:
      return new Import(Unary(&#x27;^^&#x27;, first), second, false);
    case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
    case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
      return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
    case &#x27;&#x3c;|&#x27;:
      return Block(first).pipe(second, op);
    case &#x27;|&#x3e;&#x27;:
      return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
    case &#x27;.&#x27;:
    case &#x27;.~&#x27;:
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.getDefault" id="apidoc.element.livescript.ast.Binary.prototype.getDefault">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>getDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefault = function (){
  switch (this.op) {
  case &#x27;?&#x27;:
  case &#x27;||&#x27;:
  case &#x27;&#x26;&#x26;&#x27;:
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
} else {
  if (logic = node.<span class="apidocCodeKeywordSpan">getDefault</span>()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
      ref$ = [node, key], key = ref$[0], node = ref$[1];
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invert" id="apidoc.element.livescript.ast.Binary.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  var that;
  if (that = !COMPARER.test(this.second.op) &#x26;&#x26; INVERSIONS[this.op]) {
    this.op = that;
    this.wasInverted = true;
    return this;
  }
  return Unary(&#x27;!&#x27;, Parens(this), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invertIt" id="apidoc.element.livescript.ast.Binary.prototype.invertIt">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invertIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invertIt = function (){
  this.inverted = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
case 17:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],&#x27;!&#x27; === $$[$0-1].charAt(0)
        ? yy.Binary($$[$0-1].slice(1)).<span class="apidocCodeKeywordSpan">invertIt</span>()
        : yy.Binary($$[$0-1]))));
break;
case 18:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],&#x27;!&#x27; === $$[$0-2].charAt(0)
        ? yy.Binary($$[$0-2].slice(1), void 8, $$[$0-1]).invertIt()
        : yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isArray" id="apidoc.element.livescript.ast.Binary.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  switch (this.op) {
  case &#x27;*&#x27;:
    return this.first.isArray();
  case &#x27;/&#x27;:
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isCallable" id="apidoc.element.livescript.ast.Binary.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return this.partial || ((ref$ = this.op) === &#x27;&#x26;&#x26;&#x27; || ref$ === &#x27;||&#x27; || ref$ === &#x27;?&#x27; || ref$ === &#x27;&#x3c;&#x3c;&#x27; || ref$ === &#x27;&#x3e;&#x3e;&#x27;) &#x26;&#x26; this.
first.isCallable() &#x26;&#x26; this.second.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isString" id="apidoc.element.livescript.ast.Binary.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  switch (this.op) {
  case &#x27;+&#x27;:
  case &#x27;*&#x27;:
    return this.first.isString() || this.second.isString();
  case &#x27;-&#x27;:
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.mapOp" id="apidoc.element.livescript.ast.Binary.prototype.mapOp">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>mapOp
        <span class="apidocSignatureSpan">(op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapOp = function (op){
  var that;
  switch (false) {
  case !(that = op.match(/\.([&#x26;\|\^]|&#x3c;&#x3c;|&#x3e;&#x3e;&#x3e;?)\./)):
    return that[1];
  case op !== &#x27;of&#x27;:
    return &#x27;in&#x27;;
  default:
    return op;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
    if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), &#x22; &#x22;, this.<span class="apidocCodeKeywordSpan">mapOp
</span>(this.op), &#x22; &#x22;, this.second.compile(o, level)];
  if (o.level &#x3c;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
};
Binary.prototype.mapOp = function(op){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.show" id="apidoc.element.livescript.ast.Binary.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren" id="apidoc.element.livescript.ast.Binary.prototype.xorChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>xorChildren
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xorChildren = function (test){
  var ref$, ref1$, first;
  if (!(!(ref$ = first = test(this.first)) !== !(ref1$ = test(this.second)) &#x26;&#x26; (ref$ || ref1$))) {
    return false;
  }
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3c;==&#x27;:
case &#x27;&#x3e;==&#x27;:
case &#x27;&#x3c;&#x3c;=&#x27;:
case &#x27;&#x3e;&#x3e;=&#x27;:
  return this.compileDeepEq(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.<span class="apidocCodeKeywordSpan
">xorChildren</span>(function(it){
      return it.isRegex();
    })) {
      return this.compileRegexEquals(o, that);
    }
    if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
        console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#
x22; == &#x22; + this.second.value);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileAnyInstanceOf" id="apidoc.module.livescript.ast.Binary.prototype.compileAnyInstanceOf">module livescript.ast.Binary.prototype.compileAnyInstanceOf</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf.compileAnyInstanceOf" id="apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf.compileAnyInstanceOf">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileAnyInstanceOf
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAnyInstanceOf = function (o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary(&#x27;instanceof&#x27;, sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    item = items[i$];
    test = Binary(&#x27;||&#x27;, test, Binary(&#x27;instanceof&#x27;, ref, item));
  }
  return sn(this, Parens(test).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.second.cond = true;
  }
  break;
case &#x27;instanceof&#x27;:
  rite = this.second.expandSlice(o).unwrap(), items = rite.items;
  if (rite instanceof Arr) {
    if (items[1]) {
      return this.<span class="apidocCodeKeywordSpan">compileAnyInstanceOf</span>(o, items);
    }
    this.second = items[0] || rite;
  }
  this.second.isCallable() || this.second.carp(&#x27;invalid instanceof operand&#x27;);
  break;
case &#x27;====&#x27;:
case &#x27;!===&#x27;:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileChain" id="apidoc.module.livescript.ast.Binary.prototype.compileChain">module livescript.ast.Binary.prototype.compileChain</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileChain.compileChain" id="apidoc.element.livescript.ast.Binary.prototype.compileChain.compileChain">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileChain
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileChain = function (o){
  var code, level, ref$, sub;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
  ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
  code.push(&#x22; &#x22;, this.op, &#x22; &#x22;, sub.compile(o, level), &#x22; &#x26;&#x26; &#x22;, this.second.compile(o, LEVEL_OP));
  if (o.level &#x3c;= LEVEL_OP) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
        console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#
x22; == &#x22; + this.second.value);
      }
    }
  }
  if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
    return this.<span class="apidocCodeKeywordSpan">compileChain</span>(o);
  }
}
this.first.front = this.front;
code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), &#x22; &#x22;, this.mapOp(this.op), &#x22; &#x22;, this.second.
compile(o, level)];
if (o.level &#x3c;= level) {
  return sn.apply(null, [this].concat(slice$.call(code)));
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileCompose" id="apidoc.module.livescript.ast.Binary.prototype.compileCompose">module livescript.ast.Binary.prototype.compileCompose</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose.compileCompose" id="apidoc.element.livescript.ast.Binary.prototype.compileCompose.compileCompose">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileCompose
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileCompose = function (o){
  var op, functions, x;
  op = this.op;
  functions = [this.first];
  x = this.second;
  while (x instanceof Binary &#x26;&#x26; x.op === op &#x26;&#x26; !x.partial) {
    functions.push(x.first);
    x = x.second;
  }
  functions.push(x);
  if (op === &#x27;&#x3c;&#x3c;&#x27;) {
    functions.reverse();
  }
  return sn(this, Chain(Var(util(&#x27;compose&#x27;))).add(Call(functions)).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileCompose</span>(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
case &#x27;xor&#x27;:
  return this.compileXor(o);
case &#x27;&#x26;&#x26;&#x27;:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileConcat" id="apidoc.module.livescript.ast.Binary.prototype.compileConcat">module livescript.ast.Binary.prototype.compileConcat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat.compileConcat" id="apidoc.element.livescript.ast.Binary.prototype.compileConcat.compileConcat">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileConcat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileConcat = function (o){
  var f;
  f = function(x){
    switch (false) {
    case !(x instanceof Binary &#x26;&#x26; x.op === &#x27;++&#x27;):
      return f(x.first).concat(f(x.second));
    default:
      return [x];
    }
  };
  return sn(null, Chain(this.first).add(CopyL(this, Index(Key(&#x27;concat&#x27;), &#x27;.&#x27;, true))).add(Call(f(this.second))).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileConcat</span>(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
case &#x27;xor&#x27;:
  return this.compileXor(o);
case &#x27;&#x26;&#x26;&#x27;:
case &#x27;||&#x27;:
  if (top = this[&#x27;void&#x27;] || !o.level) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileDeepEq" id="apidoc.module.livescript.ast.Binary.prototype.compileDeepEq">module livescript.ast.Binary.prototype.compileDeepEq</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq.compileDeepEq" id="apidoc.element.livescript.ast.Binary.prototype.compileDeepEq.compileDeepEq">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileDeepEq
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDeepEq = function (o){
  var ref$, negate, i$, len$, x, r;
  if ((ref$ = this.op) === &#x27;&#x3e;==&#x27; || ref$ === &#x27;&#x3e;&#x3e;=&#x27;) {
    ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
    this.op = this.op === &#x27;&#x3e;==&#x27; ? &#x27;&#x3c;==&#x27; : &#x27;&#x3c;&#x3c;=&#x27;;
  }
  if (this.op === &#x27;!==&#x27;) {
    this.op = &#x27;===&#x27;;
    negate = true;
  }
  for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ &#x3c; len$; ++i$) {
    x = ref$[i$];
    if (x instanceof Obj || x instanceof Arr) {
      x.deepEq = true;
    }
  }
  r = Chain(Var(util(&#x27;deepEq&#x27;))).add(Call([this.first, this.second, Literal(&#x22;&#x27;&#x22; + this.op + &#x22;&#x27;&#x22;)]));
  return sn(this, (negate ? Unary(&#x27;!&#x27;, r) : r).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;!===&#x27;:
  this.op = this.op.slice(0, 3);
  // fallthrough
case &#x27;&#x3c;==&#x27;:
case &#x27;&#x3e;==&#x27;:
case &#x27;&#x3c;&#x3c;=&#x27;:
case &#x27;&#x3e;&#x3e;=&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileDeepEq</span>(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
      return it.isRegex();
    })) {
      return this.compileRegexEquals(o, that);
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileExistence" id="apidoc.module.livescript.ast.Binary.prototype.compileExistence">module livescript.ast.Binary.prototype.compileExistence</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence.compileExistence" id="apidoc.element.livescript.ast.Binary.prototype.compileExistence.compileExistence">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileExistence
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExistence = function (o){
  var x;
  if (this[&#x27;void&#x27;] || !o.level) {
    x = Binary(&#x27;&#x26;&#x26;&#x27;, Existence(this.first, true), this.second);
    return (x[&#x27;void&#x27;] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Binary.prototype.compileNode = function(o){
var top, rite, items, that, ref$, code, level, this$ = this;
if (this.partial) {
  return this.compilePartial(o);
}
switch (this.op) {
case &#x27;?&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileExistence</span>(o);
case &#x27;*&#x27;:
  if (this.second.isString()) {
    return this.compileJoin(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileJoin" id="apidoc.module.livescript.ast.Binary.prototype.compileJoin">module livescript.ast.Binary.prototype.compileJoin</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin.compileJoin" id="apidoc.element.livescript.ast.Binary.prototype.compileJoin.compileJoin">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileJoin
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileJoin = function (it){
  return this.compileMethod(it, &#x27;Array&#x27;, &#x27;join&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.compilePartial(o);
}
switch (this.op) {
case &#x27;?&#x27;:
  return this.compileExistence(o);
case &#x27;*&#x27;:
  if (this.second.isString()) {
    return this.<span class="apidocCodeKeywordSpan">compileJoin</span>(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
  break;
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMethod" id="apidoc.module.livescript.ast.Binary.prototype.compileMethod">module livescript.ast.Binary.prototype.compileMethod</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod.compileMethod" id="apidoc.element.livescript.ast.Binary.prototype.compileMethod.compileMethod">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMethod
        <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMethod = function (o, klass, method, arg){
  var args;
  args = [this.second].concat(arg || []);
  if (this.first[&#x22;is&#x22; + klass]()) {
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + &#x27;.call&#x27;), args).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + &#x27;.call&#x27;), args).compile(o));
  }
};
Binary.prototype.compileJoin = function(it){
  return this.<span class="apidocCodeKeywordSpan">compileMethod</span>(it, &#x27;Array&#x27;, &#x27;join&#x27;);
};
Binary.prototype.compileRemove = function(it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;replace&#x27;, JS(&#x22;&#x27;&#x27;&#x22;));
};
Binary.prototype.compileSplit = function(it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;split&#x27;);
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMinMax" id="apidoc.module.livescript.ast.Binary.prototype.compileMinMax">module livescript.ast.Binary.prototype.compileMinMax</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax.compileMinMax" id="apidoc.element.livescript.ast.Binary.prototype.compileMinMax.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMinMax
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMinMax = function (o){
  var lefts, rites, x;
  lefts = this.first.cache(o, true);
  rites = this.second.cache(o, true);
  x = Binary(this.op.charAt(), lefts[0], rites[0]);
  return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileMinMax</span>(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMod" id="apidoc.module.livescript.ast.Binary.prototype.compileMod">module livescript.ast.Binary.prototype.compileMod</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMod.compileMod" id="apidoc.element.livescript.ast.Binary.prototype.compileMod.compileMod">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMod
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMod = function (o){
  var ref, code;
  ref = o.scope.temporary();
  code = [sn(this, &#x22;(((&#x22;), this.first.compile(o), sn(this, &#x22;) % (&#x22;), sn(this, ref, &#x22; = &#x22;), this.second.compile(o), sn(this, &#x22;) + &#x22;,
ref, &#x22;) % &#x22;, ref, &#x22;)&#x22;)];
  o.scope.free(ref);
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileMod</span>(o);
case &#x27;xor&#x27;:
  return this.compileXor(o);
case &#x27;&#x26;&#x26;&#x27;:
case &#x27;||&#x27;:
  if (top = this[&#x27;void&#x27;] || !o.level) {
    this.second[&#x27;void&#x27;] = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileNode" id="apidoc.module.livescript.ast.Binary.prototype.compileNode">module livescript.ast.Binary.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Binary.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.compilePartial(o);
  }
  switch (this.op) {
  case &#x27;?&#x27;:
    return this.compileExistence(o);
  case &#x27;*&#x27;:
    if (this.second.isString()) {
      return this.compileJoin(o);
    }
    if (this.first.isString() || this.first.isArray()) {
      return this.compileRepeat(o);
    }
    break;
  case &#x27;-&#x27;:
    if (this.second.isMatcher()) {
      return this.compileRemove(o);
    }
    break;
  case &#x27;/&#x27;:
    if (this.second.isMatcher()) {
      return this.compileSplit(o);
    }
    break;
  case &#x27;**&#x27;:
  case &#x27;^&#x27;:
    return this.compilePow(o);
  case &#x27;&#x3c;?&#x27;:
  case &#x27;&#x3e;?&#x27;:
    return this.compileMinMax(o);
  case &#x27;&#x3c;&#x3c;&#x27;:
  case &#x27;&#x3e;&#x3e;&#x27;:
    return this.compileCompose(o);
  case &#x27;++&#x27;:
    return this.compileConcat(o);
  case &#x27;%%&#x27;:
    return this.compileMod(o);
  case &#x27;xor&#x27;:
    return this.compileXor(o);
  case &#x27;&#x26;&#x26;&#x27;:
  case &#x27;||&#x27;:
    if (top = this[&#x27;void&#x27;] || !o.level) {
      this.second[&#x27;void&#x27;] = true;
    }
    if (top || this.cond) {
      this.first.cond = true;
      this.second.cond = true;
    }
    break;
  case &#x27;instanceof&#x27;:
    rite = this.second.expandSlice(o).unwrap(), items = rite.items;
    if (rite instanceof Arr) {
      if (items[1]) {
        return this.compileAnyInstanceOf(o, items);
      }
      this.second = items[0] || rite;
    }
    this.second.isCallable() || this.second.carp(&#x27;invalid instanceof operand&#x27;);
    break;
  case &#x27;====&#x27;:
  case &#x27;!===&#x27;:
    this.op = this.op.slice(0, 3);
    // fallthrough
  case &#x27;&#x3c;==&#x27;:
  case &#x27;&#x3e;==&#x27;:
  case &#x27;&#x3c;&#x3c;=&#x27;:
  case &#x27;&#x3e;&#x3e;=&#x27;:
    return this.compileDeepEq(o);
  default:
    if (COMPARER.test(this.op)) {
      if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
        return it.isRegex();
      })) {
        return this.compileRegexEquals(o, that);
      }
      if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26;&#x26; this.first.isWhat() !== this
.second.isWhat()) {
        if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
          console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#x22; == &#x22; +
this.second.value);
        }
      }
    }
    if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), &#x22; &#x22;, this.mapOp(this.op), &#x22; &#x22;, this.second.compile(o, level)];
  if (o.level &#x3c;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compilePartial" id="apidoc.module.livescript.ast.Binary.prototype.compilePartial">module livescript.ast.Binary.prototype.compilePartial</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial.compilePartial" id="apidoc.element.livescript.ast.Binary.prototype.compilePartial.compilePartial">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePartial
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePartial = function (o){
  var vit, x, y;
  vit = Var(&#x27;it&#x27;);
  switch (false) {
  case !(this.first == null &#x26;&#x26; this.second == null):
    x = Var(&#x27;x$&#x27;);
    y = Var(&#x27;y$&#x27;);
    return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));
  case this.first == null:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), &#x22;)&#x22;);
  default:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
};
Binary.prototype.compileNode = function(o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.<span class="apidocCodeKeywordSpan">compilePartial</span>(o);
  }
  switch (this.op) {
  case &#x27;?&#x27;:
    return this.compileExistence(o);
  case &#x27;*&#x27;:
    if (this.second.isString()) {
      return this.compileJoin(o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compilePow" id="apidoc.module.livescript.ast.Binary.prototype.compilePow">module livescript.ast.Binary.prototype.compilePow</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePow.compilePow" id="apidoc.element.livescript.ast.Binary.prototype.compilePow.compilePow">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePow
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePow = function (o){
  return sn(null, Call.make(CopyL(this, JS(&#x27;Math.pow&#x27;)), [this.first, this.second]).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;/&#x27;:
  if (this.second.isMatcher()) {
    return this.compileSplit(o);
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compilePow</span>(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRegexEquals" id="apidoc.module.livescript.ast.Binary.prototype.compileRegexEquals">module livescript.ast.Binary.prototype.compileRegexEquals</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals.compileRegexEquals" id="apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals.compileRegexEquals">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRegexEquals
        <span class="apidocSignatureSpan">(o, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRegexEquals = function (o, arg$){
  var regex, target, method;
  regex = arg$[0], target = arg$[1];
  if (this.op === &#x27;===&#x27;) {
    method = this.wasInverted ? &#x27;test&#x27; : &#x27;exec&#x27;;
    return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
  } else {
    return sn(this, Unary(&#x27;!&#x27;, Chain(regex).add(Index(Key(&#x27;test&#x27;))).add(Call([target]))).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3e;&#x3e;=&#x27;:
  return this.compileDeepEq(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
      return it.isRegex();
    })) {
      return this.<span class="apidocCodeKeywordSpan">compileRegexEquals</span>(o, that);
    }
    if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
        console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#
x22; == &#x22; + this.second.value);
      }
    }
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRemove" id="apidoc.module.livescript.ast.Binary.prototype.compileRemove">module livescript.ast.Binary.prototype.compileRemove</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove.compileRemove" id="apidoc.element.livescript.ast.Binary.prototype.compileRemove.compileRemove">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRemove
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRemove = function (it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;replace&#x27;, JS(&#x22;&#x27;&#x27;&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
  break;
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
    return this.<span class="apidocCodeKeywordSpan">compileRemove</span>(o);
  }
  break;
case &#x27;/&#x27;:
  if (this.second.isMatcher()) {
    return this.compileSplit(o);
  }
  break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRepeat" id="apidoc.module.livescript.ast.Binary.prototype.compileRepeat">module livescript.ast.Binary.prototype.compileRepeat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat.compileRepeat" id="apidoc.element.livescript.ast.Binary.prototype.compileRepeat.compileRepeat">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRepeat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRepeat = function (o){
  var x, n, items, arr, arrCode, refs, i$, len$, i, item, ref$, q;
  x = this.first, n = this.second;
  items = (x = x.expandSlice(o).unwrap()).items;
  arr = x.isArray() &#x26;&#x26; &#x27;Array&#x27;;
  if (items &#x26;&#x26; !snEmpty(arrCode = Splat.compileArray(o, items))) {
    x = JS(arrCode);
    items = null;
  }
  if (arr &#x26;&#x26; !items || !(n instanceof Literal &#x26;&#x26; n.value &#x3c; 0x20)) {
    return sn(this, Call.make(Util(&#x27;repeat&#x27; + (arr || &#x27;String&#x27;)), [x, n]).compile(o));
  }
  n = +n.value;
  if (1 &#x3c;= n &#x26;&#x26; n &#x3c; 2) {
    return sn(this, x.compile(o));
  }
  if (items) {
    if (n &#x3c; 1) {
      return sn(this, Block(items).add(JS(&#x27;[]&#x27;)).compile(o));
    }
    refs = [];
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      item = items[i$];
      ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
    }
    items.push((ref$ = JS(), ref$.compile = function(){
      return sn.apply(null, [this].concat(slice$.call((repeatArray$([&#x22;, &#x22;, List.compile(o, refs)], n - 1)).slice(1))));
    }, ref$));
    return sn(this, x.compile(o));
  } else if (x instanceof Literal) {
    return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + &#x22;&#x22;, n) + q);
  } else {
    if (n &#x3c; 1) {
      return sn(this, Block(x.it).add(JS(&#x22;&#x27;&#x27;&#x22;)).compile(o));
    }
    x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(&#x22; + &#x22; + refs[1], n - 1);
    if (o.level &#x3c; LEVEL_OP + PREC[&#x27;+&#x27;]) {
      return sn(this, x);
    } else {
      return sn(this, &#x22;(&#x22;, x, &#x22;)&#x22;);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;?&#x27;:
  return this.compileExistence(o);
case &#x27;*&#x27;:
  if (this.second.isString()) {
    return this.compileJoin(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.<span class="apidocCodeKeywordSpan">compileRepeat</span>(o);
  }
  break;
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
    return this.compileRemove(o);
  }
  break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileSplit" id="apidoc.module.livescript.ast.Binary.prototype.compileSplit">module livescript.ast.Binary.prototype.compileSplit</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit.compileSplit" id="apidoc.element.livescript.ast.Binary.prototype.compileSplit.compileSplit">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileSplit
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSplit = function (it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;split&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
    return this.compileRemove(o);
  }
  break;
case &#x27;/&#x27;:
  if (this.second.isMatcher()) {
    return this.<span class="apidocCodeKeywordSpan">compileSplit</span>(o);
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileXor" id="apidoc.module.livescript.ast.Binary.prototype.compileXor">module livescript.ast.Binary.prototype.compileXor</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileXor.compileXor" id="apidoc.element.livescript.ast.Binary.prototype.compileXor.compileXor">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileXor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileXor = function (o){
  var left, right;
  left = Chain(this.first).cacheReference(o);
  right = Chain(this.second).cacheReference(o);
  return sn(this, Binary(&#x27;&#x26;&#x26;&#x27;, Binary(&#x27;!==&#x27;, Unary(&#x27;!&#x27;, left[0]), Unary(&#x27;!&#x27;, right[0])), Parens(Binary(&#x27;||&#x27;, left[1], right[1]))).
compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
case &#x27;xor&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileXor</span>(o);
case &#x27;&#x26;&#x26;&#x27;:
case &#x27;||&#x27;:
  if (top = this[&#x27;void&#x27;] || !o.level) {
    this.second[&#x27;void&#x27;] = true;
  }
  if (top || this.cond) {
    this.first.cond = true;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.getDefault" id="apidoc.module.livescript.ast.Binary.prototype.getDefault">module livescript.ast.Binary.prototype.getDefault</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.getDefault.getDefault" id="apidoc.element.livescript.ast.Binary.prototype.getDefault.getDefault">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>getDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefault = function (){
  switch (this.op) {
  case &#x27;?&#x27;:
  case &#x27;||&#x27;:
  case &#x27;&#x26;&#x26;&#x27;:
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
} else {
  if (logic = node.<span class="apidocCodeKeywordSpan">getDefault</span>()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
      ref$ = [node, key], key = ref$[0], node = ref$[1];
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.invert" id="apidoc.module.livescript.ast.Binary.prototype.invert">module livescript.ast.Binary.prototype.invert</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invert.invert" id="apidoc.element.livescript.ast.Binary.prototype.invert.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  var that;
  if (that = !COMPARER.test(this.second.op) &#x26;&#x26; INVERSIONS[this.op]) {
    this.op = that;
    this.wasInverted = true;
    return this;
  }
  return Unary(&#x27;!&#x27;, Parens(this), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.invertIt" id="apidoc.module.livescript.ast.Binary.prototype.invertIt">module livescript.ast.Binary.prototype.invertIt</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invertIt.invertIt" id="apidoc.element.livescript.ast.Binary.prototype.invertIt.invertIt">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invertIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invertIt = function (){
  this.inverted = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
case 17:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],&#x27;!&#x27; === $$[$0-1].charAt(0)
        ? yy.Binary($$[$0-1].slice(1)).<span class="apidocCodeKeywordSpan">invertIt</span>()
        : yy.Binary($$[$0-1]))));
break;
case 18:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],&#x27;!&#x27; === $$[$0-2].charAt(0)
        ? yy.Binary($$[$0-2].slice(1), void 8, $$[$0-1]).invertIt()
        : yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.isArray" id="apidoc.module.livescript.ast.Binary.prototype.isArray">module livescript.ast.Binary.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Binary.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  switch (this.op) {
  case &#x27;*&#x27;:
    return this.first.isArray();
  case &#x27;/&#x27;:
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.isCallable" id="apidoc.module.livescript.ast.Binary.prototype.isCallable">module livescript.ast.Binary.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Binary.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return this.partial || ((ref$ = this.op) === &#x27;&#x26;&#x26;&#x27; || ref$ === &#x27;||&#x27; || ref$ === &#x27;?&#x27; || ref$ === &#x27;&#x3c;&#x3c;&#x27; || ref$ === &#x27;&#x3e;&#x3e;&#x27;) &#x26;&#x26; this.
first.isCallable() &#x26;&#x26; this.second.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.isString" id="apidoc.module.livescript.ast.Binary.prototype.isString">module livescript.ast.Binary.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isString.isString" id="apidoc.element.livescript.ast.Binary.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  switch (this.op) {
  case &#x27;+&#x27;:
  case &#x27;*&#x27;:
    return this.first.isString() || this.second.isString();
  case &#x27;-&#x27;:
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.mapOp" id="apidoc.module.livescript.ast.Binary.prototype.mapOp">module livescript.ast.Binary.prototype.mapOp</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.mapOp.mapOp" id="apidoc.element.livescript.ast.Binary.prototype.mapOp.mapOp">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>mapOp
        <span class="apidocSignatureSpan">(op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapOp = function (op){
  var that;
  switch (false) {
  case !(that = op.match(/\.([&#x26;\|\^]|&#x3c;&#x3c;|&#x3e;&#x3e;&#x3e;?)\./)):
    return that[1];
  case op !== &#x27;of&#x27;:
    return &#x27;in&#x27;;
  default:
    return op;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
    if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), &#x22; &#x22;, this.<span class="apidocCodeKeywordSpan">mapOp
</span>(this.op), &#x22; &#x22;, this.second.compile(o, level)];
  if (o.level &#x3c;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
};
Binary.prototype.mapOp = function(op){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.show" id="apidoc.module.livescript.ast.Binary.prototype.show">module livescript.ast.Binary.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.show.show" id="apidoc.element.livescript.ast.Binary.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.xorChildren" id="apidoc.module.livescript.ast.Binary.prototype.xorChildren">module livescript.ast.Binary.prototype.xorChildren</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren.xorChildren" id="apidoc.element.livescript.ast.Binary.prototype.xorChildren.xorChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>xorChildren
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xorChildren = function (test){
  var ref$, ref1$, first;
  if (!(!(ref$ = first = test(this.first)) !== !(ref1$ = test(this.second)) &#x26;&#x26; (ref$ || ref1$))) {
    return false;
  }
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3c;==&#x27;:
case &#x27;&#x3e;==&#x27;:
case &#x27;&#x3c;&#x3c;=&#x27;:
case &#x27;&#x3e;&#x3e;=&#x27;:
  return this.compileDeepEq(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.<span class="apidocCodeKeywordSpan
">xorChildren</span>(function(it){
      return it.isRegex();
    })) {
      return this.compileRegexEquals(o, that);
    }
    if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
        console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#
x22; == &#x22; + this.second.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block" id="apidoc.module.livescript.ast.Block">module livescript.ast.Block</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.Block" id="apidoc.element.livescript.ast.Block.Block">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Block
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if (&#x27;length&#x27; in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Block</span>());
break;
case 62:
this.$ = yy.L(_$[$0], _$[$0],yy.Block($$[$0]));
break;
case 63: case 172:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.superclass" id="apidoc.element.livescript.ast.Block.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Block.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype" id="apidoc.module.livescript.ast.Block.prototype">module livescript.ast.Block.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.add" id="apidoc.element.livescript.ast.Block.prototype.add">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (it){
  var that, ref$;
  it = it.unparen();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
  default:
    this.lines.push(it);
    if (that = (ref$ = it.back, delete it.back, ref$)) {
      this.back = that;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  items = this instanceof Arr
    ? (this.items[0] == null || this.items[1] == null &#x26;&#x26; this.carp(&#x27;must specify both key and value for object comprehension
&#x27;), this.items)
    : (kv = &#x27;keyValue$&#x27;, (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &#x3c; len$; ++i$) {
        i = i$;
        v = ref$[i$];
        results$.push(Chain(v).<span class="apidocCodeKeywordSpan">add</span>(Index(Literal(i))));
      }
      return results$;
    }.call(this)));
  return Assign(Chain(Var(ref)).add(Index(items[0], &#x27;.&#x27;, true)), items[1]);
} else if (ref) {
  return Call.make(JS(ref + &#x27;.push&#x27;), [this]);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.chomp" id="apidoc.element.livescript.ast.Block.prototype.chomp">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>chomp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chomp = function (){
  var lines, i, that;
  lines = this.lines;
  i = lines.length;
  while (that = lines[--i]) {
    if (!that.comment) {
      break;
    }
  }
  lines.length = i + 1;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (that = node.getJump(it)) {
      return that;
    }
  }
};
Block.prototype.makeReturn = function(){
  var that, ref$, key$, ref1$;
  this.<span class="apidocCodeKeywordSpan">chomp</span>();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &#x26;&#x26; !that.it) {
      --this.lines.length;
    }
  }
  return this;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compile" id="apidoc.element.livescript.ast.Block.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &#x26;&#x26; (level = o.level);
  if (level) {
    return this.compileExpressions(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
    if (snEmpty(code = (node.front = true, node).compile(o, level))) {
      continue;
    }
    codes.push(tab);
    codes.push(code);
    node.isStatement() || codes.push(node.terminator);
    codes.push(&#x27;\n&#x27;);
  }
  codes.pop();
  return sn.apply(null, [null].concat(slice$.call(codes)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions" id="apidoc.element.livescript.ast.Block.prototype.compileExpressions">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileExpressions
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExpressions = function (o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
      lines.splice(i--, 1);
    }
  }
  if (!lines.length) {
    lines.push(Literal(&#x27;void&#x27;));
  }
  lines[0].front = this.front;
  lines[lines.length - 1][&#x27;void&#x27;] = this[&#x27;void&#x27;];
  if (!lines[1]) {
    return lines[0].compile(o, level);
  }
  code = [];
  last = lines.pop();
  for (i$ = 0, len$ = lines.length; i$ &#x3c; len$; ++i$) {
    node = lines[i$];
    code.push((node[&#x27;void&#x27;] = true, node).compile(o, LEVEL_PAREN), &#x27;, &#x27;);
  }
  code.push(last.compile(o, LEVEL_PAREN));
  if (level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return this;
};
Block.prototype.compile = function(o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &#x26;&#x26; (level = o.level);
  if (level) {
    return this.<span class="apidocCodeKeywordSpan">compileExpressions</span>(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileRoot" id="apidoc.element.livescript.ast.Block.prototype.compileRoot">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileRoot
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRoot = function (options){
  var o, that, ref$, bare, prefix, ref1$, code, result;
  o = (import$({
    level: LEVEL_TOP,
    scope: this.scope = Scope.root = new Scope
  }, options));
  if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
    this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
  }
  delete o.filename;
  o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? &#x27;&#x27; : TAB;
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations" id="apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileWithDeclarations
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileWithDeclarations = function (o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
  if (i = this.neck()) {
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), &#x22;\n&#x22;];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.emit(post, o.indent) : post]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.<span class="apidocCodeKeywordSpan">compileWithDeclarations</span>(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.constructor" id="apidoc.element.livescript.ast.Block.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>constructor
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if (&#x27;length&#x27; in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.getJump" id="apidoc.element.livescript.ast.Block.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var i$, ref$, len$, node, that;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (that = node.getJump(it)) {
      return that;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isArray" id="apidoc.element.livescript.ast.Block.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isCallable" id="apidoc.element.livescript.ast.Block.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isComplex" id="apidoc.element.livescript.ast.Block.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  var ref$;
  return this.lines.length &#x3e; 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isRegex" id="apidoc.element.livescript.ast.Block.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isString" id="apidoc.element.livescript.ast.Block.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.makeReturn" id="apidoc.element.livescript.ast.Block.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var that, ref$, key$, ref1$;
  this.chomp();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &#x26;&#x26; !that.it) {
      --this.lines.length;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.neck" id="apidoc.element.livescript.ast.Block.prototype.neck">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>neck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neck = function (){
  var pos, i$, ref$, len$, x;
  pos = 0;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    x = ref$[i$];
    if (!(x.comment || x instanceof Literal)) {
      break;
    }
    ++pos;
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.back = that;
    }
  }
  return this;
};
Block.prototype.prepend = function(){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.<span class="apidocCodeKeywordSpan">neck</span>(), 0].concat(slice$.call(arguments
)));
  return this;
};
Block.prototype.pipe = function(target, type){
  var args;
  args = type === &#x27;|&#x3e;&#x27; ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== &#x27;Array&#x27;) {
    args = [args];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.pipe" id="apidoc.element.livescript.ast.Block.prototype.pipe">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>pipe
        <span class="apidocSignatureSpan">(target, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (target, type){
  var args;
  args = type === &#x27;|&#x3e;&#x27; ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== &#x27;Array&#x27;) {
    args = [args];
  }
  switch (type) {
  case &#x27;|&#x3e;&#x27;:
    this.lines.push(Call.make(target, args, {
      pipe: true
    }));
    break;
  case &#x27;&#x3c;|&#x27;:
    this.lines.push(Call.make(this.lines.pop(), args));
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new In(first, second);
  case &#x27;with&#x27;:
    return new Import(Unary(&#x27;^^&#x27;, first), second, false);
  case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
  case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
    return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
  case &#x27;&#x3c;|&#x27;:
    return Block(first).<span class="apidocCodeKeywordSpan">pipe</span>(second, op);
  case &#x27;|&#x3e;&#x27;:
    return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
  case &#x27;.&#x27;:
  case &#x27;.~&#x27;:
    return Chain(first).add(Index(second, op));
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.prepend" id="apidoc.element.livescript.ast.Block.prototype.prepend">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>prepend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(slice$.call(arguments)));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    args[args.length] = that[i$];
    res$.push(Import(proto, JS(&#x22;arguments[&#x22; + (args.length - 1) + &#x22;]&#x22;), true));
  }
  imports = res$;
  body.prepend.apply(body, imports);
}
if (fun.cname &#x26;&#x26; !this.sup) {
  body.<span class="apidocCodeKeywordSpan">prepend</span>(Literal(name + &#x22;.displayName = &#x27;&#x22; + name + &#x22;&#x27;&#
x22;));
}
clas = Parens(Call.make(fun, args), true);
if (decl &#x26;&#x26; title.isComplex()) {
  clas = Assign(vname, clas);
}
if (title) {
  clas = Assign(title, clas);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.toJSON" id="apidoc.element.livescript.ast.Block.prototype.toJSON">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.unwrap" id="apidoc.element.livescript.ast.Block.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (){
  if (this.lines.length === 1) {
    return this.lines[0];
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.add" id="apidoc.module.livescript.ast.Block.prototype.add">module livescript.ast.Block.prototype.add</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.add.add" id="apidoc.element.livescript.ast.Block.prototype.add.add">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (it){
  var that, ref$;
  it = it.unparen();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
  default:
    this.lines.push(it);
    if (that = (ref$ = it.back, delete it.back, ref$)) {
      this.back = that;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  items = this instanceof Arr
    ? (this.items[0] == null || this.items[1] == null &#x26;&#x26; this.carp(&#x27;must specify both key and value for object comprehension
&#x27;), this.items)
    : (kv = &#x27;keyValue$&#x27;, (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &#x3c; len$; ++i$) {
        i = i$;
        v = ref$[i$];
        results$.push(Chain(v).<span class="apidocCodeKeywordSpan">add</span>(Index(Literal(i))));
      }
      return results$;
    }.call(this)));
  return Assign(Chain(Var(ref)).add(Index(items[0], &#x27;.&#x27;, true)), items[1]);
} else if (ref) {
  return Call.make(JS(ref + &#x27;.push&#x27;), [this]);
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.chomp" id="apidoc.module.livescript.ast.Block.prototype.chomp">module livescript.ast.Block.prototype.chomp</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.chomp.chomp" id="apidoc.element.livescript.ast.Block.prototype.chomp.chomp">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>chomp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chomp = function (){
  var lines, i, that;
  lines = this.lines;
  i = lines.length;
  while (that = lines[--i]) {
    if (!that.comment) {
      break;
    }
  }
  lines.length = i + 1;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (that = node.getJump(it)) {
      return that;
    }
  }
};
Block.prototype.makeReturn = function(){
  var that, ref$, key$, ref1$;
  this.<span class="apidocCodeKeywordSpan">chomp</span>();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &#x26;&#x26; !that.it) {
      --this.lines.length;
    }
  }
  return this;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.compile" id="apidoc.module.livescript.ast.Block.prototype.compile">module livescript.ast.Block.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compile.compile" id="apidoc.element.livescript.ast.Block.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &#x26;&#x26; (level = o.level);
  if (level) {
    return this.compileExpressions(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
    if (snEmpty(code = (node.front = true, node).compile(o, level))) {
      continue;
    }
    codes.push(tab);
    codes.push(code);
    node.isStatement() || codes.push(node.terminator);
    codes.push(&#x27;\n&#x27;);
  }
  codes.pop();
  return sn.apply(null, [null].concat(slice$.call(codes)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.compileExpressions" id="apidoc.module.livescript.ast.Block.prototype.compileExpressions">module livescript.ast.Block.prototype.compileExpressions</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions.compileExpressions" id="apidoc.element.livescript.ast.Block.prototype.compileExpressions.compileExpressions">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileExpressions
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExpressions = function (o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
      lines.splice(i--, 1);
    }
  }
  if (!lines.length) {
    lines.push(Literal(&#x27;void&#x27;));
  }
  lines[0].front = this.front;
  lines[lines.length - 1][&#x27;void&#x27;] = this[&#x27;void&#x27;];
  if (!lines[1]) {
    return lines[0].compile(o, level);
  }
  code = [];
  last = lines.pop();
  for (i$ = 0, len$ = lines.length; i$ &#x3c; len$; ++i$) {
    node = lines[i$];
    code.push((node[&#x27;void&#x27;] = true, node).compile(o, LEVEL_PAREN), &#x27;, &#x27;);
  }
  code.push(last.compile(o, LEVEL_PAREN));
  if (level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return this;
};
Block.prototype.compile = function(o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &#x26;&#x26; (level = o.level);
  if (level) {
    return this.<span class="apidocCodeKeywordSpan">compileExpressions</span>(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.compileRoot" id="apidoc.module.livescript.ast.Block.prototype.compileRoot">module livescript.ast.Block.prototype.compileRoot</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileRoot.compileRoot" id="apidoc.element.livescript.ast.Block.prototype.compileRoot.compileRoot">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileRoot
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRoot = function (options){
  var o, that, ref$, bare, prefix, ref1$, code, result;
  o = (import$({
    level: LEVEL_TOP,
    scope: this.scope = Scope.root = new Scope
  }, options));
  if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
    this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
  }
  delete o.filename;
  o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? &#x27;&#x27; : TAB;
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.compileWithDeclarations" id="apidoc.module.livescript.ast.Block.prototype.compileWithDeclarations">module livescript.ast.Block.prototype.compileWithDeclarations</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations.compileWithDeclarations" id="apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations.compileWithDeclarations">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileWithDeclarations
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileWithDeclarations = function (o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
  if (i = this.neck()) {
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), &#x22;\n&#x22;];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.emit(post, o.indent) : post]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.<span class="apidocCodeKeywordSpan">compileWithDeclarations</span>(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.getJump" id="apidoc.module.livescript.ast.Block.prototype.getJump">module livescript.ast.Block.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Block.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var i$, ref$, len$, node, that;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (that = node.getJump(it)) {
      return that;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.isArray" id="apidoc.module.livescript.ast.Block.prototype.isArray">module livescript.ast.Block.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Block.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.isCallable" id="apidoc.module.livescript.ast.Block.prototype.isCallable">module livescript.ast.Block.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Block.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.isComplex" id="apidoc.module.livescript.ast.Block.prototype.isComplex">module livescript.ast.Block.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Block.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  var ref$;
  return this.lines.length &#x3e; 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.isRegex" id="apidoc.module.livescript.ast.Block.prototype.isRegex">module livescript.ast.Block.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Block.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.isString" id="apidoc.module.livescript.ast.Block.prototype.isString">module livescript.ast.Block.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isString.isString" id="apidoc.element.livescript.ast.Block.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.makeReturn" id="apidoc.module.livescript.ast.Block.prototype.makeReturn">module livescript.ast.Block.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Block.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var that, ref$, key$, ref1$;
  this.chomp();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &#x26;&#x26; !that.it) {
      --this.lines.length;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.neck" id="apidoc.module.livescript.ast.Block.prototype.neck">module livescript.ast.Block.prototype.neck</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.neck.neck" id="apidoc.element.livescript.ast.Block.prototype.neck.neck">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>neck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neck = function (){
  var pos, i$, ref$, len$, x;
  pos = 0;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    x = ref$[i$];
    if (!(x.comment || x instanceof Literal)) {
      break;
    }
    ++pos;
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.back = that;
    }
  }
  return this;
};
Block.prototype.prepend = function(){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.<span class="apidocCodeKeywordSpan">neck</span>(), 0].concat(slice$.call(arguments
)));
  return this;
};
Block.prototype.pipe = function(target, type){
  var args;
  args = type === &#x27;|&#x3e;&#x27; ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== &#x27;Array&#x27;) {
    args = [args];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.pipe" id="apidoc.module.livescript.ast.Block.prototype.pipe">module livescript.ast.Block.prototype.pipe</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.pipe.pipe" id="apidoc.element.livescript.ast.Block.prototype.pipe.pipe">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>pipe
        <span class="apidocSignatureSpan">(target, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (target, type){
  var args;
  args = type === &#x27;|&#x3e;&#x27; ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== &#x27;Array&#x27;) {
    args = [args];
  }
  switch (type) {
  case &#x27;|&#x3e;&#x27;:
    this.lines.push(Call.make(target, args, {
      pipe: true
    }));
    break;
  case &#x27;&#x3c;|&#x27;:
    this.lines.push(Call.make(this.lines.pop(), args));
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new In(first, second);
  case &#x27;with&#x27;:
    return new Import(Unary(&#x27;^^&#x27;, first), second, false);
  case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
  case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
    return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
  case &#x27;&#x3c;|&#x27;:
    return Block(first).<span class="apidocCodeKeywordSpan">pipe</span>(second, op);
  case &#x27;|&#x3e;&#x27;:
    return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
  case &#x27;.&#x27;:
  case &#x27;.~&#x27;:
    return Chain(first).add(Index(second, op));
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.prepend" id="apidoc.module.livescript.ast.Block.prototype.prepend">module livescript.ast.Block.prototype.prepend</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.prepend.prepend" id="apidoc.element.livescript.ast.Block.prototype.prepend.prepend">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>prepend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(slice$.call(arguments)));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    args[args.length] = that[i$];
    res$.push(Import(proto, JS(&#x22;arguments[&#x22; + (args.length - 1) + &#x22;]&#x22;), true));
  }
  imports = res$;
  body.prepend.apply(body, imports);
}
if (fun.cname &#x26;&#x26; !this.sup) {
  body.<span class="apidocCodeKeywordSpan">prepend</span>(Literal(name + &#x22;.displayName = &#x27;&#x22; + name + &#x22;&#x27;&#
x22;));
}
clas = Parens(Call.make(fun, args), true);
if (decl &#x26;&#x26; title.isComplex()) {
  clas = Assign(vname, clas);
}
if (title) {
  clas = Assign(title, clas);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.toJSON" id="apidoc.module.livescript.ast.Block.prototype.toJSON">module livescript.ast.Block.prototype.toJSON</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.toJSON.toJSON" id="apidoc.element.livescript.ast.Block.prototype.toJSON.toJSON">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.unwrap" id="apidoc.module.livescript.ast.Block.prototype.unwrap">module livescript.ast.Block.prototype.unwrap</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.unwrap.unwrap" id="apidoc.element.livescript.ast.Block.prototype.unwrap.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (){
  if (this.lines.length === 1) {
    return this.lines[0];
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Box" id="apidoc.module.livescript.ast.Box">module livescript.ast.Box</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Box.Box" id="apidoc.element.livescript.ast.Box.Box">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Box
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Box = function (v){
  if (typeof v === &#x22;object&#x22;) {
    return v;
  } else {
    return new v.constructor(v);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan
">Box</span>($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Call" id="apidoc.module.livescript.ast.Call">module livescript.ast.Call</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Call.Call" id="apidoc.element.livescript.ast.Call.Call">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Call
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &#x26;&#x26; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = &#x27;.call&#x27;;
      args[0] = Literal(&#x27;this&#x27;);
      args[1] = Splat(Literal(&#x27;arguments&#x27;));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === &#x27;_&#x27;) {
        args[i] = Chain(Literal(&#x27;void&#x27;));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.<span class="apidocCodeKeywordSpan">Call</span>($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call[&#x27;let&#x27;]($$[$0-3], $$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.back" id="apidoc.element.livescript.ast.Call.back">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>back
        <span class="apidocSignatureSpan">(params, node, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">back = function (params, node, bound, curried, hushed, generator){
  var fun, ref$, args, index, i$, len$, a;
  fun = Fun(params, void 8, bound, curried, hushed, generator);
  if (node instanceof Label) {
    fun.name = node.label;
    fun.labeled = true;
    node = node.it;
  }
  if (!fun.hushed &#x26;&#x26; (fun.hushed = node.op === &#x27;!&#x27;)) {
    node = node.it;
  }
  if ((ref$ = node.getCall()) != null) {
    ref$.partialized = null;
  }
  args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
  index = 0;
  for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
    a = args[i$];
    if (a.placeholder) {
      break;
    }
    ++index;
  }
  return node.back = (args[index] = fun).body, node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 63: case 172:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
break;
case 66:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], &#x27;cascade&#x27;));
break;
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.<span class="apidocCodeKeywordSpan">back</span>($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.
test($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented&#x27;)&#x22;))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.block" id="apidoc.element.livescript.ast.Call.block">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>block
        <span class="apidocSignatureSpan">(fun, args, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function (fun, args, method){
  var ref$, ref1$;
  return ref$ = Parens(Chain(fun, [(ref1$ = Call(args), ref1$.method = method, ref1$)]), true), ref$.calling = true, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      res$.push(a.left);
    } else {
      res$.push(Var(a.varName() || a.carp(&#x27;invalid &#x22;let&#x22; argument&#x27;)));
    }
  }
  params = res$;
  gotThis || args.unshift(Literal(&#x27;this&#x27;));
  return this.<span class="apidocCodeKeywordSpan">block</span>(Fun(params, body, null, null, null, generator), args, &#x27;.call
&#x27;);
};
return Call;
}(Node));
List = (function(superclass){
var prototype = extend$((import$(List, superclass).displayName = &#x27;List&#x27;, List), superclass).prototype, constructor = List
;
List.prototype.children = [&#x27;items&#x27;];
List.prototype.show = function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.let" id="apidoc.element.livescript.ast.Call.let">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>let
        <span class="apidocSignatureSpan">(args, body, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">let = function (args, body, generator){
  var params, res$, i$, len$, i, a, that, gotThis;
  generator == null &#x26;&#x26; (generator = false);
  res$ = [];
  for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    a = args[i$];
    if (that = a.op === &#x27;=&#x27; &#x26;&#x26; !a.logic &#x26;&#x26; a.right) {
      args[i] = that;
      if (i === 0 &#x26;&#x26; (gotThis = a.left.value === &#x27;this&#x27;)) {
        continue;
      }
      res$.push(a.left);
    } else {
      res$.push(Var(a.varName() || a.carp(&#x27;invalid &#x22;let&#x22; argument&#x27;)));
    }
  }
  params = res$;
  gotThis || args.unshift(Literal(&#x27;this&#x27;));
  return this.block(Fun(params, body, null, null, null, generator), args, &#x27;.call&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.make" id="apidoc.element.livescript.ast.Call.make">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>make
        <span class="apidocSignatureSpan">(callee, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make = function (callee, args, opts){
  var call;
  call = Call(args);
  if (opts) {
    import$(call, opts);
  }
  return Chain(callee).add(call);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          v = ref$[i$];
          results$.push(Chain(v).add(Index(Literal(i))));
        }
        return results$;
      }.call(this)));
    return Assign(Chain(Var(ref)).add(Index(items[0], &#x27;.&#x27;, true)), items[1]);
  } else if (ref) {
    return Call.<span class="apidocCodeKeywordSpan">make</span>(JS(ref + &#x27;.push&#x27;), [this]);
  } else {
    return Return(this);
  }
},
show: String,
toString: function(idt){
  var tree, that;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.superclass" id="apidoc.element.livescript.ast.Call.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Call.prototype" id="apidoc.module.livescript.ast.Call.prototype">module livescript.ast.Call.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.compile" id="apidoc.element.livescript.ast.Call.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var code, i$, ref$, len$, i, a;
  code = [sn(this, this.method || &#x27;&#x27;, &#x27;(&#x27;) + (this.pipe ? &#x22;\n&#x22; + o.indent : &#x27;&#x27;)];
  for (i$ = 0, len$ = (ref$ = this.args).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    a = ref$[i$];
    code.push(i ? &#x27;, &#x27; : &#x27;&#x27;, a.compile(o, LEVEL_LIST));
  }
  code.push(sn(this, &#x27;)&#x27;));
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.constructor" id="apidoc.element.livescript.ast.Call.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>constructor
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &#x26;&#x26; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = &#x27;.call&#x27;;
      args[0] = Literal(&#x27;this&#x27;);
      args[1] = Splat(Literal(&#x27;arguments&#x27;));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === &#x27;_&#x27;) {
        args[i] = Chain(Literal(&#x27;void&#x27;));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.show" id="apidoc.element.livescript.ast.Call.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this[&#x27;new&#x27;]] + [this.method] + [this.soak ? &#x27;?&#x27; : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Call.prototype.compile" id="apidoc.module.livescript.ast.Call.prototype.compile">module livescript.ast.Call.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.compile.compile" id="apidoc.element.livescript.ast.Call.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var code, i$, ref$, len$, i, a;
  code = [sn(this, this.method || &#x27;&#x27;, &#x27;(&#x27;) + (this.pipe ? &#x22;\n&#x22; + o.indent : &#x27;&#x27;)];
  for (i$ = 0, len$ = (ref$ = this.args).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    a = ref$[i$];
    code.push(i ? &#x27;, &#x27; : &#x27;&#x27;, a.compile(o, LEVEL_LIST));
  }
  code.push(sn(this, &#x27;)&#x27;));
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Call.prototype.show" id="apidoc.module.livescript.ast.Call.prototype.show">module livescript.ast.Call.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.show.show" id="apidoc.element.livescript.ast.Call.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this[&#x27;new&#x27;]] + [this.method] + [this.soak ? &#x27;?&#x27; : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade" id="apidoc.module.livescript.ast.Cascade">module livescript.ast.Cascade</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.Cascade" id="apidoc.element.livescript.ast.Cascade.Cascade">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 40:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], yy.Slice({
type: $$[$0-1],
target: $$[$0-4]
      }))));
break;
case 41:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], yy.<span class="apidocCodeKeywordSpan">Cascade</span>($$[$0-1], $$[$
0], &#x27;with&#x27;))));
break;
case 42:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({
kind: $$[$0-2],
source: $$[$0-1],
body: $$[$0],
ref: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.superclass" id="apidoc.element.livescript.ast.Cascade.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype" id="apidoc.module.livescript.ast.Cascade.prototype">module livescript.ast.Cascade.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode" id="apidoc.element.livescript.ast.Cascade.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var level, input, output, prog1, ref, ref$, code, out;
  level = o.level;
  input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
  if (prog1 &#x26;&#x26; (&#x27;ret&#x27; in this || level &#x26;&#x26; !this[&#x27;void&#x27;])) {
    output.add((ref$ = Literal(&#x27;..&#x27;), ref$.cascadee = true, ref$));
  }
  if (&#x27;ret&#x27; in this) {
    output = output.makeReturn(this.ret);
  }
  if (ref) {
    prog1 || (output = Assign(Var(ref), output));
  } else {
    ref = o.scope.temporary(&#x27;x&#x27;);
  }
  if (input instanceof Cascade) {
    input.ref = ref;
  } else {
    input &#x26;&#x26; (input = Assign(Var(ref), input));
  }
  o.level &#x26;&#x26; (o.level = LEVEL_PAREN);
  code = [input.compile(o)];
  out = Block(output).compile((o.ref = new String(ref), o));
  if (prog1 === &#x27;cascade&#x27; &#x26;&#x26; !o.ref.erred) {
    this.carp(&#x22;unreferred cascadee&#x22;);
  }
  if (!level) {
    return sn.apply(null, [null].concat(slice$.call(code), [input.terminator, &#x22;\n&#x22;, out]));
  }
  code.push(&#x22;, &#x22;, out);
  if (level &#x3e; LEVEL_PAREN) {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.constructor" id="apidoc.element.livescript.ast.Cascade.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>constructor
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.getJump" id="apidoc.element.livescript.ast.Cascade.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  return this.output.getJump(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isArray" id="apidoc.element.livescript.ast.Cascade.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable" id="apidoc.element.livescript.ast.Cascade.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex" id="apidoc.element.livescript.ast.Cascade.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isString" id="apidoc.element.livescript.ast.Cascade.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn" id="apidoc.element.livescript.ast.Cascade.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(ret)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (ret){
  this.ret = ret;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.show" id="apidoc.element.livescript.ast.Cascade.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.prog1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.compileNode" id="apidoc.module.livescript.ast.Cascade.prototype.compileNode">module livescript.ast.Cascade.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Cascade.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var level, input, output, prog1, ref, ref$, code, out;
  level = o.level;
  input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
  if (prog1 &#x26;&#x26; (&#x27;ret&#x27; in this || level &#x26;&#x26; !this[&#x27;void&#x27;])) {
    output.add((ref$ = Literal(&#x27;..&#x27;), ref$.cascadee = true, ref$));
  }
  if (&#x27;ret&#x27; in this) {
    output = output.makeReturn(this.ret);
  }
  if (ref) {
    prog1 || (output = Assign(Var(ref), output));
  } else {
    ref = o.scope.temporary(&#x27;x&#x27;);
  }
  if (input instanceof Cascade) {
    input.ref = ref;
  } else {
    input &#x26;&#x26; (input = Assign(Var(ref), input));
  }
  o.level &#x26;&#x26; (o.level = LEVEL_PAREN);
  code = [input.compile(o)];
  out = Block(output).compile((o.ref = new String(ref), o));
  if (prog1 === &#x27;cascade&#x27; &#x26;&#x26; !o.ref.erred) {
    this.carp(&#x22;unreferred cascadee&#x22;);
  }
  if (!level) {
    return sn.apply(null, [null].concat(slice$.call(code), [input.terminator, &#x22;\n&#x22;, out]));
  }
  code.push(&#x22;, &#x22;, out);
  if (level &#x3e; LEVEL_PAREN) {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.getJump" id="apidoc.module.livescript.ast.Cascade.prototype.getJump">module livescript.ast.Cascade.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Cascade.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  return this.output.getJump(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.isArray" id="apidoc.module.livescript.ast.Cascade.prototype.isArray">module livescript.ast.Cascade.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Cascade.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.isCallable" id="apidoc.module.livescript.ast.Cascade.prototype.isCallable">module livescript.ast.Cascade.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Cascade.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.isRegex" id="apidoc.module.livescript.ast.Cascade.prototype.isRegex">module livescript.ast.Cascade.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Cascade.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.isString" id="apidoc.module.livescript.ast.Cascade.prototype.isString">module livescript.ast.Cascade.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isString.isString" id="apidoc.element.livescript.ast.Cascade.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.makeReturn" id="apidoc.module.livescript.ast.Cascade.prototype.makeReturn">module livescript.ast.Cascade.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Cascade.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(ret)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (ret){
  this.ret = ret;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.show" id="apidoc.module.livescript.ast.Cascade.prototype.show">module livescript.ast.Cascade.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.show.show" id="apidoc.element.livescript.ast.Cascade.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.prog1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case" id="apidoc.module.livescript.ast.Case">module livescript.ast.Case</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.Case" id="apidoc.element.livescript.ast.Case.Case">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Case
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 201:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-4], $$[$0-5] === &#x27;until&#x27;, $$[$0-2]).addGuard($$[$0]));
break;
case 203:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].concat($$[$0]));
break;
case 206:
this.$ = yy.L(_$[$0-2], _$[$0],[yy.L(_$[$0-2],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">Case</span>($$[$0-1], $$[$0]))]);
break;
case 207:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat(yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))));
break;
case 212:
return this.$
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.superclass" id="apidoc.element.livescript.ast.Case.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Case.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case.prototype" id="apidoc.module.livescript.ast.Case.prototype">module livescript.ast.Case.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.compileCase" id="apidoc.element.livescript.ast.Case.prototype.compileCase">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>compileCase
        <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileCase = function (o, tab, nobr, bool, type, target){
  var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
  tests = [];
  for (i$ = 0, len$ = (ref$ = this.tests).length; i$ &#x3c; len$; ++i$) {
    test = ref$[i$];
    test = test.expandSlice(o).unwrap();
    if (test instanceof Arr &#x26;&#x26; type !== &#x27;match&#x27;) {
      for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ &#x3c; len1$; ++j$) {
        t = ref1$[j$];
        tests.push(t);
      }
    } else {
      tests.push(test);
    }
  }
  tests.length || tests.push(Literal(&#x27;void&#x27;));
  if (type === &#x27;match&#x27;) {
    for (i$ = 0, len$ = tests.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      test = tests[i$];
      tar = Chain(target).add(Index(Literal(i), &#x27;.&#x27;, true));
      tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
    }
  }
  if (bool) {
    binary = type === &#x27;match&#x27; ? &#x27;&#x26;&#x26;&#x27; : &#x27;||&#x27;;
    t = tests[0];
    i = 0;
    while (that = tests[++i]) {
      t = Binary(binary, t, that);
    }
    tests = [(this.t = t, this.aSource = &#x27;t&#x27;, this.aTargets = [&#x27;body&#x27;], this).anaphorize().invert()];
  }
  code = [];
  for (i$ = 0, len$ = tests.length; i$ &#x3c; len$; ++i$) {
    t = tests[i$];
    code.push(tab, sn(t, &#x22;case &#x22;, t.compile(o, LEVEL_PAREN), &#x22;:\n&#x22;));
  }
  lines = this.body.lines;
  last = lines[lines.length - 1];
  if (ft = (last != null ? last.value : void 8) === &#x27;fallthrough&#x27;) {
    lines[lines.length - 1] = JS(&#x27;// fallthrough&#x27;);
  }
  o.indent = tab += TAB;
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(bodyCode, &#x27;\n&#x27;);
  }
  if (!(nobr || ft || last instanceof Jump)) {
    code.push(tab + &#x27;break;\n&#x27;);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  : !!this.topic &#x26;&#x26; this.anaphorize().compile(o, LEVEL_PAREN);
code = [sn(this, &#x22;switch (&#x22;, snSafe(topic), &#x22;) {\n&#x22;)];
stop = this[&#x27;default&#x27;] || this.cases.length - 1;
o[&#x27;break&#x27;] = true;
for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
  i = i$;
  c = ref$[i$];
  code.push(c.<span class="apidocCodeKeywordSpan">compileCase</span>(o, tab, i === stop, this.type === &#x27;match&#x27; || !topic
, this.type, target));
}
if (this[&#x27;default&#x27;]) {
  o.indent = tab + TAB;
  if (that = this[&#x27;default&#x27;].compile(o, LEVEL_TOP)) {
    code.push(tab + &#x22;default:\n&#x22;, that, &#x22;\n&#x22;);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.constructor" id="apidoc.element.livescript.ast.Case.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>constructor
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.isCallable" id="apidoc.element.livescript.ast.Case.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  return this.body.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.makeReturn" id="apidoc.element.livescript.ast.Case.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$, ref1$;
  if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== &#x27;fallthrough&#x27;) {
    (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case.prototype.compileCase" id="apidoc.module.livescript.ast.Case.prototype.compileCase">module livescript.ast.Case.prototype.compileCase</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.compileCase.compileCase" id="apidoc.element.livescript.ast.Case.prototype.compileCase.compileCase">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>compileCase
        <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileCase = function (o, tab, nobr, bool, type, target){
  var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
  tests = [];
  for (i$ = 0, len$ = (ref$ = this.tests).length; i$ &#x3c; len$; ++i$) {
    test = ref$[i$];
    test = test.expandSlice(o).unwrap();
    if (test instanceof Arr &#x26;&#x26; type !== &#x27;match&#x27;) {
      for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ &#x3c; len1$; ++j$) {
        t = ref1$[j$];
        tests.push(t);
      }
    } else {
      tests.push(test);
    }
  }
  tests.length || tests.push(Literal(&#x27;void&#x27;));
  if (type === &#x27;match&#x27;) {
    for (i$ = 0, len$ = tests.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      test = tests[i$];
      tar = Chain(target).add(Index(Literal(i), &#x27;.&#x27;, true));
      tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
    }
  }
  if (bool) {
    binary = type === &#x27;match&#x27; ? &#x27;&#x26;&#x26;&#x27; : &#x27;||&#x27;;
    t = tests[0];
    i = 0;
    while (that = tests[++i]) {
      t = Binary(binary, t, that);
    }
    tests = [(this.t = t, this.aSource = &#x27;t&#x27;, this.aTargets = [&#x27;body&#x27;], this).anaphorize().invert()];
  }
  code = [];
  for (i$ = 0, len$ = tests.length; i$ &#x3c; len$; ++i$) {
    t = tests[i$];
    code.push(tab, sn(t, &#x22;case &#x22;, t.compile(o, LEVEL_PAREN), &#x22;:\n&#x22;));
  }
  lines = this.body.lines;
  last = lines[lines.length - 1];
  if (ft = (last != null ? last.value : void 8) === &#x27;fallthrough&#x27;) {
    lines[lines.length - 1] = JS(&#x27;// fallthrough&#x27;);
  }
  o.indent = tab += TAB;
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(bodyCode, &#x27;\n&#x27;);
  }
  if (!(nobr || ft || last instanceof Jump)) {
    code.push(tab + &#x27;break;\n&#x27;);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  : !!this.topic &#x26;&#x26; this.anaphorize().compile(o, LEVEL_PAREN);
code = [sn(this, &#x22;switch (&#x22;, snSafe(topic), &#x22;) {\n&#x22;)];
stop = this[&#x27;default&#x27;] || this.cases.length - 1;
o[&#x27;break&#x27;] = true;
for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
  i = i$;
  c = ref$[i$];
  code.push(c.<span class="apidocCodeKeywordSpan">compileCase</span>(o, tab, i === stop, this.type === &#x27;match&#x27; || !topic
, this.type, target));
}
if (this[&#x27;default&#x27;]) {
  o.indent = tab + TAB;
  if (that = this[&#x27;default&#x27;].compile(o, LEVEL_TOP)) {
    code.push(tab + &#x22;default:\n&#x22;, that, &#x22;\n&#x22;);
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case.prototype.isCallable" id="apidoc.module.livescript.ast.Case.prototype.isCallable">module livescript.ast.Case.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Case.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  return this.body.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case.prototype.makeReturn" id="apidoc.module.livescript.ast.Case.prototype.makeReturn">module livescript.ast.Case.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Case.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$, ref1$;
  if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== &#x27;fallthrough&#x27;) {
    (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain" id="apidoc.module.livescript.ast.Chain">module livescript.ast.Chain</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.Chain" id="apidoc.element.livescript.ast.Chain.Chain">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &#x26;&#x26; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Chain</span>(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.superclass" id="apidoc.element.livescript.ast.Chain.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype" id="apidoc.module.livescript.ast.Chain.prototype">module livescript.ast.Chain.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.add" id="apidoc.element.livescript.ast.Chain.prototype.add">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (it){
  var last, ref$, index, ref1$, bi, logics, call, f;
  if (this.tails.length) {
    last = (ref$ = this.tails)[ref$.length - 1];
    if (last instanceof Call &#x26;&#x26; ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 &#x26;&#x26; it.args.length === 1) {
      index = last.partialized[0].head.value;
      delete last.partialized;
      last.args[index] = it.args[0];
      return this;
    }
  }
  if (this.head instanceof Existence) {
    ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
    it.soak = true;
  }
  this.tails.push(it);
  bi = this.head instanceof Parens &#x26;&#x26; this.head.it instanceof Binary &#x26;&#x26; !this.head.it.partial
    ? this.head.it
    : this.head instanceof Binary &#x26;&#x26; !this.head.partial ? this.head : void 8;
  if (this.head instanceof Super) {
    if (!this.head.called &#x26;&#x26; it instanceof Call &#x26;&#x26; !it.method) {
      it.method = &#x27;.call&#x27;;
      it.args.unshift(Literal(&#x27;this&#x27;));
      this.head.called = true;
    } else if (!this.tails[1] &#x26;&#x26; ((ref1$ = it.key) != null ? ref1$.name : void 8) === &#x27;prototype&#x27;) {
      this.head.sproto = true;
    }
  } else if (it instanceof Call &#x26;&#x26; this.tails.length === 1 &#x26;&#x26; bi &#x26;&#x26; in$(bi.op, logics = [&#x27;&#x26;&#x26;&#x27;, &#x27;||&#x27;, &#x27;xor&#x27;])) {
    call = it;
    f = function(x, key){
      var y;
      y = x[key];
      if (y instanceof Binary &#x26;&#x26; in$(y.op, logics)) {
        f(y, &#x27;first&#x27;);
        return f(y, &#x27;second&#x27;);
      } else {
        return x[key] = Chain(y).autoCompare(call.args);
      }
    };
    f(bi, &#x27;first&#x27;);
    f(bi, &#x27;second&#x27;);
    return bi;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  items = this instanceof Arr
    ? (this.items[0] == null || this.items[1] == null &#x26;&#x26; this.carp(&#x27;must specify both key and value for object comprehension
&#x27;), this.items)
    : (kv = &#x27;keyValue$&#x27;, (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &#x3c; len$; ++i$) {
        i = i$;
        v = ref$[i$];
        results$.push(Chain(v).<span class="apidocCodeKeywordSpan">add</span>(Index(Literal(i))));
      }
      return results$;
    }.call(this)));
  return Assign(Chain(Var(ref)).add(Index(items[0], &#x27;.&#x27;, true)), items[1]);
} else if (ref) {
  return Call.make(JS(ref + &#x27;.push&#x27;), [this]);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.assigns" id="apidoc.element.livescript.ast.Chain.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare" id="apidoc.element.livescript.ast.Chain.prototype.autoCompare">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>autoCompare
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoCompare = function (target){
  var test;
  test = this.head;
  switch (false) {
  case !(test instanceof Literal):
    return Binary(&#x27;===&#x27;, test, target[0]);
  case !(test instanceof Unary &#x26;&#x26; test.it instanceof Literal):
    return Binary(&#x27;===&#x27;, test, target[0]);
  case !(test instanceof Arr || test instanceof Obj):
    return Binary(&#x27;====&#x27;, test, target[0]);
  case !(test instanceof Var &#x26;&#x26; test.value === &#x27;_&#x27;):
    return Literal(&#x27;true&#x27;);
  default:
    return this.add(Call(target)) || [];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  f = function(x, key){
    var y;
    y = x[key];
    if (y instanceof Binary &#x26;&#x26; in$(y.op, logics)) {
      f(y, &#x27;first&#x27;);
      return f(y, &#x27;second&#x27;);
    } else {
      return x[key] = Chain(y).<span class="apidocCodeKeywordSpan">autoCompare</span>(call.args);
    }
  };
  f(bi, &#x27;first&#x27;);
  f(bi, &#x27;second&#x27;);
  return bi;
}
return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference" id="apidoc.element.livescript.ast.Chain.prototype.cacheReference">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>cacheReference
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cacheReference = function (o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.unwrap().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
    base = Chain(Assign(Var(ref), base));
    bref = (ref$ = Var(ref), ref$.temp = true, ref$);
  }
  if (!name) {
    return [base, bref];
  }
  if (name.isComplex()) {
    ref = o.scope.temporary(&#x27;key&#x27;);
    name = Index(Assign(Var(ref), name.key));
    nref = Index((ref$ = Var(ref), ref$.temp = true, ref$));
  }
  return [base.add(name), Chain(bref || base.head, [nref || name])];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = ref$[i$];
if (ref1$ = node.soak, delete node.soak, ref1$) {
  bust = Chain(this.head, this.tails.splice(0, i));
  if (node.assign &#x26;&#x26; !bust.isAssignable()) {
    node.carp(&#x27;invalid accessign&#x27;);
  }
  if (i &#x26;&#x26; (node.assign || node instanceof Call)) {
    ref1$ = bust.<span class="apidocCodeKeywordSpan">cacheReference</span>(o), test = ref1$[0], bust = ref1$[1];
    if (bust instanceof Chain) {
      (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
      bust = bust.head;
    }
    this.head = bust;
  } else {
    ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.compileNode" id="apidoc.element.livescript.ast.Chain.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
  if (this.flip) {
    util(&#x27;flip&#x27;);
    util(&#x27;curry&#x27;);
  }
  head = this.head, tails = this.tails;
  head.front = this.front;
  head.newed = this.newed;
  if (!tails.length) {
    return head.compile(o);
  }
  if (that = this.unfoldAssign(o)) {
    return that.compile(o);
  }
  for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
    t = tails[i$];
    if (t.partialized) {
      hasPartial = true;
      break;
    }
  }
  if (hasPartial) {
    util(&#x27;slice&#x27;);
    pre = [];
    rest = [];
    for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
      t = tails[i$];
      broken = broken || t.partialized != null;
      if (broken) {
        rest.push(t);
      } else {
        pre.push(t);
      }
    }
    if (rest != null) {
      partial = rest[0], post = slice$.call(rest, 1);
    }
    this.tails = pre;
    context = pre.length
      ? Chain(head, slice$.call(pre, 0, -1))
      : Literal(&#x27;this&#x27;);
    return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial
.partialized)])])), post).compile(o);
  }
  if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
    this.carp(&#x27;invalid callee&#x27;);
  }
  this.expandSlice(o);
  this.expandVivify();
  this.expandBind(o);
  this.expandSplat(o);
  this.expandStar(o);
  if (this.splattedNewArgs) {
    idt = o.indent + TAB;
    func = Chain(this.head, tails.slice(0, -1));
    return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22;var child = new ctor
, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
  }
  if (!this.tails.length) {
    return this.head.compile(o);
  }
  base = [this.head.compile(o, LEVEL_CALL)];
  news = [];
  rest = [];
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    t = ref$[i$];
    if (t[&#x27;new&#x27;]) {
      news.push(&#x27;new &#x27;);
    }
    rest.push(t.compile(o));
  }
  if (&#x27;.&#x27; === rest.join(&#x22;&#x22;).charAt(0) &#x26;&#x26; SIMPLENUM.test(base[0].toString())) {
    base.push(&#x27; &#x27;);
  }
  return sn.apply(null, [null].concat(slice$.call(news), slice$.call(base), slice$.call(rest)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.constructor" id="apidoc.element.livescript.ast.Chain.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>constructor
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &#x26;&#x26; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandBind" id="apidoc.element.livescript.ast.Chain.prototype.expandBind">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandBind
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandBind = function (o){
  var tails, i, that, obj, key, call;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.symbol !== &#x27;.~&#x27;) {
      continue;
    }
    that.symbol = &#x27;&#x27;;
    obj = Chain(this.head, tails.splice(0, i)).unwrap();
    key = tails.shift().key;
    call = Call.make(Util(&#x27;bind&#x27;), [obj, (key.reserved = true, key)]);
    this.head = this.newed ? Parens(call, true) : call;
    i = -1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.expandVivify();
this.<span class="apidocCodeKeywordSpan">expandBind</span>(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice" id="apidoc.element.livescript.ast.Chain.prototype.expandSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSlice
        <span class="apidocSignatureSpan">(o, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandSlice = function (o, assign){
  var tails, i, tail, ref$, x;
  tails = this.tails;
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &#x26;&#x26; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp(&#x27;calling a slice&#x27;);
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? Chain(head, slice$.call(pre, 0, -1))
    : Literal(&#x27;this&#x27;);
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.<span class="apidocCodeKeywordSpan">expandSlice</span>(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat" id="apidoc.element.livescript.ast.Chain.prototype.expandSplat">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSplat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandSplat = function (o){
  var tails, i, call, args, ctx, ref$;
  tails = this.tails;
  i = -1;
  while (call = tails[++i]) {
    if (!(args = call.args)) {
      continue;
    }
    ctx = call.method === &#x27;.call&#x27; &#x26;&#x26; (args = args.concat()).shift();
    if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
      continue;
    }
    if (call[&#x27;new&#x27;]) {
      this.splattedNewArgs = args;
    } else {
      if (!ctx &#x26;&#x26; tails[i - 1] instanceof Index) {
        ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
        i = 0;
      }
      call.method = &#x27;.apply&#x27;;
      call.args = [ctx || Literal(&#x27;null&#x27;), JS(args)];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.expandVivify();
this.expandBind(o);
this.<span class="apidocCodeKeywordSpan">expandSplat</span>(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
}
if (!this.tails.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandStar" id="apidoc.element.livescript.ast.Chain.prototype.expandStar">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandStar
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandStar = function (o){
  var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.args || that.stars || that.key instanceof Key) {
      continue;
    }
    stars = that.stars = [];
    that.eachChild(seek);
    if (!stars.length) {
      continue;
    }
    ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
    value = Chain(ref, [Index(Key(&#x27;length&#x27;))]).compile(o);
    for (i$ = 0, len$ = stars.length; i$ &#x3c; len$; ++i$) {
      star = stars[i$];
      star.value = value;
      star.isAssignable = YES;
    }
    this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
    if (temps) {
      o.scope.free(temps[0]);
    }
    i = -1;
  }
  function seek(it){
    if (it.value === &#x27;*&#x27;) {
      stars.push(it);
    } else if (!(it instanceof Index)) {
      it.eachChild(seek);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.<span class="apidocCodeKeywordSpan">expandStar</span>(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
}
if (!this.tails.length) {
  return this.head.compile(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify" id="apidoc.element.livescript.ast.Chain.prototype.expandVivify">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandVivify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandVivify = function (){
  var tails, i, that, ref$, ref1$;
  tails = this.tails;
  i = 0;
  while (i &#x3c; tails.length) {
    if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
      this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), &#x27;=&#x27;, &#x27;||&#x27;);
      i = 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    : Literal(&#x27;this&#x27;);
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.<span class="apidocCodeKeywordSpan">expandVivify</span>();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.flipIt" id="apidoc.element.livescript.ast.Chain.prototype.flipIt">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>flipIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flipIt = function (){
  this.flip = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 26:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 28:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var(&#x27;flip$&#x27;))).add(yy.L(_$[$0-3],_$[$0-3],yy
.Call([$$[$0-3]])))).<span class="apidocCodeKeywordSpan">flipIt</span>().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 29:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.For({
from: $$[$0-3],
op: $$[$0-2],
to: $$[$0-1],
inComprehension: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getCall" id="apidoc.element.livescript.ast.Chain.prototype.getCall">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCall = function (){
  var tail, ref$;
  return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call &#x26;&#x26; tail;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fun.name = node.label;
  fun.labeled = true;
  node = node.it;
}
if (!fun.hushed &#x26;&#x26; (fun.hushed = node.op === &#x27;!&#x27;)) {
  node = node.it;
}
if ((ref$ = node.<span class="apidocCodeKeywordSpan">getCall</span>()) != null) {
  ref$.partialized = null;
}
args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
index = 0;
for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
  a = args[i$];
  if (a.placeholder) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getJump" id="apidoc.element.livescript.ast.Chain.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isArray" id="apidoc.element.livescript.ast.Chain.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.isArray();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable" id="apidoc.element.livescript.ast.Chain.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAssignable = function (){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.isAssignable();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isCallable" id="apidoc.element.livescript.ast.Chain.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return !((ref$ = that.key) != null &#x26;&#x26; ref$.items);
  } else {
    return this.head.isCallable();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isComplex" id="apidoc.element.livescript.ast.Chain.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.tails.length || this.head.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isRegex" id="apidoc.element.livescript.ast.Chain.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess" id="apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isSimpleAccess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSimpleAccess = function (){
  return this.tails.length === 1 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !this.tails[0].isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    dotSplit = name.toString().split(&#x27;.&#x27;);
    if (protoSplit.length &#x3e; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &#x3e; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join(&#x27;&#x27;);
    }
  }
  code = !o.level &#x26;&#x26; right instanceof While &#x26;&#x26; !right[&#x27;else&#x27;] &#x26;&#x26; (lvar || left instanceof
 Chain &#x26;&#x26; left.<span class="apidocCodeKeywordSpan">isSimpleAccess</span>())
    ? (empty = right.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;, [res = o.scope.temporary(&#x27;res&#x27;), &#x22; = &#x22; + empty
 + &#x22;;\n&#x22; + this.tab, right.makeReturn(res).compile(o), &#x22;\n&#x22; + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &#x3e; LEVEL_LIST) {
    code = [&#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isStatement" id="apidoc.element.livescript.ast.Chain.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isStatement
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStatement = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isString" id="apidoc.element.livescript.ast.Chain.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn" id="apidoc.element.livescript.ast.Chain.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  if (this.tails.length) {
    return superclass.prototype.makeReturn.apply(this, arguments);
  } else {
    return (ref$ = this.head).makeReturn.apply(ref$, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Chain.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldAssign = function (o){
  var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
  if (that = this.head.unfoldAssign(o)) {
    (ref$ = that.right.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    index = ref$[i$];
    if (op = index.assign) {
      index.assign = &#x27;&#x27;;
      left = Chain(this.head, this.tails.splice(0, i)).expandSlice(o).unwrap();
      if (left instanceof Arr) {
        lefts = left.items;
        rites = (this.head = Arr()).items;
        for (j$ = 0, len1$ = lefts.length; j$ &#x3c; len1$; ++j$) {
          i = j$;
          node = lefts[j$];
          ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
        }
      } else {
        ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
      }
      if (op === &#x27;=&#x27;) {
        op = &#x27;:=&#x27;;
      }
      return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Chain.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var that, ref$, i$, len$, i, node, ref1$, bust, test;
  if (that = this.head.unfoldSoak(o)) {
    (ref$ = that.then.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = ref$[i$];
    if (ref1$ = node.soak, delete node.soak, ref1$) {
      bust = Chain(this.head, this.tails.splice(0, i));
      if (node.assign &#x26;&#x26; !bust.isAssignable()) {
        node.carp(&#x27;invalid accessign&#x27;);
      }
      if (i &#x26;&#x26; (node.assign || node instanceof Call)) {
        ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
        if (bust instanceof Chain) {
          (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
          bust = bust.head;
        }
        this.head = bust;
      } else {
        ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
      }
      test = node instanceof Call
        ? JS(&#x22;typeof &#x22; + test.compile(o, LEVEL_OP) + &#x22; == &#x27;function&#x27;&#x22;)
        : Existence(test);
      return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unwrap" id="apidoc.element.livescript.ast.Chain.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (){
  if (this.tails.length) {
    return this;
  } else {
    return this.head;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.varName" id="apidoc.element.livescript.ast.Chain.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.add" id="apidoc.module.livescript.ast.Chain.prototype.add">module livescript.ast.Chain.prototype.add</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.add.add" id="apidoc.element.livescript.ast.Chain.prototype.add.add">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (it){
  var last, ref$, index, ref1$, bi, logics, call, f;
  if (this.tails.length) {
    last = (ref$ = this.tails)[ref$.length - 1];
    if (last instanceof Call &#x26;&#x26; ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 &#x26;&#x26; it.args.length === 1) {
      index = last.partialized[0].head.value;
      delete last.partialized;
      last.args[index] = it.args[0];
      return this;
    }
  }
  if (this.head instanceof Existence) {
    ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
    it.soak = true;
  }
  this.tails.push(it);
  bi = this.head instanceof Parens &#x26;&#x26; this.head.it instanceof Binary &#x26;&#x26; !this.head.it.partial
    ? this.head.it
    : this.head instanceof Binary &#x26;&#x26; !this.head.partial ? this.head : void 8;
  if (this.head instanceof Super) {
    if (!this.head.called &#x26;&#x26; it instanceof Call &#x26;&#x26; !it.method) {
      it.method = &#x27;.call&#x27;;
      it.args.unshift(Literal(&#x27;this&#x27;));
      this.head.called = true;
    } else if (!this.tails[1] &#x26;&#x26; ((ref1$ = it.key) != null ? ref1$.name : void 8) === &#x27;prototype&#x27;) {
      this.head.sproto = true;
    }
  } else if (it instanceof Call &#x26;&#x26; this.tails.length === 1 &#x26;&#x26; bi &#x26;&#x26; in$(bi.op, logics = [&#x27;&#x26;&#x26;&#x27;, &#x27;||&#x27;, &#x27;xor&#x27;])) {
    call = it;
    f = function(x, key){
      var y;
      y = x[key];
      if (y instanceof Binary &#x26;&#x26; in$(y.op, logics)) {
        f(y, &#x27;first&#x27;);
        return f(y, &#x27;second&#x27;);
      } else {
        return x[key] = Chain(y).autoCompare(call.args);
      }
    };
    f(bi, &#x27;first&#x27;);
    f(bi, &#x27;second&#x27;);
    return bi;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  items = this instanceof Arr
    ? (this.items[0] == null || this.items[1] == null &#x26;&#x26; this.carp(&#x27;must specify both key and value for object comprehension
&#x27;), this.items)
    : (kv = &#x27;keyValue$&#x27;, (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &#x3c; len$; ++i$) {
        i = i$;
        v = ref$[i$];
        results$.push(Chain(v).<span class="apidocCodeKeywordSpan">add</span>(Index(Literal(i))));
      }
      return results$;
    }.call(this)));
  return Assign(Chain(Var(ref)).add(Index(items[0], &#x27;.&#x27;, true)), items[1]);
} else if (ref) {
  return Call.make(JS(ref + &#x27;.push&#x27;), [this]);
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.assigns" id="apidoc.module.livescript.ast.Chain.prototype.assigns">module livescript.ast.Chain.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Chain.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.autoCompare" id="apidoc.module.livescript.ast.Chain.prototype.autoCompare">module livescript.ast.Chain.prototype.autoCompare</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare.autoCompare" id="apidoc.element.livescript.ast.Chain.prototype.autoCompare.autoCompare">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>autoCompare
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoCompare = function (target){
  var test;
  test = this.head;
  switch (false) {
  case !(test instanceof Literal):
    return Binary(&#x27;===&#x27;, test, target[0]);
  case !(test instanceof Unary &#x26;&#x26; test.it instanceof Literal):
    return Binary(&#x27;===&#x27;, test, target[0]);
  case !(test instanceof Arr || test instanceof Obj):
    return Binary(&#x27;====&#x27;, test, target[0]);
  case !(test instanceof Var &#x26;&#x26; test.value === &#x27;_&#x27;):
    return Literal(&#x27;true&#x27;);
  default:
    return this.add(Call(target)) || [];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  f = function(x, key){
    var y;
    y = x[key];
    if (y instanceof Binary &#x26;&#x26; in$(y.op, logics)) {
      f(y, &#x27;first&#x27;);
      return f(y, &#x27;second&#x27;);
    } else {
      return x[key] = Chain(y).<span class="apidocCodeKeywordSpan">autoCompare</span>(call.args);
    }
  };
  f(bi, &#x27;first&#x27;);
  f(bi, &#x27;second&#x27;);
  return bi;
}
return this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.cacheReference" id="apidoc.module.livescript.ast.Chain.prototype.cacheReference">module livescript.ast.Chain.prototype.cacheReference</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference.cacheReference" id="apidoc.element.livescript.ast.Chain.prototype.cacheReference.cacheReference">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>cacheReference
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cacheReference = function (o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.unwrap().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
    base = Chain(Assign(Var(ref), base));
    bref = (ref$ = Var(ref), ref$.temp = true, ref$);
  }
  if (!name) {
    return [base, bref];
  }
  if (name.isComplex()) {
    ref = o.scope.temporary(&#x27;key&#x27;);
    name = Index(Assign(Var(ref), name.key));
    nref = Index((ref$ = Var(ref), ref$.temp = true, ref$));
  }
  return [base.add(name), Chain(bref || base.head, [nref || name])];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = ref$[i$];
if (ref1$ = node.soak, delete node.soak, ref1$) {
  bust = Chain(this.head, this.tails.splice(0, i));
  if (node.assign &#x26;&#x26; !bust.isAssignable()) {
    node.carp(&#x27;invalid accessign&#x27;);
  }
  if (i &#x26;&#x26; (node.assign || node instanceof Call)) {
    ref1$ = bust.<span class="apidocCodeKeywordSpan">cacheReference</span>(o), test = ref1$[0], bust = ref1$[1];
    if (bust instanceof Chain) {
      (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
      bust = bust.head;
    }
    this.head = bust;
  } else {
    ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.compileNode" id="apidoc.module.livescript.ast.Chain.prototype.compileNode">module livescript.ast.Chain.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Chain.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
  if (this.flip) {
    util(&#x27;flip&#x27;);
    util(&#x27;curry&#x27;);
  }
  head = this.head, tails = this.tails;
  head.front = this.front;
  head.newed = this.newed;
  if (!tails.length) {
    return head.compile(o);
  }
  if (that = this.unfoldAssign(o)) {
    return that.compile(o);
  }
  for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
    t = tails[i$];
    if (t.partialized) {
      hasPartial = true;
      break;
    }
  }
  if (hasPartial) {
    util(&#x27;slice&#x27;);
    pre = [];
    rest = [];
    for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
      t = tails[i$];
      broken = broken || t.partialized != null;
      if (broken) {
        rest.push(t);
      } else {
        pre.push(t);
      }
    }
    if (rest != null) {
      partial = rest[0], post = slice$.call(rest, 1);
    }
    this.tails = pre;
    context = pre.length
      ? Chain(head, slice$.call(pre, 0, -1))
      : Literal(&#x27;this&#x27;);
    return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial
.partialized)])])), post).compile(o);
  }
  if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
    this.carp(&#x27;invalid callee&#x27;);
  }
  this.expandSlice(o);
  this.expandVivify();
  this.expandBind(o);
  this.expandSplat(o);
  this.expandStar(o);
  if (this.splattedNewArgs) {
    idt = o.indent + TAB;
    func = Chain(this.head, tails.slice(0, -1));
    return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22;var child = new ctor
, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
  }
  if (!this.tails.length) {
    return this.head.compile(o);
  }
  base = [this.head.compile(o, LEVEL_CALL)];
  news = [];
  rest = [];
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    t = ref$[i$];
    if (t[&#x27;new&#x27;]) {
      news.push(&#x27;new &#x27;);
    }
    rest.push(t.compile(o));
  }
  if (&#x27;.&#x27; === rest.join(&#x22;&#x22;).charAt(0) &#x26;&#x26; SIMPLENUM.test(base[0].toString())) {
    base.push(&#x27; &#x27;);
  }
  return sn.apply(null, [null].concat(slice$.call(news), slice$.call(base), slice$.call(rest)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.expandBind" id="apidoc.module.livescript.ast.Chain.prototype.expandBind">module livescript.ast.Chain.prototype.expandBind</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandBind.expandBind" id="apidoc.element.livescript.ast.Chain.prototype.expandBind.expandBind">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandBind
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandBind = function (o){
  var tails, i, that, obj, key, call;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.symbol !== &#x27;.~&#x27;) {
      continue;
    }
    that.symbol = &#x27;&#x27;;
    obj = Chain(this.head, tails.splice(0, i)).unwrap();
    key = tails.shift().key;
    call = Call.make(Util(&#x27;bind&#x27;), [obj, (key.reserved = true, key)]);
    this.head = this.newed ? Parens(call, true) : call;
    i = -1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.expandVivify();
this.<span class="apidocCodeKeywordSpan">expandBind</span>(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.expandSlice" id="apidoc.module.livescript.ast.Chain.prototype.expandSlice">module livescript.ast.Chain.prototype.expandSlice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice.expandSlice" id="apidoc.element.livescript.ast.Chain.prototype.expandSlice.expandSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSlice
        <span class="apidocSignatureSpan">(o, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandSlice = function (o, assign){
  var tails, i, tail, ref$, x;
  tails = this.tails;
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &#x26;&#x26; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp(&#x27;calling a slice&#x27;);
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? Chain(head, slice$.call(pre, 0, -1))
    : Literal(&#x27;this&#x27;);
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.<span class="apidocCodeKeywordSpan">expandSlice</span>(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.expandSplat" id="apidoc.module.livescript.ast.Chain.prototype.expandSplat">module livescript.ast.Chain.prototype.expandSplat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat.expandSplat" id="apidoc.element.livescript.ast.Chain.prototype.expandSplat.expandSplat">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSplat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandSplat = function (o){
  var tails, i, call, args, ctx, ref$;
  tails = this.tails;
  i = -1;
  while (call = tails[++i]) {
    if (!(args = call.args)) {
      continue;
    }
    ctx = call.method === &#x27;.call&#x27; &#x26;&#x26; (args = args.concat()).shift();
    if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
      continue;
    }
    if (call[&#x27;new&#x27;]) {
      this.splattedNewArgs = args;
    } else {
      if (!ctx &#x26;&#x26; tails[i - 1] instanceof Index) {
        ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
        i = 0;
      }
      call.method = &#x27;.apply&#x27;;
      call.args = [ctx || Literal(&#x27;null&#x27;), JS(args)];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.expandVivify();
this.expandBind(o);
this.<span class="apidocCodeKeywordSpan">expandSplat</span>(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
}
if (!this.tails.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.expandStar" id="apidoc.module.livescript.ast.Chain.prototype.expandStar">module livescript.ast.Chain.prototype.expandStar</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandStar.expandStar" id="apidoc.element.livescript.ast.Chain.prototype.expandStar.expandStar">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandStar
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandStar = function (o){
  var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.args || that.stars || that.key instanceof Key) {
      continue;
    }
    stars = that.stars = [];
    that.eachChild(seek);
    if (!stars.length) {
      continue;
    }
    ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
    value = Chain(ref, [Index(Key(&#x27;length&#x27;))]).compile(o);
    for (i$ = 0, len$ = stars.length; i$ &#x3c; len$; ++i$) {
      star = stars[i$];
      star.value = value;
      star.isAssignable = YES;
    }
    this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
    if (temps) {
      o.scope.free(temps[0]);
    }
    i = -1;
  }
  function seek(it){
    if (it.value === &#x27;*&#x27;) {
      stars.push(it);
    } else if (!(it instanceof Index)) {
      it.eachChild(seek);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.<span class="apidocCodeKeywordSpan">expandStar</span>(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
}
if (!this.tails.length) {
  return this.head.compile(o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.expandVivify" id="apidoc.module.livescript.ast.Chain.prototype.expandVivify">module livescript.ast.Chain.prototype.expandVivify</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify.expandVivify" id="apidoc.element.livescript.ast.Chain.prototype.expandVivify.expandVivify">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandVivify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandVivify = function (){
  var tails, i, that, ref$, ref1$;
  tails = this.tails;
  i = 0;
  while (i &#x3c; tails.length) {
    if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
      this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), &#x27;=&#x27;, &#x27;||&#x27;);
      i = 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    : Literal(&#x27;this&#x27;);
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.<span class="apidocCodeKeywordSpan">expandVivify</span>();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.flipIt" id="apidoc.module.livescript.ast.Chain.prototype.flipIt">module livescript.ast.Chain.prototype.flipIt</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.flipIt.flipIt" id="apidoc.element.livescript.ast.Chain.prototype.flipIt.flipIt">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>flipIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flipIt = function (){
  this.flip = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 26:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 28:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var(&#x27;flip$&#x27;))).add(yy.L(_$[$0-3],_$[$0-3],yy
.Call([$$[$0-3]])))).<span class="apidocCodeKeywordSpan">flipIt</span>().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 29:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.For({
from: $$[$0-3],
op: $$[$0-2],
to: $$[$0-1],
inComprehension: true
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.getCall" id="apidoc.module.livescript.ast.Chain.prototype.getCall">module livescript.ast.Chain.prototype.getCall</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getCall.getCall" id="apidoc.element.livescript.ast.Chain.prototype.getCall.getCall">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCall = function (){
  var tail, ref$;
  return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call &#x26;&#x26; tail;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fun.name = node.label;
  fun.labeled = true;
  node = node.it;
}
if (!fun.hushed &#x26;&#x26; (fun.hushed = node.op === &#x27;!&#x27;)) {
  node = node.it;
}
if ((ref$ = node.<span class="apidocCodeKeywordSpan">getCall</span>()) != null) {
  ref$.partialized = null;
}
args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
index = 0;
for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
  a = args[i$];
  if (a.placeholder) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.getJump" id="apidoc.module.livescript.ast.Chain.prototype.getJump">module livescript.ast.Chain.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Chain.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isArray" id="apidoc.module.livescript.ast.Chain.prototype.isArray">module livescript.ast.Chain.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Chain.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.isArray();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isAssignable" id="apidoc.module.livescript.ast.Chain.prototype.isAssignable">module livescript.ast.Chain.prototype.isAssignable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable.isAssignable" id="apidoc.element.livescript.ast.Chain.prototype.isAssignable.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAssignable = function (){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.isAssignable();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isCallable" id="apidoc.module.livescript.ast.Chain.prototype.isCallable">module livescript.ast.Chain.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Chain.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return !((ref$ = that.key) != null &#x26;&#x26; ref$.items);
  } else {
    return this.head.isCallable();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isComplex" id="apidoc.module.livescript.ast.Chain.prototype.isComplex">module livescript.ast.Chain.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Chain.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.tails.length || this.head.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isRegex" id="apidoc.module.livescript.ast.Chain.prototype.isRegex">module livescript.ast.Chain.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Chain.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isSimpleAccess" id="apidoc.module.livescript.ast.Chain.prototype.isSimpleAccess">module livescript.ast.Chain.prototype.isSimpleAccess</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess.isSimpleAccess" id="apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess.isSimpleAccess">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isSimpleAccess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSimpleAccess = function (){
  return this.tails.length === 1 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !this.tails[0].isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    dotSplit = name.toString().split(&#x27;.&#x27;);
    if (protoSplit.length &#x3e; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &#x3e; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join(&#x27;&#x27;);
    }
  }
  code = !o.level &#x26;&#x26; right instanceof While &#x26;&#x26; !right[&#x27;else&#x27;] &#x26;&#x26; (lvar || left instanceof
 Chain &#x26;&#x26; left.<span class="apidocCodeKeywordSpan">isSimpleAccess</span>())
    ? (empty = right.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;, [res = o.scope.temporary(&#x27;res&#x27;), &#x22; = &#x22; + empty
 + &#x22;;\n&#x22; + this.tab, right.makeReturn(res).compile(o), &#x22;\n&#x22; + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &#x3e; LEVEL_LIST) {
    code = [&#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isStatement" id="apidoc.module.livescript.ast.Chain.prototype.isStatement">module livescript.ast.Chain.prototype.isStatement</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isStatement.isStatement" id="apidoc.element.livescript.ast.Chain.prototype.isStatement.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isStatement
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStatement = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isString" id="apidoc.module.livescript.ast.Chain.prototype.isString">module livescript.ast.Chain.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isString.isString" id="apidoc.element.livescript.ast.Chain.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.makeReturn" id="apidoc.module.livescript.ast.Chain.prototype.makeReturn">module livescript.ast.Chain.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Chain.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  if (this.tails.length) {
    return superclass.prototype.makeReturn.apply(this, arguments);
  } else {
    return (ref$ = this.head).makeReturn.apply(ref$, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.unfoldAssign" id="apidoc.module.livescript.ast.Chain.prototype.unfoldAssign">module livescript.ast.Chain.prototype.unfoldAssign</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign.unfoldAssign" id="apidoc.element.livescript.ast.Chain.prototype.unfoldAssign.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldAssign = function (o){
  var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
  if (that = this.head.unfoldAssign(o)) {
    (ref$ = that.right.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    index = ref$[i$];
    if (op = index.assign) {
      index.assign = &#x27;&#x27;;
      left = Chain(this.head, this.tails.splice(0, i)).expandSlice(o).unwrap();
      if (left instanceof Arr) {
        lefts = left.items;
        rites = (this.head = Arr()).items;
        for (j$ = 0, len1$ = lefts.length; j$ &#x3c; len1$; ++j$) {
          i = j$;
          node = lefts[j$];
          ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
        }
      } else {
        ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
      }
      if (op === &#x27;=&#x27;) {
        op = &#x27;:=&#x27;;
      }
      return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.unfoldSoak" id="apidoc.module.livescript.ast.Chain.prototype.unfoldSoak">module livescript.ast.Chain.prototype.unfoldSoak</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak.unfoldSoak" id="apidoc.element.livescript.ast.Chain.prototype.unfoldSoak.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var that, ref$, i$, len$, i, node, ref1$, bust, test;
  if (that = this.head.unfoldSoak(o)) {
    (ref$ = that.then.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = ref$[i$];
    if (ref1$ = node.soak, delete node.soak, ref1$) {
      bust = Chain(this.head, this.tails.splice(0, i));
      if (node.assign &#x26;&#x26; !bust.isAssignable()) {
        node.carp(&#x27;invalid accessign&#x27;);
      }
      if (i &#x26;&#x26; (node.assign || node instanceof Call)) {
        ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
        if (bust instanceof Chain) {
          (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
          bust = bust.head;
        }
        this.head = bust;
      } else {
        ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
      }
      test = node instanceof Call
        ? JS(&#x22;typeof &#x22; + test.compile(o, LEVEL_OP) + &#x22; == &#x27;function&#x27;&#x22;)
        : Existence(test);
      return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.unwrap" id="apidoc.module.livescript.ast.Chain.prototype.unwrap">module livescript.ast.Chain.prototype.unwrap</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unwrap.unwrap" id="apidoc.element.livescript.ast.Chain.prototype.unwrap.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (){
  if (this.tails.length) {
    return this;
  } else {
    return this.head;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.varName" id="apidoc.module.livescript.ast.Chain.prototype.varName">module livescript.ast.Chain.prototype.varName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.varName.varName" id="apidoc.element.livescript.ast.Chain.prototype.varName.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Class" id="apidoc.module.livescript.ast.Class">module livescript.ast.Class</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Class.Class" id="apidoc.element.livescript.ast.Class.Class">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Class
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 139:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.Try($$[$0-5], $$[$0-3], yy.L(_$[$0-4],_$[$0-3], $$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 140:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 141:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Class</span>({
        title: $$[$0-3].unwrap(),
        sup: $$[$0-2],
        mixins: $$[$0-1],
        body: $$[$0]
      }));
break;
case 142:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.superclass" id="apidoc.element.livescript.ast.Class.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Class.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Class.prototype" id="apidoc.module.livescript.ast.Class.prototype">module livescript.ast.Class.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.compile" id="apidoc.element.livescript.ast.Class.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj
, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
  fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
  CopyL(this, fun);
  boundFuncs = [];
  curriedBoundFuncs = [];
  decl = title != null ? title.varName() : void 8;
  name = decl || this.name;
  if (ID.test(name || &#x27;&#x27;)) {
    fun.cname = name;
  } else {
    name = &#x27;constructor&#x27;;
  }
  proto = Var(&#x27;prototype&#x27;);
  vname = fun.proto = Var(fun.bound = name);
  ctorName = &#x27;constructor$$&#x27;;
  importProtoObj = function(node, i){
    var j, prop, key, i$, ref$, len$, v;
    j = 0;
    for (; j &#x3c; node.items.length; j++) {
      prop = node.items[j];
      key = prop.key;
      if ((key instanceof Key &#x26;&#x26; key.name === ctorName) || (key instanceof Literal &#x26;&#x26; key.value === &#x22;&#x27;&#x22; + ctorName + &#x22;&#x27;&#x22;)) {
        if (ctor) {
          node.carp(&#x27;redundant constructor&#x27;);
        }
        ctor = prop.val;
        node.items.splice(j--, 1);
        ctorPlace = i;
      }
      if (!(prop.val instanceof Fun || prop.accessor)) {
        continue;
      }
      if (key.isComplex()) {
        key = Var(o.scope.temporary(&#x27;key&#x27;));
        prop.key = Assign(key, prop.key);
      }
      if (prop.val.bound) {
        if (prop.val.curried) {
          curriedBoundFuncs.push(prop.key);
        } else {
          boundFuncs.push(prop.key);
        }
        prop.val.bound = false;
        prop.val.classBound = true;
      }
      for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ &#x3c; len$; ++i$) {
        v = ref$[i$];
        v.meth = key;
      }
    }
    if (node.items.length) {
      return ref$ = Import(Chain(vname).add(Index(Key(&#x27;prototype&#x27;))), node), ref$.proto = true, ref$;
    } else {
      return Literal(&#x27;void&#x27;);
    }
  };
  for (i$ = 0, len$ = lines.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = lines[i$];
    if (node instanceof Obj) {
      lines[i] = importProtoObj(node, i);
    } else if (node instanceof Fun &#x26;&#x26; !node.statement) {
      ctor &#x26;&#x26; node.carp(&#x27;redundant constructor&#x27;);
      ctor = node;
    } else if (node instanceof Assign &#x26;&#x26; node.left instanceof Chain &#x26;&#x26; node.left.head.value === &#x27;this&#x27; &#x26;&#x26; node.right instanceof
Fun) {
      node.right.stat = node.left.tails[0].key;
    } else {
      node.traverseChildren(fn$);
    }
  }
  ctor || (ctor = lines[lines.length] = this.sup
    ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal(&#x27;arguments&#x27;))]))))
    : Fun());
  if (!(ctor instanceof Fun)) {
    lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
    lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat(&#x27;arguments&#x27;, true)]))))));
  }
  ctor.name = name;
  ctor.ctor = true;
  ctor.statement = true;
  for (i$ = 0, len$ = boundFuncs.length; i$ &#x3c; len$; ++i$) {
    f = boundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(f)), Chain(Var(util(&#x27;bind&#x27;))).add(Call([Literal(&#x27;this&#x27;), Literal
(&#x22;&#x27;&#x22; + f.name + &#x22;&#x27;&#x22;), Var(&#x27;prototype&#x27;)]))));
  }
  for (i$ = 0, len$ = curriedBoundFuncs.length; i$ &#x3c; len$; ++i$) {
    f = curriedBoundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(Key(&#x22;_&#x22; + f.name))), Chain(Var(util(&#x27;curry&#x27;))).add(Call([Chain
(Var(&#x27;prototype&#x27;)).add(Index(f)), Var(&#x27;true&#x27;)]))), Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(f)), Chain(Var(util(&#x27;bind&#x27;))).add(Call
([Literal(&#x27;this&#x27;), Literal(&#x22;&#x27;_&#x22; + f.name + &#x22;&#x27;&#x22;)]))));
  }
  lines.push(vname);
  args = [];
  if (that = this.sup) {
    args.push(that);
    imports = Chain(Import(Literal(&#x27;this&#x27;), Var(&#x27;superclass&#x27;)));
    fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key(&#x27;displayName&#x27;))), Literal(&#x22;&#x27;&#x22; + name + &#x22;&#x27;&#x22;)), Literal
(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var(&#x27;superclass&#x27;));
  }
  if (that = this.mixins) {
    res$ = [];
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      args[args.length] = that[i$];
      res$.push(Import(proto, JS(&#x22;arguments[&#x22; + (args.length - 1) + &#x22;]&#x22;), true));
    }
    import ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.constructor" id="apidoc.element.livescript.ast.Class.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>constructor
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.isCallable" id="apidoc.element.livescript.ast.Class.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.ripName" id="apidoc.element.livescript.ast.Class.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripName = function (it){
  this.name = it.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Class.prototype.compile" id="apidoc.module.livescript.ast.Class.prototype.compile">module livescript.ast.Class.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.compile.compile" id="apidoc.element.livescript.ast.Class.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj
, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
  fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
  CopyL(this, fun);
  boundFuncs = [];
  curriedBoundFuncs = [];
  decl = title != null ? title.varName() : void 8;
  name = decl || this.name;
  if (ID.test(name || &#x27;&#x27;)) {
    fun.cname = name;
  } else {
    name = &#x27;constructor&#x27;;
  }
  proto = Var(&#x27;prototype&#x27;);
  vname = fun.proto = Var(fun.bound = name);
  ctorName = &#x27;constructor$$&#x27;;
  importProtoObj = function(node, i){
    var j, prop, key, i$, ref$, len$, v;
    j = 0;
    for (; j &#x3c; node.items.length; j++) {
      prop = node.items[j];
      key = prop.key;
      if ((key instanceof Key &#x26;&#x26; key.name === ctorName) || (key instanceof Literal &#x26;&#x26; key.value === &#x22;&#x27;&#x22; + ctorName + &#x22;&#x27;&#x22;)) {
        if (ctor) {
          node.carp(&#x27;redundant constructor&#x27;);
        }
        ctor = prop.val;
        node.items.splice(j--, 1);
        ctorPlace = i;
      }
      if (!(prop.val instanceof Fun || prop.accessor)) {
        continue;
      }
      if (key.isComplex()) {
        key = Var(o.scope.temporary(&#x27;key&#x27;));
        prop.key = Assign(key, prop.key);
      }
      if (prop.val.bound) {
        if (prop.val.curried) {
          curriedBoundFuncs.push(prop.key);
        } else {
          boundFuncs.push(prop.key);
        }
        prop.val.bound = false;
        prop.val.classBound = true;
      }
      for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ &#x3c; len$; ++i$) {
        v = ref$[i$];
        v.meth = key;
      }
    }
    if (node.items.length) {
      return ref$ = Import(Chain(vname).add(Index(Key(&#x27;prototype&#x27;))), node), ref$.proto = true, ref$;
    } else {
      return Literal(&#x27;void&#x27;);
    }
  };
  for (i$ = 0, len$ = lines.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = lines[i$];
    if (node instanceof Obj) {
      lines[i] = importProtoObj(node, i);
    } else if (node instanceof Fun &#x26;&#x26; !node.statement) {
      ctor &#x26;&#x26; node.carp(&#x27;redundant constructor&#x27;);
      ctor = node;
    } else if (node instanceof Assign &#x26;&#x26; node.left instanceof Chain &#x26;&#x26; node.left.head.value === &#x27;this&#x27; &#x26;&#x26; node.right instanceof
Fun) {
      node.right.stat = node.left.tails[0].key;
    } else {
      node.traverseChildren(fn$);
    }
  }
  ctor || (ctor = lines[lines.length] = this.sup
    ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal(&#x27;arguments&#x27;))]))))
    : Fun());
  if (!(ctor instanceof Fun)) {
    lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
    lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat(&#x27;arguments&#x27;, true)]))))));
  }
  ctor.name = name;
  ctor.ctor = true;
  ctor.statement = true;
  for (i$ = 0, len$ = boundFuncs.length; i$ &#x3c; len$; ++i$) {
    f = boundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(f)), Chain(Var(util(&#x27;bind&#x27;))).add(Call([Literal(&#x27;this&#x27;), Literal
(&#x22;&#x27;&#x22; + f.name + &#x22;&#x27;&#x22;), Var(&#x27;prototype&#x27;)]))));
  }
  for (i$ = 0, len$ = curriedBoundFuncs.length; i$ &#x3c; len$; ++i$) {
    f = curriedBoundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(Key(&#x22;_&#x22; + f.name))), Chain(Var(util(&#x27;curry&#x27;))).add(Call([Chain
(Var(&#x27;prototype&#x27;)).add(Index(f)), Var(&#x27;true&#x27;)]))), Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(f)), Chain(Var(util(&#x27;bind&#x27;))).add(Call
([Literal(&#x27;this&#x27;), Literal(&#x22;&#x27;_&#x22; + f.name + &#x22;&#x27;&#x22;)]))));
  }
  lines.push(vname);
  args = [];
  if (that = this.sup) {
    args.push(that);
    imports = Chain(Import(Literal(&#x27;this&#x27;), Var(&#x27;superclass&#x27;)));
    fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key(&#x27;displayName&#x27;))), Literal(&#x22;&#x27;&#x22; + name + &#x22;&#x27;&#x22;)), Literal
(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var(&#x27;superclass&#x27;));
  }
  if (that = this.mixins) {
    res$ = [];
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      args[args.length] = that[i$];
      res$.push(Import(proto, JS(&#x22;arguments[&#x22; + (args.length - 1) + &#x22;]&#x22;), true));
    }
    import ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Class.prototype.ripName" id="apidoc.module.livescript.ast.Class.prototype.ripName">module livescript.ast.Class.prototype.ripName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.ripName.ripName" id="apidoc.element.livescript.ast.Class.prototype.ripName.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripName = function (it){
  this.name = it.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.CopyL" id="apidoc.module.livescript.ast.CopyL">module livescript.ast.CopyL</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.CopyL.CopyL" id="apidoc.element.livescript.ast.CopyL.CopyL">
        function <span class="apidocSignatureSpan">livescript.ast.</span>CopyL
        <span class="apidocSignatureSpan">(a, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CopyL = function (a, node){
  if (node &#x26;&#x26; typeof node === &#x22;object&#x22;) {
    node.first_line = a.first_line;
    node.first_column = a.first_column;
    node.last_line = a.last_line;
    node.last_column = a.last_column;
    node.line = a.line;
    node.column = a.column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Decl" id="apidoc.module.livescript.ast.Decl">module livescript.ast.Decl</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Decl.Decl" id="apidoc.element.livescript.ast.Decl.Decl">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Decl
        <span class="apidocSignatureSpan">(type, nodes, lno)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decl = function (type, nodes, lno){
  if (!nodes[0]) {
    throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
  }
  return DECLS[type](nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.<span class="apidocCodeKeywordSpan">Decl</span>($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27;arguments&#x27; &#x26;&#x26; $$[$0] !== &#
x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence" id="apidoc.module.livescript.ast.Existence">module livescript.ast.Existence</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.Existence" id="apidoc.element.livescript.ast.Existence.Existence">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Existence</span>($$[$0-1].unwrap
()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call[&#x27;let&#x27;]($$[$0-3], $$[$0]))));
break;
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.superclass" id="apidoc.element.livescript.ast.Existence.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence.prototype" id="apidoc.module.livescript.ast.Existence.prototype">module livescript.ast.Existence.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.compileNode" id="apidoc.element.livescript.ast.Existence.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var node, ref$, code, op, eq;
  node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
  code = [node.compile(o, LEVEL_OP + PREC[&#x27;==&#x27;])];
  if (node instanceof Var &#x26;&#x26; !o.scope.check(code.join(&#x22;&#x22;), true)) {
    ref$ = this.negated
      ? [&#x27;||&#x27;, &#x27;=&#x27;]
      : [&#x27;&#x26;&#x26;&#x27;, &#x27;!&#x27;], op = ref$[0], eq = ref$[1];
    code = [&#x22;typeof &#x22;].concat(slice$.call(code), [&#x22; &#x22; + eq + &#x22;= &#x27;undefined&#x27; &#x22; + op + &#x22; &#x22;], slice$.call(code), [&#x22; &#x22; + eq + &#x22;== null
&#x22;]);
  } else {
    code.push(&#x22; &#x22; + (op = this.negated ? &#x27;==&#x27; : &#x27;!=&#x27;) + &#x22; null&#x22;);
  }
  if (o.level &#x3c; LEVEL_OP + PREC[op]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn(this, &#x22;(&#x22;, code, &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.constructor" id="apidoc.element.livescript.ast.Existence.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.invert" id="apidoc.element.livescript.ast.Existence.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  this.negated = !this.negated;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.show" id="apidoc.element.livescript.ast.Existence.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.negated &#x26;&#x26; &#x27;!&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence.prototype.compileNode" id="apidoc.module.livescript.ast.Existence.prototype.compileNode">module livescript.ast.Existence.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Existence.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var node, ref$, code, op, eq;
  node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
  code = [node.compile(o, LEVEL_OP + PREC[&#x27;==&#x27;])];
  if (node instanceof Var &#x26;&#x26; !o.scope.check(code.join(&#x22;&#x22;), true)) {
    ref$ = this.negated
      ? [&#x27;||&#x27;, &#x27;=&#x27;]
      : [&#x27;&#x26;&#x26;&#x27;, &#x27;!&#x27;], op = ref$[0], eq = ref$[1];
    code = [&#x22;typeof &#x22;].concat(slice$.call(code), [&#x22; &#x22; + eq + &#x22;= &#x27;undefined&#x27; &#x22; + op + &#x22; &#x22;], slice$.call(code), [&#x22; &#x22; + eq + &#x22;== null
&#x22;]);
  } else {
    code.push(&#x22; &#x22; + (op = this.negated ? &#x27;==&#x27; : &#x27;!=&#x27;) + &#x22; null&#x22;);
  }
  if (o.level &#x3c; LEVEL_OP + PREC[op]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn(this, &#x22;(&#x22;, code, &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence.prototype.invert" id="apidoc.module.livescript.ast.Existence.prototype.invert">module livescript.ast.Existence.prototype.invert</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.invert.invert" id="apidoc.element.livescript.ast.Existence.prototype.invert.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  this.negated = !this.negated;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence.prototype.show" id="apidoc.module.livescript.ast.Existence.prototype.show">module livescript.ast.Existence.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.show.show" id="apidoc.element.livescript.ast.Existence.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.negated &#x26;&#x26; &#x27;!&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For" id="apidoc.module.livescript.ast.For">module livescript.ast.For</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.For" id="apidoc.element.livescript.ast.For.For">
        function <span class="apidocSignatureSpan">livescript.ast.</span>For
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &#x26;&#x26; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &#x3c; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &#x26;&#x26; !this.object) {
    this.carp(&#x27;`for own` requires `of`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 28:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var(&#x27;flip$&#x27;))).add(yy.L(_$[$0-3],_$[$0-3],yy
.Call([$$[$0-3]])))).flipIt().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 29:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">For</span>({
        from: $$[$0-3],
        op: $$[$0-2],
        to: $$[$0-1],
        inComprehension: true
      }))));
break;
case 30:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.superclass" id="apidoc.element.livescript.ast.For.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.For.</span>superclass
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &#x26;&#x26; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== &#x27;&#x27; + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For.prototype" id="apidoc.module.livescript.ast.For.prototype">module livescript.ast.For.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.addBody" id="apidoc.element.livescript.ast.For.prototype.addBody">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBody = function (body){
  var hasYield, ref$, x$, that, this$ = this;
  hasYield = !!body.traverseChildren(function(child){
    if (child instanceof Yield) {
      return true;
    }
  });
  if (this[&#x27;let&#x27;]) {
    if (ref$ = this.ref, delete this.ref, ref$) {
      this.item = Literal(&#x27;..&#x27;);
    }
    body = Block(Call[&#x27;let&#x27;]((x$ = [], (that = this.index) &#x26;&#x26; x$.push(Assign(Var(that), Literal(&#x27;index$$&#x27;))), (that = this.item) &#x26;&#x26;
x$.push(Assign(that, Literal(&#x27;item$$&#x27;))), x$), body, hasYield));
  }
  superclass.prototype.addBody.call(this, body);
  if (this.guard &#x26;&#x26; this[&#x27;let&#x27;] &#x26;&#x26; (this.index || this.item)) {
    this.body.lines[0][&#x27;if&#x27;].traverseChildren(function(it){
      if (it instanceof Var) {
        if (this$.index &#x26;&#x26; it.value === this$.index) {
          it.value = &#x27;index$$&#x27;;
        }
        if (this$.item &#x26;&#x26; it.value === this$.item.value) {
          it.value = &#x27;item$$&#x27;;
        }
      }
    });
  }
  if (this[&#x27;let&#x27;]) {
    if (hasYield) {
      this.body = Block(Yield(&#x27;yieldfrom&#x27;, body));
    }
    delete this.index;
    delete this.item;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
While.prototype.show = function(){
  return [this.un ? &#x27;!&#x27; : void 8, this.post ? &#x27;do&#x27; : void 8].join(&#x27;&#x27;);
};
prototype.isStatement = prototype.isArray = YES;
While.prototype.makeComprehension = function(toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().<span class="apidocCodeKeywordSpan">addBody</span>(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
};
While.prototype.getJump = function(ctx){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.compileNode" id="apidoc.element.livescript.ast.For.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
  o.loop = true;
  temps = this.temps = [];
  if (this.object &#x26;&#x26; this.index) {
    o.scope.declare(idx = this.index);
  } else {
    temps.push(idx = o.scope.temporary(&#x27;i&#x27;));
  }
  if (!this.body) {
    this.addBody(Block(Var(idx)));
  }
  if (!this.object) {
    ref$ = (this.step || Literal(1)).compileLoopReference(o, &#x27;step&#x27;), pvar = ref$[0], step = ref$[1];
    pvar === step || temps.push(pvar);
  }
  if (this.from) {
    if (this.ref) {
      this.item = Var(idx);
    }
    ref$ = this.to.compileLoopReference(o, &#x27;to&#x27;), tvar = ref$[0], tail = ref$[1];
    fvar = this.from.compile(o, LEVEL_LIST);
    vars = idx + &#x22; = &#x22; + fvar;
    if (tail !== tvar) {
      vars += &#x22;, &#x22; + tail;
      temps.push(tvar);
    }
    if (!this.step &#x26;&#x26; +fvar &#x3e; +tvar) {
      pvar = step = -1;
    }
    eq = this.op === &#x27;til&#x27; ? &#x27;&#x27; : &#x27;=&#x27;;
    cond = +pvar
      ? idx + &#x22; &#x22; + &#x27;&#x3c;&#x3e;&#x27;.charAt(pvar &#x3c; 0) + eq + &#x22; &#x22; + tvar
      : pvar + &#x22; &#x3c; 0 ? &#x22; + idx + &#x22; &#x3e;&#x22; + eq + &#x22; &#x22; + tvar + &#x22; : &#x22; + idx + &#x22; &#x3c;&#x22; + eq + &#x22; &#x22; + tvar;
  } else {
    if (this.ref) {
      this.item = Var(o.scope.temporary(&#x27;x&#x27;));
    }
    if (this.item || this.object &#x26;&#x26; this.own || this[&#x27;let&#x27;]) {
      ref$ = this.source.compileLoopReference(o, &#x27;ref&#x27;, !this.object, true), svar = ref$[0], srcPart = ref$[1];
      svar === srcPart || temps.push(svar);
    } else {
      svar = srcPart = this.source.compile(o, LEVEL_PAREN);
    }
    if (!this.object) {
      if (0 &#x3e; pvar &#x26;&#x26; ~~pvar === +pvar) {
        vars = idx + &#x22; = &#x22; + srcPart + &#x22;.length - 1&#x22;;
        cond = idx + &#x22; &#x3e;= 0&#x22;;
      } else {
        temps.push(lvar = o.scope.temporary(&#x27;len&#x27;));
        vars = idx + &#x22; = 0, &#x22; + lvar + &#x22; = &#x22; + srcPart + &#x22;.length&#x22;;
        cond = idx + &#x22; &#x3c; &#x22; + lvar;
      }
    }
  }
  this[&#x27;else&#x27;] &#x26;&#x26; (this.yet = o.scope.temporary(&#x27;yet&#x27;));
  head = [sn(this, &#x27;for (&#x27;)];
  if (this.object) {
    head.push(idx, &#x22; in &#x22;);
  }
  if (that = this.yet) {
    head.push(that, &#x22; = true, &#x22;);
  }
  if (this.object) {
    head.push(srcPart);
  } else {
    step === pvar || (vars += &#x27;, &#x27; + step);
    head.push(vars, &#x22;; &#x22;, cond, &#x22;; &#x22; + (1 == Math.abs(pvar)
      ? (pvar &#x3c; 0 ? &#x27;--&#x27; : &#x27;++&#x27;) + idx
      : idx + (pvar &#x3c; 0
        ? &#x27; -= &#x27; + pvar.toString().slice(1)
        : &#x27; += &#x27; + pvar)));
  }
  this.own &#x26;&#x26; head.push(sn(this, &#x22;) if (&#x22;), o.scope.assign(&#x27;own$&#x27;, &#x27;{}.hasOwnProperty&#x27;), &#x22;.call(&#x22;, svar, &#x22;, &#x22;, idx, &#x22;)&#x22;);
  head.push(sn(this, &#x27;) {&#x27;));
  if (this[&#x27;let&#x27;]) {
    this.body.traverseChildren(function(it){
      switch (it.value) {
      case &#x27;index$$&#x27;:
        it.value = idx;
        break;
      case &#x27;item$$&#x27;:
        it.value = svar + &#x22;[&#x22; + idx + &#x22;]&#x22;;
      }
    });
  }
  o.indent += TAB;
  if (this.index &#x26;&#x26; !this.object) {
    head.push(&#x27;\n&#x27; + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), &#x27;;&#x27;);
  }
  if (this.item &#x26;&#x26; !this.item.isEmpty() &#x26;&#x26; !this.from) {
    head.push(&#x27;\n&#x27; + o.indent, Assign(this.item, JS(svar + &#x22;[&#x22; + idx + &#x22;]&#x22;)).compile(o, LEVEL_TOP), &#x27;;&#x27;);
  }
  if (this.ref) {
    o.ref = this.item.value;
  }
  body = this.compileBody(o);
  if ((this.item || (this.index &#x26;&#x26; !this.object)) &#x26;&#x26; &#x27;}&#x27; === body.toString().charAt(0)) {
    head.push(&#x27;\n&#x27; + this.tab);
  }
  return sn.apply(null, [null].concat(slice$.call(head), [body]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.constructor" id="apidoc.element.livescript.ast.For.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &#x26;&#x26; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &#x3c; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &#x26;&#x26; !this.object) {
    this.carp(&#x27;`for own` requires `of`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.show" id="apidoc.element.livescript.ast.For.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return ((this.kind || []).concat(this.index)).join(&#x27; &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For.prototype.addBody" id="apidoc.module.livescript.ast.For.prototype.addBody">module livescript.ast.For.prototype.addBody</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.addBody.addBody" id="apidoc.element.livescript.ast.For.prototype.addBody.addBody">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBody = function (body){
  var hasYield, ref$, x$, that, this$ = this;
  hasYield = !!body.traverseChildren(function(child){
    if (child instanceof Yield) {
      return true;
    }
  });
  if (this[&#x27;let&#x27;]) {
    if (ref$ = this.ref, delete this.ref, ref$) {
      this.item = Literal(&#x27;..&#x27;);
    }
    body = Block(Call[&#x27;let&#x27;]((x$ = [], (that = this.index) &#x26;&#x26; x$.push(Assign(Var(that), Literal(&#x27;index$$&#x27;))), (that = this.item) &#x26;&#x26;
x$.push(Assign(that, Literal(&#x27;item$$&#x27;))), x$), body, hasYield));
  }
  superclass.prototype.addBody.call(this, body);
  if (this.guard &#x26;&#x26; this[&#x27;let&#x27;] &#x26;&#x26; (this.index || this.item)) {
    this.body.lines[0][&#x27;if&#x27;].traverseChildren(function(it){
      if (it instanceof Var) {
        if (this$.index &#x26;&#x26; it.value === this$.index) {
          it.value = &#x27;index$$&#x27;;
        }
        if (this$.item &#x26;&#x26; it.value === this$.item.value) {
          it.value = &#x27;item$$&#x27;;
        }
      }
    });
  }
  if (this[&#x27;let&#x27;]) {
    if (hasYield) {
      this.body = Block(Yield(&#x27;yieldfrom&#x27;, body));
    }
    delete this.index;
    delete this.item;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
While.prototype.show = function(){
  return [this.un ? &#x27;!&#x27; : void 8, this.post ? &#x27;do&#x27; : void 8].join(&#x27;&#x27;);
};
prototype.isStatement = prototype.isArray = YES;
While.prototype.makeComprehension = function(toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().<span class="apidocCodeKeywordSpan">addBody</span>(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
};
While.prototype.getJump = function(ctx){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For.prototype.compileNode" id="apidoc.module.livescript.ast.For.prototype.compileNode">module livescript.ast.For.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.For.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
  o.loop = true;
  temps = this.temps = [];
  if (this.object &#x26;&#x26; this.index) {
    o.scope.declare(idx = this.index);
  } else {
    temps.push(idx = o.scope.temporary(&#x27;i&#x27;));
  }
  if (!this.body) {
    this.addBody(Block(Var(idx)));
  }
  if (!this.object) {
    ref$ = (this.step || Literal(1)).compileLoopReference(o, &#x27;step&#x27;), pvar = ref$[0], step = ref$[1];
    pvar === step || temps.push(pvar);
  }
  if (this.from) {
    if (this.ref) {
      this.item = Var(idx);
    }
    ref$ = this.to.compileLoopReference(o, &#x27;to&#x27;), tvar = ref$[0], tail = ref$[1];
    fvar = this.from.compile(o, LEVEL_LIST);
    vars = idx + &#x22; = &#x22; + fvar;
    if (tail !== tvar) {
      vars += &#x22;, &#x22; + tail;
      temps.push(tvar);
    }
    if (!this.step &#x26;&#x26; +fvar &#x3e; +tvar) {
      pvar = step = -1;
    }
    eq = this.op === &#x27;til&#x27; ? &#x27;&#x27; : &#x27;=&#x27;;
    cond = +pvar
      ? idx + &#x22; &#x22; + &#x27;&#x3c;&#x3e;&#x27;.charAt(pvar &#x3c; 0) + eq + &#x22; &#x22; + tvar
      : pvar + &#x22; &#x3c; 0 ? &#x22; + idx + &#x22; &#x3e;&#x22; + eq + &#x22; &#x22; + tvar + &#x22; : &#x22; + idx + &#x22; &#x3c;&#x22; + eq + &#x22; &#x22; + tvar;
  } else {
    if (this.ref) {
      this.item = Var(o.scope.temporary(&#x27;x&#x27;));
    }
    if (this.item || this.object &#x26;&#x26; this.own || this[&#x27;let&#x27;]) {
      ref$ = this.source.compileLoopReference(o, &#x27;ref&#x27;, !this.object, true), svar = ref$[0], srcPart = ref$[1];
      svar === srcPart || temps.push(svar);
    } else {
      svar = srcPart = this.source.compile(o, LEVEL_PAREN);
    }
    if (!this.object) {
      if (0 &#x3e; pvar &#x26;&#x26; ~~pvar === +pvar) {
        vars = idx + &#x22; = &#x22; + srcPart + &#x22;.length - 1&#x22;;
        cond = idx + &#x22; &#x3e;= 0&#x22;;
      } else {
        temps.push(lvar = o.scope.temporary(&#x27;len&#x27;));
        vars = idx + &#x22; = 0, &#x22; + lvar + &#x22; = &#x22; + srcPart + &#x22;.length&#x22;;
        cond = idx + &#x22; &#x3c; &#x22; + lvar;
      }
    }
  }
  this[&#x27;else&#x27;] &#x26;&#x26; (this.yet = o.scope.temporary(&#x27;yet&#x27;));
  head = [sn(this, &#x27;for (&#x27;)];
  if (this.object) {
    head.push(idx, &#x22; in &#x22;);
  }
  if (that = this.yet) {
    head.push(that, &#x22; = true, &#x22;);
  }
  if (this.object) {
    head.push(srcPart);
  } else {
    step === pvar || (vars += &#x27;, &#x27; + step);
    head.push(vars, &#x22;; &#x22;, cond, &#x22;; &#x22; + (1 == Math.abs(pvar)
      ? (pvar &#x3c; 0 ? &#x27;--&#x27; : &#x27;++&#x27;) + idx
      : idx + (pvar &#x3c; 0
        ? &#x27; -= &#x27; + pvar.toString().slice(1)
        : &#x27; += &#x27; + pvar)));
  }
  this.own &#x26;&#x26; head.push(sn(this, &#x22;) if (&#x22;), o.scope.assign(&#x27;own$&#x27;, &#x27;{}.hasOwnProperty&#x27;), &#x22;.call(&#x22;, svar, &#x22;, &#x22;, idx, &#x22;)&#x22;);
  head.push(sn(this, &#x27;) {&#x27;));
  if (this[&#x27;let&#x27;]) {
    this.body.traverseChildren(function(it){
      switch (it.value) {
      case &#x27;index$$&#x27;:
        it.value = idx;
        break;
      case &#x27;item$$&#x27;:
        it.value = svar + &#x22;[&#x22; + idx + &#x22;]&#x22;;
      }
    });
  }
  o.indent += TAB;
  if (this.index &#x26;&#x26; !this.object) {
    head.push(&#x27;\n&#x27; + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), &#x27;;&#x27;);
  }
  if (this.item &#x26;&#x26; !this.item.isEmpty() &#x26;&#x26; !this.from) {
    head.push(&#x27;\n&#x27; + o.indent, Assign(this.item, JS(svar + &#x22;[&#x22; + idx + &#x22;]&#x22;)).compile(o, LEVEL_TOP), &#x27;;&#x27;);
  }
  if (this.ref) {
    o.ref = this.item.value;
  }
  body = this.compileBody(o);
  if ((this.item || (this.index &#x26;&#x26; !this.object)) &#x26;&#x26; &#x27;}&#x27; === body.toString().charAt(0)) {
    head.push(&#x27;\n&#x27; + this.tab);
  }
  return sn.apply(null, [null].concat(slice$.call(head), [body]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For.prototype.show" id="apidoc.module.livescript.ast.For.prototype.show">module livescript.ast.For.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.show.show" id="apidoc.element.livescript.ast.For.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return ((this.kind || []).concat(this.index)).join(&#x27; &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun" id="apidoc.module.livescript.ast.Fun">module livescript.ast.Fun</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.Fun" id="apidoc.element.livescript.ast.Fun.Fun">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &#x26;&#x26; &#x27;this$&#x27;;
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 113:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]));
break;
case 114:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Existence($$[$0-1].unwrap(), true));
break;
case 115:
this.$ = yy.L(_$[$0-5], _$[$0],yy.<span class="apidocCodeKeywordSpan">Fun</span>($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test
($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
break;
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.superclass" id="apidoc.element.livescript.ast.Fun.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype" id="apidoc.module.livescript.ast.Fun.prototype">module livescript.ast.Fun.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileNode" id="apidoc.element.livescript.ast.Fun.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this;
  pscope = o.scope;
  sscope = pscope.shared || pscope;
  scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper &#x26;&#x26; sscope);
  scope.fun = this;
  if (that = this.proto) {
    scope.assign(&#x27;prototype&#x27;, that.compile(o) + &#x22;.prototype&#x22;);
  }
  if (that = this.cname) {
    scope.assign(&#x27;constructor&#x27;, that);
  }
  if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
    o.indent = this.tab = &#x27;&#x27;;
  }
  o.indent += TAB;
  body = this.body, name = this.name, tab = this.tab;
  code = [&#x27;function&#x27;];
  if (this.generator) {
    this.ctor &#x26;&#x26; this.carp(&#x22;a constructor can&#x27;t be a generator&#x22;);
    o.inGenerator = true;
    code.push(&#x27;*&#x27;);
  } else if (!this.wrapper) {
    o.inGenerator = false;
  }
  if (this.bound === &#x27;this$&#x27;) {
    if (this.ctor) {
      scope.assign(&#x27;this$&#x27;, &#x27;this instanceof ctor$ ? this : new ctor$&#x27;);
      body.lines.push(Return(Literal(&#x27;this$&#x27;)));
    } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
      this.bound = that;
    } else {
      sscope.assign(&#x27;this$&#x27;, &#x27;this&#x27;);
    }
  }
  if (this.statement) {
    name || this.carp(&#x27;nameless function declaration&#x27;);
    pscope === o.block.scope || this.carp(&#x27;misplaced function declaration&#x27;);
    this.accessor &#x26;&#x26; this.carp(&#x27;named accessor&#x27;);
    pscope.add(name, &#x27;function&#x27;, this);
  }
  if (this.statement || name &#x26;&#x26; this.labeled) {
    code.push(&#x27; &#x27;, scope.add(name, &#x27;function&#x27;, this));
  }
  this.hushed || this.ctor || this.newed || body.makeReturn();
  code.push(&#x22;(&#x22;, this.compileParams(o, scope), &#x22;)&#x22;);
  code = [sn.apply(null, [this].concat(slice$.call(code)))];
  code.push(&#x22;{&#x22;);
  if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
    code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
  }
  code.push(&#x27;}&#x27;);
  curryCodeCheck = function(){
    if (this$.curried &#x26;&#x26; this$.hasSplats) {
      this$.carp(&#x27;cannot curry a function with a variable number of arguments&#x27;);
    }
    if (this$.curried &#x26;&#x26; this$.params.length &#x3e; 1 &#x26;&#x26; !this$.classBound) {
      if (this$.bound) {
        return [util(&#x27;curry&#x27;), &#x22;((&#x22;].concat(slice$.call(code), [&#x22;), true)&#x22;]);
      } else {
        return [util(&#x27;curry&#x27;), &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
      }
    } else {
      return code;
    }
  };
  if (inLoop) {
    return pscope.assign(pscope.temporary(&#x27;fn&#x27;), sn.apply(null, [null].concat(slice$.call(curryCodeCheck()))));
  }
  if (this.returns) {
    code.push(&#x22;\n&#x22; + tab + &#x22;return &#x22;, name, &#x22;;&#x22;);
  } else if (this.bound &#x26;&#x26; this.ctor) {
    code.push(&#x27; function ctor$(){} ctor$.prototype = prototype;&#x27;);
  }
  code = curryCodeCheck();
  if (this.front &#x26;&#x26; !this.statement) {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileParams" id="apidoc.element.livescript.ast.Fun.prototype.compileParams">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileParams
        <span class="apidocSignatureSpan">(o, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileParams = function (o, scope){
  var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
  params = this.params, length = params.length, body = this.body;
  for (i$ = params.length - 1; i$ &#x3e;= 0; --i$) {
    p = params[i$];
    if (!(p.isEmpty() || p.filler)) {
      break;
    }
    --params.length;
  }
  for (i$ = 0, len$ = params.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    p = params[i$];
    if (p.left instanceof Splat) {
      p.carp(&#x27;invalid splat&#x27;);
    }
    if (p instanceof Splat) {
      this.hasSplats = true;
      splace = i;
    } else if (p.op === &#x27;=&#x27;) {
      params[i] = Binary(p.logic || &#x27;?&#x27;, p.left, p.right);
    }
  }
  if (splace != null) {
    rest = params.splice(splace, 9e9);
  } else if (this.accessor) {
    if (that = params[1]) {
      that.carp(&#x27;excess accessor parameter&#x27;);
    }
  } else if (!(length || this.wrapper)) {
    if (body.traverseChildren(function(it){
      return it.value === &#x27;it&#x27; || null;
    })) {
      params[0] = Var(&#x27;it&#x27;);
    }
  }
  names = [];
  assigns = [];
  for (i$ = 0, len$ = params.length; i$ &#x3c; len$; ++i$) {
    p = params[i$];
    vr = p;
    if (df = vr.getDefault()) {
      vr = vr.first;
    }
    if (vr.isEmpty()) {
      vr = Var(scope.temporary(&#x27;arg&#x27;));
    } else if (vr.value === &#x27;..&#x27;) {
      vr = Var(o.ref = scope.temporary());
    } else if (!(vr instanceof Var)) {
      unaries = [];
      while (vr instanceof Unary) {
        hasUnary = true;
        unaries.push(vr);
        vr = vr.it;
      }
      v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary(&#x27;arg&#x27;));
      assigns.push(Assign(vr, (fn$())));
      vr = v;
    } else if (df) {
      assigns.push(Assign(vr, p.second, &#x27;=&#x27;, p.op, true));
    }
    names.push(scope.add(vr.value, &#x27;arg&#x27;, p), &#x27;, &#x27;);
  }
  if (rest) {
    while (splace--) {
      rest.unshift(Arr());
    }
    assigns.push(Assign(Arr(rest), Literal(&#x27;arguments&#x27;)));
  }
  if (assigns.length) {
    (ref$ = this.body).prepend.apply(ref$, assigns);
  }
  names.pop();
  return sn.apply(null, [null].concat(slice$.call(names)));
  function fn$(){
    switch (false) {
    case !df:
      return Binary(p.op, v, p.second);
    case !hasUnary:
      return fold(function(x, y){
        y.it = x;
        return y;
      }, v, unaries.reverse());
    default:
      return v;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.accessor &#x26;&#x26; this.carp(&#x27;named accessor&#x27;);
  pscope.add(name, &#x27;function&#x27;, this);
}
if (this.statement || name &#x26;&#x26; this.labeled) {
  code.push(&#x27; &#x27;, scope.add(name, &#x27;function&#x27;, this));
}
this.hushed || this.ctor || this.newed || body.makeReturn();
code.push(&#x22;(&#x22;, this.<span class="apidocCodeKeywordSpan">compileParams</span>(o, scope), &#x22;)&#x22;);
code = [sn.apply(null, [this].concat(slice$.call(code)))];
code.push(&#x22;{&#x22;);
if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
  code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
}
code.push(&#x27;}&#x27;);
curryCodeCheck = function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.constructor" id="apidoc.element.livescript.ast.Fun.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>constructor
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &#x26;&#x26; &#x27;this$&#x27;;
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.isCallable" id="apidoc.element.livescript.ast.Fun.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.isStatement" id="apidoc.element.livescript.ast.Fun.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStatement = function (){
  return !!this.statement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn" id="apidoc.element.livescript.ast.Fun.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  if (this.statement) {
    return this.returns = true, this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.named" id="apidoc.element.livescript.ast.Fun.prototype.named">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>named
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">named = function (it){
  return this.name = it, this.statement = true, this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Obj($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).<span class="apidocCodeKeywordSpan">named</span>($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.ripName" id="apidoc.element.livescript.ast.Fun.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripName = function (it){
  this.name || (this.name = it.varName());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.show" id="apidoc.element.livescript.ast.Fun.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return [this.name] + [(that = this.bound) ? &#x22;~&#x22; + that : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren" id="apidoc.element.livescript.ast.Fun.prototype.traverseChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>traverseChildren
        <span class="apidocSignatureSpan">(arg$, xscope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseChildren = function (arg$, xscope){
  if (xscope) {
    return superclass.prototype.traverseChildren.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.carp(&#x27;inconvertible statement&#x27;);
}
fun = Fun([], Block(this));
call = Call();
if (o.inGenerator) {
  fun.generator = true;
}
this.<span class="apidocCodeKeywordSpan">traverseChildren</span>(function(it){
  switch (it.value) {
  case &#x27;this&#x27;:
    hasThis = true;
    break;
  case &#x27;arguments&#x27;:
    hasArgs = it.value = &#x27;args$&#x27;;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.compileNode" id="apidoc.module.livescript.ast.Fun.prototype.compileNode">module livescript.ast.Fun.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Fun.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this;
  pscope = o.scope;
  sscope = pscope.shared || pscope;
  scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper &#x26;&#x26; sscope);
  scope.fun = this;
  if (that = this.proto) {
    scope.assign(&#x27;prototype&#x27;, that.compile(o) + &#x22;.prototype&#x22;);
  }
  if (that = this.cname) {
    scope.assign(&#x27;constructor&#x27;, that);
  }
  if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
    o.indent = this.tab = &#x27;&#x27;;
  }
  o.indent += TAB;
  body = this.body, name = this.name, tab = this.tab;
  code = [&#x27;function&#x27;];
  if (this.generator) {
    this.ctor &#x26;&#x26; this.carp(&#x22;a constructor can&#x27;t be a generator&#x22;);
    o.inGenerator = true;
    code.push(&#x27;*&#x27;);
  } else if (!this.wrapper) {
    o.inGenerator = false;
  }
  if (this.bound === &#x27;this$&#x27;) {
    if (this.ctor) {
      scope.assign(&#x27;this$&#x27;, &#x27;this instanceof ctor$ ? this : new ctor$&#x27;);
      body.lines.push(Return(Literal(&#x27;this$&#x27;)));
    } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
      this.bound = that;
    } else {
      sscope.assign(&#x27;this$&#x27;, &#x27;this&#x27;);
    }
  }
  if (this.statement) {
    name || this.carp(&#x27;nameless function declaration&#x27;);
    pscope === o.block.scope || this.carp(&#x27;misplaced function declaration&#x27;);
    this.accessor &#x26;&#x26; this.carp(&#x27;named accessor&#x27;);
    pscope.add(name, &#x27;function&#x27;, this);
  }
  if (this.statement || name &#x26;&#x26; this.labeled) {
    code.push(&#x27; &#x27;, scope.add(name, &#x27;function&#x27;, this));
  }
  this.hushed || this.ctor || this.newed || body.makeReturn();
  code.push(&#x22;(&#x22;, this.compileParams(o, scope), &#x22;)&#x22;);
  code = [sn.apply(null, [this].concat(slice$.call(code)))];
  code.push(&#x22;{&#x22;);
  if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
    code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
  }
  code.push(&#x27;}&#x27;);
  curryCodeCheck = function(){
    if (this$.curried &#x26;&#x26; this$.hasSplats) {
      this$.carp(&#x27;cannot curry a function with a variable number of arguments&#x27;);
    }
    if (this$.curried &#x26;&#x26; this$.params.length &#x3e; 1 &#x26;&#x26; !this$.classBound) {
      if (this$.bound) {
        return [util(&#x27;curry&#x27;), &#x22;((&#x22;].concat(slice$.call(code), [&#x22;), true)&#x22;]);
      } else {
        return [util(&#x27;curry&#x27;), &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
      }
    } else {
      return code;
    }
  };
  if (inLoop) {
    return pscope.assign(pscope.temporary(&#x27;fn&#x27;), sn.apply(null, [null].concat(slice$.call(curryCodeCheck()))));
  }
  if (this.returns) {
    code.push(&#x22;\n&#x22; + tab + &#x22;return &#x22;, name, &#x22;;&#x22;);
  } else if (this.bound &#x26;&#x26; this.ctor) {
    code.push(&#x27; function ctor$(){} ctor$.prototype = prototype;&#x27;);
  }
  code = curryCodeCheck();
  if (this.front &#x26;&#x26; !this.statement) {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.compileParams" id="apidoc.module.livescript.ast.Fun.prototype.compileParams">module livescript.ast.Fun.prototype.compileParams</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileParams.compileParams" id="apidoc.element.livescript.ast.Fun.prototype.compileParams.compileParams">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileParams
        <span class="apidocSignatureSpan">(o, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileParams = function (o, scope){
  var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
  params = this.params, length = params.length, body = this.body;
  for (i$ = params.length - 1; i$ &#x3e;= 0; --i$) {
    p = params[i$];
    if (!(p.isEmpty() || p.filler)) {
      break;
    }
    --params.length;
  }
  for (i$ = 0, len$ = params.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    p = params[i$];
    if (p.left instanceof Splat) {
      p.carp(&#x27;invalid splat&#x27;);
    }
    if (p instanceof Splat) {
      this.hasSplats = true;
      splace = i;
    } else if (p.op === &#x27;=&#x27;) {
      params[i] = Binary(p.logic || &#x27;?&#x27;, p.left, p.right);
    }
  }
  if (splace != null) {
    rest = params.splice(splace, 9e9);
  } else if (this.accessor) {
    if (that = params[1]) {
      that.carp(&#x27;excess accessor parameter&#x27;);
    }
  } else if (!(length || this.wrapper)) {
    if (body.traverseChildren(function(it){
      return it.value === &#x27;it&#x27; || null;
    })) {
      params[0] = Var(&#x27;it&#x27;);
    }
  }
  names = [];
  assigns = [];
  for (i$ = 0, len$ = params.length; i$ &#x3c; len$; ++i$) {
    p = params[i$];
    vr = p;
    if (df = vr.getDefault()) {
      vr = vr.first;
    }
    if (vr.isEmpty()) {
      vr = Var(scope.temporary(&#x27;arg&#x27;));
    } else if (vr.value === &#x27;..&#x27;) {
      vr = Var(o.ref = scope.temporary());
    } else if (!(vr instanceof Var)) {
      unaries = [];
      while (vr instanceof Unary) {
        hasUnary = true;
        unaries.push(vr);
        vr = vr.it;
      }
      v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary(&#x27;arg&#x27;));
      assigns.push(Assign(vr, (fn$())));
      vr = v;
    } else if (df) {
      assigns.push(Assign(vr, p.second, &#x27;=&#x27;, p.op, true));
    }
    names.push(scope.add(vr.value, &#x27;arg&#x27;, p), &#x27;, &#x27;);
  }
  if (rest) {
    while (splace--) {
      rest.unshift(Arr());
    }
    assigns.push(Assign(Arr(rest), Literal(&#x27;arguments&#x27;)));
  }
  if (assigns.length) {
    (ref$ = this.body).prepend.apply(ref$, assigns);
  }
  names.pop();
  return sn.apply(null, [null].concat(slice$.call(names)));
  function fn$(){
    switch (false) {
    case !df:
      return Binary(p.op, v, p.second);
    case !hasUnary:
      return fold(function(x, y){
        y.it = x;
        return y;
      }, v, unaries.reverse());
    default:
      return v;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.accessor &#x26;&#x26; this.carp(&#x27;named accessor&#x27;);
  pscope.add(name, &#x27;function&#x27;, this);
}
if (this.statement || name &#x26;&#x26; this.labeled) {
  code.push(&#x27; &#x27;, scope.add(name, &#x27;function&#x27;, this));
}
this.hushed || this.ctor || this.newed || body.makeReturn();
code.push(&#x22;(&#x22;, this.<span class="apidocCodeKeywordSpan">compileParams</span>(o, scope), &#x22;)&#x22;);
code = [sn.apply(null, [this].concat(slice$.call(code)))];
code.push(&#x22;{&#x22;);
if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
  code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
}
code.push(&#x27;}&#x27;);
curryCodeCheck = function(){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.isStatement" id="apidoc.module.livescript.ast.Fun.prototype.isStatement">module livescript.ast.Fun.prototype.isStatement</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.isStatement.isStatement" id="apidoc.element.livescript.ast.Fun.prototype.isStatement.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStatement = function (){
  return !!this.statement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.makeReturn" id="apidoc.module.livescript.ast.Fun.prototype.makeReturn">module livescript.ast.Fun.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Fun.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  if (this.statement) {
    return this.returns = true, this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.named" id="apidoc.module.livescript.ast.Fun.prototype.named">module livescript.ast.Fun.prototype.named</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.named.named" id="apidoc.element.livescript.ast.Fun.prototype.named.named">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>named
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">named = function (it){
  return this.name = it, this.statement = true, this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Obj($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).<span class="apidocCodeKeywordSpan">named</span>($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.ripName" id="apidoc.module.livescript.ast.Fun.prototype.ripName">module livescript.ast.Fun.prototype.ripName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.ripName.ripName" id="apidoc.element.livescript.ast.Fun.prototype.ripName.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripName = function (it){
  this.name || (this.name = it.varName());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.show" id="apidoc.module.livescript.ast.Fun.prototype.show">module livescript.ast.Fun.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.show.show" id="apidoc.element.livescript.ast.Fun.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return [this.name] + [(that = this.bound) ? &#x22;~&#x22; + that : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.traverseChildren" id="apidoc.module.livescript.ast.Fun.prototype.traverseChildren">module livescript.ast.Fun.prototype.traverseChildren</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren.traverseChildren" id="apidoc.element.livescript.ast.Fun.prototype.traverseChildren.traverseChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>traverseChildren
        <span class="apidocSignatureSpan">(arg$, xscope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseChildren = function (arg$, xscope){
  if (xscope) {
    return superclass.prototype.traverseChildren.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.carp(&#x27;inconvertible statement&#x27;);
}
fun = Fun([], Block(this));
call = Call();
if (o.inGenerator) {
  fun.generator = true;
}
this.<span class="apidocCodeKeywordSpan">traverseChildren</span>(function(it){
  switch (it.value) {
  case &#x27;this&#x27;:
    hasThis = true;
    break;
  case &#x27;arguments&#x27;:
    hasArgs = it.value = &#x27;args$&#x27;;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If" id="apidoc.module.livescript.ast.If">module livescript.ast.If</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.If" id="apidoc.element.livescript.ast.If.If">
        function <span class="apidocSignatureSpan">livescript.ast.</span>If
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$[&#x27;if&#x27;] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
case 118:
this.$ = (yy.L(_$[$0-3],_$[$0-2], yy.<span class="apidocCodeKeywordSpan">If</span>($$[$0-2], $$[$0-1], $$[$0-3] === &#x27;unless
&#x27;)).addElse($$[$0]));
break;
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === &#x27;unless&#x27;)));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.superclass" id="apidoc.element.livescript.ast.If.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.If.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.unfoldSoak" id="apidoc.element.livescript.ast.If.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.If.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o, parent, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o, parent, name){
  var that;
  if (that = parent[name].unfoldSoak(o)) {
    parent[name] = that.then;
    return that.cond = parent.cond, that[&#x27;void&#x27;] = parent[&#x27;void&#x27;], that.then = Chain(parent), that;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype" id="apidoc.module.livescript.ast.If.prototype">module livescript.ast.If.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileExpression" id="apidoc.element.livescript.ast.If.prototype.compileExpression">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileExpression
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExpression = function (o){
  var thn, els, code, pad;
  thn = this.then, els = this[&#x27;else&#x27;] || Literal(&#x27;void&#x27;);
  this[&#x27;void&#x27;] &#x26;&#x26; (thn[&#x27;void&#x27;] = els[&#x27;void&#x27;] = true);
  if (!this[&#x27;else&#x27;] &#x26;&#x26; (this.cond || this[&#x27;void&#x27;])) {
    return Parens(Binary(&#x27;&#x26;&#x26;&#x27;, this[&#x27;if&#x27;], thn)).compile(o);
  }
  code = [sn(this, this[&#x27;if&#x27;].compile(o, LEVEL_COND))];
  pad = els.isComplex() ? &#x27;\n&#x27; + (o.indent += TAB) : &#x27; &#x27;;
  code.push(pad + &#x22;&#x22;, sn(thn, &#x22;? &#x22;), thn.compile(o, LEVEL_LIST), pad + &#x22;&#x22;, sn(els, &#x22;: &#x22;), els.compile(o, LEVEL_LIST));
  if (o.level &#x3c; LEVEL_COND) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, &#x22;(&#x22;, code, &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compileExistence = function(o){
  var x;
  if (this[&#x27;void&#x27;] || !o.level) {
    x = Binary(&#x27;&#x26;&#x26;&#x27;, Existence(this.first, true), this.second);
    return (x[&#x27;void&#x27;] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).<span class="apidocCodeKeywordSpan">compileExpression</span>(o));
};
Binary.prototype.compileAnyInstanceOf = function(o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary(&#x27;instanceof&#x27;, sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    item = items[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileNode" id="apidoc.element.livescript.ast.If.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  if (this.un) {
    this[&#x27;if&#x27;] = this[&#x27;if&#x27;].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.compileStatement(o);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileStatement" id="apidoc.element.livescript.ast.If.prototype.compileStatement">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileStatement
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileStatement = function (o){
  var code, els;
  code = [sn(this, &#x22;if (&#x22;, this[&#x27;if&#x27;].compile(o, LEVEL_PAREN), &#x22;) &#x22;)];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
  if (!(els = this[&#x27;else&#x27;])) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  return sn.apply(null, [null].concat(
    slice$.call(code), [
      sn(els, &#x27; else &#x27;), els instanceof constructor
        ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
        : this.compileBlock(o, els)
    ]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this[&#x27;if&#x27;] = this[&#x27;if&#x27;].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.<span class="apidocCodeKeywordSpan">compileStatement</span>(o);
  }
};
If.prototype.compileStatement = function(o){
  var code, els;
  code = [sn(this, &#x22;if (&#x22;, this[&#x27;if&#x27;].compile(o, LEVEL_PAREN), &#x22;) &#x22;)];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.constructor" id="apidoc.element.livescript.ast.If.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>constructor
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$[&#x27;if&#x27;] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.getJump" id="apidoc.element.livescript.ast.If.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var ref$;
  return this.then.getJump(it) || ((ref$ = this[&#x27;else&#x27;]) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isArray" id="apidoc.element.livescript.ast.If.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isCallable" id="apidoc.element.livescript.ast.If.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isRegex" id="apidoc.element.livescript.ast.If.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isString" id="apidoc.element.livescript.ast.If.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.makeReturn" id="apidoc.element.livescript.ast.If.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
  if (this[&#x27;else&#x27;] != null) {
    this[&#x27;else&#x27;] = (ref$ = this[&#x27;else&#x27;]).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.show" id="apidoc.element.livescript.ast.If.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.un &#x26;&#x26; &#x27;!&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.compileExpression" id="apidoc.module.livescript.ast.If.prototype.compileExpression">module livescript.ast.If.prototype.compileExpression</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileExpression.compileExpression" id="apidoc.element.livescript.ast.If.prototype.compileExpression.compileExpression">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileExpression
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExpression = function (o){
  var thn, els, code, pad;
  thn = this.then, els = this[&#x27;else&#x27;] || Literal(&#x27;void&#x27;);
  this[&#x27;void&#x27;] &#x26;&#x26; (thn[&#x27;void&#x27;] = els[&#x27;void&#x27;] = true);
  if (!this[&#x27;else&#x27;] &#x26;&#x26; (this.cond || this[&#x27;void&#x27;])) {
    return Parens(Binary(&#x27;&#x26;&#x26;&#x27;, this[&#x27;if&#x27;], thn)).compile(o);
  }
  code = [sn(this, this[&#x27;if&#x27;].compile(o, LEVEL_COND))];
  pad = els.isComplex() ? &#x27;\n&#x27; + (o.indent += TAB) : &#x27; &#x27;;
  code.push(pad + &#x22;&#x22;, sn(thn, &#x22;? &#x22;), thn.compile(o, LEVEL_LIST), pad + &#x22;&#x22;, sn(els, &#x22;: &#x22;), els.compile(o, LEVEL_LIST));
  if (o.level &#x3c; LEVEL_COND) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, &#x22;(&#x22;, code, &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compileExistence = function(o){
  var x;
  if (this[&#x27;void&#x27;] || !o.level) {
    x = Binary(&#x27;&#x26;&#x26;&#x27;, Existence(this.first, true), this.second);
    return (x[&#x27;void&#x27;] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).<span class="apidocCodeKeywordSpan">compileExpression</span>(o));
};
Binary.prototype.compileAnyInstanceOf = function(o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary(&#x27;instanceof&#x27;, sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    item = items[i$];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.compileNode" id="apidoc.module.livescript.ast.If.prototype.compileNode">module livescript.ast.If.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.If.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  if (this.un) {
    this[&#x27;if&#x27;] = this[&#x27;if&#x27;].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.compileStatement(o);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.compileStatement" id="apidoc.module.livescript.ast.If.prototype.compileStatement">module livescript.ast.If.prototype.compileStatement</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileStatement.compileStatement" id="apidoc.element.livescript.ast.If.prototype.compileStatement.compileStatement">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileStatement
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileStatement = function (o){
  var code, els;
  code = [sn(this, &#x22;if (&#x22;, this[&#x27;if&#x27;].compile(o, LEVEL_PAREN), &#x22;) &#x22;)];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
  if (!(els = this[&#x27;else&#x27;])) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  return sn.apply(null, [null].concat(
    slice$.call(code), [
      sn(els, &#x27; else &#x27;), els instanceof constructor
        ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
        : this.compileBlock(o, els)
    ]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this[&#x27;if&#x27;] = this[&#x27;if&#x27;].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.<span class="apidocCodeKeywordSpan">compileStatement</span>(o);
  }
};
If.prototype.compileStatement = function(o){
  var code, els;
  code = [sn(this, &#x22;if (&#x22;, this[&#x27;if&#x27;].compile(o, LEVEL_PAREN), &#x22;) &#x22;)];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.getJump" id="apidoc.module.livescript.ast.If.prototype.getJump">module livescript.ast.If.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.getJump.getJump" id="apidoc.element.livescript.ast.If.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var ref$;
  return this.then.getJump(it) || ((ref$ = this[&#x27;else&#x27;]) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.isArray" id="apidoc.module.livescript.ast.If.prototype.isArray">module livescript.ast.If.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isArray.isArray" id="apidoc.element.livescript.ast.If.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.isCallable" id="apidoc.module.livescript.ast.If.prototype.isCallable">module livescript.ast.If.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.If.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.isRegex" id="apidoc.module.livescript.ast.If.prototype.isRegex">module livescript.ast.If.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.If.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.isString" id="apidoc.module.livescript.ast.If.prototype.isString">module livescript.ast.If.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isString.isString" id="apidoc.element.livescript.ast.If.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.makeReturn" id="apidoc.module.livescript.ast.If.prototype.makeReturn">module livescript.ast.If.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.If.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
  if (this[&#x27;else&#x27;] != null) {
    this[&#x27;else&#x27;] = (ref$ = this[&#x27;else&#x27;]).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.show" id="apidoc.module.livescript.ast.If.prototype.show">module livescript.ast.If.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.show.show" id="apidoc.element.livescript.ast.If.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.un &#x26;&#x26; &#x27;!&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import" id="apidoc.module.livescript.ast.Import">module livescript.ast.Import</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.Import" id="apidoc.element.livescript.ast.Import.Import">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Import
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
case 73:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Import</span>(yy.L(_$[$0-2],_$[$0-1], yy.Unary(&#x27;^^&#x27
;, $$[$0-2], {
  prec: &#x27;yy.UNARY&#x27;
})), $$[$0], false));
break;
case 74:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary(&#x27;^^&#x27;, $$[$0-2], {
  prec: &#x27;yy.UNARY&#x27;
})), $$[$0].unwrap(), false));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.superclass" id="apidoc.element.livescript.ast.Import.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Import.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype" id="apidoc.module.livescript.ast.Import.prototype">module livescript.ast.Import.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileAssign" id="apidoc.element.livescript.ast.Import.prototype.compileAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileAssign
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAssign = function (o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
    return this.left.compile(o);
  }
  top = !o.level;
  if (this.proto || (items.length &#x3c; 2 &#x26;&#x26; (top || this[&#x27;void&#x27;] || items[0] instanceof Splat))) {
    reft = this.left;
    if (reft.isComplex()) {
      reft = Parens(reft);
    }
  } else {
    ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
  }
  ref$ = top
    ? [&#x27;;&#x27;, &#x27;\n&#x27; + this.tab]
    : [&#x27;,&#x27;, &#x27; &#x27;], delim = ref$[0], space = ref$[1];
  delim += space;
  code = this.temps
    ? [left.compile(o, LEVEL_PAREN), delim]
    : [];
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    i &#x26;&#x26; code.push(com ? space : delim);
    if (com = node.comment) {
      code.push(node.compile(o));
      continue;
    }
    if (node instanceof Splat) {
      code.push(Import(reft, node.it).compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (dyna = node instanceof Parens) {
      ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
    } else if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        if (key instanceof Key) {
          key = JS(&#x22;&#x27;&#x22; + key.name + &#x22;&#x27;&#x22;);
        }
        code.push(&#x22;Object.defineProperty(&#x22;, reft.compile(o, LEVEL_LIST), &#x22;, &#x22;, key.compile(o, LEVEL_LIST), &#x22;, &#x22;, node.compileDescriptor
(o), &#x22;)&#x22;);
        continue;
      }
    } else {
      key = val = node;
    }
    dyna || (key = key.maybeKey());
    logic &#x26;&#x26; (val = (logic.first = val, logic));
    code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
  }
  if (top) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  this[&#x27;void&#x27;] || node instanceof Splat || code.push(com ? &#x27; &#x27; : &#x27;, &#x27;, reft.compile(o, LEVEL_PAREN));
  if (o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.<span class="apidocCodeKeywordSpan">compileAssign</span>(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util(&#x22;import&#x22; + (this.all || &#x27;&#x27;)), [this.left, right])).compileNode(o);
};
Import.prototype.compileAssign = function(o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileNode" id="apidoc.element.livescript.ast.Import.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.compileAssign(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util(&#x22;import&#x22; + (this.all || &#x27;&#x27;)), [this.left, right])).compileNode(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.constructor" id="apidoc.element.livescript.ast.Import.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>constructor
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isArray" id="apidoc.element.livescript.ast.Import.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isCallable" id="apidoc.element.livescript.ast.Import.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.show" id="apidoc.element.livescript.ast.Import.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.all;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Import.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var left, value, ref$, temps;
  left = this.left;
  if (left instanceof Existence &#x26;&#x26; !left.negated) {
    if ((left = left.it) instanceof Var) {
      value = (this.left = left).value;
      if (!o.scope.check(value, true)) {
        left = JS(&#x22;typeof &#x22; + value + &#x22; != &#x27;undefined&#x27; &#x26;&#x26; &#x22; + value);
      }
    } else {
      ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
    }
    return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref$;
  }
  return If.unfoldSoak(o, this, &#x27;left&#x27;) || (this[&#x27;void&#x27;] || !o.level) &#x26;&#x26; If.unfoldSoak(o, this, &#x27;right&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.compileAssign" id="apidoc.module.livescript.ast.Import.prototype.compileAssign">module livescript.ast.Import.prototype.compileAssign</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileAssign.compileAssign" id="apidoc.element.livescript.ast.Import.prototype.compileAssign.compileAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileAssign
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAssign = function (o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
    return this.left.compile(o);
  }
  top = !o.level;
  if (this.proto || (items.length &#x3c; 2 &#x26;&#x26; (top || this[&#x27;void&#x27;] || items[0] instanceof Splat))) {
    reft = this.left;
    if (reft.isComplex()) {
      reft = Parens(reft);
    }
  } else {
    ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
  }
  ref$ = top
    ? [&#x27;;&#x27;, &#x27;\n&#x27; + this.tab]
    : [&#x27;,&#x27;, &#x27; &#x27;], delim = ref$[0], space = ref$[1];
  delim += space;
  code = this.temps
    ? [left.compile(o, LEVEL_PAREN), delim]
    : [];
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    i &#x26;&#x26; code.push(com ? space : delim);
    if (com = node.comment) {
      code.push(node.compile(o));
      continue;
    }
    if (node instanceof Splat) {
      code.push(Import(reft, node.it).compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (dyna = node instanceof Parens) {
      ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
    } else if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        if (key instanceof Key) {
          key = JS(&#x22;&#x27;&#x22; + key.name + &#x22;&#x27;&#x22;);
        }
        code.push(&#x22;Object.defineProperty(&#x22;, reft.compile(o, LEVEL_LIST), &#x22;, &#x22;, key.compile(o, LEVEL_LIST), &#x22;, &#x22;, node.compileDescriptor
(o), &#x22;)&#x22;);
        continue;
      }
    } else {
      key = val = node;
    }
    dyna || (key = key.maybeKey());
    logic &#x26;&#x26; (val = (logic.first = val, logic));
    code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
  }
  if (top) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  this[&#x27;void&#x27;] || node instanceof Splat || code.push(com ? &#x27; &#x27; : &#x27;, &#x27;, reft.compile(o, LEVEL_PAREN));
  if (o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.<span class="apidocCodeKeywordSpan">compileAssign</span>(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util(&#x22;import&#x22; + (this.all || &#x27;&#x27;)), [this.left, right])).compileNode(o);
};
Import.prototype.compileAssign = function(o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.compileNode" id="apidoc.module.livescript.ast.Import.prototype.compileNode">module livescript.ast.Import.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Import.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.compileAssign(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util(&#x22;import&#x22; + (this.all || &#x27;&#x27;)), [this.left, right])).compileNode(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.isArray" id="apidoc.module.livescript.ast.Import.prototype.isArray">module livescript.ast.Import.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Import.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.isCallable" id="apidoc.module.livescript.ast.Import.prototype.isCallable">module livescript.ast.Import.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Import.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.show" id="apidoc.module.livescript.ast.Import.prototype.show">module livescript.ast.Import.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.show.show" id="apidoc.element.livescript.ast.Import.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.all;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.unfoldSoak" id="apidoc.module.livescript.ast.Import.prototype.unfoldSoak">module livescript.ast.Import.prototype.unfoldSoak</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak.unfoldSoak" id="apidoc.element.livescript.ast.Import.prototype.unfoldSoak.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var left, value, ref$, temps;
  left = this.left;
  if (left instanceof Existence &#x26;&#x26; !left.negated) {
    if ((left = left.it) instanceof Var) {
      value = (this.left = left).value;
      if (!o.scope.check(value, true)) {
        left = JS(&#x22;typeof &#x22; + value + &#x22; != &#x27;undefined&#x27; &#x26;&#x26; &#x22; + value);
      }
    } else {
      ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
    }
    return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref$;
  }
  return If.unfoldSoak(o, this, &#x27;left&#x27;) || (this[&#x27;void&#x27;] || !o.level) &#x26;&#x26; If.unfoldSoak(o, this, &#x27;right&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.In" id="apidoc.module.livescript.ast.In">module livescript.ast.In</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.In.In" id="apidoc.element.livescript.ast.In.In">
        function <span class="apidocSignatureSpan">livescript.ast.</span>In
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.superclass" id="apidoc.element.livescript.ast.In.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.In.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.In.prototype" id="apidoc.module.livescript.ast.In.prototype">module livescript.ast.In.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.compileNode" id="apidoc.element.livescript.ast.In.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var array, items, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
  items = (array = this.array.expandSlice(o).unwrap()).items;
  if (!(array instanceof Arr) || items.length &#x3c; 2) {
    return sn(this, this.negated ? &#x27;!&#x27; : &#x27;&#x27;, util(&#x27;in&#x27;), &#x22;(&#x22;, this.item.compile(o, LEVEL_LIST), &#x22;, &#x22;, array.compile(o, LEVEL_LIST
), &#x22;)&#x22;);
  }
  code = [];
  ref$ = this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
  ref$ = this.negated
    ? [&#x27; !== &#x27;, &#x27; &#x26;&#x26; &#x27;]
    : [&#x27; === &#x27;, &#x27; || &#x27;], cmp = ref$[0], cnj = ref$[1];
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    test = items[i$];
    if (code.length &#x3e; 0) {
      code.push(cnj);
    }
    if (test instanceof Splat) {
      code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
      if (!(i || sub === ref)) {
        code = [&#x22;(&#x22; + sub + &#x22;, &#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
      }
    } else {
      code.push(i || sub === ref
        ? ref
        : &#x22;(&#x22; + sub + &#x22;)&#x22;, cmp, test.compile(o, LEVEL_OP + PREC[&#x27;==&#x27;]));
    }
  }
  sub === ref || o.scope.free(ref);
  if (o.level &#x3c; LEVEL_OP + PREC[&#x27;||&#x27;]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.constructor" id="apidoc.element.livescript.ast.In.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>constructor
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.invert" id="apidoc.element.livescript.ast.In.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  this.negated = !this.negated;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.show" id="apidoc.element.livescript.ast.In.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.negated &#x26;&#x26; &#x27;!&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.In.prototype.compileNode" id="apidoc.module.livescript.ast.In.prototype.compileNode">module livescript.ast.In.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.In.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var array, items, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
  items = (array = this.array.expandSlice(o).unwrap()).items;
  if (!(array instanceof Arr) || items.length &#x3c; 2) {
    return sn(this, this.negated ? &#x27;!&#x27; : &#x27;&#x27;, util(&#x27;in&#x27;), &#x22;(&#x22;, this.item.compile(o, LEVEL_LIST), &#x22;, &#x22;, array.compile(o, LEVEL_LIST
), &#x22;)&#x22;);
  }
  code = [];
  ref$ = this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
  ref$ = this.negated
    ? [&#x27; !== &#x27;, &#x27; &#x26;&#x26; &#x27;]
    : [&#x27; === &#x27;, &#x27; || &#x27;], cmp = ref$[0], cnj = ref$[1];
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    test = items[i$];
    if (code.length &#x3e; 0) {
      code.push(cnj);
    }
    if (test instanceof Splat) {
      code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
      if (!(i || sub === ref)) {
        code = [&#x22;(&#x22; + sub + &#x22;, &#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
      }
    } else {
      code.push(i || sub === ref
        ? ref
        : &#x22;(&#x22; + sub + &#x22;)&#x22;, cmp, test.compile(o, LEVEL_OP + PREC[&#x27;==&#x27;]));
    }
  }
  sub === ref || o.scope.free(ref);
  if (o.level &#x3c; LEVEL_OP + PREC[&#x27;||&#x27;]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index" id="apidoc.module.livescript.ast.Index">module livescript.ast.Index</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.Index" id="apidoc.element.livescript.ast.Index.Index">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Index
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = &#x27;.&#x27;);
  if (init &#x26;&#x26; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case &#x27;[]&#x27;:
    this$.vivify = Arr;
    break;
  case &#x27;{}&#x27;:
    this$.vivify = Obj;
    break;
  default:
    if (&#x27;=&#x27; === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Index</span>($$[$0], $$[$
0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.superclass" id="apidoc.element.livescript.ast.Index.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Index.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype" id="apidoc.module.livescript.ast.Index.prototype">module livescript.ast.Index.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.compile" id="apidoc.element.livescript.ast.Index.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
    return sn(this, &#x22;[&#x22;, code, &#x22;]&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.constructor" id="apidoc.element.livescript.ast.Index.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>constructor
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = &#x27;.&#x27;);
  if (init &#x26;&#x26; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case &#x27;[]&#x27;:
    this$.vivify = Arr;
    break;
  case &#x27;{}&#x27;:
    this$.vivify = Obj;
    break;
  default:
    if (&#x27;=&#x27; === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.isComplex" id="apidoc.element.livescript.ast.Index.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.key.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.show" id="apidoc.element.livescript.ast.Index.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.varName" id="apidoc.element.livescript.ast.Index.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype.compile" id="apidoc.module.livescript.ast.Index.prototype.compile">module livescript.ast.Index.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.compile.compile" id="apidoc.element.livescript.ast.Index.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
    return sn(this, &#x22;[&#x22;, code, &#x22;]&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype.isComplex" id="apidoc.module.livescript.ast.Index.prototype.isComplex">module livescript.ast.Index.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Index.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.key.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype.show" id="apidoc.module.livescript.ast.Index.prototype.show">module livescript.ast.Index.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.show.show" id="apidoc.element.livescript.ast.Index.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype.varName" id="apidoc.module.livescript.ast.Index.prototype.varName">module livescript.ast.Index.prototype.varName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.varName.varName" id="apidoc.element.livescript.ast.Index.prototype.varName.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS" id="apidoc.module.livescript.ast.JS">module livescript.ast.JS</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.JS" id="apidoc.element.livescript.ast.JS.JS">
        function <span class="apidocSignatureSpan">livescript.ast.</span>JS
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 66:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], &#x27;cascade&#x27;));
break;
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">JS</span>($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.superclass" id="apidoc.element.livescript.ast.JS.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.JS.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS.prototype" id="apidoc.module.livescript.ast.JS.prototype">module livescript.ast.JS.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.compile" id="apidoc.element.livescript.ast.JS.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>compile
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (it){
  return sn(this, snSafe(this.literal
    ? entab(this.code, it.indent)
    : this.code));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.constructor" id="apidoc.element.livescript.ast.JS.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>constructor
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.isAssignable" id="apidoc.element.livescript.ast.JS.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAssignable = function (){
  return !this.comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.isCallable" id="apidoc.element.livescript.ast.JS.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  return !this.comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.show" id="apidoc.element.livescript.ast.JS.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.comment) {
    return this.code;
  } else {
    return &#x22;`&#x22; + this.code + &#x22;`&#x22;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS.prototype.compile" id="apidoc.module.livescript.ast.JS.prototype.compile">module livescript.ast.JS.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.compile.compile" id="apidoc.element.livescript.ast.JS.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>compile
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (it){
  return sn(this, snSafe(this.literal
    ? entab(this.code, it.indent)
    : this.code));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS.prototype.isCallable" id="apidoc.module.livescript.ast.JS.prototype.isCallable">module livescript.ast.JS.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.JS.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  return !this.comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS.prototype.show" id="apidoc.module.livescript.ast.JS.prototype.show">module livescript.ast.JS.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.show.show" id="apidoc.element.livescript.ast.JS.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.comment) {
    return this.code;
  } else {
    return &#x22;`&#x22; + this.code + &#x22;`&#x22;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump" id="apidoc.module.livescript.ast.Jump">module livescript.ast.Jump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.Jump" id="apidoc.element.livescript.ast.Jump.Jump">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
case 125:
this.$ = yy.L(_$[$0], _$[$0],yy.Jump[$$[$0]]());
break;
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Jump</span>($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.Switch($$[$0-2], $$[$0-1], $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.extended" id="apidoc.element.livescript.ast.Jump.extended">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>extended
        <span class="apidocSignatureSpan">(sub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extended = function (sub){
  sub.prototype.children = [&#x27;it&#x27;];
  this[sub.displayName.toLowerCase()] = sub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function THIS(){
return this;
}
function VOID(){}
UTILS = {
clone: &#x27;function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}&#x27;,
extend: &#x27;function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new
fun).constructor = sub;\n  if (typeof sup.extended == \&#x27;function\&#x27;) sup.<span class="apidocCodeKeywordSpan">extended</span>(sub);\n  return sub;\n}&#x27;,
bind: &#x27;function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}&#x27;,
&#x27;import&#x27;: &#x27;function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj
[key] = src[key];\n  return obj;\n}&#x27;,
importAll: &#x27;function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}&#x27;,
repeatString: &#x27;function(str, n){\n  for (var r = \&#x27;\&#x27;; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (str += str))
if (n &#x26; 1) r += str;\n  return r;\n}&#x27;,
repeatArray: &#x27;function(arr, n){\n  for (var r = []; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (arr = arr.concat(arr)))\n
    if (n &#x26; 1) r.push.apply(r, arr);\n  return r;\n}&#x27;,
&#x27;in&#x27;: &#x27;function(x, xs){\n  var i = -1, l = xs.length &#x3e;&#x3e;&#x3e; 0;\n  while (++i &#x3c; l) if (x === xs[i
]) return true;\n  return false;\n}&#x27;,
out: &#x27;typeof exports != \&#x27;undefined\&#x27; &#x26;&#x26; exports || this&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.return" id="apidoc.element.livescript.ast.Jump.return">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &#x26;&#x26; it.value !== &#x27;void&#x27;) {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.superclass" id="apidoc.element.livescript.ast.Jump.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.throw" id="apidoc.element.livescript.ast.Jump.throw">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype" id="apidoc.module.livescript.ast.Jump.prototype">module livescript.ast.Jump.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.compileNode" id="apidoc.element.livescript.ast.Jump.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that, ref$;
  if (that = this.label) {
    in$(that, (ref$ = o.labels) != null
      ? ref$
      : o.labels = []) || this.carp(&#x22;unknown label \&#x22;&#x22; + that + &#x22;\&#x22;&#x22;);
  } else {
    o[this.verb] || this.carp(&#x22;stray &#x22; + this.verb);
  }
  return sn(this, this.show() + &#x27;;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.constructor" id="apidoc.element.livescript.ast.Jump.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>constructor
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.getJump" id="apidoc.element.livescript.ast.Jump.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var that, ref$;
  ctx || (ctx = {});
  if (!ctx[this.verb]) {
    return this;
  }
  if (that = this.label) {
    return !in$(that, (ref$ = ctx.labels) != null
      ? ref$
      : ctx.labels = []) &#x26;&#x26; this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.isStatement" id="apidoc.element.livescript.ast.Jump.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn" id="apidoc.element.livescript.ast.Jump.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.show" id="apidoc.element.livescript.ast.Jump.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return (this.verb || &#x27;&#x27;) + ((that = this.label) ? &#x27; &#x27; + that : &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype.compileNode" id="apidoc.module.livescript.ast.Jump.prototype.compileNode">module livescript.ast.Jump.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Jump.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that, ref$;
  if (that = this.label) {
    in$(that, (ref$ = o.labels) != null
      ? ref$
      : o.labels = []) || this.carp(&#x22;unknown label \&#x22;&#x22; + that + &#x22;\&#x22;&#x22;);
  } else {
    o[this.verb] || this.carp(&#x22;stray &#x22; + this.verb);
  }
  return sn(this, this.show() + &#x27;;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype.getJump" id="apidoc.module.livescript.ast.Jump.prototype.getJump">module livescript.ast.Jump.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Jump.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var that, ref$;
  ctx || (ctx = {});
  if (!ctx[this.verb]) {
    return this;
  }
  if (that = this.label) {
    return !in$(that, (ref$ = ctx.labels) != null
      ? ref$
      : ctx.labels = []) &#x26;&#x26; this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype.makeReturn" id="apidoc.module.livescript.ast.Jump.prototype.makeReturn">module livescript.ast.Jump.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Jump.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype.show" id="apidoc.module.livescript.ast.Jump.prototype.show">module livescript.ast.Jump.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.show.show" id="apidoc.element.livescript.ast.Jump.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return (this.verb || &#x27;&#x27;) + ((that = this.label) ? &#x27; &#x27; + that : &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key" id="apidoc.module.livescript.ast.Key">module livescript.ast.Key</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.Key" id="apidoc.element.livescript.ast.Key.Key">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Key
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = &#x27;&#x27; + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
case 49:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Key</span>($$[$0]));
break;
case 50:
this.$ = yy.L(_$[$0], _$[$0],yy.Literal($$[$0]));
break;
case 51: case 164:
this.$ = yy.L(_$[$0], _$[$0],[]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.superclass" id="apidoc.element.livescript.ast.Key.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Key.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype" id="apidoc.module.livescript.ast.Key.prototype">module livescript.ast.Key.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.assigns" id="apidoc.element.livescript.ast.Key.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return it === this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.compile" id="apidoc.element.livescript.ast.Key.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return sn(this, this.show());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.constructor" id="apidoc.element.livescript.ast.Key.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = &#x27;&#x27; + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.isComplex" id="apidoc.element.livescript.ast.Key.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.show" id="apidoc.element.livescript.ast.Key.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.reserved) {
    return &#x22;&#x27;&#x22; + this.name + &#x22;&#x27;&#x22;;
  } else {
    return this.name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.varName" id="apidoc.element.livescript.ast.Key.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var name;
  name = this.name;
  if (this.reserved || (name === &#x27;arguments&#x27; || name === &#x27;eval&#x27;)) {
    return &#x22;$&#x22; + name;
  } else {
    return name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype.assigns" id="apidoc.module.livescript.ast.Key.prototype.assigns">module livescript.ast.Key.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Key.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return it === this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype.compile" id="apidoc.module.livescript.ast.Key.prototype.compile">module livescript.ast.Key.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.compile.compile" id="apidoc.element.livescript.ast.Key.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return sn(this, this.show());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype.isComplex" id="apidoc.module.livescript.ast.Key.prototype.isComplex">module livescript.ast.Key.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Key.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype.show" id="apidoc.module.livescript.ast.Key.prototype.show">module livescript.ast.Key.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.show.show" id="apidoc.element.livescript.ast.Key.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.reserved) {
    return &#x22;&#x27;&#x22; + this.name + &#x22;&#x27;&#x22;;
  } else {
    return this.name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype.varName" id="apidoc.module.livescript.ast.Key.prototype.varName">module livescript.ast.Key.prototype.varName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.varName.varName" id="apidoc.element.livescript.ast.Key.prototype.varName.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var name;
  name = this.name;
  if (this.reserved || (name === &#x27;arguments&#x27; || name === &#x27;eval&#x27;)) {
    return &#x22;$&#x22; + name;
  } else {
    return name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.L" id="apidoc.module.livescript.ast.L">module livescript.ast.L</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.L.L" id="apidoc.element.livescript.ast.L.L">
        function <span class="apidocSignatureSpan">livescript.ast.</span>L
        <span class="apidocSignatureSpan">(a, b, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">L = function (a, b, node){
  if (node &#x26;&#x26; typeof node === &#x22;object&#x22;) {
    node.first_line = a.first_line + 1;
    node.first_column = a.first_column;
    node.last_line = b.last_line + 1;
    node.last_column = b.last_column;
    node.line = a.first_line + 1;
    node.column = a.first_column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.<span class="apidocCodeKeywordSpan">L</span>(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label" id="apidoc.module.livescript.ast.Label">module livescript.ast.Label</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.Label" id="apidoc.element.livescript.ast.Label.Label">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Label
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || &#x27;_&#x27;;
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &#x26;&#x26; it || it.calling &#x26;&#x26; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        body: $$[$0]
      }));
break;
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Label</span>($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27;arguments&#x27; &#x26;&#x26; $$[$0] !== &#
x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.superclass" id="apidoc.element.livescript.ast.Label.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Label.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype" id="apidoc.module.livescript.ast.Label.prototype">module livescript.ast.Label.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.compileNode" id="apidoc.element.livescript.ast.Label.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var label, it, labels;
  label = this.label, it = this.it;
  labels = o.labels = slice$.call(o.labels || []);
  if (in$(label, labels)) {
    this.carp(&#x22;duplicate label \&#x22;&#x22; + label + &#x22;\&#x22;&#x22;);
  }
  labels.push(label);
  it.isStatement() || (it = Block(it));
  return sn(null, sn(this, label, &#x22;: &#x22;), it instanceof Block
    ? (o.indent += TAB, this.compileBlock(o, it))
    : it.compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.constructor" id="apidoc.element.livescript.ast.Label.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>constructor
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || &#x27;_&#x27;;
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &#x26;&#x26; it || it.calling &#x26;&#x26; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.getJump" id="apidoc.element.livescript.ast.Label.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var ref$;
  ctx || (ctx = {});
  ((ref$ = ctx.labels) != null
    ? ref$
    : ctx.labels = []).push(this.label);
  return this.it.getJump((ctx[&#x27;break&#x27;] = true, ctx));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isArray" id="apidoc.element.livescript.ast.Label.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isCallable" id="apidoc.element.livescript.ast.Label.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isStatement" id="apidoc.element.livescript.ast.Label.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.makeReturn" id="apidoc.element.livescript.ast.Label.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.show" id="apidoc.element.livescript.ast.Label.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.compileNode" id="apidoc.module.livescript.ast.Label.prototype.compileNode">module livescript.ast.Label.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Label.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var label, it, labels;
  label = this.label, it = this.it;
  labels = o.labels = slice$.call(o.labels || []);
  if (in$(label, labels)) {
    this.carp(&#x22;duplicate label \&#x22;&#x22; + label + &#x22;\&#x22;&#x22;);
  }
  labels.push(label);
  it.isStatement() || (it = Block(it));
  return sn(null, sn(this, label, &#x22;: &#x22;), it instanceof Block
    ? (o.indent += TAB, this.compileBlock(o, it))
    : it.compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.getJump" id="apidoc.module.livescript.ast.Label.prototype.getJump">module livescript.ast.Label.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Label.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var ref$;
  ctx || (ctx = {});
  ((ref$ = ctx.labels) != null
    ? ref$
    : ctx.labels = []).push(this.label);
  return this.it.getJump((ctx[&#x27;break&#x27;] = true, ctx));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.isArray" id="apidoc.module.livescript.ast.Label.prototype.isArray">module livescript.ast.Label.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Label.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.isCallable" id="apidoc.module.livescript.ast.Label.prototype.isCallable">module livescript.ast.Label.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Label.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.makeReturn" id="apidoc.module.livescript.ast.Label.prototype.makeReturn">module livescript.ast.Label.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Label.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.show" id="apidoc.module.livescript.ast.Label.prototype.show">module livescript.ast.Label.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.show.show" id="apidoc.element.livescript.ast.Label.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal" id="apidoc.module.livescript.ast.Literal">module livescript.ast.Literal</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.Literal" id="apidoc.element.livescript.ast.Literal.Literal">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + &#x22;&#x22;, true);
  }
  if (value === &#x27;super&#x27;) {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Literal</span>($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass" id="apidoc.element.livescript.ast.Literal.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(){
  Atom.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype" id="apidoc.module.livescript.ast.Literal.prototype">module livescript.ast.Literal.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.compile" id="apidoc.element.livescript.ast.Literal.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var val, ref$;
  level == null &#x26;&#x26; (level = o.level);
  switch (val = this.value + &#x22;&#x22;) {
  case &#x27;this&#x27;:
    return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
  case &#x27;void&#x27;:
    if (!level) {
      return sn(this, &#x27;&#x27;);
    }
    val += &#x27; 8&#x27;;
    // fallthrough
  case &#x27;null&#x27;:
    if (level === LEVEL_CALL) {
      this.carp(&#x27;invalid use of &#x27; + this.value);
    }
    break;
  case &#x27;on&#x27;:
  case &#x27;yes&#x27;:
    val = &#x27;true&#x27;;
    break;
  case &#x27;off&#x27;:
  case &#x27;no&#x27;:
    val = &#x27;false&#x27;;
    break;
  case &#x27;*&#x27;:
    this.carp(&#x27;stray star&#x27;);
    break;
  case &#x27;..&#x27;:
    if (!(val = o.ref)) {
      this.carp(&#x27;stray reference&#x27;);
    }
    this.cascadee || (val.erred = true);
    break;
  case &#x27;debugger&#x27;:
    if (level) {
      return sn(this, &#x22;(function(){ debugger; }())&#x22;);
    }
  }
  return sn(this, snSafe(val));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.constructor" id="apidoc.element.livescript.ast.Literal.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + &#x22;&#x22;, true);
  }
  if (value === &#x27;super&#x27;) {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isCallable" id="apidoc.element.livescript.ast.Literal.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return (ref$ = this.value) === &#x27;this&#x27; || ref$ === &#x27;eval&#x27; || ref$ === &#x27;..&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isComplex" id="apidoc.element.livescript.ast.Literal.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty" id="apidoc.element.livescript.ast.Literal.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (){
  var ref$;
  return (ref$ = this.value) === &#x27;void&#x27; || ref$ === &#x27;null&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isRegex" id="apidoc.element.livescript.ast.Literal.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (){
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isString" id="apidoc.element.livescript.ast.Literal.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  return 0 &#x3c;= &#x27;\&#x27;&#x22;&#x27;.indexOf((this.value + &#x22;&#x22;).charAt());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isWhat" id="apidoc.element.livescript.ast.Literal.prototype.isWhat">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isWhat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isWhat = function (){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
  default:

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    default:
if (COMPARER.test(this.op)) {
  if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
    return it.isRegex();
  })) {
    return this.compileRegexEquals(o, that);
  }
  if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.<span class="apidocCodeKeywordSpan">isWhat</span>() !== this.second.isWhat()) {
    if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
      console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#x22
; == &#x22; + this.second.value);
    }
  }
}
if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
  return this.compileChain(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn" id="apidoc.element.livescript.ast.Literal.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (it){
  if (!it &#x26;&#x26; this.value === &#x27;debugger&#x27;) {
    return this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey" id="apidoc.element.livescript.ast.Literal.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeKey = function (){
  if (ID.test(this.value)) {
    return Key(this.value);
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.varName" id="apidoc.element.livescript.ast.Literal.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  if (/^\w+$/.test(this.value)) {
    return &#x27;$&#x27; + this.value;
  } else {
    return &#x27;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.compile" id="apidoc.module.livescript.ast.Literal.prototype.compile">module livescript.ast.Literal.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.compile.compile" id="apidoc.element.livescript.ast.Literal.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var val, ref$;
  level == null &#x26;&#x26; (level = o.level);
  switch (val = this.value + &#x22;&#x22;) {
  case &#x27;this&#x27;:
    return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
  case &#x27;void&#x27;:
    if (!level) {
      return sn(this, &#x27;&#x27;);
    }
    val += &#x27; 8&#x27;;
    // fallthrough
  case &#x27;null&#x27;:
    if (level === LEVEL_CALL) {
      this.carp(&#x27;invalid use of &#x27; + this.value);
    }
    break;
  case &#x27;on&#x27;:
  case &#x27;yes&#x27;:
    val = &#x27;true&#x27;;
    break;
  case &#x27;off&#x27;:
  case &#x27;no&#x27;:
    val = &#x27;false&#x27;;
    break;
  case &#x27;*&#x27;:
    this.carp(&#x27;stray star&#x27;);
    break;
  case &#x27;..&#x27;:
    if (!(val = o.ref)) {
      this.carp(&#x27;stray reference&#x27;);
    }
    this.cascadee || (val.erred = true);
    break;
  case &#x27;debugger&#x27;:
    if (level) {
      return sn(this, &#x22;(function(){ debugger; }())&#x22;);
    }
  }
  return sn(this, snSafe(val));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isCallable" id="apidoc.module.livescript.ast.Literal.prototype.isCallable">module livescript.ast.Literal.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Literal.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return (ref$ = this.value) === &#x27;this&#x27; || ref$ === &#x27;eval&#x27; || ref$ === &#x27;..&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isComplex" id="apidoc.module.livescript.ast.Literal.prototype.isComplex">module livescript.ast.Literal.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Literal.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isEmpty" id="apidoc.module.livescript.ast.Literal.prototype.isEmpty">module livescript.ast.Literal.prototype.isEmpty</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty.isEmpty" id="apidoc.element.livescript.ast.Literal.prototype.isEmpty.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (){
  var ref$;
  return (ref$ = this.value) === &#x27;void&#x27; || ref$ === &#x27;null&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isRegex" id="apidoc.module.livescript.ast.Literal.prototype.isRegex">module livescript.ast.Literal.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Literal.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (){
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isString" id="apidoc.module.livescript.ast.Literal.prototype.isString">module livescript.ast.Literal.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isString.isString" id="apidoc.element.livescript.ast.Literal.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  return 0 &#x3c;= &#x27;\&#x27;&#x22;&#x27;.indexOf((this.value + &#x22;&#x22;).charAt());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isWhat" id="apidoc.module.livescript.ast.Literal.prototype.isWhat">module livescript.ast.Literal.prototype.isWhat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isWhat.isWhat" id="apidoc.element.livescript.ast.Literal.prototype.isWhat.isWhat">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isWhat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isWhat = function (){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
  default:

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    default:
if (COMPARER.test(this.op)) {
  if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
    return it.isRegex();
  })) {
    return this.compileRegexEquals(o, that);
  }
  if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.<span class="apidocCodeKeywordSpan">isWhat</span>() !== this.second.isWhat()) {
    if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
      console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#x22
; == &#x22; + this.second.value);
    }
  }
}
if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
  return this.compileChain(o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.makeReturn" id="apidoc.module.livescript.ast.Literal.prototype.makeReturn">module livescript.ast.Literal.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Literal.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (it){
  if (!it &#x26;&#x26; this.value === &#x27;debugger&#x27;) {
    return this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.maybeKey" id="apidoc.module.livescript.ast.Literal.prototype.maybeKey">module livescript.ast.Literal.prototype.maybeKey</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey.maybeKey" id="apidoc.element.livescript.ast.Literal.prototype.maybeKey.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeKey = function (){
  if (ID.test(this.value)) {
    return Key(this.value);
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.varName" id="apidoc.module.livescript.ast.Literal.prototype.varName">module livescript.ast.Literal.prototype.varName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.varName.varName" id="apidoc.element.livescript.ast.Literal.prototype.varName.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  if (/^\w+$/.test(this.value)) {
    return &#x27;$&#x27; + this.value;
  } else {
    return &#x27;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.superclass.prototype" id="apidoc.module.livescript.ast.Literal.superclass.prototype">module livescript.ast.Literal.superclass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass.prototype.constructor" id="apidoc.element.livescript.ast.Literal.superclass.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(){
  Atom.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass.prototype.isComplex" id="apidoc.element.livescript.ast.Literal.superclass.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass.prototype.show" id="apidoc.element.livescript.ast.Literal.superclass.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Obj" id="apidoc.module.livescript.ast.Obj">module livescript.ast.Obj</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.Obj" id="apidoc.element.livescript.ast.Obj.Obj">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ref: true
      }).addBody($$[$0]))));
break;
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.<span class="apidocCodeKeywordSpan">Obj</span>($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).named($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.compile" id="apidoc.element.livescript.ast.Obj.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>compile
        <span class="apidocSignatureSpan">(o, items, deepEq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
  case 0:
    return &#x27;&#x27;;
  case 1:
    return items[0].compile(o, LEVEL_LIST);
  }
  indent = o.indent, level = o.level;
  o.indent = indent + TAB;
  o.level = LEVEL_LIST;
  code = [items[i = 0].compile(o)];
  while (that = items[++i]) {
    code.push(&#x27;, &#x27;);
    target = that;
    if (deepEq) {
      if (target instanceof Var &#x26;&#x26; target.value === &#x27;_&#x27;) {
        target = Obj([Prop(Key(&#x27;__placeholder__&#x27;), Literal(true))]);
      } else if (target instanceof Obj || target instanceof Arr) {
        target.deepEq = true;
      }
    }
    code.push(target.compile(o));
  }
  if (~code.join(&#x22;&#x22;).indexOf(&#x27;\n&#x27;)) {
    code = [&#x22;\n&#x22; + o.indent].concat(slice$.call(code), [&#x22;\n&#x22; + indent]);
  }
  o.indent = indent;
  o.level = level;
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.superclass" id="apidoc.element.livescript.ast.Obj.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(){
  List.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Obj.prototype" id="apidoc.module.livescript.ast.Obj.prototype">module livescript.ast.Obj.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.asObj" id="apidoc.element.livescript.ast.Obj.prototype.asObj">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>asObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prototype = extend$((import$(Import, superclass).displayName = &#x27;Import&#x27;, Import), superclass).prototype, constructor
 = Import;
function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.<span class="apidocCodeKeywordSpan">asObj</span>().items));
  }
  return this$;
} function ctor$(){} ctor$.prototype = prototype;
Import.prototype.children = [&#x27;left&#x27;, &#x27;right&#x27;];
Import.prototype.show = function(){
  return this.all;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.compileNode" id="apidoc.element.livescript.ast.Obj.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var items, code, idt, dic, i$, len$, i, node, logic, rest, ref$, multi, key, val;
  items = this.items;
  if (!items.length) {
    return sn(this, this.front ? &#x27;({})&#x27; : &#x27;{}&#x27;);
  }
  code = [];
  idt = &#x27;\n&#x27; + (o.indent += TAB);
  dic = {};
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      code.push(idt, node.compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Splat || (node.key || node) instanceof Parens) {
      rest = items.slice(i);
      break;
    }
    if (logic) {
      if (node instanceof Prop) {
        node.val = (logic.first = node.val, logic);
      } else {
        node = Prop(node, (logic.first = node, logic));
      }
    }
    if (this.deepEq &#x26;&#x26; node instanceof Prop) {
      if (node.val instanceof Var &#x26;&#x26; node.val.value === &#x27;_&#x27;) {
        node.val = Obj([Prop(Key(&#x27;__placeholder__&#x27;), Literal(true))]);
      } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
        node.val.deepEq = true;
      }
    }
    if (multi) {
      code.push(&#x27;,&#x27;);
    } else {
      multi = true;
    }
    code.push(idt);
    if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        code.push(node.compileAccessor(o, key = key.compile(o)));
      } else {
        val.ripName(key);
        code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
      }
    } else {
      code.push(key = node.compile(o), &#x22;: &#x22;, key);
    }
    ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
    if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
      node.carp(&#x22;duplicate property \&#x22;&#x22; + key + &#x22;\&#x22;&#x22;);
    }
  }
  if (code.join(&#x22;&#x22;)) {
    code.push(&#x27;\n&#x27; + this.tab);
  }
  code = sn.apply(null, [null, sn(this, &#x22;{&#x22;)].concat(slice$.call(code), [sn(this, &#x22;}&#x22;)]));
  rest &#x26;&#x26; (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
  if (this.front &#x26;&#x26; &#x27;{&#x27; === code.toString().charAt()) {
    return sn(null, &#x22;(&#x22;, code, &#x22;)&#x22;);
  } else {
    return code;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.constructor" id="apidoc.element.livescript.ast.Obj.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>constructor
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.toSlice" id="apidoc.element.livescript.ast.Obj.prototype.toSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>toSlice
        <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSlice = function (o, base, symbol, assign){
  var items, ref$, ref, temps, i$, len$, i, node, name, chain, logic, key, val;
  items = this.items;
  if (items.length &#x3e; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      continue;
    }
    if (node instanceof Prop || node instanceof Splat) {
      node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
    } else {
      if (logic = node.getDefault()) {
        node = node.first;
      }
      if (node instanceof Parens) {
        ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
        if (assign) {
          ref$ = [node, key], key = ref$[0], node = ref$[1];
        }
        key = Parens(key);
      } else {
        key = node;
      }
      val = chain = Chain(base, [Index(node.maybeKey(), symbol)]);
      if (logic) {
        val = (logic.first = val, logic);
      }
      items[i] = Prop(key, val);
    }
    base = ref;
  }
  chain || this.carp(&#x27;empty slice&#x27;);
  if (temps) {
    (chain.head = Var(temps[0])).temp = true;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &#x26;&#x26; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp(&#x27;calling a slice&#x27;);
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.<span class="apidocCodeKeywordSpan">toSlice</span>(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
};
return Chain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Obj.prototype.compileNode" id="apidoc.module.livescript.ast.Obj.prototype.compileNode">module livescript.ast.Obj.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Obj.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var items, code, idt, dic, i$, len$, i, node, logic, rest, ref$, multi, key, val;
  items = this.items;
  if (!items.length) {
    return sn(this, this.front ? &#x27;({})&#x27; : &#x27;{}&#x27;);
  }
  code = [];
  idt = &#x27;\n&#x27; + (o.indent += TAB);
  dic = {};
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      code.push(idt, node.compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Splat || (node.key || node) instanceof Parens) {
      rest = items.slice(i);
      break;
    }
    if (logic) {
      if (node instanceof Prop) {
        node.val = (logic.first = node.val, logic);
      } else {
        node = Prop(node, (logic.first = node, logic));
      }
    }
    if (this.deepEq &#x26;&#x26; node instanceof Prop) {
      if (node.val instanceof Var &#x26;&#x26; node.val.value === &#x27;_&#x27;) {
        node.val = Obj([Prop(Key(&#x27;__placeholder__&#x27;), Literal(true))]);
      } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
        node.val.deepEq = true;
      }
    }
    if (multi) {
      code.push(&#x27;,&#x27;);
    } else {
      multi = true;
    }
    code.push(idt);
    if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        code.push(node.compileAccessor(o, key = key.compile(o)));
      } else {
        val.ripName(key);
        code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
      }
    } else {
      code.push(key = node.compile(o), &#x22;: &#x22;, key);
    }
    ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
    if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
      node.carp(&#x22;duplicate property \&#x22;&#x22; + key + &#x22;\&#x22;&#x22;);
    }
  }
  if (code.join(&#x22;&#x22;)) {
    code.push(&#x27;\n&#x27; + this.tab);
  }
  code = sn.apply(null, [null, sn(this, &#x22;{&#x22;)].concat(slice$.call(code), [sn(this, &#x22;}&#x22;)]));
  rest &#x26;&#x26; (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
  if (this.front &#x26;&#x26; &#x27;{&#x27; === code.toString().charAt()) {
    return sn(null, &#x22;(&#x22;, code, &#x22;)&#x22;);
  } else {
    return code;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Obj.prototype.toSlice" id="apidoc.module.livescript.ast.Obj.prototype.toSlice">module livescript.ast.Obj.prototype.toSlice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.toSlice.toSlice" id="apidoc.element.livescript.ast.Obj.prototype.toSlice.toSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>toSlice
        <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSlice = function (o, base, symbol, assign){
  var items, ref$, ref, temps, i$, len$, i, node, name, chain, logic, key, val;
  items = this.items;
  if (items.length &#x3e; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      continue;
    }
    if (node instanceof Prop || node instanceof Splat) {
      node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
    } else {
      if (logic = node.getDefault()) {
        node = node.first;
      }
      if (node instanceof Parens) {
        ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
        if (assign) {
          ref$ = [node, key], key = ref$[0], node = ref$[1];
        }
        key = Parens(key);
      } else {
        key = node;
      }
      val = chain = Chain(base, [Index(node.maybeKey(), symbol)]);
      if (logic) {
        val = (logic.first = val, logic);
      }
      items[i] = Prop(key, val);
    }
    base = ref;
  }
  chain || this.carp(&#x27;empty slice&#x27;);
  if (temps) {
    (chain.head = Var(temps[0])).temp = true;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &#x26;&#x26; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp(&#x27;calling a slice&#x27;);
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.<span class="apidocCodeKeywordSpan">toSlice</span>(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
};
return Chain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens" id="apidoc.module.livescript.ast.Parens">module livescript.ast.Parens</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.Parens" id="apidoc.element.livescript.ast.Parens.Parens">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 161:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], true)), yy.L(_$[$0-1],_$[$0-1],yy.Literal($$[$0-1] === &#
x27;+&#x27;))));
break;
case 168:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-2]);
break;
case 169:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Parens</span>($$[$0-1].chomp().unwrap(), false, $$[$0-2] === &#
x27;&#x22;&#x27;, yy.L(_$[$0-2],_$[$0-2],{}), yy.L(_$[$0],_$[$0],{})));
break;
case 173: case 209: case 211:
this.$ = yy.L(_$[$0], _$[$0],null);
break;
case 174: case 208: case 210:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.superclass" id="apidoc.element.livescript.ast.Parens.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype" id="apidoc.module.livescript.ast.Parens.prototype">module livescript.ast.Parens.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.compile" id="apidoc.element.livescript.ast.Parens.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var it;
  level == null &#x26;&#x26; (level = o.level);
  it = this.it;
  it.cond || (it.cond = this.cond), it[&#x27;void&#x27;] || (it[&#x27;void&#x27;] = this[&#x27;void&#x27;]);
  if (this.calling &#x26;&#x26; (!level || this[&#x27;void&#x27;])) {
    it.head.hushed = true;
  }
  if (!(this.keep || this.newed || level &#x3e;= LEVEL_OP + PREC[it.op])) {
    return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
  }
  if (it.isStatement()) {
    return it.compileClosure(o);
  } else {
    return sn(null, sn(this.lb, &#x22;(&#x22;), it.compile(o, LEVEL_PAREN), sn(this.rb, &#x22;)&#x22;));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.constructor" id="apidoc.element.livescript.ast.Parens.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isArray" id="apidoc.element.livescript.ast.Parens.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isCallable" id="apidoc.element.livescript.ast.Parens.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isComplex" id="apidoc.element.livescript.ast.Parens.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isComplex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isRegex" id="apidoc.element.livescript.ast.Parens.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isString" id="apidoc.element.livescript.ast.Parens.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  return this.string || this.it.isString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.show" id="apidoc.element.livescript.ast.Parens.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.string &#x26;&#x26; &#x27;&#x22;&#x22;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.unparen" id="apidoc.element.livescript.ast.Parens.prototype.unparen">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>unparen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unparen = function (){
  if (this.keep) {
    return this;
  } else {
    return this.it.unparen();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Block.prototype.children = [&#x27;lines&#x27;];
Block.prototype.toJSON = function(){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
};
Block.prototype.add = function(it){
  var that, ref$;
  it = it.<span class="apidocCodeKeywordSpan">unparen</span>();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.compile" id="apidoc.module.livescript.ast.Parens.prototype.compile">module livescript.ast.Parens.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.compile.compile" id="apidoc.element.livescript.ast.Parens.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var it;
  level == null &#x26;&#x26; (level = o.level);
  it = this.it;
  it.cond || (it.cond = this.cond), it[&#x27;void&#x27;] || (it[&#x27;void&#x27;] = this[&#x27;void&#x27;]);
  if (this.calling &#x26;&#x26; (!level || this[&#x27;void&#x27;])) {
    it.head.hushed = true;
  }
  if (!(this.keep || this.newed || level &#x3e;= LEVEL_OP + PREC[it.op])) {
    return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
  }
  if (it.isStatement()) {
    return it.compileClosure(o);
  } else {
    return sn(null, sn(this.lb, &#x22;(&#x22;), it.compile(o, LEVEL_PAREN), sn(this.rb, &#x22;)&#x22;));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.isComplex" id="apidoc.module.livescript.ast.Parens.prototype.isComplex">module livescript.ast.Parens.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Parens.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isComplex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.isRegex" id="apidoc.module.livescript.ast.Parens.prototype.isRegex">module livescript.ast.Parens.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Parens.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.isString" id="apidoc.module.livescript.ast.Parens.prototype.isString">module livescript.ast.Parens.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isString.isString" id="apidoc.element.livescript.ast.Parens.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  return this.string || this.it.isString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.show" id="apidoc.module.livescript.ast.Parens.prototype.show">module livescript.ast.Parens.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.show.show" id="apidoc.element.livescript.ast.Parens.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.string &#x26;&#x26; &#x27;&#x22;&#x22;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.unparen" id="apidoc.module.livescript.ast.Parens.prototype.unparen">module livescript.ast.Parens.prototype.unparen</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.unparen.unparen" id="apidoc.element.livescript.ast.Parens.prototype.unparen.unparen">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>unparen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unparen = function (){
  if (this.keep) {
    return this;
  } else {
    return this.it.unparen();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Block.prototype.children = [&#x27;lines&#x27;];
Block.prototype.toJSON = function(){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
};
Block.prototype.add = function(it){
  var that, ref$;
  it = it.<span class="apidocCodeKeywordSpan">unparen</span>();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop" id="apidoc.module.livescript.ast.Prop">module livescript.ast.Prop</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.Prop" id="apidoc.element.livescript.ast.Prop.Prop">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === &#x27;...&#x27;) {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
    }
    this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Prop</span>(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27
;arguments&#x27; &#x26;&#x26; $$[$0] !== &#x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
case 152:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Literal($$[$0-2])), [yy.L(_$[$0-1],_$[$0], yy.
Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.superclass" id="apidoc.element.livescript.ast.Prop.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype" id="apidoc.module.livescript.ast.Prop.prototype">module livescript.ast.Prop.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.assigns" id="apidoc.element.livescript.ast.Prop.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  var ref$;
  return typeof (ref$ = this.val).assigns == &#x27;function&#x27; ? ref$.assigns(it) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor" id="apidoc.element.livescript.ast.Prop.prototype.compileAccessor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileAccessor
        <span class="apidocSignatureSpan">(o, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAccessor = function (o, key){
  var funs, code, i$, len$, fun;
  funs = this.val;
  if (funs[1] &#x26;&#x26; funs[0].params.length + funs[1].params.length !== 1) {
    funs[0].carp(&#x27;invalid accessor parameter&#x27;);
  }
  code = [];
  for (i$ = 0, len$ = funs.length; i$ &#x3c; len$; ++i$) {
    fun = funs[i$];
    fun.accessor = true;
    code.push(fun.x, &#x22;et &#x22;, key, fun.compile(o, LEVEL_LIST).toString().slice(8), &#x27;,\n&#x27; + o.indent);
  }
  code.pop();
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  multi = true;
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.<span class="apidocCodeKeywordSpan">compileAccessor</span>(o, key = key.compile(o)));
  } else {
    val.ripName(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor" id="apidoc.element.livescript.ast.Prop.prototype.compileDescriptor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileDescriptor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDescriptor = function (o){
  var obj, i$, ref$, len$, fun;
  obj = Obj();
  for (i$ = 0, len$ = (ref$ = this.val).length; i$ &#x3c; len$; ++i$) {
    fun = ref$[i$];
    obj.items.push(Prop(Key(fun.x + &#x27;et&#x27;), fun));
  }
  obj.items.push(Prop(Key(&#x27;configurable&#x27;), Literal(true)));
  obj.items.push(Prop(Key(&#x27;enumerable&#x27;), Literal(true)));
  return obj.compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
} else if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    if (key instanceof Key) {
      key = JS(&#x22;&#x27;&#x22; + key.name + &#x22;&#x27;&#x22;);
    }
    code.push(&#x22;Object.defineProperty(&#x22;, reft.compile(o, LEVEL_LIST), &#x22;, &#x22;, key.compile(o, LEVEL_LIST), &#x22
;, &#x22;, node.<span class="apidocCodeKeywordSpan">compileDescriptor</span>(o), &#x22;)&#x22;);
    continue;
  }
} else {
  key = val = node;
}
dyna || (key = key.maybeKey());
logic &#x26;&#x26; (val = (logic.first = val, logic));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.constructor" id="apidoc.element.livescript.ast.Prop.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>constructor
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === &#x27;...&#x27;) {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
    }
    this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.show" id="apidoc.element.livescript.ast.Prop.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.accessor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype.assigns" id="apidoc.module.livescript.ast.Prop.prototype.assigns">module livescript.ast.Prop.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Prop.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  var ref$;
  return typeof (ref$ = this.val).assigns == &#x27;function&#x27; ? ref$.assigns(it) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype.compileAccessor" id="apidoc.module.livescript.ast.Prop.prototype.compileAccessor">module livescript.ast.Prop.prototype.compileAccessor</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor.compileAccessor" id="apidoc.element.livescript.ast.Prop.prototype.compileAccessor.compileAccessor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileAccessor
        <span class="apidocSignatureSpan">(o, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAccessor = function (o, key){
  var funs, code, i$, len$, fun;
  funs = this.val;
  if (funs[1] &#x26;&#x26; funs[0].params.length + funs[1].params.length !== 1) {
    funs[0].carp(&#x27;invalid accessor parameter&#x27;);
  }
  code = [];
  for (i$ = 0, len$ = funs.length; i$ &#x3c; len$; ++i$) {
    fun = funs[i$];
    fun.accessor = true;
    code.push(fun.x, &#x22;et &#x22;, key, fun.compile(o, LEVEL_LIST).toString().slice(8), &#x27;,\n&#x27; + o.indent);
  }
  code.pop();
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  multi = true;
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.<span class="apidocCodeKeywordSpan">compileAccessor</span>(o, key = key.compile(o)));
  } else {
    val.ripName(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype.compileDescriptor" id="apidoc.module.livescript.ast.Prop.prototype.compileDescriptor">module livescript.ast.Prop.prototype.compileDescriptor</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor.compileDescriptor" id="apidoc.element.livescript.ast.Prop.prototype.compileDescriptor.compileDescriptor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileDescriptor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDescriptor = function (o){
  var obj, i$, ref$, len$, fun;
  obj = Obj();
  for (i$ = 0, len$ = (ref$ = this.val).length; i$ &#x3c; len$; ++i$) {
    fun = ref$[i$];
    obj.items.push(Prop(Key(fun.x + &#x27;et&#x27;), fun));
  }
  obj.items.push(Prop(Key(&#x27;configurable&#x27;), Literal(true)));
  obj.items.push(Prop(Key(&#x27;enumerable&#x27;), Literal(true)));
  return obj.compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
} else if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    if (key instanceof Key) {
      key = JS(&#x22;&#x27;&#x22; + key.name + &#x22;&#x27;&#x22;);
    }
    code.push(&#x22;Object.defineProperty(&#x22;, reft.compile(o, LEVEL_LIST), &#x22;, &#x22;, key.compile(o, LEVEL_LIST), &#x22
;, &#x22;, node.<span class="apidocCodeKeywordSpan">compileDescriptor</span>(o), &#x22;)&#x22;);
    continue;
  }
} else {
  key = val = node;
}
dyna || (key = key.maybeKey());
logic &#x26;&#x26; (val = (logic.first = val, logic));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype.show" id="apidoc.module.livescript.ast.Prop.prototype.show">module livescript.ast.Prop.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.show.show" id="apidoc.element.livescript.ast.Prop.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.accessor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Require" id="apidoc.module.livescript.ast.Require">module livescript.ast.Require</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Require.Require" id="apidoc.element.livescript.ast.Require.Require">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Require
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Require</span>($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require.superclass" id="apidoc.element.livescript.ast.Require.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Require.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Require.prototype" id="apidoc.module.livescript.ast.Require.prototype">module livescript.ast.Require.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Require.prototype.compile" id="apidoc.element.livescript.ast.Require.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
  getValue = function(item, throwError){
    switch (false) {
    case !(item instanceof Key):
      return item.name;
    case !(item instanceof Var):
      return item.value;
    case !(item instanceof Literal):
      return item.value;
    default:
      if (throwError) {
        return this$.carp(&#x27;invalid require! argument&#x27;);
      } else {
        return item;
      }
    }
  };
  processItem = function(item){
    var ref$, asg, value, asgValue, toAsg, main;
    ref$ = (function(){
      switch (false) {
      case !(item instanceof Prop):
        return [item.val, item.key];
      default:
        return [item, item];
      }
    }()), asg = ref$[0], value = ref$[1];
    asgValue = getValue(asg);
    toAsg = toString$.call(asgValue).slice(8, -1) === &#x27;String&#x27; ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
    value = stripString(getValue(value, true));
    main = Chain(CopyL(this, Var(&#x27;require&#x27;))).add(Call([Literal(&#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22;)]));
    return sn(item, Assign(toAsg, main).compile(o));
  };
  if (this.body.items != null) {
    code = [];
    for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ &#x3c; len$; ++i$) {
      item = ref$[i$];
      code.push(processItem(item), &#x22;;\n&#x22; + o.indent);
    }
    code.pop();
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, processItem(this.body));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require.prototype.constructor" id="apidoc.element.livescript.ast.Require.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>constructor
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Require.prototype.compile" id="apidoc.module.livescript.ast.Require.prototype.compile">module livescript.ast.Require.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Require.prototype.compile.compile" id="apidoc.element.livescript.ast.Require.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
  getValue = function(item, throwError){
    switch (false) {
    case !(item instanceof Key):
      return item.name;
    case !(item instanceof Var):
      return item.value;
    case !(item instanceof Literal):
      return item.value;
    default:
      if (throwError) {
        return this$.carp(&#x27;invalid require! argument&#x27;);
      } else {
        return item;
      }
    }
  };
  processItem = function(item){
    var ref$, asg, value, asgValue, toAsg, main;
    ref$ = (function(){
      switch (false) {
      case !(item instanceof Prop):
        return [item.val, item.key];
      default:
        return [item, item];
      }
    }()), asg = ref$[0], value = ref$[1];
    asgValue = getValue(asg);
    toAsg = toString$.call(asgValue).slice(8, -1) === &#x27;String&#x27; ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
    value = stripString(getValue(value, true));
    main = Chain(CopyL(this, Var(&#x27;require&#x27;))).add(Call([Literal(&#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22;)]));
    return sn(item, Assign(toAsg, main).compile(o));
  };
  if (this.body.items != null) {
    code = [];
    for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ &#x3c; len$; ++i$) {
      item = ref$[i$];
      code.push(processItem(item), &#x22;;\n&#x22; + o.indent);
    }
    code.pop();
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, processItem(this.body));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Return" id="apidoc.module.livescript.ast.Return">module livescript.ast.Return</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Return.Return" id="apidoc.element.livescript.ast.Return.Return">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &#x26;&#x26; it.value !== &#x27;void&#x27;) {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.extended" id="apidoc.element.livescript.ast.Return.extended">
        function <span class="apidocSignatureSpan">livescript.ast.Return.</span>extended
        <span class="apidocSignatureSpan">(sub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extended = function (sub){
  sub.prototype.children = [&#x27;it&#x27;];
  this[sub.displayName.toLowerCase()] = sub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function THIS(){
return this;
}
function VOID(){}
UTILS = {
clone: &#x27;function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}&#x27;,
extend: &#x27;function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new
fun).constructor = sub;\n  if (typeof sup.extended == \&#x27;function\&#x27;) sup.<span class="apidocCodeKeywordSpan">extended</span>(sub);\n  return sub;\n}&#x27;,
bind: &#x27;function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}&#x27;,
&#x27;import&#x27;: &#x27;function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj
[key] = src[key];\n  return obj;\n}&#x27;,
importAll: &#x27;function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}&#x27;,
repeatString: &#x27;function(str, n){\n  for (var r = \&#x27;\&#x27;; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (str += str))
if (n &#x26; 1) r += str;\n  return r;\n}&#x27;,
repeatArray: &#x27;function(arr, n){\n  for (var r = []; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (arr = arr.concat(arr)))\n
    if (n &#x26; 1) r.push.apply(r, arr);\n  return r;\n}&#x27;,
&#x27;in&#x27;: &#x27;function(x, xs){\n  var i = -1, l = xs.length &#x3e;&#x3e;&#x3e; 0;\n  while (++i &#x3c; l) if (x === xs[i
]) return true;\n  return false;\n}&#x27;,
out: &#x27;typeof exports != \&#x27;undefined\&#x27; &#x26;&#x26; exports || this&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.superclass" id="apidoc.element.livescript.ast.Return.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Return.</span>superclass
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.throw" id="apidoc.element.livescript.ast.Return.throw">
        function <span class="apidocSignatureSpan">livescript.ast.Return.</span>throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Return.prototype" id="apidoc.module.livescript.ast.Return.prototype">module livescript.ast.Return.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.compileNode" id="apidoc.element.livescript.ast.Return.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that;
  return sn.apply(null, [this, &#x22;return&#x22;].concat(
    (that = this.it)
      ? [&#x27; &#x27;, that.compile(o, LEVEL_PAREN)]
      : [], [&#x22;;&#x22;]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.constructor" id="apidoc.element.livescript.ast.Return.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &#x26;&#x26; it.value !== &#x27;void&#x27;) {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.getJump" id="apidoc.element.livescript.ast.Return.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Return.prototype.compileNode" id="apidoc.module.livescript.ast.Return.prototype.compileNode">module livescript.ast.Return.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Return.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that;
  return sn.apply(null, [this, &#x22;return&#x22;].concat(
    (that = this.it)
      ? [&#x27; &#x27;, that.compile(o, LEVEL_PAREN)]
      : [], [&#x22;;&#x22;]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Slice" id="apidoc.module.livescript.ast.Slice">module livescript.ast.Slice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.Slice" id="apidoc.element.livescript.ast.Slice.Slice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &#x26;&#x26; (this$.from = Literal(0));
  if (this$.to &#x26;&#x26; this$.type === &#x27;to&#x27;) {
    this$.to = Binary(&#x27;+&#x27;, this$.to, Literal(&#x27;1&#x27;));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        target: $$[$0-7],
        from: yy.Literal(0),
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
case 37:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], yy.<span class="apidocCodeKeywordSpan">Slice</span>({
        type: $$[$0-2],
        target: $$[$0-6],
        from: $$[$0-3],
        to: $$[$0-1]
      }))));
break;
case 38:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.superclass" id="apidoc.element.livescript.ast.Slice.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Slice.prototype" id="apidoc.module.livescript.ast.Slice.prototype">module livescript.ast.Slice.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.compileNode" id="apidoc.element.livescript.ast.Slice.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var args;
  if (this.to &#x26;&#x26; this.type === &#x27;to&#x27;) {
    this.to = Binary(&#x27;||&#x27;, this.to, Literal(&#x27;9e9&#x27;));
  }
  args = [this.target, this.from];
  if (this.to) {
    args.push(this.to);
  }
  return Chain(Var(util(&#x27;slice&#x27;))).add(Index(Key(&#x27;call&#x27;), &#x27;.&#x27;, true)).add(Call(args)).compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.constructor" id="apidoc.element.livescript.ast.Slice.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>constructor
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &#x26;&#x26; (this$.from = Literal(0));
  if (this$.to &#x26;&#x26; this$.type === &#x27;to&#x27;) {
    this$.to = Binary(&#x27;+&#x27;, this$.to, Literal(&#x27;1&#x27;));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.show" id="apidoc.element.livescript.ast.Slice.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Slice.prototype.compileNode" id="apidoc.module.livescript.ast.Slice.prototype.compileNode">module livescript.ast.Slice.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Slice.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var args;
  if (this.to &#x26;&#x26; this.type === &#x27;to&#x27;) {
    this.to = Binary(&#x27;||&#x27;, this.to, Literal(&#x27;9e9&#x27;));
  }
  args = [this.target, this.from];
  if (this.to) {
    args.push(this.to);
  }
  return Chain(Var(util(&#x27;slice&#x27;))).add(Index(Key(&#x27;call&#x27;), &#x27;.&#x27;, true)).add(Call(args)).compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Slice.prototype.show" id="apidoc.module.livescript.ast.Slice.prototype.show">module livescript.ast.Slice.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.show.show" id="apidoc.element.livescript.ast.Slice.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Splat" id="apidoc.module.livescript.ast.Splat">module livescript.ast.Splat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.Splat" id="apidoc.element.livescript.ast.Splat.Splat">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 54: case 167:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat($$[$0]));
break;
case 55:
this.$ = yy.L(_$[$0-5], _$[$0-2],$$[$0-5].concat($$[$0-2]));
break;
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Splat</span>($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.Block());
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.compileArray" id="apidoc.element.livescript.ast.Splat.compileArray">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>compileArray
        <span class="apidocSignatureSpan">(o, list, apply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileArray = function (o, list, apply){
  var index, i$, len$, node, args, atoms, ref$;
  expand(list);
  index = 0;
  for (i$ = 0, len$ = list.length; i$ &#x3c; len$; ++i$) {
    node = list[i$];
    if (node instanceof Splat) {
      break;
    }
    ++index;
  }
  if (index &#x3e;= list.length) {
    return sn(this, &#x27;&#x27;);
  }
  if (!list[1]) {
    return sn(this, (apply ? Object : ensureArray)(list[0].it).compile(o, LEVEL_LIST));
  }
  args = [];
  atoms = [];
  for (i$ = 0, len$ = (ref$ = list.splice(index, 9e9)).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node instanceof Splat) {
      if (atoms.length) {
        args.push(Arr(atoms.splice(0, 9e9)));
      }
      args.push(ensureArray(node.it));
    } else {
      atoms.push(node);
    }
  }
  if (atoms.length) {
    args.push(Arr(atoms));
  }
  return sn(null, (index
    ? Arr(list)
    : args.shift()).compile(o, LEVEL_CALL), sn(this, &#x22;.concat(&#x22;), List.compile(o, args), sn(this, &#x22;)&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
tails = this.tails;
i = -1;
while (call = tails[++i]) {
  if (!(args = call.args)) {
    continue;
  }
  ctx = call.method === &#x27;.call&#x27; &#x26;&#x26; (args = args.concat()).shift();
  if (!!snEmpty(args = Splat.<span class="apidocCodeKeywordSpan">compileArray</span>(o, args, true))) {
    continue;
  }
  if (call[&#x27;new&#x27;]) {
    this.splattedNewArgs = args;
  } else {
    if (!ctx &#x26;&#x26; tails[i - 1] instanceof Index) {
      ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.superclass" id="apidoc.element.livescript.ast.Splat.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Splat.prototype" id="apidoc.module.livescript.ast.Splat.prototype">module livescript.ast.Splat.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.assigns" id="apidoc.element.livescript.ast.Splat.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return this.it.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.compile" id="apidoc.element.livescript.ast.Splat.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return this.carp(&#x27;invalid splat&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.constructor" id="apidoc.element.livescript.ast.Splat.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.isAssignable" id="apidoc.element.livescript.ast.Splat.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.isComplex" id="apidoc.element.livescript.ast.Splat.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isComplex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Splat.prototype.assigns" id="apidoc.module.livescript.ast.Splat.prototype.assigns">module livescript.ast.Splat.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Splat.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return this.it.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Splat.prototype.compile" id="apidoc.module.livescript.ast.Splat.prototype.compile">module livescript.ast.Splat.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.compile.compile" id="apidoc.element.livescript.ast.Splat.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return this.carp(&#x27;invalid splat&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.StepSlice" id="apidoc.module.livescript.ast.StepSlice">module livescript.ast.StepSlice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.StepSlice" id="apidoc.element.livescript.ast.StepSlice.StepSlice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        op: $$[$0-4],
        to: $$[$0-3],
        step: $$[$0-1],
        inComprehension: true
      }))));
break;
case 35:
this.$ = yy.L(_$[$0-8], _$[$0],yy.Chain(yy.L(_$[$0-8],_$[$0], new yy.<span class="apidocCodeKeywordSpan">StepSlice</span>({
        op: $$[$0-4],
        target: $$[$0-8],
        from: $$[$0-5],
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.superclass" id="apidoc.element.livescript.ast.StepSlice.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.</span>superclass
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &#x26;&#x26; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &#x3c; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &#x26;&#x26; !this.object) {
    this.carp(&#x27;`for own` requires `of`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.StepSlice.prototype" id="apidoc.module.livescript.ast.StepSlice.prototype">module livescript.ast.StepSlice.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode" id="apidoc.element.livescript.ast.StepSlice.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var ref$, sub, ref, temps, code;
  this.index = o.scope.temporary(&#x27;x&#x27;);
  ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
  this.guard = Binary(&#x27;&#x3c;&#x27;, Literal(this.index), Chain(ref).add(Index(Key(&#x27;length&#x27;))));
  this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
  if (this.makeReturnArg != null) {
    this.makeReturn(this.makeReturnArg);
  }
  code = [];
  if (temps) {
    code.push(sub.compile(o), &#x27;;&#x27; + &#x27;\n&#x27; + o.indent);
  }
  code.push(superclass.prototype.compileNode.apply(this, arguments));
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.constructor" id="apidoc.element.livescript.ast.StepSlice.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn" id="apidoc.element.livescript.ast.StepSlice.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(makeReturnArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (makeReturnArg){
  this.makeReturnArg = makeReturnArg;
  return superclass.prototype.makeReturn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.StepSlice.prototype.compileNode" id="apidoc.module.livescript.ast.StepSlice.prototype.compileNode">module livescript.ast.StepSlice.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.StepSlice.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var ref$, sub, ref, temps, code;
  this.index = o.scope.temporary(&#x27;x&#x27;);
  ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
  this.guard = Binary(&#x27;&#x3c;&#x27;, Literal(this.index), Chain(ref).add(Index(Key(&#x27;length&#x27;))));
  this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
  if (this.makeReturnArg != null) {
    this.makeReturn(this.makeReturnArg);
  }
  code = [];
  if (temps) {
    code.push(sub.compile(o), &#x27;;&#x27; + &#x27;\n&#x27; + o.indent);
  }
  code.push(superclass.prototype.compileNode.apply(this, arguments));
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.StepSlice.prototype.makeReturn" id="apidoc.module.livescript.ast.StepSlice.prototype.makeReturn">module livescript.ast.StepSlice.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.StepSlice.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(makeReturnArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (makeReturnArg){
  this.makeReturnArg = makeReturnArg;
  return superclass.prototype.makeReturn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Super" id="apidoc.module.livescript.ast.Super">module livescript.ast.Super</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Super.Super" id="apidoc.element.livescript.ast.Super.Super">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.superclass" id="apidoc.element.livescript.ast.Super.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Super.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Super.prototype" id="apidoc.module.livescript.ast.Super.prototype">module livescript.ast.Super.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.compile" id="apidoc.element.livescript.ast.Super.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var scope, that, result, ref$;
  scope = o.scope;
  if (!this.sproto) {
    for (; that = !scope.get(&#x27;superclass&#x27;) &#x26;&#x26; scope.fun; scope = scope.parent) {
      result = that;
      if (that = result.meth) {
        return sn(this, &#x27;superclass.prototype&#x27;, Index(that).compile(o));
      }
      if (that = result.stat) {
        return sn(this, &#x27;superclass&#x27;, Index(that).compile(o));
      }
      if (that = scope.fun.inClass) {
        return sn(this, that, &#x22;.superclass.prototype.&#x22;, scope.fun.name);
      } else if (that = scope.fun.inClassStatic) {
        return sn(this, that, &#x22;.superclass.&#x22;, scope.fun.name);
      }
    }
    if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
      return sn(this, that, &#x22;.superclass&#x22;);
    }
  }
  return sn(this, &#x27;superclass&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.constructor" id="apidoc.element.livescript.ast.Super.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.isCallable" id="apidoc.element.livescript.ast.Super.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Super.prototype.compile" id="apidoc.module.livescript.ast.Super.prototype.compile">module livescript.ast.Super.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.compile.compile" id="apidoc.element.livescript.ast.Super.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var scope, that, result, ref$;
  scope = o.scope;
  if (!this.sproto) {
    for (; that = !scope.get(&#x27;superclass&#x27;) &#x26;&#x26; scope.fun; scope = scope.parent) {
      result = that;
      if (that = result.meth) {
        return sn(this, &#x27;superclass.prototype&#x27;, Index(that).compile(o));
      }
      if (that = result.stat) {
        return sn(this, &#x27;superclass&#x27;, Index(that).compile(o));
      }
      if (that = scope.fun.inClass) {
        return sn(this, that, &#x22;.superclass.prototype.&#x22;, scope.fun.name);
      } else if (that = scope.fun.inClassStatic) {
        return sn(this, that, &#x22;.superclass.&#x22;, scope.fun.name);
      }
    }
    if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
      return sn(this, that, &#x22;.superclass&#x22;);
    }
  }
  return sn(this, &#x27;superclass&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch" id="apidoc.module.livescript.ast.Switch">module livescript.ast.Switch</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.Switch" id="apidoc.element.livescript.ast.Switch.Switch">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this[&#x27;default&#x27;] = $default;
  if (type === &#x27;match&#x27;) {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &#x3e; 1) {
        throw &#x22;can&#x27;t have more than one topic in switch statement&#x22;;
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &#x26;&#x26; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &#x26;&#x26; last.tests[0] instanceof Var &#x26;&#x26; last
.tests[0].value === &#x27;_&#x27;) {
    this.cases.pop();
    this[&#x27;default&#x27;] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.Jump($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Switch</span>($$[$0-2], $$[$0-1], $$[$0]));
break;
case 129: case 130:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]));
break;
case 131:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.superclass" id="apidoc.element.livescript.ast.Switch.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype" id="apidoc.module.livescript.ast.Switch.prototype">module livescript.ast.Switch.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.compileNode" id="apidoc.element.livescript.ast.Switch.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var tab, ref$, targetNode, target, topic, t, code, stop, i$, len$, i, c, that;
  tab = this.tab;
  if (this.target) {
    ref$ = Chain(this.target).cacheReference(o), targetNode = ref$[0], target = ref$[1];
  }
  topic = this.type === &#x27;match&#x27;
    ? (t = target
      ? [targetNode]
      : [], Block(t.concat([Literal(&#x27;false&#x27;)])).compile(o, LEVEL_PAREN))
    : !!this.topic &#x26;&#x26; this.anaphorize().compile(o, LEVEL_PAREN);
  code = [sn(this, &#x22;switch (&#x22;, snSafe(topic), &#x22;) {\n&#x22;)];
  stop = this[&#x27;default&#x27;] || this.cases.length - 1;
  o[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    c = ref$[i$];
    code.push(c.compileCase(o, tab, i === stop, this.type === &#x27;match&#x27; || !topic, this.type, target));
  }
  if (this[&#x27;default&#x27;]) {
    o.indent = tab + TAB;
    if (that = this[&#x27;default&#x27;].compile(o, LEVEL_TOP)) {
      code.push(tab + &#x22;default:\n&#x22;, that, &#x22;\n&#x22;);
    }
  }
  return sn.apply(null, [null].concat(slice$.call(code), [tab + &#x27;}&#x27;]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.constructor" id="apidoc.element.livescript.ast.Switch.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>constructor
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this[&#x27;default&#x27;] = $default;
  if (type === &#x27;match&#x27;) {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &#x3e; 1) {
        throw &#x22;can&#x27;t have more than one topic in switch statement&#x22;;
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &#x26;&#x26; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &#x26;&#x26; last.tests[0] instanceof Var &#x26;&#x26; last
.tests[0].value === &#x27;_&#x27;) {
    this.cases.pop();
    this[&#x27;default&#x27;] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.getJump" id="apidoc.element.livescript.ast.Switch.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var i$, ref$, len$, c, that;
  ctx || (ctx = {});
  ctx[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    if (that = c.body.getJump(ctx)) {
      return that;
    }
  }
  return (ref$ = this[&#x27;default&#x27;]) != null ? ref$.getJump(ctx) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.isCallable" id="apidoc.element.livescript.ast.Switch.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    if (!c.isCallable()) {
      return false;
    }
  }
  if (this[&#x27;default&#x27;]) {
    return this[&#x27;default&#x27;].isCallable();
  } else {
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.isStatement" id="apidoc.element.livescript.ast.Switch.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn" id="apidoc.element.livescript.ast.Switch.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    c.makeReturn.apply(c, arguments);
  }
  if ((ref$ = this[&#x27;default&#x27;]) != null) {
    ref$.makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.show" id="apidoc.element.livescript.ast.Switch.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype.compileNode" id="apidoc.module.livescript.ast.Switch.prototype.compileNode">module livescript.ast.Switch.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Switch.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var tab, ref$, targetNode, target, topic, t, code, stop, i$, len$, i, c, that;
  tab = this.tab;
  if (this.target) {
    ref$ = Chain(this.target).cacheReference(o), targetNode = ref$[0], target = ref$[1];
  }
  topic = this.type === &#x27;match&#x27;
    ? (t = target
      ? [targetNode]
      : [], Block(t.concat([Literal(&#x27;false&#x27;)])).compile(o, LEVEL_PAREN))
    : !!this.topic &#x26;&#x26; this.anaphorize().compile(o, LEVEL_PAREN);
  code = [sn(this, &#x22;switch (&#x22;, snSafe(topic), &#x22;) {\n&#x22;)];
  stop = this[&#x27;default&#x27;] || this.cases.length - 1;
  o[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    c = ref$[i$];
    code.push(c.compileCase(o, tab, i === stop, this.type === &#x27;match&#x27; || !topic, this.type, target));
  }
  if (this[&#x27;default&#x27;]) {
    o.indent = tab + TAB;
    if (that = this[&#x27;default&#x27;].compile(o, LEVEL_TOP)) {
      code.push(tab + &#x22;default:\n&#x22;, that, &#x22;\n&#x22;);
    }
  }
  return sn.apply(null, [null].concat(slice$.call(code), [tab + &#x27;}&#x27;]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype.getJump" id="apidoc.module.livescript.ast.Switch.prototype.getJump">module livescript.ast.Switch.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Switch.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var i$, ref$, len$, c, that;
  ctx || (ctx = {});
  ctx[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    if (that = c.body.getJump(ctx)) {
      return that;
    }
  }
  return (ref$ = this[&#x27;default&#x27;]) != null ? ref$.getJump(ctx) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype.isCallable" id="apidoc.module.livescript.ast.Switch.prototype.isCallable">module livescript.ast.Switch.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Switch.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    if (!c.isCallable()) {
      return false;
    }
  }
  if (this[&#x27;default&#x27;]) {
    return this[&#x27;default&#x27;].isCallable();
  } else {
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype.makeReturn" id="apidoc.module.livescript.ast.Switch.prototype.makeReturn">module livescript.ast.Switch.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Switch.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    c.makeReturn.apply(c, arguments);
  }
  if ((ref$ = this[&#x27;default&#x27;]) != null) {
    ref$.makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype.show" id="apidoc.module.livescript.ast.Switch.prototype.show">module livescript.ast.Switch.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.show.show" id="apidoc.element.livescript.ast.Switch.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Throw" id="apidoc.module.livescript.ast.Throw">module livescript.ast.Throw</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.Throw" id="apidoc.element.livescript.ast.Throw.Throw">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Throw</span>(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented
&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.extended" id="apidoc.element.livescript.ast.Throw.extended">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>extended
        <span class="apidocSignatureSpan">(sub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extended = function (sub){
  sub.prototype.children = [&#x27;it&#x27;];
  this[sub.displayName.toLowerCase()] = sub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function THIS(){
return this;
}
function VOID(){}
UTILS = {
clone: &#x27;function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}&#x27;,
extend: &#x27;function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new
fun).constructor = sub;\n  if (typeof sup.extended == \&#x27;function\&#x27;) sup.<span class="apidocCodeKeywordSpan">extended</span>(sub);\n  return sub;\n}&#x27;,
bind: &#x27;function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}&#x27;,
&#x27;import&#x27;: &#x27;function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj
[key] = src[key];\n  return obj;\n}&#x27;,
importAll: &#x27;function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}&#x27;,
repeatString: &#x27;function(str, n){\n  for (var r = \&#x27;\&#x27;; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (str += str))
if (n &#x26; 1) r += str;\n  return r;\n}&#x27;,
repeatArray: &#x27;function(arr, n){\n  for (var r = []; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (arr = arr.concat(arr)))\n
    if (n &#x26; 1) r.push.apply(r, arr);\n  return r;\n}&#x27;,
&#x27;in&#x27;: &#x27;function(x, xs){\n  var i = -1, l = xs.length &#x3e;&#x3e;&#x3e; 0;\n  while (++i &#x3c; l) if (x === xs[i
]) return true;\n  return false;\n}&#x27;,
out: &#x27;typeof exports != \&#x27;undefined\&#x27; &#x26;&#x26; exports || this&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.superclass" id="apidoc.element.livescript.ast.Throw.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>superclass
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Throw.prototype" id="apidoc.module.livescript.ast.Throw.prototype">module livescript.ast.Throw.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.compileNode" id="apidoc.element.livescript.ast.Throw.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var ref$;
  return sn(this, &#x22;throw &#x22;, ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;null&#x27;, &#x22;;&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.constructor" id="apidoc.element.livescript.ast.Throw.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.getJump" id="apidoc.element.livescript.ast.Throw.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Throw.prototype.compileNode" id="apidoc.module.livescript.ast.Throw.prototype.compileNode">module livescript.ast.Throw.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Throw.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var ref$;
  return sn(this, &#x22;throw &#x22;, ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;null&#x27;, &#x22;;&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Throw.prototype.getJump" id="apidoc.module.livescript.ast.Throw.prototype.getJump">module livescript.ast.Throw.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Throw.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try" id="apidoc.module.livescript.ast.Try">module livescript.ast.Try</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.Try" id="apidoc.element.livescript.ast.Try.Try">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Try
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var(&#x27;e&#x27;), Var(&#x27;e$&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 132: case 133:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]));
break;
case 134:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, [], $$[$0]));
break;
case 135:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Try</span>($$[$0]));
break;
case 136:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 137:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.Try($$[$0-4], void 8, yy.L(_$[$0-3],_$[$0-3],$$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.superclass" id="apidoc.element.livescript.ast.Try.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Try.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype" id="apidoc.module.livescript.ast.Try.prototype">module livescript.ast.Try.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.compileNode" id="apidoc.element.livescript.ast.Try.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var code, that;
  o.indent += TAB;
  code = [sn(this, &#x27;try &#x27;), this.compileBlock(o, this.attempt)];
  if (that = this.recovery || !this.ensure &#x26;&#x26; JS(&#x27;&#x27;)) {
    code.push(sn(that, &#x27; catch (e$) &#x27;), this.compileBlock(o, that));
  }
  if (that = this.ensure) {
    code.push(sn(that, &#x27; finally &#x27;), this.compileBlock(o, that));
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.constructor" id="apidoc.element.livescript.ast.Try.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>constructor
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var(&#x27;e&#x27;), Var(&#x27;e$&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.getJump" id="apidoc.element.livescript.ast.Try.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var ref$;
  return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.isCallable" id="apidoc.element.livescript.ast.Try.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) &#x26;&#x26; this.attempt.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.isStatement" id="apidoc.element.livescript.ast.Try.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.makeReturn" id="apidoc.element.livescript.ast.Try.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
  if (this.recovery != null) {
    this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.show" id="apidoc.element.livescript.ast.Try.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.thrown;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype.compileNode" id="apidoc.module.livescript.ast.Try.prototype.compileNode">module livescript.ast.Try.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Try.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var code, that;
  o.indent += TAB;
  code = [sn(this, &#x27;try &#x27;), this.compileBlock(o, this.attempt)];
  if (that = this.recovery || !this.ensure &#x26;&#x26; JS(&#x27;&#x27;)) {
    code.push(sn(that, &#x27; catch (e$) &#x27;), this.compileBlock(o, that));
  }
  if (that = this.ensure) {
    code.push(sn(that, &#x27; finally &#x27;), this.compileBlock(o, that));
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype.getJump" id="apidoc.module.livescript.ast.Try.prototype.getJump">module livescript.ast.Try.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Try.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var ref$;
  return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype.isCallable" id="apidoc.module.livescript.ast.Try.prototype.isCallable">module livescript.ast.Try.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Try.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) &#x26;&#x26; this.attempt.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype.makeReturn" id="apidoc.module.livescript.ast.Try.prototype.makeReturn">module livescript.ast.Try.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Try.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
  if (this.recovery != null) {
    this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype.show" id="apidoc.module.livescript.ast.Try.prototype.show">module livescript.ast.Try.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.show.show" id="apidoc.element.livescript.ast.Try.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.thrown;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary" id="apidoc.module.livescript.ast.Unary">module livescript.ast.Unary</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.Unary" id="apidoc.element.livescript.ast.Unary.Unary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &#x26;&#x26; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case &#x27;!&#x27;:
      if (flag) {
        break;
      }
      if (it instanceof Fun &#x26;&#x26; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case &#x27;++&#x27;:
    case &#x27;--&#x27;:
      if (flag) {
        this$.post = true;
      }
      break;
    case &#x27;new&#x27;:
      if (it instanceof Existence &#x26;&#x26; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || &#x27;&#x27;).length; i$ &#x3c; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &#x26;&#x26; !node[&#x27;new&#x27;]) {
          if (node.method === &#x27;.call&#x27;) {
            node.args.shift();
          }
          node[&#x27;new&#x27;] = &#x27;new&#x27;;
          node.method = &#x27;&#x27;;
          return it;
        }
      }
      break;
    case &#x27;~&#x27;:
      if (it instanceof Fun &#x26;&#x26; it.statement &#x26;&#x26; !it.bound) {
        return it.bound = &#x27;this$&#x27;, it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 21:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-5],yy.Binary($$[$0-5], void 8, $$[$0-3]))));
break;
case 23:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-4]))));
break;
case 24: case 25:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Unary</span>($$[$0-1]))));
break;
case 26:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.superclass" id="apidoc.element.livescript.ast.Unary.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype" id="apidoc.module.livescript.ast.Unary.prototype">module livescript.ast.Unary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc" id="apidoc.element.livescript.ast.Unary.prototype.compileAsFunc">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileAsFunc
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAsFunc = function (o){
  if (this.op === &#x27;!&#x27;) {
    return sn(this, util(&#x27;not&#x27;));
  } else {
    return sn(this, &#x22;(&#x22;, Fun([], Block(Unary(this.op, Chain(Var(&#x27;it&#x27;))))).compile(o), &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;++&#x27;: &#x27;in&#x27;,
    &#x27;--&#x27;: &#x27;de&#x27;
  }[it] + &#x27;crement&#x27;;
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.<span class="apidocCodeKeywordSpan">compileAsFunc</span>(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileNode" id="apidoc.element.livescript.ast.Unary.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
    it.cond = true;
    break;
  case &#x27;new&#x27;:
    it.isCallable() || it.carp(&#x27;invalid constructor&#x27;);
    break;
  case &#x27;do&#x27;:
    if (o.level === LEVEL_TOP &#x26;&#x26; it instanceof Fun &#x26;&#x26; it.isStatement()) {
      return sn(this, it.compile(o), &#x22; &#x22;, Unary(&#x27;do&#x27;, Var(it.name)).compile(o));
    }
    x = Parens(it instanceof Existence &#x26;&#x26; !it.negated
      ? Chain(it).add(Call())
      : Call.make(it));
    return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
  case &#x27;delete&#x27;:
    if (it instanceof Var || !it.isAssignable()) {
      this.carp(&#x27;invalid delete&#x27;);
    }
    if (o.level &#x26;&#x26; !this[&#x27;void&#x27;]) {
      return this.compilePluck(o);
    }
    break;
  case &#x27;++&#x27;:
  case &#x27;--&#x27;:
    it.isAssignable() || this.carp(&#x27;invalid &#x27; + crement(op));
    if (that = it instanceof Var &#x26;&#x26; o.scope.checkReadOnly(it.value)) {
      this.carp(crement(op) + &#x22; of &#x22; + that + &#x22; \&#x22;&#x22; + it.value + &#x22;\&#x22;&#x22;, ReferenceError);
    }
    if (this.post) {
      it.front = this.front;
    }
    break;
  case &#x27;^^&#x27;:
    return sn(this, util(&#x27;clone&#x27;), &#x22;(&#x22;, it.compile(o, LEVEL_LIST), &#x22;)&#x22;);
  case &#x27;jsdelete&#x27;:
    return sn(this, &#x22;delete &#x22;, it.compile(o, LEVEL_LIST));
  case &#x27;classof&#x27;:
    return sn(this, util(&#x27;toString&#x27;), &#x22;.call(&#x22;, it.compile(o, LEVEL_LIST), &#x22;).slice(8, -1)&#x22;);
  }
  code = [it.compile(o, LEVEL_OP + PREC.unary)];
  if (this.post) {
    code.push(op);
  } else {
    if ((op === &#x27;new&#x27; || op === &#x27;typeof&#x27; || op === &#x27;delete&#x27;) || (op === &#x27;+&#x27; || op === &#x27;-&#x27;) &#x26;&#x26; op === code.join(&#x22;&#x22;).charAt()) {
      op += &#x27; &#x27;;
    }
    code.unshift(op);
  }
  if (o.level &#x3c; LEVEL_CALL) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck" id="apidoc.element.livescript.ast.Unary.prototype.compilePluck">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compilePluck
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePluck = function (o){
  var ref$, get, del, code, ref;
  ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
  code = [ref = o.scope.temporary(), &#x22; = &#x22;, get.compile(o, LEVEL_LIST), &#x22;, delete &#x22;, del.compile(o, LEVEL_LIST), &#x22;, &#x22;, o.scope.free
(ref)];
  if (o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    : Call.make(it));
  return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
case &#x27;delete&#x27;:
  if (it instanceof Var || !it.isAssignable()) {
    this.carp(&#x27;invalid delete&#x27;);
  }
  if (o.level &#x26;&#x26; !this[&#x27;void&#x27;]) {
    return this.<span class="apidocCodeKeywordSpan">compilePluck</span>(o);
  }
  break;
case &#x27;++&#x27;:
case &#x27;--&#x27;:
  it.isAssignable() || this.carp(&#x27;invalid &#x27; + crement(op));
  if (that = it instanceof Var &#x26;&#x26; o.scope.checkReadOnly(it.value)) {
    this.carp(crement(op) + &#x22; of &#x22; + that + &#x22; \&#x22;&#x22; + it.value + &#x22;\&#x22;&#x22;, ReferenceError);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread" id="apidoc.element.livescript.ast.Unary.prototype.compileSpread">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileSpread
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpread = function (o){
  var it, ops;
  it = this.it;
  ops = [this];
  for (; it instanceof constructor; it = it.it) {
    ops.push(it);
  }
  if (!(it instanceof Splat &#x26;&#x26; (it = it.it.expandSlice(o).unwrap()) instanceof List)) {
    return &#x27;&#x27;;
  }
  return this.compileSpreadOver(o, it, function(node){
    var i$, ref$, op;
    for (i$ = (ref$ = ops).length - 1; i$ &#x3e;= 0; --i$) {
      op = ref$[i$];
      node = constructor(op.op, node, op.post);
    }
    return node;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }[it] + &#x27;crement&#x27;;
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.<span class="apidocCodeKeywordSpan">compileSpread</span>(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
    it.cond = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.constructor" id="apidoc.element.livescript.ast.Unary.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>constructor
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &#x26;&#x26; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case &#x27;!&#x27;:
      if (flag) {
        break;
      }
      if (it instanceof Fun &#x26;&#x26; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case &#x27;++&#x27;:
    case &#x27;--&#x27;:
      if (flag) {
        this$.post = true;
      }
      break;
    case &#x27;new&#x27;:
      if (it instanceof Existence &#x26;&#x26; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || &#x27;&#x27;).length; i$ &#x3c; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &#x26;&#x26; !node[&#x27;new&#x27;]) {
          if (node.method === &#x27;.call&#x27;) {
            node.args.shift();
          }
          node[&#x27;new&#x27;] = &#x27;new&#x27;;
          node.method = &#x27;&#x27;;
          return it;
        }
      }
      break;
    case &#x27;~&#x27;:
      if (it instanceof Fun &#x26;&#x26; it.statement &#x26;&#x26; !it.bound) {
        return it.bound = &#x27;this$&#x27;, it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors" id="apidoc.element.livescript.ast.Unary.prototype.getAccessors">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>getAccessors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAccessors = function (){
  var items;
  if (this.op !== &#x27;~&#x27;) {
    return;
  }
  if (this.it instanceof Fun) {
    return [this.it];
  }
  if (this.it instanceof Arr) {
    items = this.it.items;
    if (!items[2] &#x26;&#x26; items[0] instanceof Fun &#x26;&#x26; items[1] instanceof Fun) {
      return items;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function Prop(key, val){
var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
this$.key = key;
this$.val = val;
if (key.value === &#x27;...&#x27;) {
  return Splat(this$.val);
}
if (that = val.<span class="apidocCodeKeywordSpan">getAccessors</span>()) {
  this$.val = that;
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    fun = that[i$];
    fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
  }
  this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.invert" id="apidoc.element.livescript.ast.Unary.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  var ref$;
  if (this.op === &#x27;!&#x27; &#x26;&#x26; ((ref$ = this.it.op) === &#x27;!&#x27; || ref$ === &#x27;&#x3c;&#x27; || ref$ === &#x27;&#x3e;&#x27; || ref$ === &#x27;&#x3c;=&#x27; || ref$ === &#x27;&#x3e;=&#x27; || ref$ === &#x27;
of&#x27; || ref$ === &#x27;instanceof&#x27;)) {
    return this.it;
  }
  return constructor(&#x27;!&#x27;, this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isArray" id="apidoc.element.livescript.ast.Unary.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  return this.it instanceof Arr &#x26;&#x26; this.it.items.length || this.it instanceof Chain &#x26;&#x26; this.it.isArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isCallable" id="apidoc.element.livescript.ast.Unary.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return ((ref$ = this.op) === &#x27;do&#x27; || ref$ === &#x27;new&#x27; || ref$ === &#x27;delete&#x27;) || this.it == null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isString" id="apidoc.element.livescript.ast.Unary.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  var ref$;
  return (ref$ = this.op) === &#x27;typeof&#x27; || ref$ === &#x27;classof&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.show" id="apidoc.element.livescript.ast.Unary.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.post ? &#x27;@&#x27; : void 8] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Unary.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var ref$;
  return ((ref$ = this.op) === &#x27;++&#x27; || ref$ === &#x27;--&#x27; || ref$ === &#x27;delete&#x27;) &#x26;&#x26; this.it != null &#x26;&#x26; If.unfoldSoak(o, this, &#x27;it&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.compileAsFunc" id="apidoc.module.livescript.ast.Unary.prototype.compileAsFunc">module livescript.ast.Unary.prototype.compileAsFunc</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc.compileAsFunc" id="apidoc.element.livescript.ast.Unary.prototype.compileAsFunc.compileAsFunc">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileAsFunc
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAsFunc = function (o){
  if (this.op === &#x27;!&#x27;) {
    return sn(this, util(&#x27;not&#x27;));
  } else {
    return sn(this, &#x22;(&#x22;, Fun([], Block(Unary(this.op, Chain(Var(&#x27;it&#x27;))))).compile(o), &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;++&#x27;: &#x27;in&#x27;,
    &#x27;--&#x27;: &#x27;de&#x27;
  }[it] + &#x27;crement&#x27;;
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.<span class="apidocCodeKeywordSpan">compileAsFunc</span>(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.compileNode" id="apidoc.module.livescript.ast.Unary.prototype.compileNode">module livescript.ast.Unary.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Unary.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
    it.cond = true;
    break;
  case &#x27;new&#x27;:
    it.isCallable() || it.carp(&#x27;invalid constructor&#x27;);
    break;
  case &#x27;do&#x27;:
    if (o.level === LEVEL_TOP &#x26;&#x26; it instanceof Fun &#x26;&#x26; it.isStatement()) {
      return sn(this, it.compile(o), &#x22; &#x22;, Unary(&#x27;do&#x27;, Var(it.name)).compile(o));
    }
    x = Parens(it instanceof Existence &#x26;&#x26; !it.negated
      ? Chain(it).add(Call())
      : Call.make(it));
    return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
  case &#x27;delete&#x27;:
    if (it instanceof Var || !it.isAssignable()) {
      this.carp(&#x27;invalid delete&#x27;);
    }
    if (o.level &#x26;&#x26; !this[&#x27;void&#x27;]) {
      return this.compilePluck(o);
    }
    break;
  case &#x27;++&#x27;:
  case &#x27;--&#x27;:
    it.isAssignable() || this.carp(&#x27;invalid &#x27; + crement(op));
    if (that = it instanceof Var &#x26;&#x26; o.scope.checkReadOnly(it.value)) {
      this.carp(crement(op) + &#x22; of &#x22; + that + &#x22; \&#x22;&#x22; + it.value + &#x22;\&#x22;&#x22;, ReferenceError);
    }
    if (this.post) {
      it.front = this.front;
    }
    break;
  case &#x27;^^&#x27;:
    return sn(this, util(&#x27;clone&#x27;), &#x22;(&#x22;, it.compile(o, LEVEL_LIST), &#x22;)&#x22;);
  case &#x27;jsdelete&#x27;:
    return sn(this, &#x22;delete &#x22;, it.compile(o, LEVEL_LIST));
  case &#x27;classof&#x27;:
    return sn(this, util(&#x27;toString&#x27;), &#x22;.call(&#x22;, it.compile(o, LEVEL_LIST), &#x22;).slice(8, -1)&#x22;);
  }
  code = [it.compile(o, LEVEL_OP + PREC.unary)];
  if (this.post) {
    code.push(op);
  } else {
    if ((op === &#x27;new&#x27; || op === &#x27;typeof&#x27; || op === &#x27;delete&#x27;) || (op === &#x27;+&#x27; || op === &#x27;-&#x27;) &#x26;&#x26; op === code.join(&#x22;&#x22;).charAt()) {
      op += &#x27; &#x27;;
    }
    code.unshift(op);
  }
  if (o.level &#x3c; LEVEL_CALL) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.compilePluck" id="apidoc.module.livescript.ast.Unary.prototype.compilePluck">module livescript.ast.Unary.prototype.compilePluck</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck.compilePluck" id="apidoc.element.livescript.ast.Unary.prototype.compilePluck.compilePluck">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compilePluck
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePluck = function (o){
  var ref$, get, del, code, ref;
  ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
  code = [ref = o.scope.temporary(), &#x22; = &#x22;, get.compile(o, LEVEL_LIST), &#x22;, delete &#x22;, del.compile(o, LEVEL_LIST), &#x22;, &#x22;, o.scope.free
(ref)];
  if (o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    : Call.make(it));
  return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
case &#x27;delete&#x27;:
  if (it instanceof Var || !it.isAssignable()) {
    this.carp(&#x27;invalid delete&#x27;);
  }
  if (o.level &#x26;&#x26; !this[&#x27;void&#x27;]) {
    return this.<span class="apidocCodeKeywordSpan">compilePluck</span>(o);
  }
  break;
case &#x27;++&#x27;:
case &#x27;--&#x27;:
  it.isAssignable() || this.carp(&#x27;invalid &#x27; + crement(op));
  if (that = it instanceof Var &#x26;&#x26; o.scope.checkReadOnly(it.value)) {
    this.carp(crement(op) + &#x22; of &#x22; + that + &#x22; \&#x22;&#x22; + it.value + &#x22;\&#x22;&#x22;, ReferenceError);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.compileSpread" id="apidoc.module.livescript.ast.Unary.prototype.compileSpread">module livescript.ast.Unary.prototype.compileSpread</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread.compileSpread" id="apidoc.element.livescript.ast.Unary.prototype.compileSpread.compileSpread">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileSpread
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpread = function (o){
  var it, ops;
  it = this.it;
  ops = [this];
  for (; it instanceof constructor; it = it.it) {
    ops.push(it);
  }
  if (!(it instanceof Splat &#x26;&#x26; (it = it.it.expandSlice(o).unwrap()) instanceof List)) {
    return &#x27;&#x27;;
  }
  return this.compileSpreadOver(o, it, function(node){
    var i$, ref$, op;
    for (i$ = (ref$ = ops).length - 1; i$ &#x3e;= 0; --i$) {
      op = ref$[i$];
      node = constructor(op.op, node, op.post);
    }
    return node;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }[it] + &#x27;crement&#x27;;
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.<span class="apidocCodeKeywordSpan">compileSpread</span>(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
    it.cond = true;
    break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.getAccessors" id="apidoc.module.livescript.ast.Unary.prototype.getAccessors">module livescript.ast.Unary.prototype.getAccessors</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors.getAccessors" id="apidoc.element.livescript.ast.Unary.prototype.getAccessors.getAccessors">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>getAccessors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAccessors = function (){
  var items;
  if (this.op !== &#x27;~&#x27;) {
    return;
  }
  if (this.it instanceof Fun) {
    return [this.it];
  }
  if (this.it instanceof Arr) {
    items = this.it.items;
    if (!items[2] &#x26;&#x26; items[0] instanceof Fun &#x26;&#x26; items[1] instanceof Fun) {
      return items;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function Prop(key, val){
var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
this$.key = key;
this$.val = val;
if (key.value === &#x27;...&#x27;) {
  return Splat(this$.val);
}
if (that = val.<span class="apidocCodeKeywordSpan">getAccessors</span>()) {
  this$.val = that;
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    fun = that[i$];
    fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
  }
  this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.invert" id="apidoc.module.livescript.ast.Unary.prototype.invert">module livescript.ast.Unary.prototype.invert</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.invert.invert" id="apidoc.element.livescript.ast.Unary.prototype.invert.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  var ref$;
  if (this.op === &#x27;!&#x27; &#x26;&#x26; ((ref$ = this.it.op) === &#x27;!&#x27; || ref$ === &#x27;&#x3c;&#x27; || ref$ === &#x27;&#x3e;&#x27; || ref$ === &#x27;&#x3c;=&#x27; || ref$ === &#x27;&#x3e;=&#x27; || ref$ === &#x27;
of&#x27; || ref$ === &#x27;instanceof&#x27;)) {
    return this.it;
  }
  return constructor(&#x27;!&#x27;, this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.isArray" id="apidoc.module.livescript.ast.Unary.prototype.isArray">module livescript.ast.Unary.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Unary.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  return this.it instanceof Arr &#x26;&#x26; this.it.items.length || this.it instanceof Chain &#x26;&#x26; this.it.isArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.isCallable" id="apidoc.module.livescript.ast.Unary.prototype.isCallable">module livescript.ast.Unary.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Unary.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return ((ref$ = this.op) === &#x27;do&#x27; || ref$ === &#x27;new&#x27; || ref$ === &#x27;delete&#x27;) || this.it == null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.isString" id="apidoc.module.livescript.ast.Unary.prototype.isString">module livescript.ast.Unary.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isString.isString" id="apidoc.element.livescript.ast.Unary.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  var ref$;
  return (ref$ = this.op) === &#x27;typeof&#x27; || ref$ === &#x27;classof&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.show" id="apidoc.module.livescript.ast.Unary.prototype.show">module livescript.ast.Unary.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.show.show" id="apidoc.element.livescript.ast.Unary.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.post ? &#x27;@&#x27; : void 8] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.unfoldSoak" id="apidoc.module.livescript.ast.Unary.prototype.unfoldSoak">module livescript.ast.Unary.prototype.unfoldSoak</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak.unfoldSoak" id="apidoc.element.livescript.ast.Unary.prototype.unfoldSoak.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var ref$;
  return ((ref$ = this.op) === &#x27;++&#x27; || ref$ === &#x27;--&#x27; || ref$ === &#x27;delete&#x27;) &#x26;&#x26; this.it != null &#x26;&#x26; If.unfoldSoak(o, this, &#x27;it&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Util" id="apidoc.module.livescript.ast.Util">module livescript.ast.Util</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Util.Util" id="apidoc.element.livescript.ast.Util.Util">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Util
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.Extends" id="apidoc.element.livescript.ast.Util.Extends">
        function <span class="apidocSignatureSpan">livescript.ast.Util.</span>Extends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Extends = function (){
  return Call.make(Util(&#x27;extend&#x27;), [arguments[0], arguments[1]]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctor.body.lines.unshift(Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(Key(&#x22;_&#x22; + f.name))), Chain(Var(util(&#x27;
curry&#x27;))).add(Call([Chain(Var(&#x27;prototype&#x27;)).add(Index(f)), Var(&#x27;true&#x27;)]))), Assign(Chain(Literal(&#x27;
this&#x27;)).add(Index(f)), Chain(Var(util(&#x27;bind&#x27;))).add(Call([Literal(&#x27;this&#x27;), Literal(&#x22;&#x27;_&#x22; +
f.name + &#x22;&#x27;&#x22;)]))));
}
lines.push(vname);
args = [];
if (that = this.sup) {
  args.push(that);
  imports = Chain(Import(Literal(&#x27;this&#x27;), Var(&#x27;superclass&#x27;)));
  fun.proto = Util.<span class="apidocCodeKeywordSpan">Extends</span>(fun.cname ? Block([Assign(imports.add(Index(Key(&#x27;displayName
&#x27;))), Literal(&#x22;&#x27;&#x22; + name + &#x22;&#x27;&#x22;)), Literal(name)]) : imports, (ref$ = fun.params)[ref$.length] =
Var(&#x27;superclass&#x27;));
}
if (that = this.mixins) {
  res$ = [];
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    args[args.length] = that[i$];
    res$.push(Import(proto, JS(&#x22;arguments[&#x22; + (args.length - 1) + &#x22;]&#x22;), true));
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.superclass" id="apidoc.element.livescript.ast.Util.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Util.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Util.prototype" id="apidoc.module.livescript.ast.Util.prototype">module livescript.ast.Util.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.compile" id="apidoc.element.livescript.ast.Util.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return sn(this, util(this.verb));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.constructor" id="apidoc.element.livescript.ast.Util.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>constructor
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.isCallable" id="apidoc.element.livescript.ast.Util.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.show" id="apidoc.element.livescript.ast.Util.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return (this.verb || &#x27;&#x27;) + ((that = this.label) ? &#x27; &#x27; + that : &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Util.prototype.compile" id="apidoc.module.livescript.ast.Util.prototype.compile">module livescript.ast.Util.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.compile.compile" id="apidoc.element.livescript.ast.Util.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return sn(this, util(this.verb));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var" id="apidoc.module.livescript.ast.Var">module livescript.ast.Var</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.Var" id="apidoc.element.livescript.ast.Var.Var">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Var
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Var</span>($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.superclass" id="apidoc.element.livescript.ast.Var.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Var.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(){
  Atom.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype" id="apidoc.module.livescript.ast.Var.prototype">module livescript.ast.Var.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.assigns" id="apidoc.element.livescript.ast.Var.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return it === this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.compile" id="apidoc.element.livescript.ast.Var.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  return sn(this, this.temp
    ? o.scope.free(this.value)
    : this.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.constructor" id="apidoc.element.livescript.ast.Var.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.isAssignable" id="apidoc.element.livescript.ast.Var.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.isCallable" id="apidoc.element.livescript.ast.Var.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.maybeKey" id="apidoc.element.livescript.ast.Var.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeKey = function (){
  var ref$;
  return ref$ = Key(this.value), ref$.line = this.line, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.varName" id="apidoc.element.livescript.ast.Var.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype.assigns" id="apidoc.module.livescript.ast.Var.prototype.assigns">module livescript.ast.Var.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Var.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return it === this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype.compile" id="apidoc.module.livescript.ast.Var.prototype.compile">module livescript.ast.Var.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.compile.compile" id="apidoc.element.livescript.ast.Var.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  return sn(this, this.temp
    ? o.scope.free(this.value)
    : this.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype.maybeKey" id="apidoc.module.livescript.ast.Var.prototype.maybeKey">module livescript.ast.Var.prototype.maybeKey</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.maybeKey.maybeKey" id="apidoc.element.livescript.ast.Var.prototype.maybeKey.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeKey = function (){
  var ref$;
  return ref$ = Key(this.value), ref$.line = this.line, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype.varName" id="apidoc.module.livescript.ast.Var.prototype.varName">module livescript.ast.Var.prototype.varName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.varName.varName" id="apidoc.element.livescript.ast.Var.prototype.varName.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Vars" id="apidoc.module.livescript.ast.Vars">module livescript.ast.Vars</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.Vars" id="apidoc.element.livescript.ast.Vars.Vars">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.superclass" id="apidoc.element.livescript.ast.Vars.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Vars.prototype" id="apidoc.module.livescript.ast.Vars.prototype">module livescript.ast.Vars.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.compile" id="apidoc.element.livescript.ast.Vars.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var i$, ref$, len$, v, value;
  for (i$ = 0, len$ = (ref$ = this.vars).length; i$ &#x3c; len$; ++i$) {
    v = ref$[i$], value = v.value;
    if (!(v instanceof Var)) {
      v.carp(&#x27;invalid variable declaration&#x27;);
    }
    if (o.scope.check(value)) {
      v.carp(&#x22;redeclaration of \&#x22;&#x22; + value + &#x22;\&#x22;&#x22;);
    }
    o.scope.declare(value, v);
  }
  return sn(this, Literal(&#x27;void&#x27;).compile(o, level));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.constructor" id="apidoc.element.livescript.ast.Vars.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>constructor
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.makeReturn" id="apidoc.element.livescript.ast.Vars.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Vars.prototype.compile" id="apidoc.module.livescript.ast.Vars.prototype.compile">module livescript.ast.Vars.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.compile.compile" id="apidoc.element.livescript.ast.Vars.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var i$, ref$, len$, v, value;
  for (i$ = 0, len$ = (ref$ = this.vars).length; i$ &#x3c; len$; ++i$) {
    v = ref$[i$], value = v.value;
    if (!(v instanceof Var)) {
      v.carp(&#x27;invalid variable declaration&#x27;);
    }
    if (o.scope.check(value)) {
      v.carp(&#x22;redeclaration of \&#x22;&#x22; + value + &#x22;\&#x22;&#x22;);
    }
    o.scope.declare(value, v);
  }
  return sn(this, Literal(&#x27;void&#x27;).compile(o, level));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While" id="apidoc.module.livescript.ast.While">module livescript.ast.While</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.While" id="apidoc.element.livescript.ast.While.While">
        function <span class="apidocSignatureSpan">livescript.ast.</span>While
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &#x26;&#x26; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== &#x27;&#x27; + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === &#x27;unless&#x27;)));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.<span class="apidocCodeKeywordSpan">While</span>($$[$0], $$[$0-1] === &#x27;until&#x27;, true
).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === &#x27;until&#x27;, true).addGuard($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.superclass" id="apidoc.element.livescript.ast.While.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.While.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype" id="apidoc.module.livescript.ast.While.prototype">module livescript.ast.While.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addBody" id="apidoc.element.livescript.ast.While.prototype.addBody">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBody = function (body){
  var top;
  this.body = body;
  if (this.guard) {
    this.body = Block(If(this.guard, this.body));
  }
  top = this.body.lines[0];
  if ((top != null ? top.verb : void 8) === &#x27;continue&#x27; &#x26;&#x26; !top.label) {
    this.body.lines.length = 0;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
While.prototype.show = function(){
  return [this.un ? &#x27;!&#x27; : void 8, this.post ? &#x27;do&#x27; : void 8].join(&#x27;&#x27;);
};
prototype.isStatement = prototype.isArray = YES;
While.prototype.makeComprehension = function(toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().<span class="apidocCodeKeywordSpan">addBody</span>(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
};
While.prototype.getJump = function(ctx){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addGuard" id="apidoc.element.livescript.ast.While.prototype.addGuard">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addGuard
        <span class="apidocSignatureSpan">(guard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addGuard = function (guard){
  this.guard = guard;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0], $$[$0-1] === &#x27;until&#x27;, true).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === &#x27;until&#x27;, true).<span class="apidocCodeKeywordSpan">
addGuard</span>($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addObjComp" id="apidoc.element.livescript.ast.While.prototype.addObjComp">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addObjComp
        <span class="apidocSignatureSpan">(objComp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addObjComp = function (objComp){
  this.objComp = objComp != null ? objComp : true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].<span class="apidocCodeKeywordSpan">addObjComp</span>().
makeComprehension(yy.L(_$[$0-4],_$[$0-4],yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileBody" id="apidoc.element.livescript.ast.While.prototype.compileBody">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileBody
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileBody = function (o){
  var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ =
this;
  o[&#x27;break&#x27;] = o[&#x27;continue&#x27;] = true;
  lines = this.body.lines, yet = this.yet, tab = this.tab;
  code = [];
  ret = [];
  mid = [];
  empty = this.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;;
  getResultName = function(){
    return _resultName != null
      ? _resultName
      : _resultName = o.scope.temporary(this$.objComp ? &#x27;resultObj&#x27; : &#x27;results&#x27;);
  };
  last = lines != null ? lines[lines.length - 1] : void 8;
  if (!(this.isComprehension || this.inComprehension) || (last != null &#x26;&#x26; last.isComprehension)) {
    hasLoop = false;
    if (last != null) {
      last.traverseChildren(function(it){
        var ref$;
        if (it instanceof Block &#x26;&#x26; (ref$ = it.lines)[ref$.length - 1] instanceof While) {
          hasLoop = true;
        }
      });
    }
    if (this.returns &#x26;&#x26; !this.resVar) {
      this.resVar = res = o.scope.assign(getResultName(), empty);
    }
    if (this.resVar &#x26;&#x26; (last instanceof While || hasLoop)) {
      temp = o.scope.temporary(&#x27;lresult&#x27;);
      lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
        ? Obj()
        : Arr(), &#x27;=&#x27;));
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(temp);
      }
      mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key(&#x27;push&#x27;), &#x27;.&#x27;, true)).add(Call([Chain(Var(temp))])).compile(o), &#x22;;\n&#x22; +
this.tab);
    } else {
      this.hasReturned = true;
      if (this.resVar) {
        this.body.makeReturn(this.resVar);
      }
    }
  }
  if (this.returns) {
    if ((!last instanceof While &#x26;&#x26; !this.hasReturned) || this.isComprehension || this.inComprehension) {
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
      }
    }
    ret.push(&#x22;\n&#x22; + this.tab + &#x22;return &#x22;, res || empty, &#x22;;&#x22;);
    if ((ref$ = this[&#x27;else&#x27;]) != null) {
      ref$.makeReturn();
    }
  }
  yet &#x26;&#x26; lines.unshift(JS(yet + &#x22; = false;&#x22;));
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
  }
  code.push.apply(code, mid);
  code.push(&#x27;}&#x27;);
  if (this.post) {
    code.push(sn(this, &#x22; while (&#x22;), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, &#x22;);&#x22;));
  }
  if (yet) {
    code.push(sn(this, &#x22; if (&#x22;), yet, sn(this, &#x22;) &#x22;), this.compileBlock(o, Block(this[&#x27;else&#x27;])));
    o.scope.free(yet);
  }
  return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  While.prototype.compileNode = function(o){
var test, ref$, head, that;
o.loop = true;
this.test &#x26;&#x26; (this.un
  ? this.test = this.test.invert()
  : this.anaphorize());
if (this.post) {
  return sn(null, sn(this, &#x27;do {&#x27;), this.<span class="apidocCodeKeywordSpan">compileBody</span>((o.indent += TAB, o)));
}
test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;&#x27;;
if (!(this.update || this[&#x27;else&#x27;])) {
  head = !snEmpty(test)
    ? [sn(this, &#x22;while (&#x22;), test]
    : [sn(this, &#x27;for (;;&#x27;)];
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileNode" id="apidoc.element.livescript.ast.While.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var test, ref$, head, that;
  o.loop = true;
  this.test &#x26;&#x26; (this.un
    ? this.test = this.test.invert()
    : this.anaphorize());
  if (this.post) {
    return sn(null, sn(this, &#x27;do {&#x27;), this.compileBody((o.indent += TAB, o)));
  }
  test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;&#x27;;
  if (!(this.update || this[&#x27;else&#x27;])) {
    head = !snEmpty(test)
      ? [sn(this, &#x22;while (&#x22;), test]
      : [sn(this, &#x27;for (;;&#x27;)];
  } else {
    head = [sn(this, &#x27;for (&#x27;)];
    if (this[&#x27;else&#x27;]) {
      head.push(this.yet = o.scope.temporary(&#x27;yet&#x27;), &#x22; = true&#x22;);
    }
    head.push(sn(this, &#x22;;&#x22;), test.toString() &#x26;&#x26; &#x27; &#x27;, test, sn(this, &#x22;;&#x22;));
    if (that = this.update) {
      head.push(&#x27; &#x27;, that.compile(o, LEVEL_PAREN));
    }
  }
  return sn.apply(null, [null].concat(slice$.call(head), [sn(this, &#x27;) {&#x27;), this.compileBody((o.indent += TAB, o))]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.constructor" id="apidoc.element.livescript.ast.While.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>constructor
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &#x26;&#x26; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== &#x27;&#x27; + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.getJump" id="apidoc.element.livescript.ast.While.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var i$, ref$, ref1$, len$, node;
  ctx || (ctx = {});
  ctx[&#x27;continue&#x27;] = true;
  ctx[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.getJump(ctx)) {
      return node;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.isArray" id="apidoc.element.livescript.ast.While.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.isStatement" id="apidoc.element.livescript.ast.While.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeComprehension" id="apidoc.element.livescript.ast.While.prototype.makeComprehension">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeComprehension
        <span class="apidocSignatureSpan">(toAdd, loops)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeComprehension = function (toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().addBody(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
function argsSlice(begin, end){
  return new For({
    ref: true,
    from: begin,
    op: &#x27;til&#x27;,
    to: end
  }).<span class="apidocCodeKeywordSpan">makeComprehension</span>(Chain(Var(&#x27;arguments&#x27;)).add(Index(Literal(&#x27;..&#
x27;))), []);
}
ret = [];
for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
  i = i$;
  node = nodes[i$];
  if (node.isEmpty()) {
    continue;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeReturn" id="apidoc.element.livescript.ast.While.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (it){
  var last, ref$, ref1$, ref2$;
  if (this.hasReturned) {
    return this;
  }
  if (it) {
    if (this.objComp) {
      this.body = Block(this.body.makeReturn(it, true));
    } else {
      if (!(this.body || this.index)) {
        this.addBody(Block(Var(this.index = &#x27;ridx$&#x27;)));
      }
      last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
      if ((this.isComprehension || this.inComprehension) &#x26;&#x26; !(last != null &#x26;&#x26; last.isComprehension)) {
        (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
        if ((ref1$ = this[&#x27;else&#x27;]) != null) {
          ref1$.makeReturn.apply(ref1$, arguments);
        }
        this.hasReturned = true;
      } else {
        this.resVar = it;
        if ((ref2$ = this[&#x27;else&#x27;]) != null) {
          ref2$.makeReturn.apply(ref2$, arguments);
        }
      }
    }
  } else {
    this.getJump() || (this.returns = true);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.show" id="apidoc.element.livescript.ast.While.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.un ? &#x27;!&#x27; : void 8, this.post ? &#x27;do&#x27; : void 8].join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.addBody" id="apidoc.module.livescript.ast.While.prototype.addBody">module livescript.ast.While.prototype.addBody</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addBody.addBody" id="apidoc.element.livescript.ast.While.prototype.addBody.addBody">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBody = function (body){
  var top;
  this.body = body;
  if (this.guard) {
    this.body = Block(If(this.guard, this.body));
  }
  top = this.body.lines[0];
  if ((top != null ? top.verb : void 8) === &#x27;continue&#x27; &#x26;&#x26; !top.label) {
    this.body.lines.length = 0;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
While.prototype.show = function(){
  return [this.un ? &#x27;!&#x27; : void 8, this.post ? &#x27;do&#x27; : void 8].join(&#x27;&#x27;);
};
prototype.isStatement = prototype.isArray = YES;
While.prototype.makeComprehension = function(toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().<span class="apidocCodeKeywordSpan">addBody</span>(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
};
While.prototype.getJump = function(ctx){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.addGuard" id="apidoc.module.livescript.ast.While.prototype.addGuard">module livescript.ast.While.prototype.addGuard</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addGuard.addGuard" id="apidoc.element.livescript.ast.While.prototype.addGuard.addGuard">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addGuard
        <span class="apidocSignatureSpan">(guard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addGuard = function (guard){
  this.guard = guard;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0], $$[$0-1] === &#x27;until&#x27;, true).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === &#x27;until&#x27;, true).<span class="apidocCodeKeywordSpan">
addGuard</span>($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.addObjComp" id="apidoc.module.livescript.ast.While.prototype.addObjComp">module livescript.ast.While.prototype.addObjComp</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addObjComp.addObjComp" id="apidoc.element.livescript.ast.While.prototype.addObjComp.addObjComp">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addObjComp
        <span class="apidocSignatureSpan">(objComp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addObjComp = function (objComp){
  this.objComp = objComp != null ? objComp : true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].<span class="apidocCodeKeywordSpan">addObjComp</span>().
makeComprehension(yy.L(_$[$0-4],_$[$0-4],yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.compileBody" id="apidoc.module.livescript.ast.While.prototype.compileBody">module livescript.ast.While.prototype.compileBody</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileBody.compileBody" id="apidoc.element.livescript.ast.While.prototype.compileBody.compileBody">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileBody
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileBody = function (o){
  var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ =
this;
  o[&#x27;break&#x27;] = o[&#x27;continue&#x27;] = true;
  lines = this.body.lines, yet = this.yet, tab = this.tab;
  code = [];
  ret = [];
  mid = [];
  empty = this.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;;
  getResultName = function(){
    return _resultName != null
      ? _resultName
      : _resultName = o.scope.temporary(this$.objComp ? &#x27;resultObj&#x27; : &#x27;results&#x27;);
  };
  last = lines != null ? lines[lines.length - 1] : void 8;
  if (!(this.isComprehension || this.inComprehension) || (last != null &#x26;&#x26; last.isComprehension)) {
    hasLoop = false;
    if (last != null) {
      last.traverseChildren(function(it){
        var ref$;
        if (it instanceof Block &#x26;&#x26; (ref$ = it.lines)[ref$.length - 1] instanceof While) {
          hasLoop = true;
        }
      });
    }
    if (this.returns &#x26;&#x26; !this.resVar) {
      this.resVar = res = o.scope.assign(getResultName(), empty);
    }
    if (this.resVar &#x26;&#x26; (last instanceof While || hasLoop)) {
      temp = o.scope.temporary(&#x27;lresult&#x27;);
      lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
        ? Obj()
        : Arr(), &#x27;=&#x27;));
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(temp);
      }
      mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key(&#x27;push&#x27;), &#x27;.&#x27;, true)).add(Call([Chain(Var(temp))])).compile(o), &#x22;;\n&#x22; +
this.tab);
    } else {
      this.hasReturned = true;
      if (this.resVar) {
        this.body.makeReturn(this.resVar);
      }
    }
  }
  if (this.returns) {
    if ((!last instanceof While &#x26;&#x26; !this.hasReturned) || this.isComprehension || this.inComprehension) {
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
      }
    }
    ret.push(&#x22;\n&#x22; + this.tab + &#x22;return &#x22;, res || empty, &#x22;;&#x22;);
    if ((ref$ = this[&#x27;else&#x27;]) != null) {
      ref$.makeReturn();
    }
  }
  yet &#x26;&#x26; lines.unshift(JS(yet + &#x22; = false;&#x22;));
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
  }
  code.push.apply(code, mid);
  code.push(&#x27;}&#x27;);
  if (this.post) {
    code.push(sn(this, &#x22; while (&#x22;), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, &#x22;);&#x22;));
  }
  if (yet) {
    code.push(sn(this, &#x22; if (&#x22;), yet, sn(this, &#x22;) &#x22;), this.compileBlock(o, Block(this[&#x27;else&#x27;])));
    o.scope.free(yet);
  }
  return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  While.prototype.compileNode = function(o){
var test, ref$, head, that;
o.loop = true;
this.test &#x26;&#x26; (this.un
  ? this.test = this.test.invert()
  : this.anaphorize());
if (this.post) {
  return sn(null, sn(this, &#x27;do {&#x27;), this.<span class="apidocCodeKeywordSpan">compileBody</span>((o.indent += TAB, o)));
}
test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;&#x27;;
if (!(this.update || this[&#x27;else&#x27;])) {
  head = !snEmpty(test)
    ? [sn(this, &#x22;while (&#x22;), test]
    : [sn(this, &#x27;for (;;&#x27;)];
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.compileNode" id="apidoc.module.livescript.ast.While.prototype.compileNode">module livescript.ast.While.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.While.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var test, ref$, head, that;
  o.loop = true;
  this.test &#x26;&#x26; (this.un
    ? this.test = this.test.invert()
    : this.anaphorize());
  if (this.post) {
    return sn(null, sn(this, &#x27;do {&#x27;), this.compileBody((o.indent += TAB, o)));
  }
  test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;&#x27;;
  if (!(this.update || this[&#x27;else&#x27;])) {
    head = !snEmpty(test)
      ? [sn(this, &#x22;while (&#x22;), test]
      : [sn(this, &#x27;for (;;&#x27;)];
  } else {
    head = [sn(this, &#x27;for (&#x27;)];
    if (this[&#x27;else&#x27;]) {
      head.push(this.yet = o.scope.temporary(&#x27;yet&#x27;), &#x22; = true&#x22;);
    }
    head.push(sn(this, &#x22;;&#x22;), test.toString() &#x26;&#x26; &#x27; &#x27;, test, sn(this, &#x22;;&#x22;));
    if (that = this.update) {
      head.push(&#x27; &#x27;, that.compile(o, LEVEL_PAREN));
    }
  }
  return sn.apply(null, [null].concat(slice$.call(head), [sn(this, &#x27;) {&#x27;), this.compileBody((o.indent += TAB, o))]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.getJump" id="apidoc.module.livescript.ast.While.prototype.getJump">module livescript.ast.While.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.getJump.getJump" id="apidoc.element.livescript.ast.While.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var i$, ref$, ref1$, len$, node;
  ctx || (ctx = {});
  ctx[&#x27;continue&#x27;] = true;
  ctx[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.getJump(ctx)) {
      return node;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.makeComprehension" id="apidoc.module.livescript.ast.While.prototype.makeComprehension">module livescript.ast.While.prototype.makeComprehension</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeComprehension.makeComprehension" id="apidoc.element.livescript.ast.While.prototype.makeComprehension.makeComprehension">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeComprehension
        <span class="apidocSignatureSpan">(toAdd, loops)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeComprehension = function (toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().addBody(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
function argsSlice(begin, end){
  return new For({
    ref: true,
    from: begin,
    op: &#x27;til&#x27;,
    to: end
  }).<span class="apidocCodeKeywordSpan">makeComprehension</span>(Chain(Var(&#x27;arguments&#x27;)).add(Index(Literal(&#x27;..&#
x27;))), []);
}
ret = [];
for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
  i = i$;
  node = nodes[i$];
  if (node.isEmpty()) {
    continue;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.makeReturn" id="apidoc.module.livescript.ast.While.prototype.makeReturn">module livescript.ast.While.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.While.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (it){
  var last, ref$, ref1$, ref2$;
  if (this.hasReturned) {
    return this;
  }
  if (it) {
    if (this.objComp) {
      this.body = Block(this.body.makeReturn(it, true));
    } else {
      if (!(this.body || this.index)) {
        this.addBody(Block(Var(this.index = &#x27;ridx$&#x27;)));
      }
      last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
      if ((this.isComprehension || this.inComprehension) &#x26;&#x26; !(last != null &#x26;&#x26; last.isComprehension)) {
        (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
        if ((ref1$ = this[&#x27;else&#x27;]) != null) {
          ref1$.makeReturn.apply(ref1$, arguments);
        }
        this.hasReturned = true;
      } else {
        this.resVar = it;
        if ((ref2$ = this[&#x27;else&#x27;]) != null) {
          ref2$.makeReturn.apply(ref2$, arguments);
        }
      }
    }
  } else {
    this.getJump() || (this.returns = true);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.show" id="apidoc.module.livescript.ast.While.prototype.show">module livescript.ast.While.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.show.show" id="apidoc.element.livescript.ast.While.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.un ? &#x27;!&#x27; : void 8, this.post ? &#x27;do&#x27; : void 8].join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield" id="apidoc.module.livescript.ast.Yield">module livescript.ast.Yield</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.Yield" id="apidoc.element.livescript.ast.Yield.Yield">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 98:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Unary($$[$0-5], yy.Splat(yy.Arr($$[$0-2]))));
break;
case 99:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2])));
break;
case 100:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Yield</span>($$[$0]));
break;
case 101:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Yield($$[$0-1], $$[$0]));
break;
case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 158:
this.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.superclass" id="apidoc.element.livescript.ast.Yield.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield.prototype" id="apidoc.module.livescript.ast.Yield.prototype">module livescript.ast.Yield.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.compileNode" id="apidoc.element.livescript.ast.Yield.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var code;
  code = [];
  if (this.op === &#x27;yieldfrom&#x27;) {
    code.push(&#x27;yield*&#x27;);
  } else {
    code.push(&#x27;yield&#x27;);
  }
  if (this.it) {
    code.push(&#x22; &#x22; + this.it.compile(o, LEVEL_OP + PREC.unary));
  }
  return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.constructor" id="apidoc.element.livescript.ast.Yield.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>constructor
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.isCallable" id="apidoc.element.livescript.ast.Yield.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.show" id="apidoc.element.livescript.ast.Yield.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.op === &#x27;yieldfrom&#x27;) {
    return &#x27;from&#x27;;
  } else {
    return &#x27;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield.prototype.compileNode" id="apidoc.module.livescript.ast.Yield.prototype.compileNode">module livescript.ast.Yield.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Yield.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var code;
  code = [];
  if (this.op === &#x27;yieldfrom&#x27;) {
    code.push(&#x27;yield*&#x27;);
  } else {
    code.push(&#x27;yield&#x27;);
  }
  if (this.it) {
    code.push(&#x22; &#x22; + this.it.compile(o, LEVEL_OP + PREC.unary));
  }
  return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield.prototype.isCallable" id="apidoc.module.livescript.ast.Yield.prototype.isCallable">module livescript.ast.Yield.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Yield.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield.prototype.show" id="apidoc.module.livescript.ast.Yield.prototype.show">module livescript.ast.Yield.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.show.show" id="apidoc.element.livescript.ast.Yield.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.op === &#x27;yieldfrom&#x27;) {
    return &#x27;from&#x27;;
  } else {
    return &#x27;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.fromJSON" id="apidoc.module.livescript.ast.fromJSON">module livescript.ast.fromJSON</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.fromJSON.fromJSON" id="apidoc.element.livescript.ast.fromJSON.fromJSON">
        function <span class="apidocSignatureSpan">livescript.ast.</span>fromJSON
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
  if (that = it.type) {
    node = clone$(exports[that].prototype);
    for (key in it) {
      val = it[key];
      node[key] = fromJSON(val);
    }
    return node;
  }
  if (it.length != null) {
    for (i$ = 0, len$ = it.length; i$ &#x3c; len$; ++i$) {
      v = it[i$];
      results$.push(fromJSON(v));
    }
    return results$;
  } else {
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.<span class="apidocCodeKeywordSpan">fromJSON</span>(JSON.parse(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.parse" id="apidoc.module.livescript.ast.parse">module livescript.ast.parse</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.parse.parse" id="apidoc.element.livescript.ast.parse.parse">
        function <span class="apidocSignatureSpan">livescript.ast.</span>parse
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (json){
  return exports.fromJSON(JSON.parse(json));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.fromJSON(JSON.<span class="apidocCodeKeywordSpan">parse</span>(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.command" id="apidoc.module.livescript.command">module livescript.command</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.command.command" id="apidoc.element.livescript.command.command">
        function <span class="apidocSignatureSpan">livescript.</span>command
        <span class="apidocSignatureSpan">(args, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">command = function (args, arg$){
  var ref$, say, sayWithTimestamp, warn, die, p, pp, ppp, fileExists, dasherizeVars, startsWith, o, positional, e, validMapValues
, toInsert, that, filename, jsonCallback;
  ref$ = arg$ != null
    ? arg$
    : {}, say = ref$.say, sayWithTimestamp = ref$.sayWithTimestamp, warn = ref$.warn, die = ref$.die;
  say == null &#x26;&#x26; (say = console.log);
  sayWithTimestamp == null &#x26;&#x26; (sayWithTimestamp = util.log);
  warn == null &#x26;&#x26; (warn = console.error);
  die == null &#x26;&#x26; (die = function(message){
    console.error(message);
    process.exit(1);
  });
  p = function(){
    var args, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ &#x3c; to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    each(console.dir, args);
  };
  pp = function(x, showHidden, depth){
    say(util.inspect(x, showHidden, depth, !process.env.NODE_DISABLE_COLORS));
  };
  ppp = function(it){
    pp(it, true, null);
  };
  fileExists = function(path){
    try {
      fs.statSync(path);
      return true;
    } catch (e$) {}
  };
  dasherizeVars = function(str){
    if (/^[a-z]/.exec(str)) {
      return dasherize(str);
    } else {
      return str;
    }
  };
  startsWith = function(str){
    var this$ = this;
    return function(it){
      return it.indexOf(str) === 0;
    };
  };
  try {
    o = parseOptions(args);
    positional = o._;
  } catch (e$) {
    e = e$;
    die(e.message);
  }
  switch (false) {
  case !o.nodejs:
    forkNode();
    break;
  case !o.version:
    say(&#x22;LiveScript version &#x22; + version);
    break;
  case !o.help:
    say(generateHelp({
      interpolate: {
        version: version
      }
    }));
    break;
  default:
    validMapValues = [&#x27;none&#x27;, &#x27;linked&#x27;, &#x27;linked-src&#x27;, &#x27;embedded&#x27;, &#x27;debug&#x27;];
    if (!in$(o.map, validMapValues)) {
      die(&#x22;Option --map must be either: &#x22; + validMapValues.join(&#x27;, &#x27;));
    }
    o.run = !(o.compile || (o.compile = o.output));
    if (args === process.argv) {
      process.argv[0] = process.argv[1];
      toInsert = o.stdin
        ? positional
        : o.run
          ? positional.splice(1, 9e9)
          : [];
      (ref$ = process.argv).splice.apply(ref$, [2, 9e9].concat(slice$.call(toInsert)));
    }
    if (that = o.require) {
      filename = module.filename;
      module.filename = &#x27;.&#x27;;
      each(function(it){
        return global[nameFromPath(it)] = require(it);
      })(
      that);
      module.filename = filename;
    }
    switch (false) {
    case !o.eval:
      jsonCallback = function(input){
        if (o.prelude) {
          import$(global, prelude);
        }
        o.runContext = JSON.parse(input.toString());
        compileScript(&#x27;&#x27;, o.eval);
      };
      if (positional.length &#x26;&#x26; (o.json || /\.json$/.test(positional[0]))) {
        o.json = true;
        fshoot(&#x27;readFile&#x27;, positional[0], jsonCallback);
      } else if (o.json) {
        getStdin(jsonCallback);
      } else {
        compileScript(&#x27;&#x27;, o.eval);
      }
      break;
    case !o.stdin:
      compileStdin();
      break;
    case !positional.length:
      compileScripts();
      break;
    case !require(&#x27;tty&#x27;).isatty(0):
      say(&#x22;LiveScript &#x22; + version + &#x22; - use &#x27;lsc --help&#x27; for more information&#x22;);
      repl();
      break;
    default:
      compileStdin();
    }
  }
  function fshoot(name, arg, callback){
    fs[name](arg, function(e, result){
      if (e) {
        die(e.stack || e);
      }
      callback(result);
    });
  }
  function compileScripts(){
    positional.forEach(function(it){
      walk(it, path.normalize(it), true);
    });
    function walk(source, base, top){
      function work(){
        fshoot(&#x27;readFile&#x27;, source, function(it){
          compileScript(source, it + &#x22;&#x22;, base);
        });
      }
      fs.stat(source, function(e, stats){
        if (e) {
          if (!top || /(?:\.ls|\/)$/.test(source)) {
            die(&#x22;Can&#x27;t find: &#x22; + source);
          }
          walk(source + &#x22;.ls&#x22;, base);
          return;
        }
        if (stats.isDirectory()) {
          if (!o.run) {
            fshoot(&#x27;readdir&#x27;, source, function(it) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.compile" id="apidoc.module.livescript.compile">module livescript.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.compile.compile" id="apidoc.element.livescript.compile.compile">
        function <span class="apidocSignatureSpan">livescript.</span>compile
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (code, options){
  var result, ast, output, filename, outputFilename, ref$, mapPath, e, that;
  options == null &#x26;&#x26; (options = {});
  options.header == null &#x26;&#x26; (options.header = true);
  try {
    if (options.json) {
      result = Function(exports.compile(code, {
        bare: true,
        run: true,
        print: true
      }))();
      return JSON.stringify(result, null, 2) + &#x22;\n&#x22;;
    } else {
      ast = parser.parse(lexer.lex(code));
      if (options.run &#x26;&#x26; options.print) {
        ast.makeReturn();
      }
      output = ast.compileRoot(options);
      if (options.header) {
        output = new SourceNode(null, null, null, [&#x22;// Generated by LiveScript &#x22; + exports.VERSION + &#x22;\n&#x22;, output]);
      }
      if (options.map &#x26;&#x26; options.map !== &#x27;none&#x27;) {
        filename = options.filename, outputFilename = options.outputFilename;
        if (!filename) {
          filename = &#x22;unnamed-&#x22; + Math.floor(Math.random() * 4294967296).toString(16) + &#x22;.ls&#x22;;
        }
        output.setFile(filename);
        result = output.toStringWithSourceMap();
        if (options.map === &#x27;embedded&#x27;) {
          result.map.setSourceContent(filename, code);
        }
        if ((ref$ = options.map) === &#x27;linked&#x27; || ref$ === &#x27;debug&#x27;) {
          mapPath = outputFilename + &#x22;.map&#x22;;
          result.code += &#x22;\n//# sourceMappingURL=&#x22; + mapPath + &#x22;\n&#x22;;
        } else {
          result.code += &#x22;\n//# sourceMappingURL=data:application/json;base64,&#x22; + new Buffer(result.map.toString()).toString(&#x27;base64
&#x27;) + &#x22;\n&#x22;;
        }
        return result;
      } else {
        return output.toString();
      }
    }
  } catch (e$) {
    e = e$;
    if (that = options.filename) {
      e.message += &#x22;\nat &#x22; + that;
    }
    throw e;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.emit" id="apidoc.module.livescript.emit">module livescript.emit</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.emit.emit" id="apidoc.element.livescript.emit.emit">
        function <span class="apidocSignatureSpan">livescript.</span>emit
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === &#x27;error&#x27;);

  events = this._events;
  if (events)
    doError = (doError &#x26;&#x26; events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no &#x27;error&#x27; event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event&#x27;);
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit(&#x27;error&#x27;, er);
    } else if (er instanceof Error) {
      throw er; // Unhandled &#x27;error&#x27; event
    } else {
      // At least give some kind of context to the user
      var err = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event. (&#x27; + er + &#x27;)&#x27;);
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  if (domain &#x26;&#x26; this !== process) {
    domain.enter();
    needDomainExit = true;
  }

  var isFn = typeof handler === &#x27;function&#x27;;
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i &#x3c; len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  if (needDomainExit)
    domain.exit();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), &#x22;\n&#x22;];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.<span class="apidocCodeKeywordSpan">emit</span
>(post, o.indent) : post]));
};
Block.prototype.compileExpressions = function(o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.eventNames" id="apidoc.module.livescript.eventNames">module livescript.eventNames</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.eventNames.eventNames" id="apidoc.element.livescript.eventNames.eventNames">
        function <span class="apidocSignatureSpan">livescript.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  return this._eventsCount &#x3e; 0 ? Reflect.ownKeys(this._events) : [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.getMaxListeners" id="apidoc.module.livescript.getMaxListeners">module livescript.getMaxListeners</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.getMaxListeners.getMaxListeners" id="apidoc.element.livescript.getMaxListeners.getMaxListeners">
        function <span class="apidocSignatureSpan">livescript.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMaxListeners() {
  return $getMaxListeners(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.go" id="apidoc.module.livescript.go">module livescript.go</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.go.go" id="apidoc.element.livescript.go.go">
        function <span class="apidocSignatureSpan">livescript.</span>go
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">go = function (){
  var type, sink, i$, ref$, len$, script, that;
  type = /^(?:text\/|application\/)?ls$/i;
  sink = function(error){
    error &#x26;&#x26; setTimeout(function(){
      throw error;
    });
  };
  for (i$ = 0, len$ = (ref$ = document.getElementsByTagName(&#x27;script&#x27;)).length; i$ &#x3c; len$; ++i$) {
    script = ref$[i$];
    if (type.test(script.type)) {
      if (that = script.src) {
        LiveScript.load(that, sink);
      } else {
        LiveScript.stab(script.innerHTML, sink, script.id);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.lex" id="apidoc.module.livescript.lex">module livescript.lex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.lex.lex" id="apidoc.element.livescript.lex.lex">
        function <span class="apidocSignatureSpan">livescript.</span>lex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lex = function (it){
  return lexer.lex(it, {
    raw: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    stack.length = stack.length - 2 * n;
    vstack.length = vstack.length - n;
    lstack.length = lstack.length - n;
}
_token_stack:
    var lex = function () {
        var token;
        token = lexer.<span class="apidocCodeKeywordSpan">lex</span>() || EOF;
        if (typeof token !== &#x27;number&#x27;) {
            token = self.symbols_[token] || token;
        }
        return token;
    };
var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
while (true) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.lexer" id="apidoc.module.livescript.lexer">module livescript.lexer</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.lexer.able" id="apidoc.element.livescript.lexer.able">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>able
        <span class="apidocSignatureSpan">(call)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">able = function (call){
  return !this.last.spaced &#x26;&#x26; able(this.tokens, null, call);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;.&#x3e;&#x3e;.&#x27;:
case &#x27;.&#x3e;&#x3e;&#x3e;.&#x27;:
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  tag = &#x27;SHIFT&#x27;;
  break;
case &#x27;(&#x27;:
  if (!(((ref$ = this.last[0]) === &#x27;FUNCTION&#x27; || ref$ === &#x27;GENERATOR&#x27; || ref$ === &#x27;LET&#x27;) || this.<
span class="apidocCodeKeywordSpan">able</span>(true) || this.last[1] === &#x27;.@&#x27;)) {
    this.token(&#x27;(&#x27;, &#x27;(&#x27;);
    this.closes.push(&#x27;)&#x27;);
    this.parens.push(this.last);
    return 1;
  }
  tag = &#x27;CALL(&#x27;;
  this.closes.push(&#x27;)CALL&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.addInterpolated" id="apidoc.element.livescript.lexer.addInterpolated">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>addInterpolated
        <span class="apidocSignatureSpan">(parts, nlines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addInterpolated = function (parts, nlines){
  var tokens, last, ref$, left, right, joint, callable, i$, len$, i, t;
  if (!parts[1]) {
    return this.strnum(nlines(this.string(&#x27;&#x22;&#x27;, parts[0][1])));
  }
  tokens = this.tokens, last = this.last;
  ref$ = !last.spaced &#x26;&#x26; last[1] === &#x27;%&#x27;
    ? (--tokens.length, this.last = last = tokens[tokens.length - 1], [&#x27;[&#x27;, &#x27;]&#x27;, [&#x27;,&#x27;, &#x27;,&#x27;]])
    : [&#x27;(&#x27;, &#x27;)&#x27;, [&#x27;+-&#x27;, &#x27;+&#x27;]], left = ref$[0], right = ref$[1], joint = ref$[2];
  callable = this.adi();
  tokens.push([left, &#x27;&#x22;&#x27;, last[2], last[3]]);
  for (i$ = 0, len$ = parts.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    t = parts[i$];
    if (t[0] === &#x27;TOKENS&#x27;) {
      tokens.push.apply(tokens, t[1]);
    } else {
      if (i &#x3e; 1 &#x26;&#x26; !t[1]) {
        continue;
      }
      tokens.push([&#x27;STRNUM&#x27;, nlines(this.string(&#x27;&#x22;&#x27;, t[1])), t[2], t[3]]);
    }
    tokens.push(joint.concat(tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]));
  }
  --tokens.length;
  this.token(right, &#x27;&#x27;, callable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (q === code.charAt(index + 1)) {
    return q === code.charAt(index + 2)
      ? this.doHeredoc(code, index, q)
      : (this.strnum(q + q), 2);
  }
  if (q === &#x27;&#x22;&#x27;) {
    parts = this.interpolate(code, index, q);
    this.<span class="apidocCodeKeywordSpan">addInterpolated</span>(parts, unlines);
    return parts.size;
  }
  str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp(&#x27;unterminated string&#x27;);
  this.strnum(unlines(this.string(q, str.slice(1, -1))));
  return this.countLines(str).length;
};
exports.doHeredoc = function(code, index, q){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.adi" id="apidoc.element.livescript.lexer.adi">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>adi
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adi = function (){
  if (this.last.spaced) {
    return;
  }
  if (!able(this.tokens)) {
    return;
  }
  return this.token(&#x27;DOT&#x27;, &#x27;.&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Function(&#x22;var &#x22; + id);
  } catch (e$) {
    e = e$;
    this.carp(&#x22;invalid identifier &#x27;&#x22; + id + &#x22;&#x27;&#x22;);
  }
}
last = this.last;
if (regexMatch[2] || last[0] === &#x27;DOT&#x27; || this.<span class="apidocCodeKeywordSpan">adi</span>()) {
  this.token(&#x27;ID&#x27;, in$(id, JS_KEYWORDS) ? (ref$ = Object(id), ref$.reserved = true, ref$) : id);
  if (regexMatch[2]) {
    this.token(&#x27;:&#x27;, &#x27;:&#x27;);
  }
  return input.length;
}
switch (id) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.carp" id="apidoc.element.livescript.lexer.carp">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>carp
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">carp = function (it){
  carp(it, this.line);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.getJump()) {
    that.<span class="apidocCodeKeywordSpan">carp</span>(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
  this.traverseChildren(function(it){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.checkConsistency" id="apidoc.element.livescript.lexer.checkConsistency">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>checkConsistency
        <span class="apidocSignatureSpan">(camel, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkConsistency = function (camel, id){
  if (this.hasOwn.call(this.identifiers, camel) &#x26;&#x26; this.identifiers[camel] !== id) {
    throw new ReferenceError(&#x22;Inconsistent use of &#x22; + camel + &#x22; as &#x22; + id + &#x22; on line &#x22; + (-~this.line));
  } else {
    return this.identifiers[camel] = id;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var regexMatch, input, id, e, last, ref$, tag, ref1$, that;
input = (regexMatch = (ID.lastIndex = index, ID).exec(code))[0];
if (!input) {
  return 0;
}
id = camelize(regexMatch[1]);
if (/-/.test(regexMatch[1])) {
  this.<span class="apidocCodeKeywordSpan">checkConsistency</span>(id, regexMatch[1]);
}
if (NONASCII.test(id)) {
  try {
    Function(&#x22;var &#x22; + id);
  } catch (e$) {
    e = e$;
    this.carp(&#x22;invalid identifier &#x27;&#x22; + id + &#x22;&#x27;&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.countLines" id="apidoc.element.livescript.lexer.countLines">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>countLines
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">countLines = function (it){
  var pos;
  if (!this.isAtPrefix) {
    this.column += it.length;
  }
  while (pos = 1 + it.indexOf(&#x27;\n&#x27;, pos)) {
    if (!this.isAtPrefix) {
      this.column = 0;
    }
    this.column += it.length - pos;
    ++this.line;
    this.isAtPrefix = false;
  }
  this.charsCounted += it.length;
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (q === &#x27;&#x22;&#x27;) {
  parts = this.interpolate(code, index, q);
  this.addInterpolated(parts, unlines);
  return parts.size;
}
str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp(&#x27;unterminated string&#x27;);
this.strnum(unlines(this.string(q, str.slice(1, -1))));
return this.<span class="apidocCodeKeywordSpan">countLines</span>(str).length;
};
exports.doHeredoc = function(code, index, q){
var end, raw, doc, parts, tabs, i$, len$, i, t;
if (q === &#x27;\&#x27;&#x27;) {
  ~(end = code.indexOf(q + q + q, index + 3)) || this.carp(&#x27;unterminated heredoc&#x27;);
  raw = code.slice(index + 3, end);
  doc = raw.replace(LASTDENT, &#x27;&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.dedent" id="apidoc.element.livescript.lexer.dedent">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>dedent
        <span class="apidocSignatureSpan">(debt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dedent = function (debt){
  var dent;
  this.dent -= debt;
  while (debt &#x3e; 0 &#x26;&#x26; (dent = this.dents.pop())) {
    if (debt &#x3c; dent &#x26;&#x26; !this.inter) {
      this.carp(&#x22;unmatched dedent (&#x22; + debt + &#x22; for &#x22; + dent + &#x22;)&#x22;);
    }
    this.pair(&#x27;DEDENT&#x27;);
    debt -= typeof dent === &#x27;number&#x27; ? this.token(&#x27;DEDENT&#x27;, dent) : dent;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      i += this.doLiteral(code, i);
    }
    break;
  default:
    i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
  }
}
this.<span class="apidocCodeKeywordSpan">dedent</span>(this.dent);
if (that = this.closes.pop()) {
  this.carp(&#x22;missing `&#x22; + that + &#x22;`&#x22;);
}
if (this.inter) {
  this.rest == null &#x26;&#x26; this.carp(&#x27;unterminated interpolation&#x27;);
} else {
  this.last.spaced = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doBackslash" id="apidoc.element.livescript.lexer.doBackslash">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doBackslash
        <span class="apidocSignatureSpan">(code, lastIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doBackslash = function (code, lastIndex){
  var ref$, input, word;
  BSTOKEN.lastIndex = lastIndex;
  ref$ = BSTOKEN.exec(code), input = ref$[0], word = ref$[1];
  if (word) {
    this.strnum(this.string(&#x27;\&#x27;&#x27;, word));
  } else {
    this.countLines(input);
  }
  return input.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27; &#x27;:
  i += this.doSpace(code, i);
  break;
case &#x27;\n&#x27;:
  i += this.doLine(code, i);
  break;
case &#x27;\\&#x27;:
  i += this.<span class="apidocCodeKeywordSpan">doBackslash</span>(code, i);
  break;
case &#x27;\&#x27;&#x27;:
case &#x27;&#x22;&#x27;:
  i += this.doString(code, i, c);
  break;
case &#x22;0&#x22;:
case &#x22;1&#x22;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doCase" id="apidoc.element.livescript.lexer.doCase">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doCase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doCase = function (){
  var ref$, ref1$;
  this.seenFor = false;
  if (((ref$ = this.last[0]) === &#x27;ASSIGN&#x27; || ref$ === &#x27;-&#x3e;&#x27; || ref$ === &#x27;:&#x27;) || (this.last[0] === &#x27;INDENT&#x27; &#x26;&#x26; ((ref$ = (ref1$ = this
.tokens)[ref1$.length - 2][0]) === &#x27;ASSIGN&#x27; || ref$ === &#x27;-&#x3e;&#x27; || ref$ === &#x27;:&#x27;))) {
    this.token(&#x27;SWITCH&#x27;, &#x27;switch&#x27;);
    return this.token(&#x27;CASE&#x27;, &#x27;case&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }.call(this));
  break;
case &#x27;when&#x27;:
  this.fset(&#x27;for&#x27;, false);
  tag = &#x27;CASE&#x27;;
  // fallthrough
case &#x27;case&#x27;:
  if (this.<span class="apidocCodeKeywordSpan">doCase</span>()) {
    return input.length;
  }
  break;
case &#x27;match&#x27;:
  tag = &#x27;SWITCH&#x27;;
  break;
case &#x27;loop&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doComment" id="apidoc.element.livescript.lexer.doComment">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doComment
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doComment = function (code, index){
  var comment, end, ref$;
  comment = ~(end = code.indexOf(&#x27;*/&#x27;, index + 2))
    ? code.slice(index, end + 2)
    : code.slice(index) + &#x27;*/&#x27;;
  if ((ref$ = this.last[0]) === &#x27;NEWLINE&#x27; || ref$ === &#x27;INDENT&#x27; || ref$ === &#x27;THEN&#x27;) {
    this.token(&#x27;COMMENT&#x27;, detab(comment, this.dent));
    this.token(&#x27;NEWLINE&#x27;, &#x27;\n&#x27;);
  }
  return this.countLines(comment).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x22;8&#x22;:
case &#x22;9&#x22;:
  i += this.doNumber(code, i);
  break;
case &#x27;/&#x27;:
  switch (code.charAt(i + 1)) {
  case &#x27;*&#x27;:
    i += this.<span class="apidocCodeKeywordSpan">doComment</span>(code, i);
    break;
  case &#x27;/&#x27;:
    i += this.doHeregex(code, i);
    break;
  default:
    i += this.doRegex(code, i) || this.doLiteral(code, i);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doHeredoc" id="apidoc.element.livescript.lexer.doHeredoc">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doHeredoc
        <span class="apidocSignatureSpan">(code, index, q)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doHeredoc = function (code, index, q){
  var end, raw, doc, parts, tabs, i$, len$, i, t;
  if (q === &#x27;\&#x27;&#x27;) {
    ~(end = code.indexOf(q + q + q, index + 3)) || this.carp(&#x27;unterminated heredoc&#x27;);
    raw = code.slice(index + 3, end);
    doc = raw.replace(LASTDENT, &#x27;&#x27;);
    this.strnum(enlines(this.string(q, lchomp(detab(doc, heretabs(doc))))));
    return this.countLines(raw).length + 6;
  }
  parts = this.interpolate(code, index, q + q + q);
  tabs = heretabs(code.slice(index + 3, index + parts.size - 3).replace(LASTDENT, &#x27;&#x27;));
  for (i$ = 0, len$ = parts.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    t = parts[i$];
    if (t[0] === &#x27;S&#x27;) {
      if (i + 1 === parts.length) {
        t[1] = t[1].replace(LASTDENT, &#x27;&#x27;);
      }
      t[1] = detab(t[1], tabs);
      if (i === 0) {
        t[1] = lchomp(t[1]);
      }
    }
  }
  this.addInterpolated(parts, enlines);
  return parts.size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.strnum(num);
return input.length;
};
exports.doString = function(code, index, q){
var parts, str;
if (q === code.charAt(index + 1)) {
  return q === code.charAt(index + 2)
    ? this.<span class="apidocCodeKeywordSpan">doHeredoc</span>(code, index, q)
    : (this.strnum(q + q), 2);
}
if (q === &#x27;&#x22;&#x27;) {
  parts = this.interpolate(code, index, q);
  this.addInterpolated(parts, unlines);
  return parts.size;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doHeregex" id="apidoc.element.livescript.lexer.doHeregex">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doHeregex
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doHeregex = function (code, index){
  var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;
  tokens = this.tokens, last = this.last;
  parts = this.interpolate(code, index, &#x27;//&#x27;);
  rest = code.slice(index + parts.size);
  flag = this.validate(/^(?:[gimy]{1,4}|[?$]?)/.exec(rest)[0]);
  if (parts[1]) {
    if (flag === &#x27;$&#x27;) {
      this.adi();
      this.token(&#x27;(&#x27;, &#x27;&#x22;&#x27;);
    } else {
      tokens.push([&#x27;ID&#x27;, &#x27;RegExp&#x27;, last[2], last[3]], [&#x27;CALL(&#x27;, &#x27;&#x27;, last[2], last[3]]);
      if (flag === &#x27;?&#x27;) {
        for (i$ = parts.length - 1; i$ &#x3e;= 0; --i$) {
          i = i$;
          t = parts[i$];
          if (t[0] === &#x27;TOKENS&#x27;) {
            dynaflag = parts.splice(i, 1)[0][1];
            break;
          }
        }
      }
    }
    for (i$ = 0, len$ = parts.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      t = parts[i$];
      if (t[0] === &#x27;TOKENS&#x27;) {
        tokens.push.apply(tokens, t[1]);
      } else {
        val = deheregex(t[1]);
        if (one &#x26;&#x26; !val) {
          continue;
        }
        one = tokens.push((t[0] = &#x27;STRNUM&#x27;, t[1] = this.string(&#x27;\&#x27;&#x27;, enslash(val)), t));
      }
      tokens.push([&#x27;+-&#x27;, &#x27;+&#x27;, tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]]);
    }
    --tokens.length;
    if (dynaflag || flag &#x3e;= &#x27;g&#x27;) {
      this.token(&#x27;,&#x27;, &#x27;,&#x27;);
      if (dynaflag) {
        tokens.push.apply(tokens, dynaflag);
      } else {
        this.token(&#x27;STRNUM&#x27;, &#x22;&#x27;&#x22; + flag + &#x22;&#x27;&#x22;);
      }
    }
    this.token(flag === &#x27;$&#x27; ? &#x27;)&#x27; : &#x27;)CALL&#x27;, &#x27;&#x27;);
  } else {
    this.regex(reslash(deheregex(parts[0][1])), flag);
  }
  return parts.size + flag.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case &#x27;/&#x27;:
  switch (code.charAt(i + 1)) {
  case &#x27;*&#x27;:
    i += this.doComment(code, i);
    break;
  case &#x27;/&#x27;:
    i += this.<span class="apidocCodeKeywordSpan">doHeregex</span>(code, i);
    break;
  default:
    i += this.doRegex(code, i) || this.doLiteral(code, i);
  }
  break;
case &#x27;`&#x27;:
  if (&#x27;`&#x27; === code.charAt(i + 1)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doID" id="apidoc.element.livescript.lexer.doID">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doID
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doID = function (code, index){
  var regexMatch, input, id, e, last, ref$, tag, ref1$, that;
  input = (regexMatch = (ID.lastIndex = index, ID).exec(code))[0];
  if (!input) {
    return 0;
  }
  id = camelize(regexMatch[1]);
  if (/-/.test(regexMatch[1])) {
    this.checkConsistency(id, regexMatch[1]);
  }
  if (NONASCII.test(id)) {
    try {
      Function(&#x22;var &#x22; + id);
    } catch (e$) {
      e = e$;
      this.carp(&#x22;invalid identifier &#x27;&#x22; + id + &#x22;&#x27;&#x22;);
    }
  }
  last = this.last;
  if (regexMatch[2] || last[0] === &#x27;DOT&#x27; || this.adi()) {
    this.token(&#x27;ID&#x27;, in$(id, JS_KEYWORDS) ? (ref$ = Object(id), ref$.reserved = true, ref$) : id);
    if (regexMatch[2]) {
      this.token(&#x27;:&#x27;, &#x27;:&#x27;);
    }
    return input.length;
  }
  switch (id) {
  case &#x27;true&#x27;:
  case &#x27;false&#x27;:
  case &#x27;on&#x27;:
  case &#x27;off&#x27;:
  case &#x27;yes&#x27;:
  case &#x27;no&#x27;:
  case &#x27;null&#x27;:
  case &#x27;void&#x27;:
  case &#x27;arguments&#x27;:
  case &#x27;debugger&#x27;:
    tag = &#x27;LITERAL&#x27;;
    break;
  case &#x27;new&#x27;:
  case &#x27;do&#x27;:
  case &#x27;typeof&#x27;:
  case &#x27;delete&#x27;:
    tag = &#x27;UNARY&#x27;;
    break;
  case &#x27;yield&#x27;:
    tag = &#x27;YIELD&#x27;;
    break;
  case &#x27;return&#x27;:
  case &#x27;throw&#x27;:
    tag = &#x27;HURL&#x27;;
    break;
  case &#x27;break&#x27;:
  case &#x27;continue&#x27;:
    tag = &#x27;JUMP&#x27;;
    break;
  case &#x27;this&#x27;:
  case &#x27;eval&#x27;:
  case &#x27;super&#x27;:
    return this.token(&#x27;LITERAL&#x27;, id, true).length;
  case &#x27;for&#x27;:
    id = [];
    this.fset(&#x27;for&#x27;, true);
    this.fset(&#x27;to&#x27;, false);
    this.fset(&#x27;by&#x27;, true);
    break;
  case &#x27;then&#x27;:
    this.fset(&#x27;for&#x27;, false);
    this.fset(&#x27;to&#x27;, false);
    break;
  case &#x27;catch&#x27;:
  case &#x27;function&#x27;:
    id = &#x27;&#x27;;
    break;
  case &#x27;in&#x27;:
  case &#x27;of&#x27;:
    if (this.fget(&#x27;for&#x27;)) {
      this.fset(&#x27;for&#x27;, false);
      if (id === &#x27;in&#x27;) {
        this.fset(&#x27;by&#x27;, true);
        id = &#x27;&#x27;;
        if (last[0] === &#x27;ID&#x27; &#x26;&#x26; ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === &#x27;,&#x27; || ref$ === &#x27;]&#x27; || ref$ === &#x27;}&#x27;)) {
          id = this.tokens.pop()[1];
          if ((ref$ = this.tokens)[ref$.length - 1][0] === &#x27;,&#x27;) {
            this.tokens.pop();
          }
        }
      }
      break;
    }
    // fallthrough
  case &#x27;instanceof&#x27;:
    if (last[1] === &#x27;!&#x27;) {
      id = this.tokens.pop()[1] + id;
    }
    tag = (ref$ = this.tokens)[ref$.length - 1][0] === &#x27;(&#x27; ? &#x27;BIOPR&#x27; : &#x27;RELATION&#x27;;
    break;
  case &#x27;not&#x27;:
    if (last.alias &#x26;&#x26; last[1] === &#x27;===&#x27;) {
      return last[1] = &#x27;!==&#x27;, 3;
    }
    tag = &#x27;UNARY&#x27;;
    id = &#x27;!&#x27;;
    break;
  case &#x27;and&#x27;:
  case &#x27;or&#x27;:
  case &#x27;xor&#x27;:
  case &#x27;is&#x27;:
  case &#x27;isnt&#x27;:
    this.unline();
    tag = id === &#x27;is&#x27; || id === &#x27;isnt&#x27; ? &#x27;COMPARE&#x27; : &#x27;LOGIC&#x27;;
    if (last[0] === &#x27;(&#x27;) {
      tag = &#x27;BIOP&#x27;;
    }
    this.token(tag, (function(){
      switch (id) {
      case &#x27;is&#x27;:
        return &#x27;===&#x27;;
      case &#x27;isnt&#x27;:
        return &#x27;!==&#x27;;
      case &#x27;or&#x27;:
        return &#x27;||&#x27;;
      case &#x27;and&#x27;:
        return &#x27;&#x26;&#x26;&#x27;;
      case &#x27;xor&#x27;:
        return &#x27;xor&#x27;;
      }
    }()));
    this.last.alias = true;
    return id.length;
  case &#x27;unless&#x27;:
    tag = &#x27;IF&#x27;;
    break;
  case &#x27;until&#x27;:
    tag = &#x27;WHILE&#x27;;
    break;
  case &#x27;import&#x27;:
    if (last[0] === &#x27;(&#x27;) {
      id = &#x27;&#x3c;&#x3c;&#x3c;&#x27;;
      tag = &#x27;BIOP&#x27;;
    } else {
      if (able(this.tokens)) {
        id = &#x27;&#x3c;&#x3c;&#x3c;&#x27;;
      } else {
        tag = &#x27;DECL&#x27;;
      }
    }
    break;
  case &#x27;export&#x27;:
  case &#x27;const&#x27;:
  case &#x27;var&#x27;:
    tag = &#x27;DECL&#x27;;
    break;
  case &#x27;with&#x27;:
    tag = (function(){
      switch (false) {
      case !able(this.tokens):
        return &#x27;CLONEPORT&#x27;;
      case last[0] !== &#x27;(&#x27;:
        return &#x27;BIOP&#x27;;
      default:
        return &#x27;WITH&#x27;;
      }
    }.call(this));
    break;
  case &#x27;when&#x27;:
    this.fset(&#x27;for&#x27;, false);
    tag = &#x27;CASE&#x27;;
    // fallthrough
  case &#x27;case&#x27;:
    if (this.doCase()) {
      return input.length;
    }
    break;
  case &#x27;match&#x27;:
    tag = &#x27;SWITCH&#x27;;
    break;
  case &#x27;loop&#x27;:
    this.token(&#x27;WHILE&#x27;, id);
    this.token(&#x27;LITERAL&#x27;, &#x27;true&#x27;);
    return input.length;
  case &#x27;let&#x27;:
  case &#x27;own&#x27;:
    if (last[0] === &#x27;FOR&#x27; &#x26;&#x26; !in$(id, last[1])) {
      last[1].push(id);
      return 3;
    }
    // fallthrough
  default:
    if (in$(id, KEYWORDS_SHARED)) {
      break;
    }
    if (in$(id, KEYWORDS_UNUSED)) {
      this.carp(&#x22;reserve ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (&#x27;`&#x27; === code.charAt(i + 1)) {
      i += this.doJS(code, i);
    } else {
      i += this.doLiteral(code, i);
    }
    break;
  default:
    i += this.<span class="apidocCodeKeywordSpan">doID</span>(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
  }
}
this.dedent(this.dent);
if (that = this.closes.pop()) {
  this.carp(&#x22;missing `&#x22; + that + &#x22;`&#x22;);
}
if (this.inter) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doJS" id="apidoc.element.livescript.lexer.doJS">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doJS
        <span class="apidocSignatureSpan">(code, lastIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doJS = function (code, lastIndex){
  var js, ref$;
  JSTOKEN.lastIndex = lastIndex;
  js = JSTOKEN.exec(code)[0] || this.carp(&#x27;unterminated JS literal&#x27;);
  this.token(&#x27;LITERAL&#x27;, (ref$ = Object(detab(js.slice(2, -2), this.dent)), ref$.js = true, ref$), true);
  return this.countLines(js).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    break;
  default:
    i += this.doRegex(code, i) || this.doLiteral(code, i);
  }
  break;
case &#x27;`&#x27;:
  if (&#x27;`&#x27; === code.charAt(i + 1)) {
    i += this.<span class="apidocCodeKeywordSpan">doJS</span>(code, i);
  } else {
    i += this.doLiteral(code, i);
  }
  break;
default:
  i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doLine" id="apidoc.element.livescript.lexer.doLine">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doLine
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doLine = function (code, index){
  var ref$, input, tabs, length, last, that, delta, tag, val;
  ref$ = (MULTIDENT.lastIndex = index, MULTIDENT).exec(code), input = ref$[0], tabs = ref$[1];
  length = this.countLines(input).length;
  last = this.last;
  last.eol = true;
  last.spaced = true;
  if (index + length &#x3e;= code.length) {
    return length;
  }
  if (that = tabs &#x26;&#x26; (this.emender || (this.emender = RegExp(&#x27;[^&#x27; + tabs.charAt() + &#x27;]&#x27;))).exec(tabs)) {
    this.carp(&#x22;contaminated indent &#x22; + escape(that));
  }
  if (0 &#x3e; (delta = tabs.length - this.dent)) {
    this.dedent(-delta);
    this.newline();
  } else {
    tag = last[0], val = last[1];
    if (tag === &#x27;ASSIGN&#x27; &#x26;&#x26; ((ref$ = val + &#x27;&#x27;) !== &#x27;=&#x27; &#x26;&#x26; ref$ !== &#x27;:=&#x27; &#x26;&#x26; ref$ !== &#x27;+=&#x27;) || val === &#x27;++&#x27; &#x26;&#x26; (ref$ = this.tokens
)[ref$.length - 2].spaced || (tag === &#x27;+-&#x27; || tag === &#x27;PIPE&#x27; || tag === &#x27;BACKPIPE&#x27; || tag === &#x27;COMPOSE&#x27; || tag === &#x27;DOT&#x27; || tag === &#x27;
LOGIC&#x27; || tag === &#x27;MATH&#x27; || tag === &#x27;COMPARE&#x27; || tag === &#x27;RELATION&#x27; || tag === &#x27;SHIFT&#x27; || tag === &#x27;IN&#x27; || tag === &#x27;OF&#x27; || tag === &#x27;
TO&#x27; || tag === &#x27;BY&#x27; || tag === &#x27;FROM&#x27; || tag === &#x27;EXTENDS&#x27; || tag === &#x27;IMPLEMENTS&#x27;)) {
      return length;
    }
    if (delta) {
      this.indent(delta);
    } else {
      this.newline();
    }
  }
  this.fset(&#x27;for&#x27;, false);
  this.fset(&#x27;by&#x27;, false);
  return length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.column += charsConsumed - this.charsCounted;
this.charsCounted = 0;
switch (c) {
case &#x27; &#x27;:
  i += this.doSpace(code, i);
  break;
case &#x27;\n&#x27;:
  i += this.<span class="apidocCodeKeywordSpan">doLine</span>(code, i);
  break;
case &#x27;\\&#x27;:
  i += this.doBackslash(code, i);
  break;
case &#x27;\&#x27;&#x27;:
case &#x27;&#x22;&#x27;:
  i += this.doString(code, i, c);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doLiteral" id="apidoc.element.livescript.lexer.doLiteral">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doLiteral
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doLiteral = function (code, index){
  var sym, tag, val, ref$, that;
  if (!(sym = (SYMBOL.lastIndex = index, SYMBOL).exec(code)[0])) {
    return 0;
  }
  switch (tag = val = sym) {
  case &#x27;|&#x27;:
    tag = &#x27;CASE&#x27;;
    if (this.doCase()) {
      return sym.length;
    }
    break;
  case &#x27;|&#x3e;&#x27;:
    tag = &#x27;PIPE&#x27;;
    break;
  case &#x27;`&#x27;:
    tag = &#x27;BACKTICK&#x27;;
    break;
  case &#x27;&#x3c;&#x3c;&#x27;:
  case &#x27;&#x3e;&#x3e;&#x27;:
    tag = &#x27;COMPOSE&#x27;;
    break;
  case &#x27;&#x3c;|&#x27;:
    tag = &#x27;BACKPIPE&#x27;;
    break;
  case &#x27;+&#x27;:
  case &#x27;-&#x27;:
    tag = &#x27;+-&#x27;;
    break;
  case &#x27;&#x26;&#x26;&#x27;:
  case &#x27;||&#x27;:
    tag = &#x27;LOGIC&#x27;;
    break;
  case &#x27;.&#x26;.&#x27;:
  case &#x27;.|.&#x27;:
  case &#x27;.^.&#x27;:
    tag = &#x27;BITWISE&#x27;;
    break;
  case &#x27;^^&#x27;:
    tag = &#x27;CLONE&#x27;;
    break;
  case &#x27;**&#x27;:
  case &#x27;^&#x27;:
    tag = &#x27;POWER&#x27;;
    break;
  case &#x27;?&#x27;:
    if (this.last[0] === &#x27;(&#x27;) {
      this.token(&#x27;PARAM(&#x27;, &#x27;(&#x27;);
      this.token(&#x27;)PARAM&#x27;, &#x27;)&#x27;);
      this.token(&#x27;-&#x3e;&#x27;, &#x27;-&#x3e;&#x27;);
      this.token(&#x27;ID&#x27;, &#x27;it&#x27;);
    } else {
      if (this.last.spaced) {
        tag = &#x27;LOGIC&#x27;;
      }
    }
    break;
  case &#x27;/&#x27;:
  case &#x27;%&#x27;:
  case &#x27;%%&#x27;:
    tag = &#x27;MATH&#x27;;
    break;
  case &#x27;++&#x27;:
  case &#x27;--&#x27;:
    tag = &#x27;CREMENT&#x27;;
    break;
  case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
  case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
    tag = &#x27;IMPORT&#x27;;
    break;
  case &#x27;;&#x27;:
    tag = &#x27;NEWLINE&#x27;;
    this.fset(&#x27;by&#x27;, false);
    break;
  case &#x27;..&#x27;:
    this.token(&#x27;LITERAL&#x27;, &#x27;..&#x27;, true);
    return 2;
  case &#x27;.&#x27;:
    if (this.last[1] === &#x27;?&#x27;) {
      this.last[0] = &#x27;?&#x27;;
    }
    tag = &#x27;DOT&#x27;;
    break;
  case &#x27;,&#x27;:
    switch (this.last[0]) {
    case &#x27;,&#x27;:
    case &#x27;[&#x27;:
    case &#x27;(&#x27;:
    case &#x27;CALL(&#x27;:
      this.token(&#x27;LITERAL&#x27;, &#x27;void&#x27;);
      break;
    case &#x27;FOR&#x27;:
    case &#x27;OWN&#x27;:
      this.token(&#x27;ID&#x27;, &#x27;&#x27;);
    }
    break;
  case &#x27;!=&#x27;:
  case &#x27;~=&#x27;:
    if (!(able(this.tokens) || ((ref$ = this.last[0]) === &#x27;(&#x27; || ref$ === &#x27;CREMENT&#x27;))) {
      this.tokens.push(val === &#x27;!=&#x27;
        ? [&#x27;UNARY&#x27;, &#x27;!&#x27;, this.line, this.column]
        : [&#x27;UNARY&#x27;, &#x27;~&#x27;, this.line, this.column], [&#x27;ASSIGN&#x27;, &#x27;=&#x27;, this.line, this.column]);
      return 2;
    }
    // fallthrough
  case &#x27;!~=&#x27;:
  case &#x27;==&#x27;:
    val = (function(){
      switch (val) {
      case &#x27;~=&#x27;:
        return &#x27;==&#x27;;
      case &#x27;!~=&#x27;:
        return &#x27;!=&#x27;;
      case &#x27;==&#x27;:
        return &#x27;===&#x27;;
      case &#x27;!=&#x27;:
        return &#x27;!==&#x27;;
      }
    }());
    tag = &#x27;COMPARE&#x27;;
    break;
  case &#x27;===&#x27;:
  case &#x27;!==&#x27;:
    val += &#x27;=&#x27;;
    // fallthrough
  case &#x27;&#x3c;&#x27;:
  case &#x27;&#x3e;&#x27;:
  case &#x27;&#x3c;=&#x27;:
  case &#x27;&#x3e;=&#x27;:
  case &#x27;&#x3c;==&#x27;:
  case &#x27;&#x3e;==&#x27;:
  case &#x27;&#x3e;&#x3e;=&#x27;:
  case &#x27;&#x3c;&#x3c;=&#x27;:
    tag = &#x27;COMPARE&#x27;;
    break;
  case &#x27;.&#x3c;&#x3c;.&#x27;:
  case &#x27;.&#x3e;&#x3e;.&#x27;:
  case &#x27;.&#x3e;&#x3e;&#x3e;.&#x27;:
  case &#x27;&#x3c;?&#x27;:
  case &#x27;&#x3e;?&#x27;:
    tag = &#x27;SHIFT&#x27;;
    break;
  case &#x27;(&#x27;:
    if (!(((ref$ = this.last[0]) === &#x27;FUNCTION&#x27; || ref$ === &#x27;GENERATOR&#x27; || ref$ === &#x27;LET&#x27;) || this.able(true) || this.last[1] === &#x27;.@&#x27;)) {
      this.token(&#x27;(&#x27;, &#x27;(&#x27;);
      this.closes.push(&#x27;)&#x27;);
      this.parens.push(this.last);
      return 1;
    }
    tag = &#x27;CALL(&#x27;;
    this.closes.push(&#x27;)CALL&#x27;);
    break;
  case &#x27;[&#x27;:
  case &#x27;{&#x27;:
    this.adi();
    this.closes.push(&#x27;]}&#x27;.charAt(val === &#x27;{&#x27;));
    break;
  case &#x27;}&#x27;:
    if (this.inter &#x26;&#x26; val !== (ref$ = this.closes)[ref$.length - 1]) {
      this.rest = code.slice(index + 1);
      return 9e9;
    }
    // fallthrough
  case &#x27;]&#x27;:
  case &#x27;)&#x27;:
    if (tag === &#x27;)&#x27; &#x26;&#x26; ((ref$ = this.last[0]) === &#x27;+-&#x27; || ref$ === &#x27;COMPARE&#x27; || ref$ === &#x27;LOGIC&#x27; || ref$ === &#x27;MATH&#x27; || ref$ === &#x27;
POWER&#x27; || ref$ === &#x27;SHIFT&#x27; || ref$ === &#x27;BITWISE&#x27; || ref$ === &#x27;CONCAT&#x27; || ref$ === &#x27;COMPOSE&#x27; || ref$ === &#x27;RELATION&#x27; || ref$ === &#x27;
PIPE&#x27; || ref$ === &#x27;BACKPIPE&#x27; || ref$ === &#x27;IMPORT&#x27; || ref$ === &#x27;CLONEPORT&#x27; || ref$ === &#x27;ASSIGN&#x27;)) {
      (ref$ = this.tokens)[ref$.length - 1][0] = (function(){
        switch (this.last[0]) {
        case &#x27;RELATION&#x27;:
          return &#x27;BIOPR&#x27;;
        case &#x27;PIPE&#x27;:
          this.parameters(false, -1);
          return &#x27;BIOPP&#x27;;
        default:
          return &#x27;BIOP&#x27;;
        }
      }.call(this));
    }
    if (&#x27;)&#x27; === (tag = val = this.pair(val))) {
      this.lpar = this.parens.pop();
    }
    break;
  case &#x27;=&#x27;:
  case &#x27;:&#x27;:
    if (val === &#x27;:&#x27;) {
      switch (this.last[0]) {
      case &#x27;ID&#x27;:
      case &#x27;STRNUM&#x27;:
      case &#x27;)&#x27;:
        break; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case &#x27;*&#x27;:
    i += this.doComment(code, i);
    break;
  case &#x27;/&#x27;:
    i += this.doHeregex(code, i);
    break;
  default:
    i += this.doRegex(code, i) || this.<span class="apidocCodeKeywordSpan">doLiteral</span>(code, i);
  }
  break;
case &#x27;`&#x27;:
  if (&#x27;`&#x27; === code.charAt(i + 1)) {
    i += this.doJS(code, i);
  } else {
    i += this.doLiteral(code, i);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doNumber" id="apidoc.element.livescript.lexer.doNumber">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doNumber
        <span class="apidocSignatureSpan">(code, lastIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doNumber = function (code, lastIndex){
  var input, regexMatch, last, radix, num, rnum, bound, ref$;
  NUMBER.lastIndex = lastIndex;
  if (!(input = (regexMatch = NUMBER.exec(code))[0])) {
    return 0;
  }
  last = this.last;
  if (regexMatch[5] &#x26;&#x26; (last[0] === &#x27;DOT&#x27; || this.adi())) {
    this.token(&#x27;STRNUM&#x27;, regexMatch[4].replace(NUMBER_OMIT, &#x27;&#x27;));
    return regexMatch[4].length;
  }
  if (radix = regexMatch[1]) {
    num = parseInt(rnum = regexMatch[2].replace(NUMBER_OMIT, &#x27;&#x27;), radix);
    bound = false;
    if (radix &#x3e; 36 || radix &#x3c; 2) {
      if (/[0-9]/.exec(rnum)) {
        this.carp(&#x22;invalid number base &#x22; + radix + &#x22; (with number &#x22; + rnum + &#x22;),base must be from 2 to 36&#x22;);
      } else {
        bound = true;
      }
    }
    if (isNaN(num) || num === parseInt(rnum.slice(0, -1), radix)) {
      this.strnum(regexMatch[1]);
      this.token(&#x27;DOT&#x27;, &#x27;.~&#x27;);
      this.token(&#x27;ID&#x27;, regexMatch[2]);
      return input.length;
    }
    num += &#x27;&#x27;;
  } else {
    num = (regexMatch[3] || input).replace(NUMBER_OMIT, &#x27;&#x27;);
    if (regexMatch[3] &#x26;&#x26; num.charAt() === &#x27;0&#x27; &#x26;&#x26; ((ref$ = num.charAt(1)) !== &#x27;&#x27; &#x26;&#x26; ref$ !== &#x27;.&#x27;)) {
      this.carp(&#x22;deprecated octal literal &#x22; + regexMatch[4]);
    }
  }
  if (!last.spaced &#x26;&#x26; last[0] === &#x27;+-&#x27;) {
    last[0] = &#x27;STRNUM&#x27;;
    last[1] += num;
    return input.length;
  }
  this.strnum(num);
  return input.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x22;3&#x22;:
case &#x22;4&#x22;:
case &#x22;5&#x22;:
case &#x22;6&#x22;:
case &#x22;7&#x22;:
case &#x22;8&#x22;:
case &#x22;9&#x22;:
  i += this.<span class="apidocCodeKeywordSpan">doNumber</span>(code, i);
  break;
case &#x27;/&#x27;:
  switch (code.charAt(i + 1)) {
  case &#x27;*&#x27;:
    i += this.doComment(code, i);
    break;
  case &#x27;/&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doRegex" id="apidoc.element.livescript.lexer.doRegex">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doRegex
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doRegex = function (code, index){
  var divisible, ref$, input, body, flag;
  if (divisible = able(this.tokens) || this.last[0] === &#x27;CREMENT&#x27;) {
    if (!this.last.spaced || ((ref$ = code.charAt(index + 1)) === &#x27; &#x27; || ref$ === &#x27;=&#x27;)) {
      return 0;
    }
  }
  ref$ = (REGEX.lastIndex = index, REGEX).exec(code), input = ref$[0], body = ref$[1], flag = ref$[2];
  if (input) {
    this.regex(body, flag);
  } else if (!divisible &#x26;&#x26; this.last[0] !== &#x27;(&#x27;) {
    this.carp(&#x27;unterminated regex&#x27;);
  }
  return input.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case &#x27;*&#x27;:
    i += this.doComment(code, i);
    break;
  case &#x27;/&#x27;:
    i += this.doHeregex(code, i);
    break;
  default:
    i += this.<span class="apidocCodeKeywordSpan">doRegex</span>(code, i) || this.doLiteral(code, i);
  }
  break;
case &#x27;`&#x27;:
  if (&#x27;`&#x27; === code.charAt(i + 1)) {
    i += this.doJS(code, i);
  } else {
    i += this.doLiteral(code, i);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doSpace" id="apidoc.element.livescript.lexer.doSpace">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doSpace
        <span class="apidocSignatureSpan">(code, lastIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doSpace = function (code, lastIndex){
  var input;
  SPACE.lastIndex = lastIndex;
  if (input = SPACE.exec(code)[0]) {
    this.last.spaced = true;
  }
  return input.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.charsCounted &#x3e; charsConsumed) {
  throw new Error(&#x27;Location information out-of-sync in lexer&#x27;);
}
this.column += charsConsumed - this.charsCounted;
this.charsCounted = 0;
switch (c) {
case &#x27; &#x27;:
  i += this.<span class="apidocCodeKeywordSpan">doSpace</span>(code, i);
  break;
case &#x27;\n&#x27;:
  i += this.doLine(code, i);
  break;
case &#x27;\\&#x27;:
  i += this.doBackslash(code, i);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doString" id="apidoc.element.livescript.lexer.doString">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doString
        <span class="apidocSignatureSpan">(code, index, q)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doString = function (code, index, q){
  var parts, str;
  if (q === code.charAt(index + 1)) {
    return q === code.charAt(index + 2)
      ? this.doHeredoc(code, index, q)
      : (this.strnum(q + q), 2);
  }
  if (q === &#x27;&#x22;&#x27;) {
    parts = this.interpolate(code, index, q);
    this.addInterpolated(parts, unlines);
    return parts.size;
  }
  str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp(&#x27;unterminated string&#x27;);
  this.strnum(unlines(this.string(q, str.slice(1, -1))));
  return this.countLines(str).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i += this.doLine(code, i);
  break;
case &#x27;\\&#x27;:
  i += this.doBackslash(code, i);
  break;
case &#x27;\&#x27;&#x27;:
case &#x27;&#x22;&#x27;:
  i += this.<span class="apidocCodeKeywordSpan">doString</span>(code, i, c);
  break;
case &#x22;0&#x22;:
case &#x22;1&#x22;:
case &#x22;2&#x22;:
case &#x22;3&#x22;:
case &#x22;4&#x22;:
case &#x22;5&#x22;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.dotcat" id="apidoc.element.livescript.lexer.dotcat">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>dotcat
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dotcat = function (it){
  if (this.last[1] === &#x27;.&#x27; || this.adi()) {
    return this.last[1] += it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  tag = &#x27;UNARY&#x27;;
  break;
case &#x27;|&#x27;:
  tag = &#x27;BITWISE&#x27;;
  break;
case &#x27;~&#x27;:
  if (this.<span class="apidocCodeKeywordSpan">dotcat</span>(val)) {
    return 1;
  }
  tag = &#x27;UNARY&#x27;;
  break;
case &#x27;::&#x27;:
  this.adi();
  val = &#x27;prototype&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.fget" id="apidoc.element.livescript.lexer.fget">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>fget
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fget = function (key){
  var ref$;
  return (ref$ = this.flags[this.closes.length]) != null ? ref$[key] : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case &#x27;catch&#x27;:
case &#x27;function&#x27;:
  id = &#x27;&#x27;;
  break;
case &#x27;in&#x27;:
case &#x27;of&#x27;:
  if (this.<span class="apidocCodeKeywordSpan">fget</span>(&#x27;for&#x27;)) {
    this.fset(&#x27;for&#x27;, false);
    if (id === &#x27;in&#x27;) {
      this.fset(&#x27;by&#x27;, true);
      id = &#x27;&#x27;;
      if (last[0] === &#x27;ID&#x27; &#x26;&#x26; ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === &#x27;,&#x27; || ref$ === &#
x27;]&#x27; || ref$ === &#x27;}&#x27;)) {
        id = this.tokens.pop()[1];
        if ((ref$ = this.tokens)[ref$.length - 1][0] === &#x27;,&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.forange" id="apidoc.element.livescript.lexer.forange">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>forange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forange = function (){
  var ref$, ref1$, ref2$;
  if (((ref$ = (ref1$ = this.tokens)[ref1$.length - 2 - ((ref2$ = this.last[0]) === &#x27;NEWLINE&#x27; || ref2$ === &#x27;INDENT&#x27;)]) != null ?
ref$[0] : void 8) === &#x27;FOR&#x27; || this.last[0] === &#x27;FOR&#x27;) {
    this.fset(&#x27;for&#x27;, false);
    this.fset(&#x27;from&#x27;, true);
    return true;
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case &#x27;from&#x27;:
  if (last[1] === &#x27;yield&#x27;) {
    last[1] += &#x27;from&#x27;;
    return 4;
  }
  this.<span class="apidocCodeKeywordSpan">forange</span>() &#x26;&#x26; (tag = &#x27;FROM&#x27;);
  break;
case &#x27;to&#x27;:
case &#x27;til&#x27;:
  this.forange() &#x26;&#x26; this.tokens.push([&#x27;FROM&#x27;, &#x27;&#x27;, this.line, this.column], [&#x27;STRNUM&#x27;, &#
x27;0&#x27;, this.line, this.column]);
  if (this.fget(&#x27;from&#x27;)) {
    this.fset(&#x27;from&#x27;, false);
    this.fset(&#x27;by&#x27;, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.fset" id="apidoc.element.livescript.lexer.fset">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>fset
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fset = function (key, val){
  var ref$, key$;
  ((ref$ = this.flags)[key$ = this.closes.length] || (ref$[key$] = {}))[key] = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case &#x27;this&#x27;:
case &#x27;eval&#x27;:
case &#x27;super&#x27;:
  return this.token(&#x27;LITERAL&#x27;, id, true).length;
case &#x27;for&#x27;:
  id = [];
  this.<span class="apidocCodeKeywordSpan">fset</span>(&#x27;for&#x27;, true);
  this.fset(&#x27;to&#x27;, false);
  this.fset(&#x27;by&#x27;, true);
  break;
case &#x27;then&#x27;:
  this.fset(&#x27;for&#x27;, false);
  this.fset(&#x27;to&#x27;, false);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.hasOwn" id="apidoc.element.livescript.lexer.hasOwn">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>hasOwn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasOwnProperty() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.indent" id="apidoc.element.livescript.lexer.indent">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>indent
        <span class="apidocSignatureSpan">(delta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indent = function (delta){
  this.dent += delta;
  this.dents.push(this.token(&#x27;INDENT&#x27;, delta));
  this.closes.push(&#x27;DEDENT&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.newline();
} else {
  tag = last[0], val = last[1];
  if (tag === &#x27;ASSIGN&#x27; &#x26;&#x26; ((ref$ = val + &#x27;&#x27;) !== &#x27;=&#x27; &#x26;&#x26; ref$ !== &#x27;:=&#x27
; &#x26;&#x26; ref$ !== &#x27;+=&#x27;) || val === &#x27;++&#x27; &#x26;&#x26; (ref$ = this.tokens)[ref$.length - 2].spaced || (
tag === &#x27;+-&#x27; || tag === &#x27;PIPE&#x27; || tag === &#x27;BACKPIPE&#x27; || tag === &#x27;COMPOSE&#x27; || tag === &#x27
;DOT&#x27; || tag === &#x27;LOGIC&#x27; || tag === &#x27;MATH&#x27; || tag === &#x27;COMPARE&#x27; || tag === &#x27;RELATION&#x27
; || tag === &#x27;SHIFT&#x27; || tag === &#x27;IN&#x27; || tag === &#x27;OF&#x27; || tag === &#x27;TO&#x27; || tag === &#x27;BY
&#x27; || tag === &#x27;FROM&#x27; || tag === &#x27;EXTENDS&#x27; || tag === &#x27;IMPLEMENTS&#x27;)) {
    return length;
  }
  if (delta) {
    this.<span class="apidocCodeKeywordSpan">indent</span>(delta);
  } else {
    this.newline();
  }
}
this.fset(&#x27;for&#x27;, false);
this.fset(&#x27;by&#x27;, false);
return length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.interpolate" id="apidoc.element.livescript.lexer.interpolate">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>interpolate
        <span class="apidocSignatureSpan">(str, idx, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interpolate = function (str, idx, end){
  var parts, end0, pos, i, ref$, oldLine, oldColumn, ch, c1, id, stringified, length, tag, e, delta, nested, clone, ref1$;
  parts = [];
  end0 = end.charAt(0);
  pos = 0;
  i = -1;
  str = str.slice(idx + end.length);
  ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];
  this.countLines(end);
  while (ch = str.charAt(++i)) {
    switch (ch) {
    case end0:
      if (end !== str.slice(i, i + end.length)) {
        continue;
      }
      parts.push([&#x27;S&#x27;, this.countLines(str.slice(0, i)), oldLine, oldColumn]);
      this.countLines(end);
      return parts.size = pos + i + end.length * 2, parts;
    case &#x27;#&#x27;:
      c1 = str.charAt(i + 1);
      id = in$(c1, [&#x27;@&#x27;]) &#x26;&#x26; c1 || (ID.lastIndex = i + 1, ID).exec(str)[1];
      if (!(id || c1 === &#x27;{&#x27;)) {
        continue;
      }
      break;
    case &#x27;\\&#x27;:
      ++i;
      // fallthrough
    default:
      continue;
    }
    if (i || nested &#x26;&#x26; !stringified) {
      stringified = parts.push([&#x27;S&#x27;, this.countLines(str.slice(0, i)), oldLine, oldColumn]);
      ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];
    }
    if (id) {
      length = id.length;
      if (id === &#x27;@&#x27;) {
        id = &#x27;this&#x27;;
      }
      if (in$(id, [&#x27;this&#x27;])) {
        tag = &#x27;LITERAL&#x27;;
      } else {
        id = camelize(id);
        try {
          Function(&#x22;&#x27;use strict&#x27;; var &#x22; + id);
        } catch (e$) {
          e = e$;
          this.carp(&#x22;invalid variable interpolation &#x27;&#x22; + id + &#x22;&#x27;&#x22;);
        }
        tag = &#x27;ID&#x27;;
      }
      str = str.slice(delta = i + 1 + length);
      parts.push([&#x27;TOKENS&#x27;, nested = [[tag, id, this.line, this.column]]]);
    } else {
      clone = (ref$ = clone$(exports), ref$.inter = true, ref$.emender = this.emender, ref$);
      nested = clone.tokenize(str.slice(i + 2), {
        line: this.line,
        column: this.column + 2,
        raw: true
      });
      delta = str.length - clone.rest.length;
      this.countLines(str.slice(i, delta));
      str = clone.rest;
      while (((ref$ = nested[0]) != null ? ref$[0] : void 8) === &#x27;NEWLINE&#x27;) {
        nested.shift();
      }
      if (nested.length) {
        nested.unshift([&#x27;(&#x27;, &#x27;(&#x27;, oldLine, oldColumn]);
        nested.push([&#x27;)&#x27;, &#x27;)&#x27;, this.line, this.column - 1]);
        parts.push([&#x27;TOKENS&#x27;, nested]);
      }
      ref1$ = [this.line, this.column], oldLine = ref1$[0], oldColumn = ref1$[1];
    }
    pos += delta;
    i = -1;
  }
  this.carp(&#x22;missing `&#x22; + end + &#x22;`&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var parts, str;
  if (q === code.charAt(index + 1)) {
    return q === code.charAt(index + 2)
      ? this.doHeredoc(code, index, q)
      : (this.strnum(q + q), 2);
  }
  if (q === &#x27;&#x22;&#x27;) {
    parts = this.<span class="apidocCodeKeywordSpan">interpolate</span>(code, index, q);
    this.addInterpolated(parts, unlines);
    return parts.size;
  }
  str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp(&#x27;unterminated string&#x27;);
  this.strnum(unlines(this.string(q, str.slice(1, -1))));
  return this.countLines(str).length;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.lex" id="apidoc.element.livescript.lexer.lex">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>lex
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lex = function (code, options){
  return clone$(exports).tokenize(code || &#x27;&#x27;, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    stack.length = stack.length - 2 * n;
    vstack.length = vstack.length - n;
    lstack.length = lstack.length - n;
}
_token_stack:
    var lex = function () {
        var token;
        token = lexer.<span class="apidocCodeKeywordSpan">lex</span>() || EOF;
        if (typeof token !== &#x27;number&#x27;) {
            token = self.symbols_[token] || token;
        }
        return token;
    };
var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
while (true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.newline" id="apidoc.element.livescript.lexer.newline">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>newline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newline = function (){
  var ref$;
  this.last[1] === &#x27;\n&#x27; || this.tokens.push(this.last = (ref$ = [&#x27;NEWLINE&#x27;, &#x27;\n&#x27;, this.line, this.column], ref$.spaced = true, ref
$));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (that = this.closes.pop()) {
    this.carp(&#x22;missing `&#x22; + that + &#x22;`&#x22;);
  }
  if (this.inter) {
    this.rest == null &#x26;&#x26; this.carp(&#x27;unterminated interpolation&#x27;);
  } else {
    this.last.spaced = true;
    this.<span class="apidocCodeKeywordSpan">newline</span>();
  }
  o.raw || this.rewrite();
  return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.hasOwn = Object.prototype.hasOwnProperty;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.pair" id="apidoc.element.livescript.lexer.pair">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>pair
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pair = function (it){
  var wanted, ref$;
  if (!(it === (wanted = (ref$ = this.closes)[ref$.length - 1]) || &#x27;)CALL&#x27; === wanted &#x26;&#x26; it === &#x27;)&#x27;)) {
    if (&#x27;DEDENT&#x27; !== wanted) {
      this.carp(&#x22;unmatched `&#x22; + it + &#x22;`&#x22;);
    }
    this.dedent((ref$ = this.dents)[ref$.length - 1]);
    return this.pair(it);
  }
  this.unline();
  return this.closes.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.parameters(false, -1);
        return &#x27;BIOPP&#x27;;
      default:
        return &#x27;BIOP&#x27;;
      }
    }.call(this));
  }
  if (&#x27;)&#x27; === (tag = val = this.<span class="apidocCodeKeywordSpan">pair</span>(val))) {
    this.lpar = this.parens.pop();
  }
  break;
case &#x27;=&#x27;:
case &#x27;:&#x27;:
  if (val === &#x27;:&#x27;) {
    switch (this.last[0]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.parameters" id="apidoc.element.livescript.lexer.parameters">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>parameters
        <span class="apidocSignatureSpan">(arrow, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parameters = function (arrow, offset){
  var i$, ref$, i, t, ref1$;
  if (this.last[0] === &#x27;)&#x27; &#x26;&#x26; &#x27;)&#x27; === this.last[1]) {
    this.lpar[0] = &#x27;PARAM(&#x27;;
    this.last[0] = &#x27;)PARAM&#x27;;
    return;
  }
  if (arrow === &#x27;-&#x3e;&#x27;) {
    this.token(&#x27;PARAM(&#x27;, &#x27;&#x27;);
  } else {
    for (i$ = (ref$ = this.tokens).length - 1; i$ &#x3e;= 0; --i$) {
      i = i$;
      t = ref$[i$];
      if ((ref1$ = t[0]) === &#x27;NEWLINE&#x27; || ref1$ === &#x27;INDENT&#x27; || ref1$ === &#x27;THEN&#x27; || ref1$ === &#x27;=&#x3e;&#x27; || ref1$ === &#x27;(&#x27;) {
        break;
      }
    }
    this.tokens.splice(i + 1, 0, [&#x27;PARAM(&#x27;, &#x27;&#x27;, t[2], t[3]]);
  }
  if (offset) {
    this.tokens.splice(this.tokens.length + offset, 0, [&#x27;)PARAM&#x27;, &#x27;&#x27;, t[2], t[3]]);
  } else {
    this.token(&#x27;)PARAM&#x27;, &#x27;&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case &#x27;)&#x27;:
if (tag === &#x27;)&#x27; &#x26;&#x26; ((ref$ = this.last[0]) === &#x27;+-&#x27; || ref$ === &#x27;COMPARE&#x27; || ref$ === &#x27
;LOGIC&#x27; || ref$ === &#x27;MATH&#x27; || ref$ === &#x27;POWER&#x27; || ref$ === &#x27;SHIFT&#x27; || ref$ === &#x27;BITWISE&#
x27; || ref$ === &#x27;CONCAT&#x27; || ref$ === &#x27;COMPOSE&#x27; || ref$ === &#x27;RELATION&#x27; || ref$ === &#x27;PIPE&#x27
; || ref$ === &#x27;BACKPIPE&#x27; || ref$ === &#x27;IMPORT&#x27; || ref$ === &#x27;CLONEPORT&#x27; || ref$ === &#x27;ASSIGN&#x27
;)) {
  (ref$ = this.tokens)[ref$.length - 1][0] = (function(){
    switch (this.last[0]) {
    case &#x27;RELATION&#x27;:
      return &#x27;BIOPR&#x27;;
    case &#x27;PIPE&#x27;:
      this.<span class="apidocCodeKeywordSpan">parameters</span>(false, -1);
      return &#x27;BIOPP&#x27;;
    default:
      return &#x27;BIOP&#x27;;
    }
  }.call(this));
}
if (&#x27;)&#x27; === (tag = val = this.pair(val))) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.regex" id="apidoc.element.livescript.lexer.regex">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>regex
        <span class="apidocSignatureSpan">(body, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regex = function (body, flag){
  var e;
  try {
    RegExp(body);
  } catch (e$) {
    e = e$;
    this.carp(e.message);
  }
  if (flag === &#x27;$&#x27;) {
    return this.strnum(this.string(&#x27;\&#x27;&#x27;, enslash(body)));
  }
  return this.token(&#x27;LITERAL&#x27;, &#x22;/&#x22; + (body || &#x27;(?:)&#x27;) + &#x22;/&#x22; + this.validate(flag));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (divisible = able(this.tokens) || this.last[0] === &#x27;CREMENT&#x27;) {
  if (!this.last.spaced || ((ref$ = code.charAt(index + 1)) === &#x27; &#x27; || ref$ === &#x27;=&#x27;)) {
    return 0;
  }
}
ref$ = (REGEX.lastIndex = index, REGEX).exec(code), input = ref$[0], body = ref$[1], flag = ref$[2];
if (input) {
  this.<span class="apidocCodeKeywordSpan">regex</span>(body, flag);
} else if (!divisible &#x26;&#x26; this.last[0] !== &#x27;(&#x27;) {
  this.carp(&#x27;unterminated regex&#x27;);
}
return input.length;
};
exports.doHeregex = function(code, index){
var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.rewrite" id="apidoc.element.livescript.lexer.rewrite">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>rewrite
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rewrite = function (it){
  var ref$;
  it || (it = this.tokens);
  firstPass(it);
  addImplicitIndentation(it);
  rewriteBlockless(it);
  addImplicitParentheses(it);
  addImplicitBraces(it);
  expandLiterals(it);
  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === &#x27;NEWLINE&#x27;) {
    it.shift();
  }
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (this.inter) {
  this.rest == null &#x26;&#x26; this.carp(&#x27;unterminated interpolation&#x27;);
} else {
  this.last.spaced = true;
  this.newline();
}
o.raw || this.<span class="apidocCodeKeywordSpan">rewrite</span>();
return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.hasOwn = Object.prototype.hasOwnProperty;
exports.checkConsistency = function(camel, id){
if (this.hasOwn.call(this.identifiers, camel) &#x26;&#x26; this.identifiers[camel] !== id) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.string" id="apidoc.element.livescript.lexer.string">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>string
        <span class="apidocSignatureSpan">(q, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string = function (q, body){
  return string(q, body, this.line);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (q === &#x27;&#x22;&#x27;) {
  parts = this.interpolate(code, index, q);
  this.addInterpolated(parts, unlines);
  return parts.size;
}
str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp(&#x27;unterminated string&#x27;);
this.strnum(unlines(this.<span class="apidocCodeKeywordSpan">string</span>(q, str.slice(1, -1))));
return this.countLines(str).length;
};
exports.doHeredoc = function(code, index, q){
var end, raw, doc, parts, tabs, i$, len$, i, t;
if (q === &#x27;\&#x27;&#x27;) {
  ~(end = code.indexOf(q + q + q, index + 3)) || this.carp(&#x27;unterminated heredoc&#x27;);
  raw = code.slice(index + 3, end);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.strnum" id="apidoc.element.livescript.lexer.strnum">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>strnum
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">strnum = function (it){
  this.token(&#x27;STRNUM&#x27;, it, this.adi() || this.last[0] === &#x27;DOT&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (/[0-9]/.exec(rnum)) {
      this.carp(&#x22;invalid number base &#x22; + radix + &#x22; (with number &#x22; + rnum + &#x22;),base must be from 2 to 36
&#x22;);
    } else {
      bound = true;
    }
  }
  if (isNaN(num) || num === parseInt(rnum.slice(0, -1), radix)) {
    this.<span class="apidocCodeKeywordSpan">strnum</span>(regexMatch[1]);
    this.token(&#x27;DOT&#x27;, &#x27;.~&#x27;);
    this.token(&#x27;ID&#x27;, regexMatch[2]);
    return input.length;
  }
  num += &#x27;&#x27;;
} else {
  num = (regexMatch[3] || input).replace(NUMBER_OMIT, &#x27;&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.token" id="apidoc.element.livescript.lexer.token">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>token
        <span class="apidocSignatureSpan">(tag, value, callable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token = function (tag, value, callable){
  this.tokens.push(this.last = [tag, value, this.line, this.column]);
  if (callable) {
    this.last.callable = true;
  }
  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } catch (e$) {
    e = e$;
    this.carp(&#x22;invalid identifier &#x27;&#x22; + id + &#x22;&#x27;&#x22;);
  }
}
last = this.last;
if (regexMatch[2] || last[0] === &#x27;DOT&#x27; || this.adi()) {
  this.<span class="apidocCodeKeywordSpan">token</span>(&#x27;ID&#x27;, in$(id, JS_KEYWORDS) ? (ref$ = Object(id), ref$.reserved
 = true, ref$) : id);
  if (regexMatch[2]) {
    this.token(&#x27;:&#x27;, &#x27;:&#x27;);
  }
  return input.length;
}
switch (id) {
case &#x27;true&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.tokenize" id="apidoc.element.livescript.lexer.tokenize">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>tokenize
        <span class="apidocSignatureSpan">(code, o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokenize = function (code, o){
  var i, prevIndex, c, charsConsumed, that;
  this.inter || (code = code.replace(/[\r\u2028\u2029\uFEFF]/g, &#x27;&#x27;));
  code = &#x27;\n&#x27; + code;
  this.tokens = [this.last = [&#x27;NEWLINE&#x27;, &#x27;\n&#x27;, 0, 0]];
  this.line = ~-o.line;
  this.column = o.column || 0;
  this.dents = [];
  this.closes = [];
  this.parens = [];
  this.flags = [];
  i = 0;
  prevIndex = i;
  this.charsCounted = 0;
  this.isAtPrefix = true;
  while (c = code.charAt(i)) {
    charsConsumed = i - prevIndex;
    prevIndex = i;
    if (this.charsCounted &#x3e; charsConsumed) {
      throw new Error(&#x27;Location information out-of-sync in lexer&#x27;);
    }
    this.column += charsConsumed - this.charsCounted;
    this.charsCounted = 0;
    switch (c) {
    case &#x27; &#x27;:
      i += this.doSpace(code, i);
      break;
    case &#x27;\n&#x27;:
      i += this.doLine(code, i);
      break;
    case &#x27;\\&#x27;:
      i += this.doBackslash(code, i);
      break;
    case &#x27;\&#x27;&#x27;:
    case &#x27;&#x22;&#x27;:
      i += this.doString(code, i, c);
      break;
    case &#x22;0&#x22;:
    case &#x22;1&#x22;:
    case &#x22;2&#x22;:
    case &#x22;3&#x22;:
    case &#x22;4&#x22;:
    case &#x22;5&#x22;:
    case &#x22;6&#x22;:
    case &#x22;7&#x22;:
    case &#x22;8&#x22;:
    case &#x22;9&#x22;:
      i += this.doNumber(code, i);
      break;
    case &#x27;/&#x27;:
      switch (code.charAt(i + 1)) {
      case &#x27;*&#x27;:
        i += this.doComment(code, i);
        break;
      case &#x27;/&#x27;:
        i += this.doHeregex(code, i);
        break;
      default:
        i += this.doRegex(code, i) || this.doLiteral(code, i);
      }
      break;
    case &#x27;`&#x27;:
      if (&#x27;`&#x27; === code.charAt(i + 1)) {
        i += this.doJS(code, i);
      } else {
        i += this.doLiteral(code, i);
      }
      break;
    default:
      i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
    }
  }
  this.dedent(this.dent);
  if (that = this.closes.pop()) {
    this.carp(&#x22;missing `&#x22; + that + &#x22;`&#x22;);
  }
  if (this.inter) {
    this.rest == null &#x26;&#x26; this.carp(&#x27;unterminated interpolation&#x27;);
  } else {
    this.last.spaced = true;
    this.newline();
  }
  o.raw || this.rewrite();
  return this.tokens;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...




// Generated by LiveScript 1.5.0
var string, TABS, unlines, enlines, enslash, reslash, camelize, deheregex, character, KEYWORDS_SHARED, KEYWORDS_UNUSED, JS_KEYWORDS
, LS_KEYWORDS, ID, SYMBOL, SPACE, MULTIDENT, SIMPLESTR, JSTOKEN, BSTOKEN, NUMBER, NUMBER_OMIT, REGEX, HEREGEX_OMIT, LASTDENT, INLINEDENT
, NONASCII, OPENERS, CLOSERS, INVERSES, i, o, c, CHAIN, ARG, BLOCK_USERS, this$ = this, slice$ = [].slice;
exports.lex = function(code, options){
return clone$(exports).<span class="apidocCodeKeywordSpan">tokenize</span>(code || &#x27;&#x27;, options || {});
};
exports.rewrite = function(it){
var ref$;
it || (it = this.tokens);
firstPass(it);
addImplicitIndentation(it);
rewriteBlockless(it);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.unline" id="apidoc.element.livescript.lexer.unline">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>unline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unline = function (){
  var ref$;
  if (!this.tokens[1]) {
    return;
  }
  switch (this.last[0]) {
  case &#x27;INDENT&#x27;:
    (ref$ = this.dents)[ref$.length - 1] += &#x27;&#x27;;
    // fallthrough
  case &#x27;NEWLINE&#x27;:
    this.tokens.length--;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  id = &#x27;!&#x27;;
  break;
case &#x27;and&#x27;:
case &#x27;or&#x27;:
case &#x27;xor&#x27;:
case &#x27;is&#x27;:
case &#x27;isnt&#x27;:
  this.<span class="apidocCodeKeywordSpan">unline</span>();
  tag = id === &#x27;is&#x27; || id === &#x27;isnt&#x27; ? &#x27;COMPARE&#x27; : &#x27;LOGIC&#x27;;
  if (last[0] === &#x27;(&#x27;) {
    tag = &#x27;BIOP&#x27;;
  }
  this.token(tag, (function(){
    switch (id) {
    case &#x27;is&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.validate" id="apidoc.element.livescript.lexer.validate">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>validate
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (flag){
  var that;
  if (that = flag &#x26;&#x26; /(.).*\1/.exec(flag)) {
    this.carp(&#x22;duplicate regex flag `&#x22; + that[1] + &#x22;`&#x22;);
  }
  return flag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return input.length;
};
exports.doHeregex = function(code, index){
var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;
tokens = this.tokens, last = this.last;
parts = this.interpolate(code, index, &#x27;//&#x27;);
rest = code.slice(index + parts.size);
flag = this.<span class="apidocCodeKeywordSpan">validate</span>(/^(?:[gimy]{1,4}|[?$]?)/.exec(rest)[0]);
if (parts[1]) {
  if (flag === &#x27;$&#x27;) {
    this.adi();
    this.token(&#x27;(&#x27;, &#x27;&#x22;&#x27;);
  } else {
    tokens.push([&#x27;ID&#x27;, &#x27;RegExp&#x27;, last[2], last[3]], [&#x27;CALL(&#x27;, &#x27;&#x27;, last[2], last[3]]);
    if (flag === &#x27;?&#x27;) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.listenerCount" id="apidoc.module.livescript.listenerCount">module livescript.listenerCount</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.listenerCount.listenerCount" id="apidoc.element.livescript.listenerCount.listenerCount">
        function <span class="apidocSignatureSpan">livescript.</span>listenerCount
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenerCount(type) {
  const events = this._events;

  if (events) {
    const evlistener = events[type];

    if (typeof evlistener === &#x27;function&#x27;) {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.listeners" id="apidoc.module.livescript.listeners">module livescript.listeners</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.listeners.listeners" id="apidoc.element.livescript.listeners.listeners">
        function <span class="apidocSignatureSpan">livescript.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === &#x27;function&#x27;)
      ret = [evlistener];
    else
      ret = arrayClone(evlistener, evlistener.length);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      : t.output.code).trimRight());
  } else {
    writeJS(filename, t.output, t.input, base, json);
  }
} catch (e$) {
  e = e$;
  if (e != null) {
    if (LiveScript.<span class="apidocCodeKeywordSpan">listeners</span>(&#x27;failure&#x27;).length) {
      LiveScript.emit(&#x27;failure&#x27;, e, t);
    } else {
      if (filename) {
        warn(&#x22;Failed at: &#x22; + filename);
      }
      if (!(e instanceof SyntaxError || /^Parse error /.test(e.message))) {
        e = e.stack || e;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.load" id="apidoc.module.livescript.load">module livescript.load</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.load.load" id="apidoc.element.livescript.load.load">
        function <span class="apidocSignatureSpan">livescript.</span>load
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (url, callback){
  var xhr;
  xhr = new XMLHttpRequest;
  xhr.open(&#x27;GET&#x27;, url, true);
  if (&#x27;overrideMimeType&#x27; in xhr) {
    xhr.overrideMimeType(&#x27;text/plain&#x27;);
  }
  xhr.onreadystatechange = function(){
    var ref$;
    if (xhr.readyState === 4) {
      if ((ref$ = xhr.status) === 200 || ref$ === 0) {
        LiveScript.stab(xhr.responseText, callback, url);
      } else {
        if (typeof callback == &#x27;function&#x27;) {
          callback(Error(url + &#x22;: &#x22; + xhr.status + &#x22; &#x22; + xhr.statusText));
        }
      }
    }
  };
  xhr.send(null);
  return xhr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.node" id="apidoc.module.livescript.node">module livescript.node</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.node.node" id="apidoc.element.livescript.node.node">
        function <span class="apidocSignatureSpan">livescript.</span>node
        <span class="apidocSignatureSpan">(LiveScript)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">node = function (LiveScript){
  var fs, path, events;
  fs = require(&#x27;fs&#x27;);
  path = require(&#x27;path&#x27;);
  events = require(&#x27;events&#x27;);
  LiveScript.run = function(code, options, arg$){
    var filename, ref$, js, context, main, dirname, e;
    if (options != null) {
      filename = options.filename;
    }
    ref$ = arg$ != null
      ? arg$
      : {}, js = ref$.js, context = ref$.context;
    main = require.main;
    if (filename) {
      dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));
    } else {
      dirname = filename = &#x27;.&#x27;;
    }
    main.paths = main.constructor._nodeModulePaths(dirname);
    main.filename = filename;
    if (!js) {
      code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
    }
    if (context) {
      global.__runContext = context;
      code = &#x22;return (function() {\n&#x22; + code + &#x22;\n}).call(global.__runContext);&#x22;;
    }
    try {
      return main._compile(code, filename);
    } catch (e$) {
      e = e$;
      throw hackTrace(e, code, filename);
    }
  };
  importAll$(LiveScript, events.EventEmitter.prototype);
  require.extensions[&#x27;.ls&#x27;] = function(module, filename){
    var file, js, e;
    file = fs.readFileSync(filename, &#x27;utf8&#x27;);
    js = &#x27;.json.ls&#x27; === filename.substr(-8)
      ? &#x27;module.exports = &#x27; + LiveScript.compile(file, {
        filename: filename,
        json: true
      })
      : LiveScript.compile(file, {
        filename: filename,
        bare: true,
        map: &#x22;embedded&#x22;
      }).code;
    try {
      return module._compile(js, filename);
    } catch (e$) {
      e = e$;
      throw hackTrace(e, js, filename);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.once" id="apidoc.module.livescript.once">module livescript.once</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.once.once" id="apidoc.element.livescript.once.once">
        function <span class="apidocSignatureSpan">livescript.</span>once
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.on(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.options" id="apidoc.module.livescript.options">module livescript.options</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.options.generateHelp" id="apidoc.element.livescript.options.generateHelp">
        function <span class="apidocSignatureSpan">livescript.options.</span>generateHelp
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateHelp = function (arg$){
  var ref$, showHidden, interpolate, maxWidth, output, out, data, optionCount, totalPreLen, preLens, i$, len$, item, that, pre,
descParts, desc, preLen, sortedPreLens, maxPreLen, preLenMean, x, padAmount, descSepLen, fullWrapCount, partialWrapCount, descLen
, totalLen, initialSpace, wrapAllFull, i, wrap;
  ref$ = arg$ != null
    ? arg$
    : {}, showHidden = ref$.showHidden, interpolate = ref$.interpolate;
  maxWidth = stdout != null &#x26;&#x26; stdout.isTTY ? stdout.columns - 1 : null;
  output = [];
  out = function(it){
    return output.push(it != null ? it : &#x27;&#x27;);
  };
  if (prepend) {
    out(interpolate ? interp(prepend, interpolate) : prepend);
    out();
  }
  data = [];
  optionCount = 0;
  totalPreLen = 0;
  preLens = [];
  for (i$ = 0, len$ = (ref$ = options).length; i$ &#x3c; len$; ++i$) {
    item = ref$[i$];
    if (showHidden || !item.hidden) {
      if (that = item.heading) {
        data.push({
          type: &#x27;heading&#x27;,
          value: that
        });
      } else {
        pre = getPreText(item, helpStyle, maxWidth);
        descParts = [];
        if ((that = item.description) != null) {
          descParts.push(that);
        }
        if (that = item[&#x27;enum&#x27;]) {
          descParts.push(&#x22;either: &#x22; + naturalJoin(that));
        }
        if (item[&#x27;default&#x27;] &#x26;&#x26; !item.negateName) {
          descParts.push(&#x22;default: &#x22; + item[&#x27;default&#x27;]);
        }
        desc = descParts.join(&#x27; - &#x27;);
        data.push({
          type: &#x27;option&#x27;,
          pre: pre,
          desc: desc,
          descLen: desc.length
        });
        preLen = pre.length;
        optionCount++;
        totalPreLen += preLen;
        preLens.push(preLen);
      }
    }
  }
  sortedPreLens = sort(preLens);
  maxPreLen = sortedPreLens[sortedPreLens.length - 1];
  preLenMean = initialIndent + totalPreLen / optionCount;
  x = optionCount &#x3e; 2 ? min(preLenMean * maxPadFactor, maxPreLen) : maxPreLen;
  for (i$ = sortedPreLens.length - 1; i$ &#x3e;= 0; --i$) {
    preLen = sortedPreLens[i$];
    if (preLen &#x3c;= x) {
      padAmount = preLen;
      break;
    }
  }
  descSepLen = descriptionSeparator.length;
  if (maxWidth != null) {
    fullWrapCount = 0;
    partialWrapCount = 0;
    for (i$ = 0, len$ = data.length; i$ &#x3c; len$; ++i$) {
      item = data[i$];
      if (item.type === &#x27;option&#x27;) {
        pre = item.pre, desc = item.desc, descLen = item.descLen;
        if (descLen === 0) {
          item.wrap = &#x27;none&#x27;;
        } else {
          preLen = max(padAmount, pre.length) + initialIndent + descSepLen;
          totalLen = preLen + descLen;
          if (totalLen &#x3e; maxWidth) {
            if (descLen / 2.5 &#x3e; maxWidth - preLen) {
              fullWrapCount++;
              item.wrap = &#x27;full&#x27;;
            } else {
              partialWrapCount++;
              item.wrap = &#x27;partial&#x27;;
            }
          } else {
            item.wrap = &#x27;none&#x27;;
          }
        }
      }
    }
  }
  initialSpace = repeatString$(&#x27; &#x27;, initialIndent);
  wrapAllFull = optionCount &#x3e; 1 &#x26;&#x26; fullWrapCount + partialWrapCount * 0.5 &#x3e; optionCount * 0.5;
  for (i$ = 0, len$ = data.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    item = data[i$];
    if (item.type === &#x27;heading&#x27;) {
      if (i !== 0) {
        out();
      }
      out(item.value + &#x22;:&#x22;);
    } else {
      pre = item.pre, desc = item.desc, descLen = item.descLen, wrap = item.wrap;
      if (maxWidth != null) {
        if (wrapAllFull || wrap === &#x27;full&#x27;) {
          wrap = wordwrap(initialIndent + secondaryIndent, maxWidth);
          out(initialSpace + &#x22;&#x22; + pre + &#x22;\n&#x22; + wrap(desc));
          continue;
        } else if (wrap === &#x27;partial&#x27;) {
          wrap = wordwrap(initialIndent + descSepLen + max(padAmount, pre.length), maxWidth);
          out(initialSpace + &#x22;&#x22; + pad(pre, padAmount) + descriptionSeparator + wrap(desc).replace(/^\s+/, &#x27;&#x27;));
          continue;
        }
      }
      if (descLen === 0) {
        out(initialSpace + &#x22;&#x22; + pre);
      } else {
        out(initialSpace + &#x22;&#x22; + pad(pre, padAmount) + descriptionSeparator + desc);
      }
    }
  }
  if (append) {
    out();
    out(interpola ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.options.generateHelpForOption" id="apidoc.element.livescript.options.generateHelpForOption">
        function <span class="apidocSignatureSpan">livescript.options.</span>generateHelpForOption
        <span class="apidocSignatureSpan">(optionName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateHelpForOption = function (optionName){
  var maxWidth, wrap, option, e, pre, defaultString, restPositionalString, description, fullDescription, that, preDescription, descriptionString
, exampleString, examples, seperator;
  maxWidth = stdout != null &#x26;&#x26; stdout.isTTY ? stdout.columns - 1 : null;
  wrap = maxWidth ? wordwrap(maxWidth) : id;
  try {
    option = getOption(dasherize(optionName));
  } catch (e$) {
    e = e$;
    return e.message;
  }
  pre = getPreText(option, helpStyle);
  defaultString = option[&#x27;default&#x27;] &#x26;&#x26; !option.negateName ? &#x22;\ndefault: &#x22; + option[&#x27;default&#x27;] : &#x27;&#x27;;
  restPositionalString = option.restPositional ? &#x27;Everything after this option is considered a positional argument, even if it looks
 like an option.&#x27; : &#x27;&#x27;;
  description = option.longDescription || option.description &#x26;&#x26; sentencize(option.description);
  fullDescription = description &#x26;&#x26; restPositionalString
    ? description + &#x22; &#x22; + restPositionalString
    : (that = description || restPositionalString) ? that : &#x27;&#x27;;
  preDescription = &#x27;description:&#x27;;
  descriptionString = !fullDescription
    ? &#x27;&#x27;
    : maxWidth &#x26;&#x26; fullDescription.length - 1 - preDescription.length &#x3e; maxWidth
      ? &#x22;\n&#x22; + preDescription + &#x22;\n&#x22; + wrap(fullDescription)
      : &#x22;\n&#x22; + preDescription + &#x22; &#x22; + fullDescription;
  exampleString = (that = option.example) ? (examples = [].concat(that), examples.length &#x3e; 1
    ? &#x22;\nexamples:\n&#x22; + unlines(examples)
    : &#x22;\nexample: &#x22; + examples[0]) : &#x27;&#x27;;
  seperator = defaultString || descriptionString || exampleString ? &#x22;\n&#x22; + repeatString$(&#x27;=&#x27;, pre.length) : &#x27;&#x27;;
  return pre + &#x22;&#x22; + seperator + defaultString + descriptionString + exampleString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.options.parse" id="apidoc.element.livescript.options.parse">
        function <span class="apidocSignatureSpan">livescript.options.</span>parse
        <span class="apidocSignatureSpan">(input, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (input, arg$){
  var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError
, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result
, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;
  slice = (arg$ != null
    ? arg$
    : {}).slice;
  obj = {};
  positional = [];
  restPositional = false;
  overrideRequired = false;
  prop = null;
  setValue = function(name, value){
    var opt, val, cra, e, currentType;
    opt = getOption(name);
    if (opt.boolean) {
      val = value;
    } else {
      try {
        cra = opt.concatRepeatedArrays;
        if (cra != null &#x26;&#x26; cra[0] &#x26;&#x26; cra[1].oneValuePerFlag &#x26;&#x26; opt.parsedType.length === 1 &#x26;&#x26; opt.parsedType[0].structure === &#x27;array
&#x27;) {
          val = [parseLevn(opt.parsedType[0].of, value)];
        } else {
          val = parseLevn(opt.parsedType, value);
        }
      } catch (e$) {
        e = e$;
        throw new Error(&#x22;Invalid value for option &#x27;&#x22; + name + &#x22;&#x27; - expected type &#x22; + opt.type + &#x22;, received value: &#x22; + value + &#x22;.&#x22;);
      }
      if (opt[&#x27;enum&#x27;] &#x26;&#x26; !any(function(it){
        return deepIs(it, val);
      }, opt.parsedPossibilities)) {
        throw new Error(&#x22;Option &#x22; + name + &#x22;: &#x27;&#x22; + val + &#x22;&#x27; not one of &#x22; + naturalJoin(opt[&#x27;enum&#x27;]) + &#x22;.&#x22;);
      }
    }
    currentType = toString$.call(obj[name]).slice(8, -1);
    if (obj[name] != null) {
      if (opt.concatRepeatedArrays != null &#x26;&#x26; opt.concatRepeatedArrays[0] &#x26;&#x26; currentType === &#x27;Array&#x27;) {
        obj[name] = obj[name].concat(val);
      } else if (opt.mergeRepeatedObjects &#x26;&#x26; currentType === &#x27;Object&#x27;) {
        import$(obj[name], val);
      } else {
        obj[name] = val;
      }
    } else {
      obj[name] = val;
    }
    if (opt.restPositional) {
      restPositional = true;
    }
    if (opt.overrideRequired) {
      overrideRequired = true;
    }
  };
  setDefaults = function(){
    var name, ref$, value;
    for (name in ref$ = defaults) {
      value = ref$[name];
      if (obj[name] == null) {
        obj[name] = value;
      }
    }
  };
  checkRequired = function(){
    var i$, ref$, len$, name;
    if (overrideRequired) {
      return;
    }
    for (i$ = 0, len$ = (ref$ = required).length; i$ &#x3c; len$; ++i$) {
      name = ref$[i$];
      if (!obj[name]) {
        throw new Error(&#x22;Option &#x22; + nameToRaw(name) + &#x22; is required.&#x22;);
      }
    }
  };
  mutuallyExclusiveError = function(first, second){
    throw new Error(&#x22;The options &#x22; + nameToRaw(first) + &#x22; and &#x22; + nameToRaw(second) + &#x22; are mutually exclusive - you cannot use
them at the same time.&#x22;);
  };
  checkMutuallyExclusive = function(){
    var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;
    rules = libOptions.mutuallyExclusive;
    if (!rules) {
      return;
    }
    for (i$ = 0, len$ = rules.length; i$ &#x3c; len$; ++i$) {
      rule = rules[i$];
      present = null;
      for (j$ = 0, len1$ = rule.length; j$ &#x3c; len1$; ++j$) {
        element = rule[j$];
        if (toString$.call(element).slice(8, -1) === &#x27;Array&#x27;) {
          for (k$ = 0, len2$ = element.length; k$ &#x3c; len2$; ++k$) {
            opt = element[k$];
            if (opt in obj) {
              if (present != null) {
                mutuallyExclusiveError(present, opt);
              } else {
                present = opt;
                break;
              }
            }
          }
        } else {
          if (element in obj) {
            if (present != null) {
              mutuallyExclusiveError(present, element);
            } else {
              present = element;
            }
          }
        }
      }
    }
  };
  checkDependency = function(option){
    var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;
    dependsOn = option.dependsOn;
    if (!dependsOn || option.dependenciesMet) {
      return true;
    }
    type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);
    for (i$ = 0, len$ = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.fromJSON(JSON.<span class="apidocCodeKeywordSpan">parse</span>(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.options.parseArgv" id="apidoc.element.livescript.options.parseArgv">
        function <span class="apidocSignatureSpan">livescript.options.</span>parseArgv
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseArgv = function (it){
  return parse(it, {
    slice: 2
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.parser" id="apidoc.module.livescript.parser">module livescript.parser</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.parser.Parser" id="apidoc.element.livescript.parser.Parser">
        function <span class="apidocSignatureSpan">livescript.parser.</span>Parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser() {
  this.yy = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.parser.main" id="apidoc.element.livescript.parser.main">
        function <span class="apidocSignatureSpan">livescript.parser.</span>main
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function commonjsMain(args) {
    if (!args[1]) {
        console.log(&#x27;Usage: &#x27;+args[0]+&#x27; FILE&#x27;);
        process.exit(1);
    }
    var source = require(&#x27;fs&#x27;).readFileSync(require(&#x27;path&#x27;).normalize(args[1]), &#x22;utf8&#x22;);
    return exports.parser.parse(source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        console.log(&#x27;Usage: &#x27;+args[0]+&#x27; FILE&#x27;);
        process.exit(1);
    }
    var source = require(&#x27;fs&#x27;).readFileSync(require(&#x27;path&#x27;).normalize(args[1]), &#x22;utf8&#x22;);
    return exports.parser.parse(source);
};
if (typeof module !== &#x27;undefined&#x27; &#x26;&#x26; require.main === module) {
  exports.<span class="apidocCodeKeywordSpan">main</span>(process.argv.slice(1));
}
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.parser.parse" id="apidoc.element.livescript.parser.parse">
        function <span class="apidocSignatureSpan">livescript.parser.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function () { return parser.parse.apply(parser, arguments); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.fromJSON(JSON.<span class="apidocCodeKeywordSpan">parse</span>(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.prependListener" id="apidoc.module.livescript.prependListener">module livescript.prependListener</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.prependListener.prependListener" id="apidoc.element.livescript.prependListener.prependListener">
        function <span class="apidocSignatureSpan">livescript.</span>prependListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.prependOnceListener" id="apidoc.module.livescript.prependOnceListener">module livescript.prependOnceListener</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.prependOnceListener.prependOnceListener" id="apidoc.element.livescript.prependOnceListener.prependOnceListener">
        function <span class="apidocSignatureSpan">livescript.</span>prependOnceListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependOnceListener(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.removeAllListeners" id="apidoc.module.livescript.removeAllListeners">module livescript.removeAllListeners</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.removeAllListeners.removeAllListeners" id="apidoc.element.livescript.removeAllListeners.removeAllListeners">
        function <span class="apidocSignatureSpan">livescript.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(type) {
  var listeners, events;

  events = this._events;
  if (!events)
    return this;

  // not listening for removeListener, no need to emit
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i = 0, key; i &#x3c; keys.length; ++i) {
      key = keys[i];
      if (key === &#x27;removeListener&#x27;) continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners(&#x27;removeListener&#x27;);
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === &#x27;function&#x27;) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.removeListener" id="apidoc.module.livescript.removeListener">module livescript.removeListener</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.removeListener.removeListener" id="apidoc.element.livescript.removeListener.removeListener">
        function <span class="apidocSignatureSpan">livescript.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);

  events = this._events;
  if (!events)
    return this;

  list = events[type];
  if (!list)
    return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events[type];
      if (events.removeListener)
        this.emit(&#x27;removeListener&#x27;, type, list.listener || listener);
    }
  } else if (typeof list !== &#x27;function&#x27;) {
    position = -1;

    for (i = list.length; i-- &#x3e; 0;) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position &#x3c; 0)
      return this;

    if (list.length === 1) {
      list[0] = undefined;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }

    if (events.removeListener)
      this.emit(&#x27;removeListener&#x27;, type, originalListener || listener);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.run" id="apidoc.module.livescript.run">module livescript.run</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.run.run" id="apidoc.element.livescript.run.run">
        function <span class="apidocSignatureSpan">livescript.</span>run
        <span class="apidocSignatureSpan">(code, options, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (code, options, arg$){
  var filename, ref$, js, context, main, dirname, e;
  if (options != null) {
    filename = options.filename;
  }
  ref$ = arg$ != null
    ? arg$
    : {}, js = ref$.js, context = ref$.context;
  main = require.main;
  if (filename) {
    dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));
  } else {
    dirname = filename = &#x27;.&#x27;;
  }
  main.paths = main.constructor._nodeModulePaths(dirname);
  main.filename = filename;
  if (!js) {
    code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
  }
  if (context) {
    global.__runContext = context;
    code = &#x22;return (function() {\n&#x22; + code + &#x22;\n}).call(global.__runContext);&#x22;;
  }
  try {
    return main._compile(code, filename);
  } catch (e$) {
    e = e$;
    throw hackTrace(e, code, filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
json = o.json || /\.json\.ls$/.test(filename);
run = o.run || o.eval;
if (run) {
  LiveScript.emit(&#x27;compile&#x27;, t);
  print = json || o.print;
  t.output = LiveScript.compile(t.input, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$.run = run, ref$.print = print
, ref$));
  LiveScript.emit(&#x27;run&#x27;, t);
  t.result = LiveScript.<span class="apidocCodeKeywordSpan">run</span>(o.map === &#x27;none&#x27;
    ? t.output
    : t.output.code, options, {
    js: true,
    context: o.runContext
  });
  switch (false) {
  case !json:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.setMaxListeners" id="apidoc.module.livescript.setMaxListeners">module livescript.setMaxListeners</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.setMaxListeners.setMaxListeners" id="apidoc.element.livescript.setMaxListeners.setMaxListeners">
        function <span class="apidocSignatureSpan">livescript.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners(n) {
  if (typeof n !== &#x27;number&#x27; || n &#x3c; 0 || isNaN(n))
    throw new TypeError(&#x27;&#x22;n&#x22; argument must be a positive number&#x27;);
  this._maxListeners = n;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.stab" id="apidoc.module.livescript.stab">module livescript.stab</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.stab.stab" id="apidoc.element.livescript.stab.stab">
        function <span class="apidocSignatureSpan">livescript.</span>stab
        <span class="apidocSignatureSpan">(code, callback, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stab = function (code, callback, filename){
  var e;
  try {
    LiveScript.run(code, {
      filename: filename,
      map: &#x27;embedded&#x27;
    });
  } catch (e$) {
    e = e$;
  }
  if (typeof callback == &#x27;function&#x27;) {
    callback(e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.tokens" id="apidoc.module.livescript.tokens">module livescript.tokens</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.tokens.tokens" id="apidoc.element.livescript.tokens.tokens">
        function <span class="apidocSignatureSpan">livescript.</span>tokens
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokens = function (code, options){
  return clone$(exports).tokenize(code || &#x27;&#x27;, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
t = {
  input: input,
  options: options
};
try {
  if (o.lex || o.tokens || o.ast) {
    LiveScript.emit(&#x27;lex&#x27;, t);
    t.tokens = LiveScript.<span class="apidocCodeKeywordSpan">tokens</span>(t.input, {
      raw: o.lex
    });
    if (o.lex || o.tokens) {
      printTokens(t.tokens);
      throw null;
    }
    LiveScript.emit(&#x27;parse&#x27;, t);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.tokens.rewrite" id="apidoc.element.livescript.tokens.rewrite">
        function <span class="apidocSignatureSpan">livescript.tokens.</span>rewrite
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rewrite = function (it){
  var ref$;
  it || (it = this.tokens);
  firstPass(it);
  addImplicitIndentation(it);
  rewriteBlockless(it);
  addImplicitParentheses(it);
  addImplicitBraces(it);
  expandLiterals(it);
  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === &#x27;NEWLINE&#x27;) {
    it.shift();
  }
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (this.inter) {
  this.rest == null &#x26;&#x26; this.carp(&#x27;unterminated interpolation&#x27;);
} else {
  this.last.spaced = true;
  this.newline();
}
o.raw || this.<span class="apidocCodeKeywordSpan">rewrite</span>();
return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.hasOwn = Object.prototype.hasOwnProperty;
exports.checkConsistency = function(camel, id){
if (this.hasOwn.call(this.identifiers, camel) &#x26;&#x26; this.identifiers[camel] !== id) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.tokens.rewrite" id="apidoc.module.livescript.tokens.rewrite">module livescript.tokens.rewrite</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.tokens.rewrite.rewrite" id="apidoc.element.livescript.tokens.rewrite.rewrite">
        function <span class="apidocSignatureSpan">livescript.tokens.</span>rewrite
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rewrite = function (it){
  var ref$;
  it || (it = this.tokens);
  firstPass(it);
  addImplicitIndentation(it);
  rewriteBlockless(it);
  addImplicitParentheses(it);
  addImplicitBraces(it);
  expandLiterals(it);
  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === &#x27;NEWLINE&#x27;) {
    it.shift();
  }
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (this.inter) {
  this.rest == null &#x26;&#x26; this.carp(&#x27;unterminated interpolation&#x27;);
} else {
  this.last.spaced = true;
  this.newline();
}
o.raw || this.<span class="apidocCodeKeywordSpan">rewrite</span>();
return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.hasOwn = Object.prototype.hasOwnProperty;
exports.checkConsistency = function(camel, id){
if (this.hasOwn.call(this.identifiers, camel) &#x26;&#x26; this.identifiers[camel] !== id) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.util" id="apidoc.module.livescript.util">module livescript.util</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.util.nameFromPath" id="apidoc.element.livescript.util.nameFromPath">
        function <span class="apidocSignatureSpan">livescript.util.</span>nameFromPath
        <span class="apidocSignatureSpan">(modulePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nameFromPath = function (modulePath){
  return path.basename(stripString(modulePath)).split(&#x27;.&#x27;)[0].replace(/-[a-z]/ig, function(it){
    return it.charAt(1).toUpperCase();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.util.stripString" id="apidoc.element.livescript.util.stripString">
        function <span class="apidocSignatureSpan">livescript.util.</span>stripString
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripString = function (val){
  var that;
  if (that = /^[&#x27;&#x22;](.*)[&#x27;&#x22;]$/.exec(val.trim())) {
    return that[1];
  } else {
    return val;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
