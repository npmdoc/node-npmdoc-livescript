<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://livescript.net"

    >livescript (v1.5.0)</a>
</h1>
<h4>LiveScript is a language which compiles to JavaScript. It has a straightforward mapping to JavaScript and allows you to write expressive code devoid of repetitive boilerplate. While LiveScript adds many features to assist in functional style programming, </h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript">module livescript</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.addListener">
            function <span class="apidocSignatureSpan">livescript.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast">
            function <span class="apidocSignatureSpan">livescript.</span>ast
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Call
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Case
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Class
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Existence
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For">
            function <span class="apidocSignatureSpan">livescript.</span>ast.For
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In">
            function <span class="apidocSignatureSpan">livescript.</span>ast.In
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS">
            function <span class="apidocSignatureSpan">livescript.</span>ast.JS
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Obj
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Require
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Slice
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Splat
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Util
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Vars
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Yield
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.compile">
            function <span class="apidocSignatureSpan">livescript.</span>compile
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.emit">
            function <span class="apidocSignatureSpan">livescript.</span>emit
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.eventNames">
            function <span class="apidocSignatureSpan">livescript.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.getMaxListeners">
            function <span class="apidocSignatureSpan">livescript.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lex">
            function <span class="apidocSignatureSpan">livescript.</span>lex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.listenerCount">
            function <span class="apidocSignatureSpan">livescript.</span>listenerCount
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.listeners">
            function <span class="apidocSignatureSpan">livescript.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.on">
            function <span class="apidocSignatureSpan">livescript.</span>on
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.once">
            function <span class="apidocSignatureSpan">livescript.</span>once
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.prependListener">
            function <span class="apidocSignatureSpan">livescript.</span>prependListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.prependOnceListener">
            function <span class="apidocSignatureSpan">livescript.</span>prependOnceListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.removeAllListeners">
            function <span class="apidocSignatureSpan">livescript.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.removeListener">
            function <span class="apidocSignatureSpan">livescript.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.run">
            function <span class="apidocSignatureSpan">livescript.</span>run
            <span class="apidocSignatureSpan">(code, options, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.setMaxListeners">
            function <span class="apidocSignatureSpan">livescript.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens">
            function <span class="apidocSignatureSpan">livescript.</span>tokens
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Arr.superclass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Assign.superclass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.In.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Literal.superclass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Require.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Return.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Super.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Util.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Vars.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast">module livescript.ast</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.ast">
            function <span class="apidocSignatureSpan">livescript.</span>ast
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Block
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Box">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Box
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Call
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Case
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Class
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.CopyL">
            function <span class="apidocSignatureSpan">livescript.ast.</span>CopyL
            <span class="apidocSignatureSpan">(a, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Decl">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Decl
            <span class="apidocSignatureSpan">(type, nodes, lno)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For">
            function <span class="apidocSignatureSpan">livescript.ast.</span>For
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If">
            function <span class="apidocSignatureSpan">livescript.ast.</span>If
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Import
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In">
            function <span class="apidocSignatureSpan">livescript.ast.</span>In
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Index
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS">
            function <span class="apidocSignatureSpan">livescript.ast.</span>JS
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Key
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.L">
            function <span class="apidocSignatureSpan">livescript.ast.</span>L
            <span class="apidocSignatureSpan">(a, b, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Label
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Require
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Try
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Util
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Var
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While">
            function <span class="apidocSignatureSpan">livescript.ast.</span>While
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.fromJSON">
            function <span class="apidocSignatureSpan">livescript.ast.</span>fromJSON
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.parse">
            function <span class="apidocSignatureSpan">livescript.ast.</span>parse
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr">module livescript.ast.Arr</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.Arr">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>compile
            <span class="apidocSignatureSpan">(o, items, deepEq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.maybe">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>maybe
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.wrap">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>wrap
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Arr.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype">module livescript.ast.Arr.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.asObj">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>asObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>constructor
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.toSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>toSlice
            <span class="apidocSignatureSpan">(o, base, symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.superclass.prototype">module livescript.ast.Arr.superclass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.named">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>named
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign">module livescript.ast.Assign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.Assign">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Assign.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype">module livescript.ast.Assign.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileConditional
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileDestructuring
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileMinMax
            <span class="apidocSignatureSpan">(o, left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSplice
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSpread
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>constructor
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendArr">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendArr
            <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendObj">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendObj
            <span class="apidocSignatureSpan">(o, nodes, rite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.superclass.prototype">module livescript.ast.Assign.superclass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.addElse">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>addElse
            <span class="apidocSignatureSpan">($else)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.anaphorize">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>anaphorize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>assigns
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.cache">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>cache
            <span class="apidocSignatureSpan">(o, once, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.carp">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>carp
            <span class="apidocSignatureSpan">(msg, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compile
            <span class="apidocSignatureSpan">(options, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileBlock">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileBlock
            <span class="apidocSignatureSpan">(o, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileClosure">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileClosure
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileLoopReference">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileLoopReference
            <span class="apidocSignatureSpan">(o, name, ret, safeAccess)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileSpreadOver">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileSpreadOver
            <span class="apidocSignatureSpan">(o, list, transform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.delegate">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>delegate
            <span class="apidocSignatureSpan">(names, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.eachChild">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>eachChild
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.expandSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>expandSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getAccessors">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getAccessors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getCall">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getDefault">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invertCheck">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invertCheck
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isMatcher">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isMatcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(ref, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>ripName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.stringify">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>stringify
            <span class="apidocSignatureSpan">(space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toJSON">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toString
            <span class="apidocSignatureSpan">(idt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.traverseChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>traverseChildren
            <span class="apidocSignatureSpan">(fn, xscope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unparen">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unparen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary">module livescript.ast.Binary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.Binary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Binary.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype">module livescript.ast.Binary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileAnyInstanceOf
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileChain">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileChain
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileCompose
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileConcat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileDeepEq
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileExistence
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileJoin
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMethod
            <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMinMax
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMod">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMod
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePartial
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePow">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePow
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRegexEquals
            <span class="apidocSignatureSpan">(o, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRemove
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRepeat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileSplit
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileXor">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileXor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>constructor
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.getDefault">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>getDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invertIt">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invertIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.mapOp">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>mapOp
            <span class="apidocSignatureSpan">(op)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>xorChildren
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block">module livescript.ast.Block</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.Block">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Block
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Block.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Block.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype">module livescript.ast.Block.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.add">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.chomp">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>chomp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileExpressions
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileRoot">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileRoot
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileWithDeclarations
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>constructor
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.neck">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>neck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.pipe">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>pipe
            <span class="apidocSignatureSpan">(target, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.prepend">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>prepend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.toJSON">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Call">module livescript.ast.Call</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.Call">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Call
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.back">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>back
            <span class="apidocSignatureSpan">(params, node, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.block">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>block
            <span class="apidocSignatureSpan">(fun, args, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.let">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>let
            <span class="apidocSignatureSpan">(args, body, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.make">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>make
            <span class="apidocSignatureSpan">(callee, args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Call.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Call.prototype">module livescript.ast.Call.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>constructor
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade">module livescript.ast.Cascade</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.Cascade">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Cascade.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype">module livescript.ast.Cascade.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>constructor
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(ret)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case">module livescript.ast.Case</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.Case">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Case
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Case.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Case.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case.prototype">module livescript.ast.Case.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.compileCase">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>compileCase
            <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>constructor
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain">module livescript.ast.Chain</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.Chain">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Chain.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype">module livescript.ast.Chain.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.add">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>autoCompare
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>cacheReference
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>constructor
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandBind">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandBind
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSlice
            <span class="apidocSignatureSpan">(o, assign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSplat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandStar">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandStar
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandVivify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.flipIt">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>flipIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getCall">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isSimpleAccess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isStatement
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Class">module livescript.ast.Class</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.Class">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Class
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Class.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Class.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Class.prototype">module livescript.ast.Class.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>constructor
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence">module livescript.ast.Existence</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.Existence">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Existence.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence.prototype">module livescript.ast.Existence.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For">module livescript.ast.For</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.For">
            function <span class="apidocSignatureSpan">livescript.ast.</span>For
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.For.</span>superclass
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.For.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For.prototype">module livescript.ast.For.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.addBody">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>aSource</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun">module livescript.ast.Fun</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.Fun">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Fun.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype">module livescript.ast.Fun.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileParams">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileParams
            <span class="apidocSignatureSpan">(o, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>constructor
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.named">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>named
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>traverseChildren
            <span class="apidocSignatureSpan">(arg$, xscope)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If">module livescript.ast.If</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.If">
            function <span class="apidocSignatureSpan">livescript.ast.</span>If
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.If.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.If.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o, parent, name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.If.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype">module livescript.ast.If.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileExpression">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileExpression
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileStatement">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileStatement
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>constructor
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>aTargets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>aSource</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import">module livescript.ast.Import</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.Import">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Import
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Import.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Import.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype">module livescript.ast.Import.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileAssign
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>constructor
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.In">module livescript.ast.In</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.In">
            function <span class="apidocSignatureSpan">livescript.ast.</span>In
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.In.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.In.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.In.prototype">module livescript.ast.In.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>constructor
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index">module livescript.ast.Index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.Index">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Index
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Index.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Index.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype">module livescript.ast.Index.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>constructor
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS">module livescript.ast.JS</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.JS">
            function <span class="apidocSignatureSpan">livescript.ast.</span>JS
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.JS.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.JS.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS.prototype">module livescript.ast.JS.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>compile
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>constructor
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump">module livescript.ast.Jump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.Jump">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.extended">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>extended
            <span class="apidocSignatureSpan">(sub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.return">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.throw">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Jump.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype">module livescript.ast.Jump.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>constructor
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key">module livescript.ast.Key</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.Key">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Key
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Key.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Key.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype">module livescript.ast.Key.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label">module livescript.ast.Label</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.Label">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Label
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Label.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Label.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype">module livescript.ast.Label.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>constructor
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal">module livescript.ast.Literal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.Literal">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Literal.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype">module livescript.ast.Literal.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isWhat">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isWhat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.superclass.prototype">module livescript.ast.Literal.superclass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Obj">module livescript.ast.Obj</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.Obj">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>compile
            <span class="apidocSignatureSpan">(o, items, deepEq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Obj.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Obj.prototype">module livescript.ast.Obj.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.asObj">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>asObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>constructor
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.toSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>toSlice
            <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens">module livescript.ast.Parens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.Parens">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Parens.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype">module livescript.ast.Parens.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isComplex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.unparen">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>unparen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop">module livescript.ast.Prop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.Prop">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Prop.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype">module livescript.ast.Prop.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileAccessor
            <span class="apidocSignatureSpan">(o, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileDescriptor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>constructor
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Require">module livescript.ast.Require</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.Require">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Require
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Require.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Require.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Require.prototype">module livescript.ast.Require.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>constructor
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Return">module livescript.ast.Return</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.Return">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.extended">
            function <span class="apidocSignatureSpan">livescript.ast.Return.</span>extended
            <span class="apidocSignatureSpan">(sub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Return.</span>superclass
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.throw">
            function <span class="apidocSignatureSpan">livescript.ast.Return.</span>throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Return.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Return.prototype">module livescript.ast.Return.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Slice">module livescript.ast.Slice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.Slice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Slice.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Slice.prototype">module livescript.ast.Slice.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>constructor
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Splat">module livescript.ast.Splat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.Splat">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.compileArray">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>compileArray
            <span class="apidocSignatureSpan">(o, list, apply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Splat.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Splat.prototype">module livescript.ast.Splat.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isComplex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.StepSlice">module livescript.ast.StepSlice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.StepSlice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.</span>superclass
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.StepSlice.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.StepSlice.prototype">module livescript.ast.StepSlice.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(makeReturnArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Super">module livescript.ast.Super</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.Super">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Super.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Super.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Super.prototype">module livescript.ast.Super.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch">module livescript.ast.Switch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.Switch">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Switch.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype">module livescript.ast.Switch.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>constructor
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>aTargets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>aSource</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Throw">module livescript.ast.Throw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.Throw">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.extended">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>extended
            <span class="apidocSignatureSpan">(sub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>superclass
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Throw.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Throw.prototype">module livescript.ast.Throw.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try">module livescript.ast.Try</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.Try">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Try
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Try.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Try.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype">module livescript.ast.Try.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>constructor
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary">module livescript.ast.Unary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.Unary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Unary.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype">module livescript.ast.Unary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileAsFunc
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compilePluck
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileSpread
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>constructor
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>getAccessors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Util">module livescript.ast.Util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.Util">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Util
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.Extends">
            function <span class="apidocSignatureSpan">livescript.ast.Util.</span>Extends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Util.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Util.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Util.prototype">module livescript.ast.Util.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>constructor
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var">module livescript.ast.Var</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.Var">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Var
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Var.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Var.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype">module livescript.ast.Var.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Vars">module livescript.ast.Vars</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.Vars">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Vars.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Vars.prototype">module livescript.ast.Vars.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>constructor
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While">module livescript.ast.While</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.While">
            function <span class="apidocSignatureSpan">livescript.ast.</span>While
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.While.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.While.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype">module livescript.ast.While.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addBody">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addGuard">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addGuard
            <span class="apidocSignatureSpan">(guard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addObjComp">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addObjComp
            <span class="apidocSignatureSpan">(objComp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileBody">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileBody
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>constructor
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeComprehension">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeComprehension
            <span class="apidocSignatureSpan">(toAdd, loops)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>aTargets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>aSource</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield">module livescript.ast.Yield</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.Yield">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Yield.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield.prototype">module livescript.ast.Yield.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>constructor
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.tokens">module livescript.tokens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens.tokens">
            function <span class="apidocSignatureSpan">livescript.</span>tokens
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens.rewrite">
            function <span class="apidocSignatureSpan">livescript.tokens.</span>rewrite
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript" id="apidoc.module.livescript">module livescript</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.addListener" id="apidoc.element.livescript.addListener">
        function <span class="apidocSignatureSpan">livescript.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast" id="apidoc.element.livescript.ast">
        function <span class="apidocSignatureSpan">livescript.</span>ast
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast = function (it){
  return parser.parse(typeof it === &#x27;string&#x27; ? lexer.lex(it) : it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    raw: o.lex
  });
  if (o.lex || o.tokens) {
    printTokens(t.tokens);
    throw null;
  }
  LiveScript.emit(&#x27;parse&#x27;, t);
  t.ast = LiveScript.<span class="apidocCodeKeywordSpan">ast</span>(t.tokens);
  say(o.json
    ? t.ast.stringify(2)
    : &#x27;&#x27;.trim.call(t.ast));
  throw null;
}
json = o.json || /\.json\.ls$/.test(filename);
run = o.run || o.eval;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr" id="apidoc.element.livescript.ast.Arr">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign" id="apidoc.element.livescript.ast.Assign">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || &#x27;=&#x27;;
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += &#x27;&#x27;;
  this$[rite instanceof Node ? &#x27;right&#x27; : &#x27;unaries&#x27;] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary" id="apidoc.element.livescript.ast.Binary">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === &#x27;String&#x27;) {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== &#x27;=&#x27;:
        return &#x27;?&#x27;;
      default:
        return &#x27;=&#x27;;
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if (&#x27;=&#x27; === op.charAt(op.length - 1) &#x26;&#x26; ((ref$ = op.charAt(op.length - 2)) !== &#x27;=&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3c;&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3e;&#x27; &#x26;&#x26; ref$ !== &#x27;!&#x27;)) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case &#x27;in&#x27;:
      return new In(first, second);
    case &#x27;with&#x27;:
      return new Import(Unary(&#x27;^^&#x27;, first), second, false);
    case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
    case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
      return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
    case &#x27;&#x3c;|&#x27;:
      return Block(first).pipe(second, op);
    case &#x27;|&#x3e;&#x27;:
      return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
    case &#x27;.&#x27;:
    case &#x27;.~&#x27;:
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block" id="apidoc.element.livescript.ast.Block">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if (&#x27;length&#x27; in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call" id="apidoc.element.livescript.ast.Call">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Call
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &#x26;&#x26; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = &#x27;.call&#x27;;
      args[0] = Literal(&#x27;this&#x27;);
      args[1] = Splat(Literal(&#x27;arguments&#x27;));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === &#x27;_&#x27;) {
        args[i] = Chain(Literal(&#x27;void&#x27;));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade" id="apidoc.element.livescript.ast.Cascade">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case" id="apidoc.element.livescript.ast.Case">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Case
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain" id="apidoc.element.livescript.ast.Chain">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &#x26;&#x26; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class" id="apidoc.element.livescript.ast.Class">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Class
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence" id="apidoc.element.livescript.ast.Existence">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Existence
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For" id="apidoc.element.livescript.ast.For">
        function <span class="apidocSignatureSpan">livescript.</span>ast.For
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &#x26;&#x26; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &#x3c; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &#x26;&#x26; !this.object) {
    this.carp(&#x27;`for own` requires `of`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun" id="apidoc.element.livescript.ast.Fun">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &#x26;&#x26; &#x27;this$&#x27;;
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If" id="apidoc.element.livescript.ast.If">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$[&#x27;if&#x27;] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import" id="apidoc.element.livescript.ast.Import">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In" id="apidoc.element.livescript.ast.In">
        function <span class="apidocSignatureSpan">livescript.</span>ast.In
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index" id="apidoc.element.livescript.ast.Index">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = &#x27;.&#x27;);
  if (init &#x26;&#x26; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case &#x27;[]&#x27;:
    this$.vivify = Arr;
    break;
  case &#x27;{}&#x27;:
    this$.vivify = Obj;
    break;
  default:
    if (&#x27;=&#x27; === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS" id="apidoc.element.livescript.ast.JS">
        function <span class="apidocSignatureSpan">livescript.</span>ast.JS
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump" id="apidoc.element.livescript.ast.Jump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key" id="apidoc.element.livescript.ast.Key">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = &#x27;&#x27; + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label" id="apidoc.element.livescript.ast.Label">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || &#x27;_&#x27;;
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &#x26;&#x26; it || it.calling &#x26;&#x26; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal" id="apidoc.element.livescript.ast.Literal">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + &#x22;&#x22;, true);
  }
  if (value === &#x27;super&#x27;) {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj" id="apidoc.element.livescript.ast.Obj">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Obj
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens" id="apidoc.element.livescript.ast.Parens">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop" id="apidoc.element.livescript.ast.Prop">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === &#x27;...&#x27;) {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
    }
    this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require" id="apidoc.element.livescript.ast.Require">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Require
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return" id="apidoc.element.livescript.ast.Return">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &#x26;&#x26; it.value !== &#x27;void&#x27;) {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice" id="apidoc.element.livescript.ast.Slice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Slice
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &#x26;&#x26; (this$.from = Literal(0));
  if (this$.to &#x26;&#x26; this$.type === &#x27;to&#x27;) {
    this$.to = Binary(&#x27;+&#x27;, this$.to, Literal(&#x27;1&#x27;));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat" id="apidoc.element.livescript.ast.Splat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Splat
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice" id="apidoc.element.livescript.ast.StepSlice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super" id="apidoc.element.livescript.ast.Super">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch" id="apidoc.element.livescript.ast.Switch">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this[&#x27;default&#x27;] = $default;
  if (type === &#x27;match&#x27;) {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &#x3e; 1) {
        throw &#x22;can&#x27;t have more than one topic in switch statement&#x22;;
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &#x26;&#x26; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &#x26;&#x26; last.tests[0] instanceof Var &#x26;&#x26; last
.tests[0].value === &#x27;_&#x27;) {
    this.cases.pop();
    this[&#x27;default&#x27;] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw" id="apidoc.element.livescript.ast.Throw">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try" id="apidoc.element.livescript.ast.Try">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var(&#x27;e&#x27;), Var(&#x27;e$&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary" id="apidoc.element.livescript.ast.Unary">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &#x26;&#x26; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case &#x27;!&#x27;:
      if (flag) {
        break;
      }
      if (it instanceof Fun &#x26;&#x26; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case &#x27;++&#x27;:
    case &#x27;--&#x27;:
      if (flag) {
        this$.post = true;
      }
      break;
    case &#x27;new&#x27;:
      if (it instanceof Existence &#x26;&#x26; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || &#x27;&#x27;).length; i$ &#x3c; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &#x26;&#x26; !node[&#x27;new&#x27;]) {
          if (node.method === &#x27;.call&#x27;) {
            node.args.shift();
          }
          node[&#x27;new&#x27;] = &#x27;new&#x27;;
          node.method = &#x27;&#x27;;
          return it;
        }
      }
      break;
    case &#x27;~&#x27;:
      if (it instanceof Fun &#x26;&#x26; it.statement &#x26;&#x26; !it.bound) {
        return it.bound = &#x27;this$&#x27;, it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util" id="apidoc.element.livescript.ast.Util">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Util
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var" id="apidoc.element.livescript.ast.Var">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars" id="apidoc.element.livescript.ast.Vars">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Vars
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While" id="apidoc.element.livescript.ast.While">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &#x26;&#x26; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== &#x27;&#x27; + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield" id="apidoc.element.livescript.ast.Yield">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Yield
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.compile" id="apidoc.element.livescript.compile">
        function <span class="apidocSignatureSpan">livescript.</span>compile
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (code, options){
  var result, ast, output, filename, outputFilename, ref$, mapPath, e, that;
  options == null &#x26;&#x26; (options = {});
  options.header == null &#x26;&#x26; (options.header = true);
  try {
    if (options.json) {
      result = Function(exports.compile(code, {
        bare: true,
        run: true,
        print: true
      }))();
      return JSON.stringify(result, null, 2) + &#x22;\n&#x22;;
    } else {
      ast = parser.parse(lexer.lex(code));
      if (options.run &#x26;&#x26; options.print) {
        ast.makeReturn();
      }
      output = ast.compileRoot(options);
      if (options.header) {
        output = new SourceNode(null, null, null, [&#x22;// Generated by LiveScript &#x22; + exports.VERSION + &#x22;\n&#x22;, output]);
      }
      if (options.map &#x26;&#x26; options.map !== &#x27;none&#x27;) {
        filename = options.filename, outputFilename = options.outputFilename;
        if (!filename) {
          filename = &#x22;unnamed-&#x22; + Math.floor(Math.random() * 4294967296).toString(16) + &#x22;.ls&#x22;;
        }
        output.setFile(filename);
        result = output.toStringWithSourceMap();
        if (options.map === &#x27;embedded&#x27;) {
          result.map.setSourceContent(filename, code);
        }
        if ((ref$ = options.map) === &#x27;linked&#x27; || ref$ === &#x27;debug&#x27;) {
          mapPath = outputFilename + &#x22;.map&#x22;;
          result.code += &#x22;\n//# sourceMappingURL=&#x22; + mapPath + &#x22;\n&#x22;;
        } else {
          result.code += &#x22;\n//# sourceMappingURL=data:application/json;base64,&#x22; + new Buffer(result.map.toString()).toString(&#x27;base64
&#x27;) + &#x22;\n&#x22;;
        }
        return result;
      } else {
        return output.toString();
      }
    }
  } catch (e$) {
    e = e$;
    if (that = options.filename) {
      e.message += &#x22;\nat &#x22; + that;
    }
    throw e;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.emit" id="apidoc.element.livescript.emit">
        function <span class="apidocSignatureSpan">livescript.</span>emit
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === &#x27;error&#x27;);

  events = this._events;
  if (events)
    doError = (doError &#x26;&#x26; events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no &#x27;error&#x27; event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event&#x27;);
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit(&#x27;error&#x27;, er);
    } else if (er instanceof Error) {
      throw er; // Unhandled &#x27;error&#x27; event
    } else {
      // At least give some kind of context to the user
      var err = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event. (&#x27; + er + &#x27;)&#x27;);
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  if (domain &#x26;&#x26; this !== process) {
    domain.enter();
    needDomainExit = true;
  }

  var isFn = typeof handler === &#x27;function&#x27;;
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i &#x3c; len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  if (needDomainExit)
    domain.exit();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), &#x22;\n&#x22;];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.<span class="apidocCodeKeywordSpan">emit</span
>(post, o.indent) : post]));
};
Block.prototype.compileExpressions = function(o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.eventNames" id="apidoc.element.livescript.eventNames">
        function <span class="apidocSignatureSpan">livescript.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  return this._eventsCount &#x3e; 0 ? Reflect.ownKeys(this._events) : [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.getMaxListeners" id="apidoc.element.livescript.getMaxListeners">
        function <span class="apidocSignatureSpan">livescript.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMaxListeners() {
  return $getMaxListeners(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lex" id="apidoc.element.livescript.lex">
        function <span class="apidocSignatureSpan">livescript.</span>lex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lex = function (it){
  return lexer.lex(it, {
    raw: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  result = Function(exports.compile(code, {
    bare: true,
    run: true,
    print: true
  }))();
  return JSON.stringify(result, null, 2) + &#x22;\n&#x22;;
} else {
  ast = parser.parse(lexer.<span class="apidocCodeKeywordSpan">lex</span>(code));
  if (options.run &#x26;&#x26; options.print) {
    ast.makeReturn();
  }
  output = ast.compileRoot(options);
  if (options.header) {
    output = new SourceNode(null, null, null, [&#x22;// Generated by LiveScript &#x22; + exports.VERSION + &#x22;\n&#x22;, output
]);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.listenerCount" id="apidoc.element.livescript.listenerCount">
        function <span class="apidocSignatureSpan">livescript.</span>listenerCount
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenerCount(type) {
  const events = this._events;

  if (events) {
    const evlistener = events[type];

    if (typeof evlistener === &#x27;function&#x27;) {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.listeners" id="apidoc.element.livescript.listeners">
        function <span class="apidocSignatureSpan">livescript.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === &#x27;function&#x27;)
      ret = [evlistener];
    else
      ret = arrayClone(evlistener, evlistener.length);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      : t.output.code).trimRight());
  } else {
    writeJS(filename, t.output, t.input, base, json);
  }
} catch (e$) {
  e = e$;
  if (e != null) {
    if (LiveScript.<span class="apidocCodeKeywordSpan">listeners</span>(&#x27;failure&#x27;).length) {
      LiveScript.emit(&#x27;failure&#x27;, e, t);
    } else {
      if (filename) {
        warn(&#x22;Failed at: &#x22; + filename);
      }
      if (!(e instanceof SyntaxError || /^Parse error /.test(e.message))) {
        e = e.stack || e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.on" id="apidoc.element.livescript.on">
        function <span class="apidocSignatureSpan">livescript.</span>on
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  LiveScript.emit(&#x27;success&#x27;, t);
}
function getStdin(cb){
  var x$, code;
  x$ = process.openStdin();
  code = &#x27;&#x27;;
  x$.<span class="apidocCodeKeywordSpan">on</span>(&#x27;data&#x27;, function(it){
    code += it;
  });
  x$.on(&#x27;end&#x27;, function(){
    cb(code);
  });
  x$.on(&#x27;data&#x27;, function(){
    var ref$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.once" id="apidoc.element.livescript.once">
        function <span class="apidocSignatureSpan">livescript.</span>once
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.on(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.prependListener" id="apidoc.element.livescript.prependListener">
        function <span class="apidocSignatureSpan">livescript.</span>prependListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.prependOnceListener" id="apidoc.element.livescript.prependOnceListener">
        function <span class="apidocSignatureSpan">livescript.</span>prependOnceListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependOnceListener(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.removeAllListeners" id="apidoc.element.livescript.removeAllListeners">
        function <span class="apidocSignatureSpan">livescript.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(type) {
  var listeners, events;

  events = this._events;
  if (!events)
    return this;

  // not listening for removeListener, no need to emit
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i = 0, key; i &#x3c; keys.length; ++i) {
      key = keys[i];
      if (key === &#x27;removeListener&#x27;) continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners(&#x27;removeListener&#x27;);
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === &#x27;function&#x27;) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.removeListener" id="apidoc.element.livescript.removeListener">
        function <span class="apidocSignatureSpan">livescript.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);

  events = this._events;
  if (!events)
    return this;

  list = events[type];
  if (!list)
    return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events[type];
      if (events.removeListener)
        this.emit(&#x27;removeListener&#x27;, type, list.listener || listener);
    }
  } else if (typeof list !== &#x27;function&#x27;) {
    position = -1;

    for (i = list.length; i-- &#x3e; 0;) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position &#x3c; 0)
      return this;

    if (list.length === 1) {
      list[0] = undefined;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }

    if (events.removeListener)
      this.emit(&#x27;removeListener&#x27;, type, originalListener || listener);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.run" id="apidoc.element.livescript.run">
        function <span class="apidocSignatureSpan">livescript.</span>run
        <span class="apidocSignatureSpan">(code, options, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (code, options, arg$){
  var filename, ref$, js, context, main, dirname, e;
  if (options != null) {
    filename = options.filename;
  }
  ref$ = arg$ != null
    ? arg$
    : {}, js = ref$.js, context = ref$.context;
  main = require.main;
  if (filename) {
    dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));
  } else {
    dirname = filename = &#x27;.&#x27;;
  }
  main.paths = main.constructor._nodeModulePaths(dirname);
  main.filename = filename;
  if (!js) {
    code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
  }
  if (context) {
    global.__runContext = context;
    code = &#x22;return (function() {\n&#x22; + code + &#x22;\n}).call(global.__runContext);&#x22;;
  }
  try {
    return main._compile(code, filename);
  } catch (e$) {
    e = e$;
    throw hackTrace(e, code, filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Generated by LiveScript 1.5.0
var LiveScript;
LiveScript = require(&#x27;..&#x27;);
LiveScript.stab = function(code, callback, filename){
var e;
try {
  LiveScript.<span class="apidocCodeKeywordSpan">run</span>(code, {
    filename: filename,
    map: &#x27;embedded&#x27;
  });
} catch (e$) {
  e = e$;
}
if (typeof callback == &#x27;function&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.setMaxListeners" id="apidoc.element.livescript.setMaxListeners">
        function <span class="apidocSignatureSpan">livescript.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners(n) {
  if (typeof n !== &#x27;number&#x27; || n &#x3c; 0 || isNaN(n))
    throw new TypeError(&#x27;&#x22;n&#x22; argument must be a positive number&#x27;);
  this._maxListeners = n;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.tokens" id="apidoc.element.livescript.tokens">
        function <span class="apidocSignatureSpan">livescript.</span>tokens
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokens = function (code, options){
  return clone$(exports).tokenize(code || &#x27;&#x27;, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
t = {
  input: input,
  options: options
};
try {
  if (o.lex || o.tokens || o.ast) {
    LiveScript.emit(&#x27;lex&#x27;, t);
    t.tokens = LiveScript.<span class="apidocCodeKeywordSpan">tokens</span>(t.input, {
      raw: o.lex
    });
    if (o.lex || o.tokens) {
      printTokens(t.tokens);
      throw null;
    }
    LiveScript.emit(&#x27;parse&#x27;, t);
...</pre></li>
    </ul>
























































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast" id="apidoc.module.livescript.ast">module livescript.ast</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.ast" id="apidoc.element.livescript.ast.ast">
        function <span class="apidocSignatureSpan">livescript.</span>ast
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast = function (it){
  return parser.parse(typeof it === &#x27;string&#x27; ? lexer.lex(it) : it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    raw: o.lex
  });
  if (o.lex || o.tokens) {
    printTokens(t.tokens);
    throw null;
  }
  LiveScript.emit(&#x27;parse&#x27;, t);
  t.ast = LiveScript.<span class="apidocCodeKeywordSpan">ast</span>(t.tokens);
  say(o.json
    ? t.ast.stringify(2)
    : &#x27;&#x27;.trim.call(t.ast));
  throw null;
}
json = o.json || /\.json\.ls$/.test(filename);
run = o.run || o.eval;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr" id="apidoc.element.livescript.ast.Arr">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.<span class="apidocCodeKeywordSpan">Arr</span>($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign" id="apidoc.element.livescript.ast.Assign">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || &#x27;=&#x27;;
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += &#x27;&#x27;;
  this$[rite instanceof Node ? &#x27;right&#x27; : &#x27;unaries&#x27;] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Assign</span>($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$
0-1],yy.Box($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary" id="apidoc.element.livescript.ast.Binary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === &#x27;String&#x27;) {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== &#x27;=&#x27;:
        return &#x27;?&#x27;;
      default:
        return &#x27;=&#x27;;
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if (&#x27;=&#x27; === op.charAt(op.length - 1) &#x26;&#x26; ((ref$ = op.charAt(op.length - 2)) !== &#x27;=&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3c;&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3e;&#x27; &#x26;&#x26; ref$ !== &#x27;!&#x27;)) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case &#x27;in&#x27;:
      return new In(first, second);
    case &#x27;with&#x27;:
      return new Import(Unary(&#x27;^^&#x27;, first), second, false);
    case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
    case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
      return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
    case &#x27;&#x3c;|&#x27;:
      return Block(first).pipe(second, op);
    case &#x27;|&#x3e;&#x27;:
      return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
    case &#x27;.&#x27;:
    case &#x27;.~&#x27;:
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Binary</span>($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block" id="apidoc.element.livescript.ast.Block">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Block
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if (&#x27;length&#x27; in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Block</span>());
break;
case 62:
this.$ = yy.L(_$[$0], _$[$0],yy.Block($$[$0]));
break;
case 63: case 172:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Box" id="apidoc.element.livescript.ast.Box">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Box
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Box = function (v){
  if (typeof v === &#x22;object&#x22;) {
    return v;
  } else {
    return new v.constructor(v);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan
">Box</span>($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call" id="apidoc.element.livescript.ast.Call">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Call
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &#x26;&#x26; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = &#x27;.call&#x27;;
      args[0] = Literal(&#x27;this&#x27;);
      args[1] = Splat(Literal(&#x27;arguments&#x27;));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === &#x27;_&#x27;) {
        args[i] = Chain(Literal(&#x27;void&#x27;));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.<span class="apidocCodeKeywordSpan">Call</span>($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call[&#x27;let&#x27;]($$[$0-3], $$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade" id="apidoc.element.livescript.ast.Cascade">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 40:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], yy.Slice({
type: $$[$0-1],
target: $$[$0-4]
      }))));
break;
case 41:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], yy.<span class="apidocCodeKeywordSpan">Cascade</span>($$[$0-1], $$[$
0], &#x27;with&#x27;))));
break;
case 42:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({
kind: $$[$0-2],
source: $$[$0-1],
body: $$[$0],
ref: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case" id="apidoc.element.livescript.ast.Case">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Case
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 201:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-4], $$[$0-5] === &#x27;until&#x27;, $$[$0-2]).addGuard($$[$0]));
break;
case 203:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].concat($$[$0]));
break;
case 206:
this.$ = yy.L(_$[$0-2], _$[$0],[yy.L(_$[$0-2],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">Case</span>($$[$0-1], $$[$0]))]);
break;
case 207:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat(yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))));
break;
case 212:
return this.$
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain" id="apidoc.element.livescript.ast.Chain">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &#x26;&#x26; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Chain</span>(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class" id="apidoc.element.livescript.ast.Class">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Class
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 139:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.Try($$[$0-5], $$[$0-3], yy.L(_$[$0-4],_$[$0-3], $$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 140:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 141:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Class</span>({
        title: $$[$0-3].unwrap(),
        sup: $$[$0-2],
        mixins: $$[$0-1],
        body: $$[$0]
      }));
break;
case 142:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.CopyL" id="apidoc.element.livescript.ast.CopyL">
        function <span class="apidocSignatureSpan">livescript.ast.</span>CopyL
        <span class="apidocSignatureSpan">(a, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CopyL = function (a, node){
  if (node &#x26;&#x26; typeof node === &#x22;object&#x22;) {
    node.first_line = a.first_line;
    node.first_column = a.first_column;
    node.last_line = a.last_line;
    node.last_column = a.last_column;
    node.line = a.line;
    node.column = a.column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Decl" id="apidoc.element.livescript.ast.Decl">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Decl
        <span class="apidocSignatureSpan">(type, nodes, lno)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decl = function (type, nodes, lno){
  if (!nodes[0]) {
    throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
  }
  return DECLS[type](nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.<span class="apidocCodeKeywordSpan">Decl</span>($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27;arguments&#x27; &#x26;&#x26; $$[$0] !== &#
x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence" id="apidoc.element.livescript.ast.Existence">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Existence</span>($$[$0-1].unwrap
()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call[&#x27;let&#x27;]($$[$0-3], $$[$0]))));
break;
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For" id="apidoc.element.livescript.ast.For">
        function <span class="apidocSignatureSpan">livescript.ast.</span>For
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &#x26;&#x26; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &#x3c; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &#x26;&#x26; !this.object) {
    this.carp(&#x27;`for own` requires `of`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 28:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var(&#x27;flip$&#x27;))).add(yy.L(_$[$0-3],_$[$0-3],yy
.Call([$$[$0-3]])))).flipIt().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 29:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">For</span>({
        from: $$[$0-3],
        op: $$[$0-2],
        to: $$[$0-1],
        inComprehension: true
      }))));
break;
case 30:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun" id="apidoc.element.livescript.ast.Fun">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &#x26;&#x26; &#x27;this$&#x27;;
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 113:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]));
break;
case 114:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Existence($$[$0-1].unwrap(), true));
break;
case 115:
this.$ = yy.L(_$[$0-5], _$[$0],yy.<span class="apidocCodeKeywordSpan">Fun</span>($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test
($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
break;
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If" id="apidoc.element.livescript.ast.If">
        function <span class="apidocSignatureSpan">livescript.ast.</span>If
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$[&#x27;if&#x27;] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
case 118:
this.$ = (yy.L(_$[$0-3],_$[$0-2], yy.<span class="apidocCodeKeywordSpan">If</span>($$[$0-2], $$[$0-1], $$[$0-3] === &#x27;unless
&#x27;)).addElse($$[$0]));
break;
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === &#x27;unless&#x27;)));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import" id="apidoc.element.livescript.ast.Import">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Import
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
case 73:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Import</span>(yy.L(_$[$0-2],_$[$0-1], yy.Unary(&#x27;^^&#x27
;, $$[$0-2], {
  prec: &#x27;yy.UNARY&#x27;
})), $$[$0], false));
break;
case 74:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary(&#x27;^^&#x27;, $$[$0-2], {
  prec: &#x27;yy.UNARY&#x27;
})), $$[$0].unwrap(), false));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In" id="apidoc.element.livescript.ast.In">
        function <span class="apidocSignatureSpan">livescript.ast.</span>In
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index" id="apidoc.element.livescript.ast.Index">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Index
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = &#x27;.&#x27;);
  if (init &#x26;&#x26; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case &#x27;[]&#x27;:
    this$.vivify = Arr;
    break;
  case &#x27;{}&#x27;:
    this$.vivify = Obj;
    break;
  default:
    if (&#x27;=&#x27; === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Index</span>($$[$0], $$[$
0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS" id="apidoc.element.livescript.ast.JS">
        function <span class="apidocSignatureSpan">livescript.ast.</span>JS
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 66:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], &#x27;cascade&#x27;));
break;
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">JS</span>($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump" id="apidoc.element.livescript.ast.Jump">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
case 125:
this.$ = yy.L(_$[$0], _$[$0],yy.Jump[$$[$0]]());
break;
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Jump</span>($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.Switch($$[$0-2], $$[$0-1], $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key" id="apidoc.element.livescript.ast.Key">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Key
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = &#x27;&#x27; + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
case 49:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Key</span>($$[$0]));
break;
case 50:
this.$ = yy.L(_$[$0], _$[$0],yy.Literal($$[$0]));
break;
case 51: case 164:
this.$ = yy.L(_$[$0], _$[$0],[]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.L" id="apidoc.element.livescript.ast.L">
        function <span class="apidocSignatureSpan">livescript.ast.</span>L
        <span class="apidocSignatureSpan">(a, b, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">L = function (a, b, node){
  if (node &#x26;&#x26; typeof node === &#x22;object&#x22;) {
    node.first_line = a.first_line + 1;
    node.first_column = a.first_column;
    node.last_line = b.last_line + 1;
    node.last_column = b.last_column;
    node.line = a.first_line + 1;
    node.column = a.first_column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.<span class="apidocCodeKeywordSpan">L</span>(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label" id="apidoc.element.livescript.ast.Label">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Label
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || &#x27;_&#x27;;
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &#x26;&#x26; it || it.calling &#x26;&#x26; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        body: $$[$0]
      }));
break;
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Label</span>($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27;arguments&#x27; &#x26;&#x26; $$[$0] !== &#
x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal" id="apidoc.element.livescript.ast.Literal">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + &#x22;&#x22;, true);
  }
  if (value === &#x27;super&#x27;) {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Literal</span>($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj" id="apidoc.element.livescript.ast.Obj">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ref: true
      }).addBody($$[$0]))));
break;
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.<span class="apidocCodeKeywordSpan">Obj</span>($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).named($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens" id="apidoc.element.livescript.ast.Parens">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 161:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], true)), yy.L(_$[$0-1],_$[$0-1],yy.Literal($$[$0-1] === &#
x27;+&#x27;))));
break;
case 168:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-2]);
break;
case 169:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Parens</span>($$[$0-1].chomp().unwrap(), false, $$[$0-2] === &#
x27;&#x22;&#x27;, yy.L(_$[$0-2],_$[$0-2],{}), yy.L(_$[$0],_$[$0],{})));
break;
case 173: case 209: case 211:
this.$ = yy.L(_$[$0], _$[$0],null);
break;
case 174: case 208: case 210:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop" id="apidoc.element.livescript.ast.Prop">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === &#x27;...&#x27;) {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
    }
    this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Prop</span>(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27
;arguments&#x27; &#x26;&#x26; $$[$0] !== &#x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
case 152:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Literal($$[$0-2])), [yy.L(_$[$0-1],_$[$0], yy.
Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require" id="apidoc.element.livescript.ast.Require">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Require
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Require</span>($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return" id="apidoc.element.livescript.ast.Return">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &#x26;&#x26; it.value !== &#x27;void&#x27;) {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice" id="apidoc.element.livescript.ast.Slice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &#x26;&#x26; (this$.from = Literal(0));
  if (this$.to &#x26;&#x26; this$.type === &#x27;to&#x27;) {
    this$.to = Binary(&#x27;+&#x27;, this$.to, Literal(&#x27;1&#x27;));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        target: $$[$0-7],
        from: yy.Literal(0),
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
case 37:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], yy.<span class="apidocCodeKeywordSpan">Slice</span>({
        type: $$[$0-2],
        target: $$[$0-6],
        from: $$[$0-3],
        to: $$[$0-1]
      }))));
break;
case 38:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat" id="apidoc.element.livescript.ast.Splat">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 54: case 167:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat($$[$0]));
break;
case 55:
this.$ = yy.L(_$[$0-5], _$[$0-2],$$[$0-5].concat($$[$0-2]));
break;
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Splat</span>($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.Block());
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice" id="apidoc.element.livescript.ast.StepSlice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        op: $$[$0-4],
        to: $$[$0-3],
        step: $$[$0-1],
        inComprehension: true
      }))));
break;
case 35:
this.$ = yy.L(_$[$0-8], _$[$0],yy.Chain(yy.L(_$[$0-8],_$[$0], new yy.<span class="apidocCodeKeywordSpan">StepSlice</span>({
        op: $$[$0-4],
        target: $$[$0-8],
        from: $$[$0-5],
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super" id="apidoc.element.livescript.ast.Super">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch" id="apidoc.element.livescript.ast.Switch">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this[&#x27;default&#x27;] = $default;
  if (type === &#x27;match&#x27;) {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &#x3e; 1) {
        throw &#x22;can&#x27;t have more than one topic in switch statement&#x22;;
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &#x26;&#x26; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &#x26;&#x26; last.tests[0] instanceof Var &#x26;&#x26; last
.tests[0].value === &#x27;_&#x27;) {
    this.cases.pop();
    this[&#x27;default&#x27;] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.Jump($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Switch</span>($$[$0-2], $$[$0-1], $$[$0]));
break;
case 129: case 130:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]));
break;
case 131:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw" id="apidoc.element.livescript.ast.Throw">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Throw</span>(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented
&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try" id="apidoc.element.livescript.ast.Try">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Try
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var(&#x27;e&#x27;), Var(&#x27;e$&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 132: case 133:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]));
break;
case 134:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, [], $$[$0]));
break;
case 135:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Try</span>($$[$0]));
break;
case 136:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 137:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.Try($$[$0-4], void 8, yy.L(_$[$0-3],_$[$0-3],$$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary" id="apidoc.element.livescript.ast.Unary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &#x26;&#x26; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case &#x27;!&#x27;:
      if (flag) {
        break;
      }
      if (it instanceof Fun &#x26;&#x26; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case &#x27;++&#x27;:
    case &#x27;--&#x27;:
      if (flag) {
        this$.post = true;
      }
      break;
    case &#x27;new&#x27;:
      if (it instanceof Existence &#x26;&#x26; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || &#x27;&#x27;).length; i$ &#x3c; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &#x26;&#x26; !node[&#x27;new&#x27;]) {
          if (node.method === &#x27;.call&#x27;) {
            node.args.shift();
          }
          node[&#x27;new&#x27;] = &#x27;new&#x27;;
          node.method = &#x27;&#x27;;
          return it;
        }
      }
      break;
    case &#x27;~&#x27;:
      if (it instanceof Fun &#x26;&#x26; it.statement &#x26;&#x26; !it.bound) {
        return it.bound = &#x27;this$&#x27;, it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 21:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-5],yy.Binary($$[$0-5], void 8, $$[$0-3]))));
break;
case 23:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-4]))));
break;
case 24: case 25:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Unary</span>($$[$0-1]))));
break;
case 26:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util" id="apidoc.element.livescript.ast.Util">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Util
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var" id="apidoc.element.livescript.ast.Var">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Var
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Var</span>($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars" id="apidoc.element.livescript.ast.Vars">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While" id="apidoc.element.livescript.ast.While">
        function <span class="apidocSignatureSpan">livescript.ast.</span>While
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &#x26;&#x26; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== &#x27;&#x27; + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === &#x27;unless&#x27;)));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.<span class="apidocCodeKeywordSpan">While</span>($$[$0], $$[$0-1] === &#x27;until&#x27;, true
).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === &#x27;until&#x27;, true).addGuard($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield" id="apidoc.element.livescript.ast.Yield">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 98:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Unary($$[$0-5], yy.Splat(yy.Arr($$[$0-2]))));
break;
case 99:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2])));
break;
case 100:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Yield</span>($$[$0]));
break;
case 101:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Yield($$[$0-1], $$[$0]));
break;
case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 158:
this.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.fromJSON" id="apidoc.element.livescript.ast.fromJSON">
        function <span class="apidocSignatureSpan">livescript.ast.</span>fromJSON
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
  if (that = it.type) {
    node = clone$(exports[that].prototype);
    for (key in it) {
      val = it[key];
      node[key] = fromJSON(val);
    }
    return node;
  }
  if (it.length != null) {
    for (i$ = 0, len$ = it.length; i$ &#x3c; len$; ++i$) {
      v = it[i$];
      results$.push(fromJSON(v));
    }
    return results$;
  } else {
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.<span class="apidocCodeKeywordSpan">fromJSON</span>(JSON.parse(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.parse" id="apidoc.element.livescript.ast.parse">
        function <span class="apidocSignatureSpan">livescript.ast.</span>parse
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (json){
  return exports.fromJSON(JSON.parse(json));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.fromJSON(JSON.<span class="apidocCodeKeywordSpan">parse</span>(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &#x26;&#x26; typeof it === &#x27;object&#x27;)) {
    return it;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr" id="apidoc.module.livescript.ast.Arr">module livescript.ast.Arr</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.Arr" id="apidoc.element.livescript.ast.Arr.Arr">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.<span class="apidocCodeKeywordSpan">Arr</span>($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.compile" id="apidoc.element.livescript.ast.Arr.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>compile
        <span class="apidocSignatureSpan">(o, items, deepEq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
  case 0:
    return &#x27;&#x27;;
  case 1:
    return items[0].compile(o, LEVEL_LIST);
  }
  indent = o.indent, level = o.level;
  o.indent = indent + TAB;
  o.level = LEVEL_LIST;
  code = [items[i = 0].compile(o)];
  while (that = items[++i]) {
    code.push(&#x27;, &#x27;);
    target = that;
    if (deepEq) {
      if (target instanceof Var &#x26;&#x26; target.value === &#x27;_&#x27;) {
        target = Obj([Prop(Key(&#x27;__placeholder__&#x27;), Literal(true))]);
      } else if (target instanceof Obj || target instanceof Arr) {
        target.deepEq = true;
      }
    }
    code.push(target.compile(o));
  }
  if (~code.join(&#x22;&#x22;).indexOf(&#x27;\n&#x27;)) {
    code = [&#x22;\n&#x22; + o.indent].concat(slice$.call(code), [&#x22;\n&#x22; + indent]);
  }
  o.indent = indent;
  o.level = level;
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.maybe" id="apidoc.element.livescript.ast.Arr.maybe">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>maybe
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybe = function (nodes){
  if (nodes.length === 1 &#x26;&#x26; !(nodes[0] instanceof Splat)) {
    return nodes[0];
  }
  return constructor(nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}), o(&#x27;Chain&#x27;, function(){
  return $1.unwrap();
}), o(&#x27;Chain ASSIGN Expression&#x27;, function(){
  return Assign($1.unwrap(), $3, L(2, Box($2)));
}), o(&#x27;SplatChain ASSIGN Expression&#x27;, function(){
  return Assign($1, $3, L(2, Box($2)));
}), o(&#x27;Chain ASSIGN INDENT ArgList OptComma DEDENT&#x27;, function(){
  return Assign($1.unwrap(), Arr.<span class="apidocCodeKeywordSpan">maybe</span>($4), L(2, Box($2)));
}), o(&#x27;Expression IMPORT Expression&#x27;, function(){
  return Import($1, $3, $2 === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
}), o(&#x27;Expression IMPORT INDENT ArgList OptComma DEDENT&#x27;, function(){
  return Import($1, Arr.maybe($4), $2 === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
}), o(&#x27;CREMENT Chain&#x27;, function(){
  return Unary($1, $2.unwrap());
}), o(&#x27;Chain CREMENT&#x27;, function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass" id="apidoc.element.livescript.ast.Arr.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(){
  List.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.wrap" id="apidoc.element.livescript.ast.Arr.wrap">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>wrap
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrap = function (it){
  return constructor([Splat((it.isArray = YES, it))]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (i + 1 === (len = nodes.length)) {
  if (skip) {
    break;
  }
  if (destructureArgs) {
    val = argsSlice(Literal(i), Chain(Var(&#x27;arguments&#x27;)).add(Index(Key(&#x27;length&#x27;))));
  } else {
    val = Arr.<span class="apidocCodeKeywordSpan">wrap</span>(JS(util(&#x27;slice&#x27;) + &#x27;.call(&#x27; + rite + (i ? &#x22
;, &#x22; + i + &#x22;)&#x22; : &#x27;)&#x27;)));
  }
} else {
  val = ivar = rite + &#x22;.length - &#x22; + (len - i - 1);
  if (skip &#x26;&#x26; i + 2 === len) {
    continue;
  }
  start = i + 1;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype" id="apidoc.module.livescript.ast.Arr.prototype">module livescript.ast.Arr.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.asObj" id="apidoc.element.livescript.ast.Arr.prototype.asObj">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>asObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObj = function (){
  var i, item;
  return Obj((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
      i = i$;
      item = ref$[i$];
      results$.push(Prop(Literal(i), item));
    }
    return results$;
  }.call(this)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prototype = extend$((import$(Import, superclass).displayName = &#x27;Import&#x27;, Import), superclass).prototype, constructor
 = Import;
function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.<span class="apidocCodeKeywordSpan">asObj</span>().items));
  }
  return this$;
} function ctor$(){} ctor$.prototype = prototype;
Import.prototype.children = [&#x27;left&#x27;, &#x27;right&#x27;];
Import.prototype.show = function(){
  return this.all;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.compile" id="apidoc.element.livescript.ast.Arr.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var items, code;
  items = this.items;
  if (!items.length) {
    return sn(this, &#x27;[]&#x27;);
  }
  if (!snEmpty(code = Splat.compileArray(o, items))) {
    return this.newed
      ? sn(this, &#x22;(&#x22;, code, &#x22;)&#x22;)
      : sn(this, code);
  }
  return sn(null, sn(this, &#x22;[&#x22;), List.compile(o, items, this.deepEq), sn(this, &#x22;]&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.constructor" id="apidoc.element.livescript.ast.Arr.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>constructor
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.isArray" id="apidoc.element.livescript.ast.Arr.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.toSlice" id="apidoc.element.livescript.ast.Arr.prototype.toSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>toSlice
        <span class="apidocSignatureSpan">(o, base, symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSlice = function (o, base, symbol){
  var items, ref$, ref, i$, len$, i, item, splat, chain;
  items = this.items;
  if (items.length &#x3e; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    item = items[i$];
    if (splat = item instanceof Splat) {
      item = item.it;
    }
    if (item.isEmpty()) {
      continue;
    }
    chain = Chain(base, [Index(item, symbol)]);
    items[i] = splat ? Splat(chain) : chain;
    base = ref;
  }
  chain || this.carp(&#x27;empty slice&#x27;);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &#x26;&#x26; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp(&#x27;calling a slice&#x27;);
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.<span class="apidocCodeKeywordSpan">toSlice</span>(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
};
return Chain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.superclass.prototype" id="apidoc.module.livescript.ast.Arr.superclass.prototype">module livescript.ast.Arr.superclass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.assigns" id="apidoc.element.livescript.ast.Arr.superclass.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.assigns(it)) {
      return true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.constructor" id="apidoc.element.livescript.ast.Arr.superclass.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(){
  List.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.isEmpty" id="apidoc.element.livescript.ast.Arr.superclass.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (){
  return !this.items.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.named" id="apidoc.element.livescript.ast.Arr.superclass.prototype.named">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>named
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">named = function (name){
  this.name = name;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
],
List: [
  o(&#x27;[ ArgList    OptComma ]&#x27;, function(){
    return Arr($2);
  }), o(&#x27;{ Properties OptComma }&#x27;, function(){
    return Obj($2);
  }), o(&#x27;[ ArgList    OptComma ] LABEL&#x27;, function(){
    return Arr($2).<span class="apidocCodeKeywordSpan">named</span>($5);
  }), o(&#x27;{ Properties OptComma } LABEL&#x27;, function(){
    return Obj($2).named($5);
  })
],
Key: [o(&#x27;KeyBase&#x27;), o(&#x27;Parenthetical&#x27;)],
KeyBase: [
  o(&#x27;ID&#x27;, function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.show" id="apidoc.element.livescript.ast.Arr.superclass.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign" id="apidoc.module.livescript.ast.Assign">module livescript.ast.Assign</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.Assign" id="apidoc.element.livescript.ast.Assign.Assign">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || &#x27;=&#x27;;
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += &#x27;&#x27;;
  this$[rite instanceof Node ? &#x27;right&#x27; : &#x27;unaries&#x27;] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Assign</span>($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$
0-1],yy.Box($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass" id="apidoc.element.livescript.ast.Assign.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype" id="apidoc.module.livescript.ast.Assign.prototype">module livescript.ast.Assign.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.assigns" id="apidoc.element.livescript.ast.Assign.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return this.left.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional" id="apidoc.element.livescript.ast.Assign.prototype.compileConditional">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileConditional
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileConditional = function (o, left){
  var lefts, morph;
  if (left instanceof Var &#x26;&#x26; in$(this.logic, [&#x27;?&#x27;]) &#x26;&#x26; this.op === &#x27;=&#x27;) {
    o.scope.declare(left.value, left);
  }
  lefts = Chain(left).cacheReference(o);
  o.level += LEVEL_OP &#x3c; o.level;
  morph = Binary(this.logic, lefts[0], (this.logic = false, this.left = lefts[1], this));
  return sn(this, (morph[&#x27;void&#x27;] = this[&#x27;void&#x27;], morph).compileNode(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  left = left.first;
}
if (left.items) {
  return this.compileDestructuring(o, left);
}
left.isAssignable() || left.carp(&#x27;invalid assign&#x27;);
if (this.logic) {
  return this.<span class="apidocCodeKeywordSpan">compileConditional</span>(o, left);
}
op = this.op, right = this.right;
if (op === &#x27;&#x3c;?=&#x27; || op === &#x27;&#x3e;?=&#x27;) {
  return this.compileMinMax(o, left, right);
}
if ((op === &#x27;**=&#x27; || op === &#x27;^=&#x27; || op === &#x27;%%=&#x27; || op === &#x27;++=&#x27; || op === &#x27;|&#x3e;=&#
x27;) || op === &#x27;*=&#x27; &#x26;&#x26; right.isString() || (op === &#x27;-=&#x27; || op === &#x27;/=&#x27;) &#x26;&#x26; right
.isMatcher()) {
  ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring" id="apidoc.element.livescript.ast.Assign.prototype.compileDestructuring">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileDestructuring
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDestructuring = function (o, left){
  var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
  items = left.items, len = items.length;
  ret = o.level &#x26;&#x26; !this[&#x27;void&#x27;];
  rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
  if (that = left.name) {
    cache = sn(this, that, &#x22; = &#x22;, rite);
    o.scope.declare(rite = that, left);
  } else if ((ret || len &#x3e; 1) &#x26;&#x26; (!ID.test(rite.toString()) || left.assigns(rite.toString()))) {
    cache = sn(this, rref = o.scope.temporary(), &#x22; = &#x22;, rite);
    rite = rref;
  }
  if (rite.toString() === &#x27;arguments&#x27; &#x26;&#x26; !ret) {
    destructureArgs = true;
    if (!(left instanceof Arr)) {
      this.carp(&#x27;arguments can only destructure to array&#x27;);
    }
  }
  list = this[&#x22;rend&#x22; + left.constructor.displayName](o, items, rite, destructureArgs);
  if (rref) {
    o.scope.free(rref);
  }
  if (cache) {
    list.unshift(cache);
  }
  if (ret || !list.length) {
    list.push(rite);
  }
  code = [];
  sep = destructureArgs ? &#x27;; &#x27; : &#x27;, &#x27;;
  for (i$ = 0, len$ = list.length; i$ &#x3c; len$; ++i$) {
    item = list[i$];
    code.push(item, sep);
  }
  code.pop();
  if (list.length &#x3c; 2 || o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
}
if (left.getDefault()) {
  this.right = Binary(left.op, this.right, left.second);
  left = left.first;
}
if (left.items) {
  return this.<span class="apidocCodeKeywordSpan">compileDestructuring</span>(o, left);
}
left.isAssignable() || left.carp(&#x27;invalid assign&#x27;);
if (this.logic) {
  return this.compileConditional(o, left);
}
op = this.op, right = this.right;
if (op === &#x27;&#x3c;?=&#x27; || op === &#x27;&#x3e;?=&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax" id="apidoc.element.livescript.ast.Assign.prototype.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileMinMax
        <span class="apidocSignatureSpan">(o, left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMinMax = function (o, left, right){
  var lefts, rites, test, put, ref$;
  lefts = Chain(left).cacheReference(o);
  rites = right.cache(o, true);
  test = Binary(this.op.replace(&#x27;?&#x27;, &#x27;&#x27;), lefts[0], rites[0]);
  put = Assign(lefts[1], rites[1], &#x27;:=&#x27;);
  if (this[&#x27;void&#x27;] || !o.level) {
    return Parens(Binary(&#x27;||&#x27;, test, put)).compile(o);
  }
  ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
  return sn(this, If(test, left).addElse(put).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileMinMax</span>(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileNode" id="apidoc.element.livescript.ast.Assign.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &#x26;&#x26; this.op === &#x27;=&#x27;) {
    return this.compileSplice(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
    left instanceof List || this.left.carp(&#x27;invalid splat&#x27;);
    return this.compileSpread(o, left);
  }
  if (!this.right) {
    left.isAssignable() || left.carp(&#x27;invalid unary assign&#x27;);
    ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
    for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ &#x3c; len$; ++i$) {
      op = ref$[i$];
      this.right = Unary(op, this.right);
    }
  }
  if (left.isEmpty()) {
    return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
  }
  if (left.getDefault()) {
    this.right = Binary(left.op, this.right, left.second);
    left = left.first;
  }
  if (left.items) {
    return this.compileDestructuring(o, left);
  }
  left.isAssignable() || left.carp(&#x27;invalid assign&#x27;);
  if (this.logic) {
    return this.compileConditional(o, left);
  }
  op = this.op, right = this.right;
  if (op === &#x27;&#x3c;?=&#x27; || op === &#x27;&#x3e;?=&#x27;) {
    return this.compileMinMax(o, left, right);
  }
  if ((op === &#x27;**=&#x27; || op === &#x27;^=&#x27; || op === &#x27;%%=&#x27; || op === &#x27;++=&#x27; || op === &#x27;|&#x3e;=&#x27;) || op === &#x27;*=&#x27; &#x26;&#x26; right.isString() || (op === &#x27;-=&#x27; ||
op === &#x27;/=&#x27;) &#x26;&#x26; right.isMatcher()) {
    ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
    right = Binary(op.slice(0, -1), reft, right);
    op = &#x27;:=&#x27;;
  }
  if (op === &#x27;.&#x26;.=&#x27; || op === &#x27;.|.=&#x27; || op === &#x27;.^.=&#x27; || op === &#x27;.&#x3c;&#x3c;.=&#x27; || op === &#x27;.&#x3e;&#x3e;.=&#x27; || op === &#x27;.&#x3e;&#x3e;&#x3e;.=&#x27;) {
    op = op.slice(1, -2) + &#x27;=&#x27;;
  }
  (right = right.unparen()).ripName(left = left.unwrap());
  sign = sn(this.opLoc, &#x22; &#x22;, op.replace(&#x27;:&#x27;, &#x27;&#x27;), &#x22; &#x22;);
  name = (left.front = true, left).compile(o, LEVEL_LIST);
  if (lvar = left instanceof Var) {
    if (op === &#x27;=&#x27;) {
      o.scope.declare(name.toString(), left, this[&#x27;const&#x27;] || !this.defParam &#x26;&#x26; o[&#x27;const&#x27;] &#x26;&#x26; &#x27;$&#x27; !== name.toString().slice(-1));
    } else if (that = o.scope.checkReadOnly(name.toString())) {
      left.carp(&#x22;assignment to &#x22; + that + &#x22; \&#x22;&#x22; + name + &#x22;\&#x22;&#x22;, ReferenceError);
    }
  }
  if (left instanceof Chain &#x26;&#x26; right instanceof Fun) {
    protoSplit = name.toString().split(&#x27;.prototype.&#x27;);
    dotSplit = name.toString().split(&#x27;.&#x27;);
    if (protoSplit.length &#x3e; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &#x3e; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join(&#x27;&#x27;);
    }
  }
  code = !o.level &#x26;&#x26; right instanceof While &#x26;&#x26; !right[&#x27;else&#x27;] &#x26;&#x26; (lvar || left instanceof Chain &#x26;&#x26; left.isSimpleAccess())
    ? (empty = right.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;, [res = o.scope.temporary(&#x27;res&#x27;), &#x22; = &#x22; + empty + &#x22;;\n&#x22; + this.tab, right.makeReturn(
res).compile(o), &#x22;\n&#x22; + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &#x3e; LEVEL_LIST) {
    code = [&#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice" id="apidoc.element.livescript.ast.Assign.prototype.compileSplice">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSplice
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSplice = function (o){
  var ref$, fromExpNode, fromExp, rightNode, right, toExp;
  ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
  ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
  toExp = Binary(&#x27;-&#x27;, this.left.to, fromExp);
  return sn(this, Block([Chain(Var(util(&#x27;splice&#x27;))).add(Index(Key(&#x27;apply&#x27;), &#x27;.&#x27;, true)).add(Call([this.left.target, Chain(Arr([fromExpNode
, toExp])).add(Index(Key(&#x27;concat&#x27;), &#x27;.&#x27;, true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Assign.prototype.unfoldAssign = function(){
  return this.access &#x26;&#x26; this;
};
Assign.prototype.compileNode = function(o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &#x26;&#x26; this.op === &#x27;=&#x27;) {
    return this.<span class="apidocCodeKeywordSpan">compileSplice</span>(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread" id="apidoc.element.livescript.ast.Assign.prototype.compileSpread">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSpread
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpread = function (o, left){
  var that, ref$, rite, rref, this$ = this;
  ref$ = (that = this.unaries)
    ? [that, that]
    : left.items.length &#x3c;= 1
      ? [ref$ = this.right, ref$]
      : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
  return this.compileSpreadOver(o, left, function(it){
    var result;
    result = constructor(it, rite, this$.op, this$.logic);
    rite = rref;
    return result;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }[it] + &#x27;crement&#x27;;
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.<span class="apidocCodeKeywordSpan">compileSpread</span>(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
    it.cond = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.constructor" id="apidoc.element.livescript.ast.Assign.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>constructor
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || &#x27;=&#x27;;
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += &#x27;&#x27;;
  this$[rite instanceof Node ? &#x27;right&#x27; : &#x27;unaries&#x27;] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isArray" id="apidoc.element.livescript.ast.Assign.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  switch (this.op) {
  case &#x27;=&#x27;:
  case &#x27;:=&#x27;:
    return this.right &#x26;&#x26; this.right.isArray();
  case &#x27;/=&#x27;:
    return this.right &#x26;&#x26; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isCallable" id="apidoc.element.livescript.ast.Assign.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isRegex" id="apidoc.element.livescript.ast.Assign.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isString" id="apidoc.element.livescript.ast.Assign.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  switch (this.op) {
  case &#x27;=&#x27;:
  case &#x27;:=&#x27;:
  case &#x27;+=&#x27;:
  case &#x27;*=&#x27;:
    return this.right &#x26;&#x26; this.right.isString();
  case &#x27;-=&#x27;:
    return this.right &#x26;&#x26; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendArr" id="apidoc.element.livescript.ast.Assign.prototype.rendArr">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendArr
        <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rendArr = function (o, nodes, rite, destructureArgs){
  var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
  function argsSlice(begin, end){
    return new For({
      ref: true,
      from: begin,
      op: &#x27;til&#x27;,
      to: end
    }).makeComprehension(Chain(Var(&#x27;arguments&#x27;)).add(Index(Literal(&#x27;..&#x27;))), []);
  }
  ret = [];
  for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = nodes[i$];
    if (node.isEmpty()) {
      continue;
    }
    if (node instanceof Splat) {
      len &#x26;&#x26; node.carp(&#x27;multiple splat in an assignment&#x27;);
      skip = (node = node.it).isEmpty();
      if (i + 1 === (len = nodes.length)) {
        if (skip) {
          break;
        }
        if (destructureArgs) {
          val = argsSlice(Literal(i), Chain(Var(&#x27;arguments&#x27;)).add(Index(Key(&#x27;length&#x27;))));
        } else {
          val = Arr.wrap(JS(util(&#x27;slice&#x27;) + &#x27;.call(&#x27; + rite + (i ? &#x22;, &#x22; + i + &#x22;)&#x22; : &#x27;)&#x27;)));
        }
      } else {
        val = ivar = rite + &#x22;.length - &#x22; + (len - i - 1);
        if (skip &#x26;&#x26; i + 2 === len) {
          continue;
        }
        start = i + 1;
        (this.temps || (this.temps = [])).push(ivar = o.scope.temporary(&#x27;i&#x27;));
        val = (fn$());
      }
    } else {
      (inc = ivar) &#x26;&#x26; start &#x3c; i &#x26;&#x26; (inc += &#x22; + &#x22; + (i - start));
      val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
    }
    if (node instanceof Assign) {
      node = Binary(node.op, node.left, node.right, node.logic || true);
    }
    if (destructureArgs) {
      if (!(node instanceof Var) &#x26;&#x26; val instanceof For) {
        (this.temps || (this.temps = [])).push(tmp = o.scope.temporary(&#x27;ref&#x27;));
        vtmp = Var(tmp);
        ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
      } else {
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_TOP));
      }
    } else {
      ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_PAREN));
    }
  }
  return ret;
  function fn$(){
    switch (false) {
    case !skip:
      return Arr.wrap(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;) ? &#x22; + i + &#x22; : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;)&#x22;));
    case !destructureArgs:
      return argsSlice(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;) ? &#x22; + i + &#x22; : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;)&#x22;), Var(ivar));
    default:
      return Arr.wrap(JS(i + &#x22; &#x3c; (&#x22; + ivar + &#x22; = &#x22; + val + &#x22;)\ ? &#x22; + util(&#x27;slice&#x27;) + &#x22;.call(&#x22; + rite + &#x22;, &#x22; + i + &#x22;, &#x22; + ivar + &#x22;)\ : (&#x22; + ivar + &#x22; = &#x22; + i + &#x22;, [])&#x22;));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendObj" id="apidoc.element.livescript.ast.Assign.prototype.rendObj">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendObj
        <span class="apidocSignatureSpan">(o, nodes, rite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rendObj = function (o, nodes, rite){
  var i$, len$, node, splat, logic, ref$, key, val, rcache, results$ = [];
  for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
    node = nodes[i$];
    if (splat = node instanceof Splat) {
      node = node.it;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Parens) {
      ref$ = Chain(node.it).cacheReference(o), node = ref$[0], key = ref$[1];
    } else if (node instanceof Prop) {
      node = (key = node.key, node).val;
    } else {
      key = node;
    }
    if (node instanceof Key) {
      node = CopyL(node, Var(node.name));
    }
    if (logic) {
      node = (logic.first = node, logic);
    }
    val = Chain(rcache || (rcache = Var(rite)), [Index(key.maybeKey())]);
    if (splat) {
      val = Import(Obj(), val);
    }
    results$.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$[&#x27;void&#x27;] = true, ref$).compile(o, LEVEL_PAREN));
  }
  return results$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.show" id="apidoc.element.livescript.ast.Assign.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [void 8].concat(this.unaries).reverse().join(&#x27; &#x27;) + [this.logic] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Assign.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldAssign = function (){
  return this.access &#x26;&#x26; this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Assign.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var that, ref$, ref1$, rite, temps;
  if (this.left instanceof Existence) {
    if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
      rite = this.right;
      rite = Assign(this.right = Var(that), rite);
    } else {
      ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
    }
    return ref$ = If(Existence(rite), this), ref$.temps = temps, ref$.cond = this.cond, ref$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref$;
  }
  return If.unfoldSoak(o, this, &#x27;left&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.superclass.prototype" id="apidoc.module.livescript.ast.Assign.superclass.prototype">module livescript.ast.Assign.superclass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.addElse" id="apidoc.element.livescript.ast.Assign.superclass.prototype.addElse">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>addElse
        <span class="apidocSignatureSpan">($else)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addElse = function ($else){
  this[&#x27;else&#x27;] = $else;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compileExistence = function(o){
  var x;
  if (this[&#x27;void&#x27;] || !o.level) {
    x = Binary(&#x27;&#x26;&#x26;&#x27;, Existence(this.first, true), this.second);
    return (x[&#x27;void&#x27;] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).<span class="apidocCodeKeywordSpan">addElse</span>(this.second).compileExpression(o));
};
Binary.prototype.compileAnyInstanceOf = function(o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary(&#x27;instanceof&#x27;, sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    item = items[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.anaphorize" id="apidoc.element.livescript.ast.Assign.superclass.prototype.anaphorize">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>anaphorize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anaphorize = function (){
  var base, name, ref$;
  this.children = this.aTargets;
  if (this.eachChild(hasThat)) {
    if ((base = this)[name = this.aSource] instanceof Existence) {
      base = base[name];
      name = &#x27;it&#x27;;
    }
    if (base[name].value !== &#x27;that&#x27;) {
      base[name] = Assign(Var(&#x27;that&#x27;), base[name]);
    }
  }
  function hasThat(it){
    var that;
    return it.value === &#x27;that&#x27; || ((that = it.aSource)
      ? (that = it[that]) ? hasThat(that) : void 8
      : it.eachChild(hasThat));
  }
  delete this.children;
  return ref$ = this[this.aSource], ref$.cond = true, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this;
};
While.prototype.compileNode = function(o){
  var test, ref$, head, that;
  o.loop = true;
  this.test &#x26;&#x26; (this.un
    ? this.test = this.test.invert()
    : this.<span class="apidocCodeKeywordSpan">anaphorize</span>());
  if (this.post) {
    return sn(null, sn(this, &#x27;do {&#x27;), this.compileBody((o.indent += TAB, o)));
  }
  test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;&#x27;;
  if (!(this.update || this[&#x27;else&#x27;])) {
    head = !snEmpty(test)
      ? [sn(this, &#x22;while (&#x22;), test]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.assigns" id="apidoc.element.livescript.ast.Assign.superclass.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>assigns
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.cache" id="apidoc.element.livescript.ast.Assign.superclass.prototype.cache">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>cache
        <span class="apidocSignatureSpan">(o, once, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (o, once, level){
  var ref$, sub, ref;
  if (!this.isComplex()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
    }
    return [sub, ref.value];
  }
  if (once) {
    return [sub, (ref.temp = true, ref)];
  } else {
    return [sub, ref, [ref.value]];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.unwrap().<span class="apidocCodeKeywordSpan">cache</span>(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.carp" id="apidoc.element.livescript.ast.Assign.superclass.prototype.carp">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>carp
        <span class="apidocSignatureSpan">(msg, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">carp = function (msg, type){
  type == null &#x26;&#x26; (type = SyntaxError);
  throw type(msg + &#x22; on line &#x22; + (this.line || this.traverseChildren(function(it){
    return it.line;
  })));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.getJump()) {
    that.<span class="apidocCodeKeywordSpan">carp</span>(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
  this.traverseChildren(function(it){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compile" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compile
        <span class="apidocSignatureSpan">(options, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.unfoldSoak(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
      o.scope.free(tmp);
    }
  }
  return code;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileBlock" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileBlock">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileBlock
        <span class="apidocSignatureSpan">(o, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileBlock = function (o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    code.push.apply(code, mid);
    code.push(&#x27;}&#x27;);
    if (this.post) {
      code.push(sn(this, &#x22; while (&#x22;), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, &#x22;);&#x22;));
    }
    if (yet) {
      code.push(sn(this, &#x22; if (&#x22;), yet, sn(this, &#x22;) &#x22;), this.<span class="apidocCodeKeywordSpan">compileBlock
</span>(o, Block(this[&#x27;else&#x27;])));
      o.scope.free(yet);
    }
    return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));
  };
  return While;
}(Node));
exports.For = For = (function(superclass){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileClosure" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileClosure">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileClosure
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClosure = function (o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.getJump()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
  this.traverseChildren(function(it){
    switch (it.value) {
    case &#x27;this&#x27;:
      hasThis = true;
      break;
    case &#x27;arguments&#x27;:
      hasArgs = it.value = &#x27;args$&#x27;;
    }
  });
  if (hasThis) {
    call.args.push(Literal(&#x27;this&#x27;));
    call.method = &#x27;.call&#x27;;
  }
  if (hasArgs) {
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.<span class="apidocCodeKeywordSpan">compileClosure</span>(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileLoopReference" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileLoopReference">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileLoopReference
        <span class="apidocSignatureSpan">(o, name, ret, safeAccess)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileLoopReference = function (o, name, ret, safeAccess){
  var ref$, code, asn, tmp;
  if (this instanceof Var &#x26;&#x26; o.scope.check(this.value) || this instanceof Unary &#x26;&#x26; ((ref$ = this.op) === &#x27;+&#x27; || ref$ === &#x27;-&#x27;) &#x26;&#x26; (-
1 / 0 &#x3c; (ref$ = +this.it.value) &#x26;&#x26; ref$ &#x3c; 1 / 0) || this instanceof Literal &#x26;&#x26; !this.isComplex()) {
    code = this.compile(o, LEVEL_PAREN);
    if (safeAccess &#x26;&#x26; !(this instanceof Var)) {
      code = &#x22;(&#x22; + code + &#x22;)&#x22;;
    }
    return [code, code];
  }
  asn = Assign(Var(tmp = o.scope.temporary(name)), this);
  ret || (asn[&#x27;void&#x27;] = true);
  return [tmp, asn.compile(o, ret ? LEVEL_CALL : LEVEL_PAREN)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  temps.push(idx = o.scope.temporary(&#x27;i&#x27;));
}
if (!this.body) {
  this.addBody(Block(Var(idx)));
}
if (!this.object) {
  ref$ = (this.step || Literal(1)).<span class="apidocCodeKeywordSpan">compileLoopReference</span>(o, &#x27;step&#x27;), pvar =
ref$[0], step = ref$[1];
  pvar === step || temps.push(pvar);
}
if (this.from) {
  if (this.ref) {
    this.item = Var(idx);
  }
  ref$ = this.to.compileLoopReference(o, &#x27;to&#x27;), tvar = ref$[0], tail = ref$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileSpreadOver" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileSpreadOver">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileSpreadOver
        <span class="apidocSignatureSpan">(o, list, transform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpreadOver = function (o, list, transform){
  var ob, them, i$, len$, i, node, sp, lat, ref$;
  ob = list instanceof Obj;
  them = list.items;
  for (i$ = 0, len$ = them.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = them[i$];
    if (sp = node instanceof Splat) {
      node = node.it;
    }
    if (ob &#x26;&#x26; !sp) {
      node = node.val;
    }
    node = transform(node);
    if (sp) {
      node = lat = Splat(node);
    }
    if (ob &#x26;&#x26; !sp) {
      them[i].val = node;
    } else {
      them[i] = node;
    }
  }
  if (!lat &#x26;&#x26; (this[&#x27;void&#x27;] || !o.level)) {
    list = (ref$ = Block(ob ? (function(){
      var i$, x$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = them).length; i$ &#x3c; len$; ++i$) {
        x$ = ref$[i$];
        results$.push(x$.val);
      }
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ops = [this];
for (; it instanceof constructor; it = it.it) {
  ops.push(it);
}
if (!(it instanceof Splat &#x26;&#x26; (it = it.it.expandSlice(o).unwrap()) instanceof List)) {
  return &#x27;&#x27;;
}
return this.<span class="apidocCodeKeywordSpan">compileSpreadOver</span>(o, it, function(node){
  var i$, ref$, op;
  for (i$ = (ref$ = ops).length - 1; i$ &#x3e;= 0; --i$) {
    op = ref$[i$];
    node = constructor(op.op, node, op.post);
  }
  return node;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.delegate" id="apidoc.element.livescript.ast.Assign.superclass.prototype.delegate">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>delegate
        <span class="apidocSignatureSpan">(names, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delegate = function (names, fn){
  var i$, len$;
  for (i$ = 0, len$ = names.length; i$ &#x3c; len$; ++i$) {
    (fn$.call(this, names[i$]));
  }
  function fn$(name){
    this[name] = function(it){
      return fn.call(this, name, it);
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return pos;
};
Block.prototype.isComplex = function(){
  var ref$;
  return this.lines.length &#x3e; 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
};
prototype.<span class="apidocCodeKeywordSpan">delegate</span>([&#x27;isCallable&#x27;, &#x27;isArray&#x27;, &#x27;isString&#x27;, &#
x27;isRegex&#x27;], function(it){
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.lines)[ref1$.length - 1]) != null ? ref$[it]() : void 8;
});
Block.prototype.getJump = function(it){
  var i$, ref$, len$, node, that;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.eachChild" id="apidoc.element.livescript.ast.Assign.superclass.prototype.eachChild">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>eachChild
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachChild = function (fn){
  var i$, ref$, len$, name, child, j$, len1$, i, node, that;
  for (i$ = 0, len$ = (ref$ = this.children).length; i$ &#x3c; len$; ++i$) {
    name = ref$[i$];
    if (child = this[name]) {
      if (&#x27;length&#x27; in child) {
        for (j$ = 0, len1$ = child.length; j$ &#x3c; len1$; ++j$) {
          i = j$;
          node = child[j$];
          if (that = fn(node, name, i)) {
            return that;
          }
        }
      } else {
        if ((that = fn(child, name)) != null) {
          return that;
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
      }
    }
  }
},
traverseChildren: function(fn, xscope){
  var this$ = this;
  return this.<span class="apidocCodeKeywordSpan">eachChild</span>(function(node, name, index){
    var ref$;
    return (ref$ = fn(node, this$, name, index)) != null
      ? ref$
      : node.traverseChildren(fn, xscope);
  });
},
anaphorize: function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.expandSlice" id="apidoc.element.livescript.ast.Assign.superclass.prototype.expandSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>expandSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? Chain(head, slice$.call(pre, 0, -1))
    : Literal(&#x27;this&#x27;);
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.<span class="apidocCodeKeywordSpan">expandSlice</span>(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getAccessors" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getAccessors">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getAccessors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function Prop(key, val){
var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
this$.key = key;
this$.val = val;
if (key.value === &#x27;...&#x27;) {
  return Splat(this$.val);
}
if (that = val.<span class="apidocCodeKeywordSpan">getAccessors</span>()) {
  this$.val = that;
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    fun = that[i$];
    fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
  }
  this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getCall" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getCall">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fun.name = node.label;
  fun.labeled = true;
  node = node.it;
}
if (!fun.hushed &#x26;&#x26; (fun.hushed = node.op === &#x27;!&#x27;)) {
  node = node.it;
}
if ((ref$ = node.<span class="apidocCodeKeywordSpan">getCall</span>()) != null) {
  ref$.partialized = null;
}
args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
index = 0;
for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
  a = args[i$];
  if (a.placeholder) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getDefault" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getDefault">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
} else {
  if (logic = node.<span class="apidocCodeKeywordSpan">getDefault</span>()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
      ref$ = [node, key], key = ref$[0], node = ref$[1];
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getJump" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invert" id="apidoc.element.livescript.ast.Assign.superclass.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  return Unary(&#x27;!&#x27;, this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invertCheck" id="apidoc.element.livescript.ast.Assign.superclass.prototype.invertCheck">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invertCheck
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invertCheck = function (it){
  if (it.inverted) {
    return this.invert();
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compilePartial = function(o){
  var vit, x, y;
  vit = Var(&#x27;it&#x27;);
  switch (false) {
  case !(this.first == null &#x26;&#x26; this.second == null):
    x = Var(&#x27;x$&#x27;);
    y = Var(&#x27;y$&#x27;);
    return sn(this, Fun([x, y], Block(Binary(this.op, x, y).<span class="apidocCodeKeywordSpan">invertCheck</span>(this)), false
, true).compile(o));
  case this.first == null:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), &#x22
;)&#x22;);
  default:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), &#x22
;)&#x22;);
  }
};
Binary.prototype.compileRegexEquals = function(o, arg$){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isArray" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isAssignable" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isCallable" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isComplex" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isEmpty" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isMatcher" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isMatcher">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isMatcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isMatcher = function (){
  return this.isString() || this.isRegex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.partial || ((ref$ = this.op) === &#x27;&#x26;&#x26;&#x27; || ref$ === &#x27;||&#x27; || ref$ === &#x27;?&#x27; ||
ref$ === &#x27;&#x3c;&#x3c;&#x27; || ref$ === &#x27;&#x3e;&#x3e;&#x27;) &#x26;&#x26; this.first.isCallable() &#x26;&#x26; this.second
.isCallable();
};
Binary.prototype.isArray = function(){
  switch (this.op) {
  case &#x27;*&#x27;:
    return this.first.isArray();
  case &#x27;/&#x27;:
    return this.second.<span class="apidocCodeKeywordSpan">isMatcher</span>();
  }
};
Binary.prototype.isString = function(){
  switch (this.op) {
  case &#x27;+&#x27;:
  case &#x27;*&#x27;:
    return this.first.isString() || this.second.isString();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isRegex" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isStatement" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isString" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.makeReturn" id="apidoc.element.livescript.ast.Assign.superclass.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(ref, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (ref, obj){
  var items, kv, i, v;
  if (obj) {
    items = this instanceof Arr
      ? (this.items[0] == null || this.items[1] == null &#x26;&#x26; this.carp(&#x27;must specify both key and value for object comprehension&#x27;),
this.items)
      : (kv = &#x27;keyValue$&#x27;, (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &#x3c; len$; ++i$) {
          i = i$;
          v = ref$[i$];
          results$.push(Chain(v).add(Index(Literal(i))));
        }
        return results$;
      }.call(this)));
    return Assign(Chain(Var(ref)).add(Index(items[0], &#x27;.&#x27;, true)), items[1]);
  } else if (ref) {
    return Call.make(JS(ref + &#x27;.push&#x27;), [this]);
  } else {
    return Return(this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.maybeKey" id="apidoc.element.livescript.ast.Assign.superclass.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.ripName" id="apidoc.element.livescript.ast.Assign.superclass.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>ripName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.show" id="apidoc.element.livescript.ast.Assign.superclass.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function String() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.stringify" id="apidoc.element.livescript.ast.Assign.superclass.prototype.stringify">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>stringify
        <span class="apidocSignatureSpan">(space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (space){
  return JSON.stringify(this, null, space);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    genForNode(child);
  }
  debugIndent = debugIndent.slice(0, debugIndent.length - debugIndentStr.length);
  if (valid) {
    return stack.pop();
  }
} else {
  debugOutput += debugIndent + &#x22;&#x22; + JSON.<span class="apidocCodeKeywordSpan">stringify</span>(node) + &#x22;\n&#x22;;
  code += node;
  cur = stack[stack.length - 1];
  if (cur) {
    gen.addMapping({
      source: cur.source,
      original: {
        line: cur.line,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toJSON" id="apidoc.element.livescript.ast.Assign.superclass.prototype.toJSON">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
  return import$({
    type: this.constructor.displayName
  }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toString" id="apidoc.element.livescript.ast.Assign.superclass.prototype.toString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toString
        <span class="apidocSignatureSpan">(idt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.show()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return !node;
}
};
snSafe = function(code){
if (code instanceof SourceNode) {
  return code;
} else {
  return code.<span class="apidocCodeKeywordSpan">toString</span>();
}
};
snRemoveLeft = function(node, count){
var i$, to$, i, child;
for (i$ = 0, to$ = node.children.length; i$ &#x3c; to$; ++i$) {
  i = i$;
  child = node.children[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.traverseChildren" id="apidoc.element.livescript.ast.Assign.superclass.prototype.traverseChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>traverseChildren
        <span class="apidocSignatureSpan">(fn, xscope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseChildren = function (fn, xscope){
  var this$ = this;
  return this.eachChild(function(node, name, index){
    var ref$;
    return (ref$ = fn(node, this$, name, index)) != null
      ? ref$
      : node.traverseChildren(fn, xscope);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.carp(&#x27;inconvertible statement&#x27;);
}
fun = Fun([], Block(this));
call = Call();
if (o.inGenerator) {
  fun.generator = true;
}
this.<span class="apidocCodeKeywordSpan">traverseChildren</span>(function(it){
  switch (it.value) {
  case &#x27;this&#x27;:
    hasThis = true;
    break;
  case &#x27;arguments&#x27;:
    hasArgs = it.value = &#x27;args$&#x27;;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unparen" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unparen">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unparen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Block.prototype.children = [&#x27;lines&#x27;];
Block.prototype.toJSON = function(){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
};
Block.prototype.add = function(it){
  var that, ref$;
  it = it.<span class="apidocCodeKeywordSpan">unparen</span>();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unwrap" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.varName" id="apidoc.element.livescript.ast.Assign.superclass.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function String() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary" id="apidoc.module.livescript.ast.Binary">module livescript.ast.Binary</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.Binary" id="apidoc.element.livescript.ast.Binary.Binary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === &#x27;String&#x27;) {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== &#x27;=&#x27;:
        return &#x27;?&#x27;;
      default:
        return &#x27;=&#x27;;
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if (&#x27;=&#x27; === op.charAt(op.length - 1) &#x26;&#x26; ((ref$ = op.charAt(op.length - 2)) !== &#x27;=&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3c;&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3e;&#x27; &#x26;&#x26; ref$ !== &#x27;!&#x27;)) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case &#x27;in&#x27;:
      return new In(first, second);
    case &#x27;with&#x27;:
      return new Import(Unary(&#x27;^^&#x27;, first), second, false);
    case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
    case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
      return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
    case &#x27;&#x3c;|&#x27;:
      return Block(first).pipe(second, op);
    case &#x27;|&#x3e;&#x27;:
      return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
    case &#x27;.&#x27;:
    case &#x27;.~&#x27;:
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Binary</span>($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.superclass" id="apidoc.element.livescript.ast.Binary.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype" id="apidoc.module.livescript.ast.Binary.prototype">module livescript.ast.Binary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf" id="apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileAnyInstanceOf
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAnyInstanceOf = function (o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary(&#x27;instanceof&#x27;, sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    item = items[i$];
    test = Binary(&#x27;||&#x27;, test, Binary(&#x27;instanceof&#x27;, ref, item));
  }
  return sn(this, Parens(test).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.second.cond = true;
  }
  break;
case &#x27;instanceof&#x27;:
  rite = this.second.expandSlice(o).unwrap(), items = rite.items;
  if (rite instanceof Arr) {
    if (items[1]) {
      return this.<span class="apidocCodeKeywordSpan">compileAnyInstanceOf</span>(o, items);
    }
    this.second = items[0] || rite;
  }
  this.second.isCallable() || this.second.carp(&#x27;invalid instanceof operand&#x27;);
  break;
case &#x27;====&#x27;:
case &#x27;!===&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileChain" id="apidoc.element.livescript.ast.Binary.prototype.compileChain">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileChain
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileChain = function (o){
  var code, level, ref$, sub;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
  ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
  code.push(&#x22; &#x22;, this.op, &#x22; &#x22;, sub.compile(o, level), &#x22; &#x26;&#x26; &#x22;, this.second.compile(o, LEVEL_OP));
  if (o.level &#x3c;= LEVEL_OP) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
        console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#
x22; == &#x22; + this.second.value);
      }
    }
  }
  if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
    return this.<span class="apidocCodeKeywordSpan">compileChain</span>(o);
  }
}
this.first.front = this.front;
code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), &#x22; &#x22;, this.mapOp(this.op), &#x22; &#x22;, this.second.
compile(o, level)];
if (o.level &#x3c;= level) {
  return sn.apply(null, [this].concat(slice$.call(code)));
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose" id="apidoc.element.livescript.ast.Binary.prototype.compileCompose">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileCompose
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileCompose = function (o){
  var op, functions, x;
  op = this.op;
  functions = [this.first];
  x = this.second;
  while (x instanceof Binary &#x26;&#x26; x.op === op &#x26;&#x26; !x.partial) {
    functions.push(x.first);
    x = x.second;
  }
  functions.push(x);
  if (op === &#x27;&#x3c;&#x3c;&#x27;) {
    functions.reverse();
  }
  return sn(this, Chain(Var(util(&#x27;compose&#x27;))).add(Call(functions)).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileCompose</span>(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
case &#x27;xor&#x27;:
  return this.compileXor(o);
case &#x27;&#x26;&#x26;&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat" id="apidoc.element.livescript.ast.Binary.prototype.compileConcat">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileConcat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileConcat = function (o){
  var f;
  f = function(x){
    switch (false) {
    case !(x instanceof Binary &#x26;&#x26; x.op === &#x27;++&#x27;):
      return f(x.first).concat(f(x.second));
    default:
      return [x];
    }
  };
  return sn(null, Chain(this.first).add(CopyL(this, Index(Key(&#x27;concat&#x27;), &#x27;.&#x27;, true))).add(Call(f(this.second))).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileConcat</span>(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
case &#x27;xor&#x27;:
  return this.compileXor(o);
case &#x27;&#x26;&#x26;&#x27;:
case &#x27;||&#x27;:
  if (top = this[&#x27;void&#x27;] || !o.level) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq" id="apidoc.element.livescript.ast.Binary.prototype.compileDeepEq">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileDeepEq
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDeepEq = function (o){
  var ref$, negate, i$, len$, x, r;
  if ((ref$ = this.op) === &#x27;&#x3e;==&#x27; || ref$ === &#x27;&#x3e;&#x3e;=&#x27;) {
    ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
    this.op = this.op === &#x27;&#x3e;==&#x27; ? &#x27;&#x3c;==&#x27; : &#x27;&#x3c;&#x3c;=&#x27;;
  }
  if (this.op === &#x27;!==&#x27;) {
    this.op = &#x27;===&#x27;;
    negate = true;
  }
  for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ &#x3c; len$; ++i$) {
    x = ref$[i$];
    if (x instanceof Obj || x instanceof Arr) {
      x.deepEq = true;
    }
  }
  r = Chain(Var(util(&#x27;deepEq&#x27;))).add(Call([this.first, this.second, Literal(&#x22;&#x27;&#x22; + this.op + &#x22;&#x27;&#x22;)]));
  return sn(this, (negate ? Unary(&#x27;!&#x27;, r) : r).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;!===&#x27;:
  this.op = this.op.slice(0, 3);
  // fallthrough
case &#x27;&#x3c;==&#x27;:
case &#x27;&#x3e;==&#x27;:
case &#x27;&#x3c;&#x3c;=&#x27;:
case &#x27;&#x3e;&#x3e;=&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileDeepEq</span>(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
      return it.isRegex();
    })) {
      return this.compileRegexEquals(o, that);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence" id="apidoc.element.livescript.ast.Binary.prototype.compileExistence">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileExistence
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExistence = function (o){
  var x;
  if (this[&#x27;void&#x27;] || !o.level) {
    x = Binary(&#x27;&#x26;&#x26;&#x27;, Existence(this.first, true), this.second);
    return (x[&#x27;void&#x27;] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Binary.prototype.compileNode = function(o){
var top, rite, items, that, ref$, code, level, this$ = this;
if (this.partial) {
  return this.compilePartial(o);
}
switch (this.op) {
case &#x27;?&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileExistence</span>(o);
case &#x27;*&#x27;:
  if (this.second.isString()) {
    return this.compileJoin(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin" id="apidoc.element.livescript.ast.Binary.prototype.compileJoin">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileJoin
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileJoin = function (it){
  return this.compileMethod(it, &#x27;Array&#x27;, &#x27;join&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.compilePartial(o);
}
switch (this.op) {
case &#x27;?&#x27;:
  return this.compileExistence(o);
case &#x27;*&#x27;:
  if (this.second.isString()) {
    return this.<span class="apidocCodeKeywordSpan">compileJoin</span>(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
  break;
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod" id="apidoc.element.livescript.ast.Binary.prototype.compileMethod">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMethod
        <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMethod = function (o, klass, method, arg){
  var args;
  args = [this.second].concat(arg || []);
  if (this.first[&#x22;is&#x22; + klass]()) {
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + &#x27;.call&#x27;), args).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + &#x27;.call&#x27;), args).compile(o));
  }
};
Binary.prototype.compileJoin = function(it){
  return this.<span class="apidocCodeKeywordSpan">compileMethod</span>(it, &#x27;Array&#x27;, &#x27;join&#x27;);
};
Binary.prototype.compileRemove = function(it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;replace&#x27;, JS(&#x22;&#x27;&#x27;&#x22;));
};
Binary.prototype.compileSplit = function(it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;split&#x27;);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax" id="apidoc.element.livescript.ast.Binary.prototype.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMinMax
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMinMax = function (o){
  var lefts, rites, x;
  lefts = this.first.cache(o, true);
  rites = this.second.cache(o, true);
  x = Binary(this.op.charAt(), lefts[0], rites[0]);
  return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileMinMax</span>(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMod" id="apidoc.element.livescript.ast.Binary.prototype.compileMod">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMod
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMod = function (o){
  var ref, code;
  ref = o.scope.temporary();
  code = [sn(this, &#x22;(((&#x22;), this.first.compile(o), sn(this, &#x22;) % (&#x22;), sn(this, ref, &#x22; = &#x22;), this.second.compile(o), sn(this, &#x22;) + &#x22;,
ref, &#x22;) % &#x22;, ref, &#x22;)&#x22;)];
  o.scope.free(ref);
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileMod</span>(o);
case &#x27;xor&#x27;:
  return this.compileXor(o);
case &#x27;&#x26;&#x26;&#x27;:
case &#x27;||&#x27;:
  if (top = this[&#x27;void&#x27;] || !o.level) {
    this.second[&#x27;void&#x27;] = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileNode" id="apidoc.element.livescript.ast.Binary.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.compilePartial(o);
  }
  switch (this.op) {
  case &#x27;?&#x27;:
    return this.compileExistence(o);
  case &#x27;*&#x27;:
    if (this.second.isString()) {
      return this.compileJoin(o);
    }
    if (this.first.isString() || this.first.isArray()) {
      return this.compileRepeat(o);
    }
    break;
  case &#x27;-&#x27;:
    if (this.second.isMatcher()) {
      return this.compileRemove(o);
    }
    break;
  case &#x27;/&#x27;:
    if (this.second.isMatcher()) {
      return this.compileSplit(o);
    }
    break;
  case &#x27;**&#x27;:
  case &#x27;^&#x27;:
    return this.compilePow(o);
  case &#x27;&#x3c;?&#x27;:
  case &#x27;&#x3e;?&#x27;:
    return this.compileMinMax(o);
  case &#x27;&#x3c;&#x3c;&#x27;:
  case &#x27;&#x3e;&#x3e;&#x27;:
    return this.compileCompose(o);
  case &#x27;++&#x27;:
    return this.compileConcat(o);
  case &#x27;%%&#x27;:
    return this.compileMod(o);
  case &#x27;xor&#x27;:
    return this.compileXor(o);
  case &#x27;&#x26;&#x26;&#x27;:
  case &#x27;||&#x27;:
    if (top = this[&#x27;void&#x27;] || !o.level) {
      this.second[&#x27;void&#x27;] = true;
    }
    if (top || this.cond) {
      this.first.cond = true;
      this.second.cond = true;
    }
    break;
  case &#x27;instanceof&#x27;:
    rite = this.second.expandSlice(o).unwrap(), items = rite.items;
    if (rite instanceof Arr) {
      if (items[1]) {
        return this.compileAnyInstanceOf(o, items);
      }
      this.second = items[0] || rite;
    }
    this.second.isCallable() || this.second.carp(&#x27;invalid instanceof operand&#x27;);
    break;
  case &#x27;====&#x27;:
  case &#x27;!===&#x27;:
    this.op = this.op.slice(0, 3);
    // fallthrough
  case &#x27;&#x3c;==&#x27;:
  case &#x27;&#x3e;==&#x27;:
  case &#x27;&#x3c;&#x3c;=&#x27;:
  case &#x27;&#x3e;&#x3e;=&#x27;:
    return this.compileDeepEq(o);
  default:
    if (COMPARER.test(this.op)) {
      if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
        return it.isRegex();
      })) {
        return this.compileRegexEquals(o, that);
      }
      if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26;&#x26; this.first.isWhat() !== this
.second.isWhat()) {
        if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
          console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#x22; == &#x22; +
this.second.value);
        }
      }
    }
    if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), &#x22; &#x22;, this.mapOp(this.op), &#x22; &#x22;, this.second.compile(o, level)];
  if (o.level &#x3c;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial" id="apidoc.element.livescript.ast.Binary.prototype.compilePartial">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePartial
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePartial = function (o){
  var vit, x, y;
  vit = Var(&#x27;it&#x27;);
  switch (false) {
  case !(this.first == null &#x26;&#x26; this.second == null):
    x = Var(&#x27;x$&#x27;);
    y = Var(&#x27;y$&#x27;);
    return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));
  case this.first == null:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), &#x22;)&#x22;);
  default:
    return sn(this, &#x22;(&#x22;, Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
};
Binary.prototype.compileNode = function(o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.<span class="apidocCodeKeywordSpan">compilePartial</span>(o);
  }
  switch (this.op) {
  case &#x27;?&#x27;:
    return this.compileExistence(o);
  case &#x27;*&#x27;:
    if (this.second.isString()) {
      return this.compileJoin(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePow" id="apidoc.element.livescript.ast.Binary.prototype.compilePow">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePow
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePow = function (o){
  return sn(null, Call.make(CopyL(this, JS(&#x27;Math.pow&#x27;)), [this.first, this.second]).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;/&#x27;:
  if (this.second.isMatcher()) {
    return this.compileSplit(o);
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compilePow</span>(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
  return this.compileMinMax(o);
case &#x27;&#x3c;&#x3c;&#x27;:
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals" id="apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRegexEquals
        <span class="apidocSignatureSpan">(o, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRegexEquals = function (o, arg$){
  var regex, target, method;
  regex = arg$[0], target = arg$[1];
  if (this.op === &#x27;===&#x27;) {
    method = this.wasInverted ? &#x27;test&#x27; : &#x27;exec&#x27;;
    return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
  } else {
    return sn(this, Unary(&#x27;!&#x27;, Chain(regex).add(Index(Key(&#x27;test&#x27;))).add(Call([target]))).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3e;&#x3e;=&#x27;:
  return this.compileDeepEq(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
      return it.isRegex();
    })) {
      return this.<span class="apidocCodeKeywordSpan">compileRegexEquals</span>(o, that);
    }
    if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
        console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#
x22; == &#x22; + this.second.value);
      }
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove" id="apidoc.element.livescript.ast.Binary.prototype.compileRemove">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRemove
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRemove = function (it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;replace&#x27;, JS(&#x22;&#x27;&#x27;&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
  break;
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
    return this.<span class="apidocCodeKeywordSpan">compileRemove</span>(o);
  }
  break;
case &#x27;/&#x27;:
  if (this.second.isMatcher()) {
    return this.compileSplit(o);
  }
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat" id="apidoc.element.livescript.ast.Binary.prototype.compileRepeat">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRepeat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRepeat = function (o){
  var x, n, items, arr, arrCode, refs, i$, len$, i, item, ref$, q;
  x = this.first, n = this.second;
  items = (x = x.expandSlice(o).unwrap()).items;
  arr = x.isArray() &#x26;&#x26; &#x27;Array&#x27;;
  if (items &#x26;&#x26; !snEmpty(arrCode = Splat.compileArray(o, items))) {
    x = JS(arrCode);
    items = null;
  }
  if (arr &#x26;&#x26; !items || !(n instanceof Literal &#x26;&#x26; n.value &#x3c; 0x20)) {
    return sn(this, Call.make(Util(&#x27;repeat&#x27; + (arr || &#x27;String&#x27;)), [x, n]).compile(o));
  }
  n = +n.value;
  if (1 &#x3c;= n &#x26;&#x26; n &#x3c; 2) {
    return sn(this, x.compile(o));
  }
  if (items) {
    if (n &#x3c; 1) {
      return sn(this, Block(items).add(JS(&#x27;[]&#x27;)).compile(o));
    }
    refs = [];
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      item = items[i$];
      ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
    }
    items.push((ref$ = JS(), ref$.compile = function(){
      return sn.apply(null, [this].concat(slice$.call((repeatArray$([&#x22;, &#x22;, List.compile(o, refs)], n - 1)).slice(1))));
    }, ref$));
    return sn(this, x.compile(o));
  } else if (x instanceof Literal) {
    return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + &#x22;&#x22;, n) + q);
  } else {
    if (n &#x3c; 1) {
      return sn(this, Block(x.it).add(JS(&#x22;&#x27;&#x27;&#x22;)).compile(o));
    }
    x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(&#x22; + &#x22; + refs[1], n - 1);
    if (o.level &#x3c; LEVEL_OP + PREC[&#x27;+&#x27;]) {
      return sn(this, x);
    } else {
      return sn(this, &#x22;(&#x22;, x, &#x22;)&#x22;);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;?&#x27;:
  return this.compileExistence(o);
case &#x27;*&#x27;:
  if (this.second.isString()) {
    return this.compileJoin(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.<span class="apidocCodeKeywordSpan">compileRepeat</span>(o);
  }
  break;
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
    return this.compileRemove(o);
  }
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit" id="apidoc.element.livescript.ast.Binary.prototype.compileSplit">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileSplit
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSplit = function (it){
  return this.compileMethod(it, &#x27;String&#x27;, &#x27;split&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;-&#x27;:
  if (this.second.isMatcher()) {
    return this.compileRemove(o);
  }
  break;
case &#x27;/&#x27;:
  if (this.second.isMatcher()) {
    return this.<span class="apidocCodeKeywordSpan">compileSplit</span>(o);
  }
  break;
case &#x27;**&#x27;:
case &#x27;^&#x27;:
  return this.compilePow(o);
case &#x27;&#x3c;?&#x27;:
case &#x27;&#x3e;?&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileXor" id="apidoc.element.livescript.ast.Binary.prototype.compileXor">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileXor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileXor = function (o){
  var left, right;
  left = Chain(this.first).cacheReference(o);
  right = Chain(this.second).cacheReference(o);
  return sn(this, Binary(&#x27;&#x26;&#x26;&#x27;, Binary(&#x27;!==&#x27;, Unary(&#x27;!&#x27;, left[0]), Unary(&#x27;!&#x27;, right[0])), Parens(Binary(&#x27;||&#x27;, left[1], right[1]))).
compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3e;&#x3e;&#x27;:
  return this.compileCompose(o);
case &#x27;++&#x27;:
  return this.compileConcat(o);
case &#x27;%%&#x27;:
  return this.compileMod(o);
case &#x27;xor&#x27;:
  return this.<span class="apidocCodeKeywordSpan">compileXor</span>(o);
case &#x27;&#x26;&#x26;&#x27;:
case &#x27;||&#x27;:
  if (top = this[&#x27;void&#x27;] || !o.level) {
    this.second[&#x27;void&#x27;] = true;
  }
  if (top || this.cond) {
    this.first.cond = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.constructor" id="apidoc.element.livescript.ast.Binary.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>constructor
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === &#x27;String&#x27;) {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== &#x27;=&#x27;:
        return &#x27;?&#x27;;
      default:
        return &#x27;=&#x27;;
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if (&#x27;=&#x27; === op.charAt(op.length - 1) &#x26;&#x26; ((ref$ = op.charAt(op.length - 2)) !== &#x27;=&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3c;&#x27; &#x26;&#x26; ref$ !== &#x27;&#x3e;&#x27; &#x26;&#x26; ref$ !== &#x27;!&#x27;)) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case &#x27;in&#x27;:
      return new In(first, second);
    case &#x27;with&#x27;:
      return new Import(Unary(&#x27;^^&#x27;, first), second, false);
    case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
    case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
      return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
    case &#x27;&#x3c;|&#x27;:
      return Block(first).pipe(second, op);
    case &#x27;|&#x3e;&#x27;:
      return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
    case &#x27;.&#x27;:
    case &#x27;.~&#x27;:
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.getDefault" id="apidoc.element.livescript.ast.Binary.prototype.getDefault">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>getDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefault = function (){
  switch (this.op) {
  case &#x27;?&#x27;:
  case &#x27;||&#x27;:
  case &#x27;&#x26;&#x26;&#x27;:
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
} else {
  if (logic = node.<span class="apidocCodeKeywordSpan">getDefault</span>()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
      ref$ = [node, key], key = ref$[0], node = ref$[1];
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invert" id="apidoc.element.livescript.ast.Binary.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  var that;
  if (that = !COMPARER.test(this.second.op) &#x26;&#x26; INVERSIONS[this.op]) {
    this.op = that;
    this.wasInverted = true;
    return this;
  }
  return Unary(&#x27;!&#x27;, Parens(this), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invertIt" id="apidoc.element.livescript.ast.Binary.prototype.invertIt">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invertIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invertIt = function (){
  this.inverted = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Chain(L(2, Binary($2)));
}), o(&#x27;( BIOP Expression )&#x27;, function(){
  return Chain(L(2, Binary($2, void 8, $3)));
}), o(&#x27;( Expression BIOP )&#x27;, function(){
  return Chain(L(3, Binary($3, $2)));
}), o(&#x27;( BIOPR )&#x27;, function(){
  return Chain(L(2, &#x27;!&#x27; === $2.charAt(0)
    ? Binary($2.slice(1)).<span class="apidocCodeKeywordSpan">invertIt</span>()
    : Binary($2)));
}), o(&#x27;( BIOPR Expression )&#x27;, function(){
  return Chain(L(2, &#x27;!&#x27; === $2.charAt(0)
    ? Binary($2.slice(1), void 8, $3).invertIt()
    : Binary($2, void 8, $3)));
}), o(&#x27;( Expression BIOPR )&#x27;, function(){
  return Chain(L(3, &#x27;!&#x27; === $3.charAt(0)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isArray" id="apidoc.element.livescript.ast.Binary.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  switch (this.op) {
  case &#x27;*&#x27;:
    return this.first.isArray();
  case &#x27;/&#x27;:
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isCallable" id="apidoc.element.livescript.ast.Binary.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return this.partial || ((ref$ = this.op) === &#x27;&#x26;&#x26;&#x27; || ref$ === &#x27;||&#x27; || ref$ === &#x27;?&#x27; || ref$ === &#x27;&#x3c;&#x3c;&#x27; || ref$ === &#x27;&#x3e;&#x3e;&#x27;) &#x26;&#x26; this.
first.isCallable() &#x26;&#x26; this.second.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isString" id="apidoc.element.livescript.ast.Binary.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  switch (this.op) {
  case &#x27;+&#x27;:
  case &#x27;*&#x27;:
    return this.first.isString() || this.second.isString();
  case &#x27;-&#x27;:
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.mapOp" id="apidoc.element.livescript.ast.Binary.prototype.mapOp">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>mapOp
        <span class="apidocSignatureSpan">(op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapOp = function (op){
  var that;
  switch (false) {
  case !(that = op.match(/\.([&#x26;\|\^]|&#x3c;&#x3c;|&#x3e;&#x3e;&#x3e;?)\./)):
    return that[1];
  case op !== &#x27;of&#x27;:
    return &#x27;in&#x27;;
  default:
    return op;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
    if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), &#x22; &#x22;, this.<span class="apidocCodeKeywordSpan">mapOp
</span>(this.op), &#x22; &#x22;, this.second.compile(o, level)];
  if (o.level &#x3c;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
};
Binary.prototype.mapOp = function(op){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.show" id="apidoc.element.livescript.ast.Binary.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren" id="apidoc.element.livescript.ast.Binary.prototype.xorChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>xorChildren
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xorChildren = function (test){
  var ref$, ref1$, first;
  if (!(!(ref$ = first = test(this.first)) !== !(ref1$ = test(this.second)) &#x26;&#x26; (ref$ || ref1$))) {
    return false;
  }
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;&#x3c;==&#x27;:
case &#x27;&#x3e;==&#x27;:
case &#x27;&#x3c;&#x3c;=&#x27;:
case &#x27;&#x3e;&#x3e;=&#x27;:
  return this.compileDeepEq(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.<span class="apidocCodeKeywordSpan
">xorChildren</span>(function(it){
      return it.isRegex();
    })) {
      return this.compileRegexEquals(o, that);
    }
    if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
        console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#
x22; == &#x22; + this.second.value);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block" id="apidoc.module.livescript.ast.Block">module livescript.ast.Block</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.Block" id="apidoc.element.livescript.ast.Block.Block">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Block
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if (&#x27;length&#x27; in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Block</span>());
break;
case 62:
this.$ = yy.L(_$[$0], _$[$0],yy.Block($$[$0]));
break;
case 63: case 172:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.superclass" id="apidoc.element.livescript.ast.Block.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Block.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype" id="apidoc.module.livescript.ast.Block.prototype">module livescript.ast.Block.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.add" id="apidoc.element.livescript.ast.Block.prototype.add">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (it){
  var that, ref$;
  it = it.unparen();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
  default:
    this.lines.push(it);
    if (that = (ref$ = it.back, delete it.back, ref$)) {
      this.back = that;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  items = this instanceof Arr
    ? (this.items[0] == null || this.items[1] == null &#x26;&#x26; this.carp(&#x27;must specify both key and value for object comprehension
&#x27;), this.items)
    : (kv = &#x27;keyValue$&#x27;, (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &#x3c; len$; ++i$) {
        i = i$;
        v = ref$[i$];
        results$.push(Chain(v).<span class="apidocCodeKeywordSpan">add</span>(Index(Literal(i))));
      }
      return results$;
    }.call(this)));
  return Assign(Chain(Var(ref)).add(Index(items[0], &#x27;.&#x27;, true)), items[1]);
} else if (ref) {
  return Call.make(JS(ref + &#x27;.push&#x27;), [this]);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.chomp" id="apidoc.element.livescript.ast.Block.prototype.chomp">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>chomp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chomp = function (){
  var lines, i, that;
  lines = this.lines;
  i = lines.length;
  while (that = lines[--i]) {
    if (!that.comment) {
      break;
    }
  }
  lines.length = i + 1;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (that = node.getJump(it)) {
      return that;
    }
  }
};
Block.prototype.makeReturn = function(){
  var that, ref$, key$, ref1$;
  this.<span class="apidocCodeKeywordSpan">chomp</span>();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &#x26;&#x26; !that.it) {
      --this.lines.length;
    }
  }
  return this;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compile" id="apidoc.element.livescript.ast.Block.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &#x26;&#x26; (level = o.level);
  if (level) {
    return this.compileExpressions(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
    if (snEmpty(code = (node.front = true, node).compile(o, level))) {
      continue;
    }
    codes.push(tab);
    codes.push(code);
    node.isStatement() || codes.push(node.terminator);
    codes.push(&#x27;\n&#x27;);
  }
  codes.pop();
  return sn.apply(null, [null].concat(slice$.call(codes)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions" id="apidoc.element.livescript.ast.Block.prototype.compileExpressions">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileExpressions
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExpressions = function (o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
      lines.splice(i--, 1);
    }
  }
  if (!lines.length) {
    lines.push(Literal(&#x27;void&#x27;));
  }
  lines[0].front = this.front;
  lines[lines.length - 1][&#x27;void&#x27;] = this[&#x27;void&#x27;];
  if (!lines[1]) {
    return lines[0].compile(o, level);
  }
  code = [];
  last = lines.pop();
  for (i$ = 0, len$ = lines.length; i$ &#x3c; len$; ++i$) {
    node = lines[i$];
    code.push((node[&#x27;void&#x27;] = true, node).compile(o, LEVEL_PAREN), &#x27;, &#x27;);
  }
  code.push(last.compile(o, LEVEL_PAREN));
  if (level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return this;
};
Block.prototype.compile = function(o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &#x26;&#x26; (level = o.level);
  if (level) {
    return this.<span class="apidocCodeKeywordSpan">compileExpressions</span>(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileRoot" id="apidoc.element.livescript.ast.Block.prototype.compileRoot">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileRoot
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRoot = function (options){
  var o, that, ref$, bare, prefix, ref1$, code, result;
  o = (import$({
    level: LEVEL_TOP,
    scope: this.scope = Scope.root = new Scope
  }, options));
  if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
    this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
  }
  delete o.filename;
  o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? &#x27;&#x27; : TAB;
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }))();
  return JSON.stringify(result, null, 2) + &#x22;\n&#x22;;
} else {
  ast = parser.parse(lexer.lex(code));
  if (options.run &#x26;&#x26; options.print) {
    ast.makeReturn();
  }
  output = ast.<span class="apidocCodeKeywordSpan">compileRoot</span>(options);
  if (options.header) {
    output = new SourceNode(null, null, null, [&#x22;// Generated by LiveScript &#x22; + exports.VERSION + &#x22;\n&#x22;, output
]);
  }
  if (options.map &#x26;&#x26; options.map !== &#x27;none&#x27;) {
    filename = options.filename, outputFilename = options.outputFilename;
    if (!filename) {
      filename = &#x22;unnamed-&#x22; + Math.floor(Math.random() * 4294967296).toString(16) + &#x22;.ls&#x22;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations" id="apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileWithDeclarations
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileWithDeclarations = function (o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
  if (i = this.neck()) {
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), &#x22;\n&#x22;];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.emit(post, o.indent) : post]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.<span class="apidocCodeKeywordSpan">compileWithDeclarations</span>(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.constructor" id="apidoc.element.livescript.ast.Block.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>constructor
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if (&#x27;length&#x27; in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.getJump" id="apidoc.element.livescript.ast.Block.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var i$, ref$, len$, node, that;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (that = node.getJump(it)) {
      return that;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isArray" id="apidoc.element.livescript.ast.Block.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isCallable" id="apidoc.element.livescript.ast.Block.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isComplex" id="apidoc.element.livescript.ast.Block.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  var ref$;
  return this.lines.length &#x3e; 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isRegex" id="apidoc.element.livescript.ast.Block.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isString" id="apidoc.element.livescript.ast.Block.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.makeReturn" id="apidoc.element.livescript.ast.Block.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var that, ref$, key$, ref1$;
  this.chomp();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &#x26;&#x26; !that.it) {
      --this.lines.length;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.neck" id="apidoc.element.livescript.ast.Block.prototype.neck">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>neck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neck = function (){
  var pos, i$, ref$, len$, x;
  pos = 0;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &#x3c; len$; ++i$) {
    x = ref$[i$];
    if (!(x.comment || x instanceof Literal)) {
      break;
    }
    ++pos;
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.back = that;
    }
  }
  return this;
};
Block.prototype.prepend = function(){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.<span class="apidocCodeKeywordSpan">neck</span>(), 0].concat(slice$.call(arguments
)));
  return this;
};
Block.prototype.pipe = function(target, type){
  var args;
  args = type === &#x27;|&#x3e;&#x27; ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== &#x27;Array&#x27;) {
    args = [args];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.pipe" id="apidoc.element.livescript.ast.Block.prototype.pipe">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>pipe
        <span class="apidocSignatureSpan">(target, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (target, type){
  var args;
  args = type === &#x27;|&#x3e;&#x27; ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== &#x27;Array&#x27;) {
    args = [args];
  }
  switch (type) {
  case &#x27;|&#x3e;&#x27;:
    this.lines.push(Call.make(target, args, {
      pipe: true
    }));
    break;
  case &#x27;&#x3c;|&#x27;:
    this.lines.push(Call.make(this.lines.pop(), args));
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new In(first, second);
  case &#x27;with&#x27;:
    return new Import(Unary(&#x27;^^&#x27;, first), second, false);
  case &#x27;&#x3c;&#x3c;&#x3c;&#x27;:
  case &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;:
    return Import(first, second, op === &#x27;&#x3c;&#x3c;&#x3c;&#x3c;&#x27;);
  case &#x27;&#x3c;|&#x27;:
    return Block(first).<span class="apidocCodeKeywordSpan">pipe</span>(second, op);
  case &#x27;|&#x3e;&#x27;:
    return Block(second).pipe(first, &#x27;&#x3c;|&#x27;);
  case &#x27;.&#x27;:
  case &#x27;.~&#x27;:
    return Chain(first).add(Index(second, op));
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.prepend" id="apidoc.element.livescript.ast.Block.prototype.prepend">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>prepend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(slice$.call(arguments)));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    args[args.length] = that[i$];
    res$.push(Import(proto, JS(&#x22;arguments[&#x22; + (args.length - 1) + &#x22;]&#x22;), true));
  }
  imports = res$;
  body.prepend.apply(body, imports);
}
if (fun.cname &#x26;&#x26; !this.sup) {
  body.<span class="apidocCodeKeywordSpan">prepend</span>(Literal(name + &#x22;.displayName = &#x27;&#x22; + name + &#x22;&#x27;&#
x22;));
}
clas = Parens(Call.make(fun, args), true);
if (decl &#x26;&#x26; title.isComplex()) {
  clas = Assign(vname, clas);
}
if (title) {
  clas = Assign(title, clas);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.toJSON" id="apidoc.element.livescript.ast.Block.prototype.toJSON">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.unwrap" id="apidoc.element.livescript.ast.Block.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (){
  if (this.lines.length === 1) {
    return this.lines[0];
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Call" id="apidoc.module.livescript.ast.Call">module livescript.ast.Call</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Call.Call" id="apidoc.element.livescript.ast.Call.Call">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Call
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &#x26;&#x26; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = &#x27;.call&#x27;;
      args[0] = Literal(&#x27;this&#x27;);
      args[1] = Splat(Literal(&#x27;arguments&#x27;));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === &#x27;_&#x27;) {
        args[i] = Chain(Literal(&#x27;void&#x27;));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.<span class="apidocCodeKeywordSpan">Call</span>($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call[&#x27;let&#x27;]($$[$0-3], $$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.back" id="apidoc.element.livescript.ast.Call.back">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>back
        <span class="apidocSignatureSpan">(params, node, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">back = function (params, node, bound, curried, hushed, generator){
  var fun, ref$, args, index, i$, len$, a;
  fun = Fun(params, void 8, bound, curried, hushed, generator);
  if (node instanceof Label) {
    fun.name = node.label;
    fun.labeled = true;
    node = node.it;
  }
  if (!fun.hushed &#x26;&#x26; (fun.hushed = node.op === &#x27;!&#x27;)) {
    node = node.it;
  }
  if ((ref$ = node.getCall()) != null) {
    ref$.partialized = null;
  }
  args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
  index = 0;
  for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
    a = args[i$];
    if (a.placeholder) {
      break;
    }
    ++index;
  }
  return node.back = (args[index] = fun).body, node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return $1.add($3);
  }), o(&#x27;Lines NEWLINE&#x27;)
],
Line: [
  o(&#x27;Expression&#x27;), o(&#x27;Expression Block&#x27;, function(){
    return Cascade($1, $2, &#x27;cascade&#x27;);
  }), o(&#x27;PARAM( ArgList OptComma )PARAM &#x3c;- Expression&#x27;, function(){
    return Call.<span class="apidocCodeKeywordSpan">back</span>($2, $6, /~/.test($5), /--|~~/.test($5), /!/.test($5), /\*/.test($
5));
  }), o(&#x27;COMMENT&#x27;, function(){
    return JS($1, true, true);
  }), o(&#x27;...&#x27;, function(){
    return Throw(L(1, JS(&#x22;Error(&#x27;unimplemented&#x27;)&#x22;)));
  }), o(&#x27;REQUIRE Chain&#x27;, function(){
    return Require($2.unwrap());
  })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.block" id="apidoc.element.livescript.ast.Call.block">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>block
        <span class="apidocSignatureSpan">(fun, args, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function (fun, args, method){
  var ref$, ref1$;
  return ref$ = Parens(Chain(fun, [(ref1$ = Call(args), ref1$.method = method, ref1$)]), true), ref$.calling = true, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      res$.push(a.left);
    } else {
      res$.push(Var(a.varName() || a.carp(&#x27;invalid &#x22;let&#x22; argument&#x27;)));
    }
  }
  params = res$;
  gotThis || args.unshift(Literal(&#x27;this&#x27;));
  return this.<span class="apidocCodeKeywordSpan">block</span>(Fun(params, body, null, null, null, generator), args, &#x27;.call
&#x27;);
};
return Call;
}(Node));
List = (function(superclass){
var prototype = extend$((import$(List, superclass).displayName = &#x27;List&#x27;, List), superclass).prototype, constructor = List
;
List.prototype.children = [&#x27;items&#x27;];
List.prototype.show = function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.let" id="apidoc.element.livescript.ast.Call.let">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>let
        <span class="apidocSignatureSpan">(args, body, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">let = function (args, body, generator){
  var params, res$, i$, len$, i, a, that, gotThis;
  generator == null &#x26;&#x26; (generator = false);
  res$ = [];
  for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    a = args[i$];
    if (that = a.op === &#x27;=&#x27; &#x26;&#x26; !a.logic &#x26;&#x26; a.right) {
      args[i] = that;
      if (i === 0 &#x26;&#x26; (gotThis = a.left.value === &#x27;this&#x27;)) {
        continue;
      }
      res$.push(a.left);
    } else {
      res$.push(Var(a.varName() || a.carp(&#x27;invalid &#x22;let&#x22; argument&#x27;)));
    }
  }
  params = res$;
  gotThis || args.unshift(Literal(&#x27;this&#x27;));
  return this.block(Fun(params, body, null, null, null, generator), args, &#x27;.call&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.make" id="apidoc.element.livescript.ast.Call.make">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>make
        <span class="apidocSignatureSpan">(callee, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make = function (callee, args, opts){
  var call;
  call = Call(args);
  if (opts) {
    import$(call, opts);
  }
  return Chain(callee).add(call);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          v = ref$[i$];
          results$.push(Chain(v).add(Index(Literal(i))));
        }
        return results$;
      }.call(this)));
    return Assign(Chain(Var(ref)).add(Index(items[0], &#x27;.&#x27;, true)), items[1]);
  } else if (ref) {
    return Call.<span class="apidocCodeKeywordSpan">make</span>(JS(ref + &#x27;.push&#x27;), [this]);
  } else {
    return Return(this);
  }
},
show: String,
toString: function(idt){
  var tree, that;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.superclass" id="apidoc.element.livescript.ast.Call.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Call.prototype" id="apidoc.module.livescript.ast.Call.prototype">module livescript.ast.Call.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.compile" id="apidoc.element.livescript.ast.Call.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var code, i$, ref$, len$, i, a;
  code = [sn(this, this.method || &#x27;&#x27;, &#x27;(&#x27;) + (this.pipe ? &#x22;\n&#x22; + o.indent : &#x27;&#x27;)];
  for (i$ = 0, len$ = (ref$ = this.args).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    a = ref$[i$];
    code.push(i ? &#x27;, &#x27; : &#x27;&#x27;, a.compile(o, LEVEL_LIST));
  }
  code.push(sn(this, &#x27;)&#x27;));
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.constructor" id="apidoc.element.livescript.ast.Call.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>constructor
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &#x26;&#x26; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = &#x27;.call&#x27;;
      args[0] = Literal(&#x27;this&#x27;);
      args[1] = Splat(Literal(&#x27;arguments&#x27;));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === &#x27;_&#x27;) {
        args[i] = Chain(Literal(&#x27;void&#x27;));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.show" id="apidoc.element.livescript.ast.Call.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this[&#x27;new&#x27;]] + [this.method] + [this.soak ? &#x27;?&#x27; : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade" id="apidoc.module.livescript.ast.Cascade">module livescript.ast.Cascade</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.Cascade" id="apidoc.element.livescript.ast.Cascade.Cascade">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 40:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], yy.Slice({
type: $$[$0-1],
target: $$[$0-4]
      }))));
break;
case 41:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], yy.<span class="apidocCodeKeywordSpan">Cascade</span>($$[$0-1], $$[$
0], &#x27;with&#x27;))));
break;
case 42:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({
kind: $$[$0-2],
source: $$[$0-1],
body: $$[$0],
ref: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.superclass" id="apidoc.element.livescript.ast.Cascade.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype" id="apidoc.module.livescript.ast.Cascade.prototype">module livescript.ast.Cascade.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode" id="apidoc.element.livescript.ast.Cascade.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var level, input, output, prog1, ref, ref$, code, out;
  level = o.level;
  input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
  if (prog1 &#x26;&#x26; (&#x27;ret&#x27; in this || level &#x26;&#x26; !this[&#x27;void&#x27;])) {
    output.add((ref$ = Literal(&#x27;..&#x27;), ref$.cascadee = true, ref$));
  }
  if (&#x27;ret&#x27; in this) {
    output = output.makeReturn(this.ret);
  }
  if (ref) {
    prog1 || (output = Assign(Var(ref), output));
  } else {
    ref = o.scope.temporary(&#x27;x&#x27;);
  }
  if (input instanceof Cascade) {
    input.ref = ref;
  } else {
    input &#x26;&#x26; (input = Assign(Var(ref), input));
  }
  o.level &#x26;&#x26; (o.level = LEVEL_PAREN);
  code = [input.compile(o)];
  out = Block(output).compile((o.ref = new String(ref), o));
  if (prog1 === &#x27;cascade&#x27; &#x26;&#x26; !o.ref.erred) {
    this.carp(&#x22;unreferred cascadee&#x22;);
  }
  if (!level) {
    return sn.apply(null, [null].concat(slice$.call(code), [input.terminator, &#x22;\n&#x22;, out]));
  }
  code.push(&#x22;, &#x22;, out);
  if (level &#x3e; LEVEL_PAREN) {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.constructor" id="apidoc.element.livescript.ast.Cascade.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>constructor
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.getJump" id="apidoc.element.livescript.ast.Cascade.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  return this.output.getJump(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isArray" id="apidoc.element.livescript.ast.Cascade.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable" id="apidoc.element.livescript.ast.Cascade.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex" id="apidoc.element.livescript.ast.Cascade.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isString" id="apidoc.element.livescript.ast.Cascade.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn" id="apidoc.element.livescript.ast.Cascade.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(ret)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (ret){
  this.ret = ret;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.show" id="apidoc.element.livescript.ast.Cascade.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.prog1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case" id="apidoc.module.livescript.ast.Case">module livescript.ast.Case</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.Case" id="apidoc.element.livescript.ast.Case.Case">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Case
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 201:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-4], $$[$0-5] === &#x27;until&#x27;, $$[$0-2]).addGuard($$[$0]));
break;
case 203:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].concat($$[$0]));
break;
case 206:
this.$ = yy.L(_$[$0-2], _$[$0],[yy.L(_$[$0-2],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">Case</span>($$[$0-1], $$[$0]))]);
break;
case 207:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat(yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))));
break;
case 212:
return this.$
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.superclass" id="apidoc.element.livescript.ast.Case.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Case.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case.prototype" id="apidoc.module.livescript.ast.Case.prototype">module livescript.ast.Case.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.compileCase" id="apidoc.element.livescript.ast.Case.prototype.compileCase">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>compileCase
        <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileCase = function (o, tab, nobr, bool, type, target){
  var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
  tests = [];
  for (i$ = 0, len$ = (ref$ = this.tests).length; i$ &#x3c; len$; ++i$) {
    test = ref$[i$];
    test = test.expandSlice(o).unwrap();
    if (test instanceof Arr &#x26;&#x26; type !== &#x27;match&#x27;) {
      for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ &#x3c; len1$; ++j$) {
        t = ref1$[j$];
        tests.push(t);
      }
    } else {
      tests.push(test);
    }
  }
  tests.length || tests.push(Literal(&#x27;void&#x27;));
  if (type === &#x27;match&#x27;) {
    for (i$ = 0, len$ = tests.length; i$ &#x3c; len$; ++i$) {
      i = i$;
      test = tests[i$];
      tar = Chain(target).add(Index(Literal(i), &#x27;.&#x27;, true));
      tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
    }
  }
  if (bool) {
    binary = type === &#x27;match&#x27; ? &#x27;&#x26;&#x26;&#x27; : &#x27;||&#x27;;
    t = tests[0];
    i = 0;
    while (that = tests[++i]) {
      t = Binary(binary, t, that);
    }
    tests = [(this.t = t, this.aSource = &#x27;t&#x27;, this.aTargets = [&#x27;body&#x27;], this).anaphorize().invert()];
  }
  code = [];
  for (i$ = 0, len$ = tests.length; i$ &#x3c; len$; ++i$) {
    t = tests[i$];
    code.push(tab, sn(t, &#x22;case &#x22;, t.compile(o, LEVEL_PAREN), &#x22;:\n&#x22;));
  }
  lines = this.body.lines;
  last = lines[lines.length - 1];
  if (ft = (last != null ? last.value : void 8) === &#x27;fallthrough&#x27;) {
    lines[lines.length - 1] = JS(&#x27;// fallthrough&#x27;);
  }
  o.indent = tab += TAB;
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(bodyCode, &#x27;\n&#x27;);
  }
  if (!(nobr || ft || last instanceof Jump)) {
    code.push(tab + &#x27;break;\n&#x27;);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  : !!this.topic &#x26;&#x26; this.anaphorize().compile(o, LEVEL_PAREN);
code = [sn(this, &#x22;switch (&#x22;, snSafe(topic), &#x22;) {\n&#x22;)];
stop = this[&#x27;default&#x27;] || this.cases.length - 1;
o[&#x27;break&#x27;] = true;
for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
  i = i$;
  c = ref$[i$];
  code.push(c.<span class="apidocCodeKeywordSpan">compileCase</span>(o, tab, i === stop, this.type === &#x27;match&#x27; || !topic
, this.type, target));
}
if (this[&#x27;default&#x27;]) {
  o.indent = tab + TAB;
  if (that = this[&#x27;default&#x27;].compile(o, LEVEL_TOP)) {
    code.push(tab + &#x22;default:\n&#x22;, that, &#x22;\n&#x22;);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.constructor" id="apidoc.element.livescript.ast.Case.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>constructor
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.isCallable" id="apidoc.element.livescript.ast.Case.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  return this.body.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.makeReturn" id="apidoc.element.livescript.ast.Case.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$, ref1$;
  if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== &#x27;fallthrough&#x27;) {
    (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain" id="apidoc.module.livescript.ast.Chain">module livescript.ast.Chain</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.Chain" id="apidoc.element.livescript.ast.Chain.Chain">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &#x26;&#x26; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Chain</span>(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.superclass" id="apidoc.element.livescript.ast.Chain.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype" id="apidoc.module.livescript.ast.Chain.prototype">module livescript.ast.Chain.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.add" id="apidoc.element.livescript.ast.Chain.prototype.add">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (it){
  var last, ref$, index, ref1$, bi, logics, call, f;
  if (this.tails.length) {
    last = (ref$ = this.tails)[ref$.length - 1];
    if (last instanceof Call &#x26;&#x26; ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 &#x26;&#x26; it.args.length === 1) {
      index = last.partialized[0].head.value;
      delete last.partialized;
      last.args[index] = it.args[0];
      return this;
    }
  }
  if (this.head instanceof Existence) {
    ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
    it.soak = true;
  }
  this.tails.push(it);
  bi = this.head instanceof Parens &#x26;&#x26; this.head.it instanceof Binary &#x26;&#x26; !this.head.it.partial
    ? this.head.it
    : this.head instanceof Binary &#x26;&#x26; !this.head.partial ? this.head : void 8;
  if (this.head instanceof Super) {
    if (!this.head.called &#x26;&#x26; it instanceof Call &#x26;&#x26; !it.method) {
      it.method = &#x27;.call&#x27;;
      it.args.unshift(Literal(&#x27;this&#x27;));
      this.head.called = true;
    } else if (!this.tails[1] &#x26;&#x26; ((ref1$ = it.key) != null ? ref1$.name : void 8) === &#x27;prototype&#x27;) {
      this.head.sproto = true;
    }
  } else if (it instanceof Call &#x26;&#x26; this.tails.length === 1 &#x26;&#x26; bi &#x26;&#x26; in$(bi.op, logics = [&#x27;&#x26;&#x26;&#x27;, &#x27;||&#x27;, &#x27;xor&#x27;])) {
    call = it;
    f = function(x, key){
      var y;
      y = x[key];
      if (y instanceof Binary &#x26;&#x26; in$(y.op, logics)) {
        f(y, &#x27;first&#x27;);
        return f(y, &#x27;second&#x27;);
      } else {
        return x[key] = Chain(y).autoCompare(call.args);
      }
    };
    f(bi, &#x27;first&#x27;);
    f(bi, &#x27;second&#x27;);
    return bi;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  items = this instanceof Arr
    ? (this.items[0] == null || this.items[1] == null &#x26;&#x26; this.carp(&#x27;must specify both key and value for object comprehension
&#x27;), this.items)
    : (kv = &#x27;keyValue$&#x27;, (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &#x3c; len$; ++i$) {
        i = i$;
        v = ref$[i$];
        results$.push(Chain(v).<span class="apidocCodeKeywordSpan">add</span>(Index(Literal(i))));
      }
      return results$;
    }.call(this)));
  return Assign(Chain(Var(ref)).add(Index(items[0], &#x27;.&#x27;, true)), items[1]);
} else if (ref) {
  return Call.make(JS(ref + &#x27;.push&#x27;), [this]);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.assigns" id="apidoc.element.livescript.ast.Chain.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare" id="apidoc.element.livescript.ast.Chain.prototype.autoCompare">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>autoCompare
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoCompare = function (target){
  var test;
  test = this.head;
  switch (false) {
  case !(test instanceof Literal):
    return Binary(&#x27;===&#x27;, test, target[0]);
  case !(test instanceof Unary &#x26;&#x26; test.it instanceof Literal):
    return Binary(&#x27;===&#x27;, test, target[0]);
  case !(test instanceof Arr || test instanceof Obj):
    return Binary(&#x27;====&#x27;, test, target[0]);
  case !(test instanceof Var &#x26;&#x26; test.value === &#x27;_&#x27;):
    return Literal(&#x27;true&#x27;);
  default:
    return this.add(Call(target)) || [];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  f = function(x, key){
    var y;
    y = x[key];
    if (y instanceof Binary &#x26;&#x26; in$(y.op, logics)) {
      f(y, &#x27;first&#x27;);
      return f(y, &#x27;second&#x27;);
    } else {
      return x[key] = Chain(y).<span class="apidocCodeKeywordSpan">autoCompare</span>(call.args);
    }
  };
  f(bi, &#x27;first&#x27;);
  f(bi, &#x27;second&#x27;);
  return bi;
}
return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference" id="apidoc.element.livescript.ast.Chain.prototype.cacheReference">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>cacheReference
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cacheReference = function (o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.unwrap().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
    base = Chain(Assign(Var(ref), base));
    bref = (ref$ = Var(ref), ref$.temp = true, ref$);
  }
  if (!name) {
    return [base, bref];
  }
  if (name.isComplex()) {
    ref = o.scope.temporary(&#x27;key&#x27;);
    name = Index(Assign(Var(ref), name.key));
    nref = Index((ref$ = Var(ref), ref$.temp = true, ref$));
  }
  return [base.add(name), Chain(bref || base.head, [nref || name])];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = ref$[i$];
if (ref1$ = node.soak, delete node.soak, ref1$) {
  bust = Chain(this.head, this.tails.splice(0, i));
  if (node.assign &#x26;&#x26; !bust.isAssignable()) {
    node.carp(&#x27;invalid accessign&#x27;);
  }
  if (i &#x26;&#x26; (node.assign || node instanceof Call)) {
    ref1$ = bust.<span class="apidocCodeKeywordSpan">cacheReference</span>(o), test = ref1$[0], bust = ref1$[1];
    if (bust instanceof Chain) {
      (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
      bust = bust.head;
    }
    this.head = bust;
  } else {
    ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.compileNode" id="apidoc.element.livescript.ast.Chain.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
  if (this.flip) {
    util(&#x27;flip&#x27;);
    util(&#x27;curry&#x27;);
  }
  head = this.head, tails = this.tails;
  head.front = this.front;
  head.newed = this.newed;
  if (!tails.length) {
    return head.compile(o);
  }
  if (that = this.unfoldAssign(o)) {
    return that.compile(o);
  }
  for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
    t = tails[i$];
    if (t.partialized) {
      hasPartial = true;
      break;
    }
  }
  if (hasPartial) {
    util(&#x27;slice&#x27;);
    pre = [];
    rest = [];
    for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
      t = tails[i$];
      broken = broken || t.partialized != null;
      if (broken) {
        rest.push(t);
      } else {
        pre.push(t);
      }
    }
    if (rest != null) {
      partial = rest[0], post = slice$.call(rest, 1);
    }
    this.tails = pre;
    context = pre.length
      ? Chain(head, slice$.call(pre, 0, -1))
      : Literal(&#x27;this&#x27;);
    return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial
.partialized)])])), post).compile(o);
  }
  if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
    this.carp(&#x27;invalid callee&#x27;);
  }
  this.expandSlice(o);
  this.expandVivify();
  this.expandBind(o);
  this.expandSplat(o);
  this.expandStar(o);
  if (this.splattedNewArgs) {
    idt = o.indent + TAB;
    func = Chain(this.head, tails.slice(0, -1));
    return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22;var child = new ctor
, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
  }
  if (!this.tails.length) {
    return this.head.compile(o);
  }
  base = [this.head.compile(o, LEVEL_CALL)];
  news = [];
  rest = [];
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    t = ref$[i$];
    if (t[&#x27;new&#x27;]) {
      news.push(&#x27;new &#x27;);
    }
    rest.push(t.compile(o));
  }
  if (&#x27;.&#x27; === rest.join(&#x22;&#x22;).charAt(0) &#x26;&#x26; SIMPLENUM.test(base[0].toString())) {
    base.push(&#x27; &#x27;);
  }
  return sn.apply(null, [null].concat(slice$.call(news), slice$.call(base), slice$.call(rest)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.constructor" id="apidoc.element.livescript.ast.Chain.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>constructor
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &#x26;&#x26; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandBind" id="apidoc.element.livescript.ast.Chain.prototype.expandBind">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandBind
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandBind = function (o){
  var tails, i, that, obj, key, call;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.symbol !== &#x27;.~&#x27;) {
      continue;
    }
    that.symbol = &#x27;&#x27;;
    obj = Chain(this.head, tails.splice(0, i)).unwrap();
    key = tails.shift().key;
    call = Call.make(Util(&#x27;bind&#x27;), [obj, (key.reserved = true, key)]);
    this.head = this.newed ? Parens(call, true) : call;
    i = -1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.expandVivify();
this.<span class="apidocCodeKeywordSpan">expandBind</span>(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice" id="apidoc.element.livescript.ast.Chain.prototype.expandSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSlice
        <span class="apidocSignatureSpan">(o, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandSlice = function (o, assign){
  var tails, i, tail, ref$, x;
  tails = this.tails;
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &#x26;&#x26; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp(&#x27;calling a slice&#x27;);
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? Chain(head, slice$.call(pre, 0, -1))
    : Literal(&#x27;this&#x27;);
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.<span class="apidocCodeKeywordSpan">expandSlice</span>(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat" id="apidoc.element.livescript.ast.Chain.prototype.expandSplat">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSplat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandSplat = function (o){
  var tails, i, call, args, ctx, ref$;
  tails = this.tails;
  i = -1;
  while (call = tails[++i]) {
    if (!(args = call.args)) {
      continue;
    }
    ctx = call.method === &#x27;.call&#x27; &#x26;&#x26; (args = args.concat()).shift();
    if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
      continue;
    }
    if (call[&#x27;new&#x27;]) {
      this.splattedNewArgs = args;
    } else {
      if (!ctx &#x26;&#x26; tails[i - 1] instanceof Index) {
        ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
        i = 0;
      }
      call.method = &#x27;.apply&#x27;;
      call.args = [ctx || Literal(&#x27;null&#x27;), JS(args)];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.expandVivify();
this.expandBind(o);
this.<span class="apidocCodeKeywordSpan">expandSplat</span>(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
}
if (!this.tails.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandStar" id="apidoc.element.livescript.ast.Chain.prototype.expandStar">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandStar
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandStar = function (o){
  var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.args || that.stars || that.key instanceof Key) {
      continue;
    }
    stars = that.stars = [];
    that.eachChild(seek);
    if (!stars.length) {
      continue;
    }
    ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
    value = Chain(ref, [Index(Key(&#x27;length&#x27;))]).compile(o);
    for (i$ = 0, len$ = stars.length; i$ &#x3c; len$; ++i$) {
      star = stars[i$];
      star.value = value;
      star.isAssignable = YES;
    }
    this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
    if (temps) {
      o.scope.free(temps[0]);
    }
    i = -1;
  }
  function seek(it){
    if (it.value === &#x27;*&#x27;) {
      stars.push(it);
    } else if (!(it instanceof Index)) {
      it.eachChild(seek);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.<span class="apidocCodeKeywordSpan">expandStar</span>(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
}
if (!this.tails.length) {
  return this.head.compile(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify" id="apidoc.element.livescript.ast.Chain.prototype.expandVivify">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandVivify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandVivify = function (){
  var tails, i, that, ref$, ref1$;
  tails = this.tails;
  i = 0;
  while (i &#x3c; tails.length) {
    if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
      this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), &#x27;=&#x27;, &#x27;||&#x27;);
      i = 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    : Literal(&#x27;this&#x27;);
  return Chain(Chain(Var(util(&#x27;partialize&#x27;))).add(Index(Key(&#x27;apply&#x27;))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &#x26;&#x26; !head.isCallable()) {
  this.carp(&#x27;invalid callee&#x27;);
}
this.expandSlice(o);
this.<span class="apidocCodeKeywordSpan">expandVivify</span>();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, &#x22;(function(func, args, ctor) {\n&#x22; + idt + &#x22;ctor.prototype = func.prototype;\n&#x22; + idt + &#x22
;var child = new ctor, result = func.apply(child, args), t;\n&#x22; + idt + &#x22;return (t = typeof result)  == \&#x22;object\&#x22; || t == \&#x22;function\&#x22; ? result || child : child;\n&#x22; + TAB + &#x22;})(&#x22;, func.compile(o), &#x22;, &#x22;, this.splattedNewArgs, &#x22;, function(){})&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.flipIt" id="apidoc.element.livescript.ast.Chain.prototype.flipIt">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>flipIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flipIt = function (){
  this.flip = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}), o(&#x27;( UNARY )&#x27;, function(){
  return Chain(L(2, Unary($2)));
}), o(&#x27;( CREMENT )&#x27;, ditto), o(&#x27;( BACKTICK Chain BACKTICK )&#x27;, function(){
  return Chain($3);
}), o(&#x27;( Expression BACKTICK Chain BACKTICK )&#x27;, function(){
  return Chain(L(2, 5, $4.add(L(2, Call([$2])))));
}), o(&#x27;( BACKTICK Chain BACKTICK Expression )&#x27;, function(){
  return Chain(L(3, Chain(Var(&#x27;flip$&#x27;))).add(L(3, Call([$3])))).<span class="apidocCodeKeywordSpan">flipIt</span>().add
(L(5, Call([$5])));
}), o(&#x27;[ Expression TO Expression ]&#x27;, function(){
  return Chain(L(2, 4, new For({
    from: $2,
    op: $3,
    to: $4,
    inComprehension: true
  })));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getCall" id="apidoc.element.livescript.ast.Chain.prototype.getCall">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCall = function (){
  var tail, ref$;
  return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call &#x26;&#x26; tail;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fun.name = node.label;
  fun.labeled = true;
  node = node.it;
}
if (!fun.hushed &#x26;&#x26; (fun.hushed = node.op === &#x27;!&#x27;)) {
  node = node.it;
}
if ((ref$ = node.<span class="apidocCodeKeywordSpan">getCall</span>()) != null) {
  ref$.partialized = null;
}
args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
index = 0;
for (i$ = 0, len$ = args.length; i$ &#x3c; len$; ++i$) {
  a = args[i$];
  if (a.placeholder) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getJump" id="apidoc.element.livescript.ast.Chain.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isArray" id="apidoc.element.livescript.ast.Chain.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.isArray();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable" id="apidoc.element.livescript.ast.Chain.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAssignable = function (){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.isAssignable();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isCallable" id="apidoc.element.livescript.ast.Chain.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return !((ref$ = that.key) != null &#x26;&#x26; ref$.items);
  } else {
    return this.head.isCallable();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isComplex" id="apidoc.element.livescript.ast.Chain.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.tails.length || this.head.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isRegex" id="apidoc.element.livescript.ast.Chain.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess" id="apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isSimpleAccess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSimpleAccess = function (){
  return this.tails.length === 1 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !this.tails[0].isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    dotSplit = name.toString().split(&#x27;.&#x27;);
    if (protoSplit.length &#x3e; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &#x3e; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join(&#x27;&#x27;);
    }
  }
  code = !o.level &#x26;&#x26; right instanceof While &#x26;&#x26; !right[&#x27;else&#x27;] &#x26;&#x26; (lvar || left instanceof
 Chain &#x26;&#x26; left.<span class="apidocCodeKeywordSpan">isSimpleAccess</span>())
    ? (empty = right.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;, [res = o.scope.temporary(&#x27;res&#x27;), &#x22; = &#x22; + empty
 + &#x22;;\n&#x22; + this.tab, right.makeReturn(res).compile(o), &#x22;\n&#x22; + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &#x3e; LEVEL_LIST) {
    code = [&#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isStatement" id="apidoc.element.livescript.ast.Chain.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isStatement
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStatement = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isString" id="apidoc.element.livescript.ast.Chain.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn" id="apidoc.element.livescript.ast.Chain.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  if (this.tails.length) {
    return superclass.prototype.makeReturn.apply(this, arguments);
  } else {
    return (ref$ = this.head).makeReturn.apply(ref$, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Chain.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldAssign = function (o){
  var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
  if (that = this.head.unfoldAssign(o)) {
    (ref$ = that.right.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    index = ref$[i$];
    if (op = index.assign) {
      index.assign = &#x27;&#x27;;
      left = Chain(this.head, this.tails.splice(0, i)).expandSlice(o).unwrap();
      if (left instanceof Arr) {
        lefts = left.items;
        rites = (this.head = Arr()).items;
        for (j$ = 0, len1$ = lefts.length; j$ &#x3c; len1$; ++j$) {
          i = j$;
          node = lefts[j$];
          ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
        }
      } else {
        ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
      }
      if (op === &#x27;=&#x27;) {
        op = &#x27;:=&#x27;;
      }
      return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &#x3c; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Chain.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var that, ref$, i$, len$, i, node, ref1$, bust, test;
  if (that = this.head.unfoldSoak(o)) {
    (ref$ = that.then.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = ref$[i$];
    if (ref1$ = node.soak, delete node.soak, ref1$) {
      bust = Chain(this.head, this.tails.splice(0, i));
      if (node.assign &#x26;&#x26; !bust.isAssignable()) {
        node.carp(&#x27;invalid accessign&#x27;);
      }
      if (i &#x26;&#x26; (node.assign || node instanceof Call)) {
        ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
        if (bust instanceof Chain) {
          (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
          bust = bust.head;
        }
        this.head = bust;
      } else {
        ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
      }
      test = node instanceof Call
        ? JS(&#x22;typeof &#x22; + test.compile(o, LEVEL_OP) + &#x22; == &#x27;function&#x27;&#x22;)
        : Existence(test);
      return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unwrap" id="apidoc.element.livescript.ast.Chain.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (){
  if (this.tails.length) {
    return this;
  } else {
    return this.head;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &#x3c; 2 &#x26;&#x26; !this.head.isComplex() &#x26;&#x26; !(name != null &#x26;&#x26; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.varName" id="apidoc.element.livescript.ast.Chain.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Class" id="apidoc.module.livescript.ast.Class">module livescript.ast.Class</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Class.Class" id="apidoc.element.livescript.ast.Class.Class">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Class
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 139:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.Try($$[$0-5], $$[$0-3], yy.L(_$[$0-4],_$[$0-3], $$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 140:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 141:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Class</span>({
        title: $$[$0-3].unwrap(),
        sup: $$[$0-2],
        mixins: $$[$0-1],
        body: $$[$0]
      }));
break;
case 142:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.superclass" id="apidoc.element.livescript.ast.Class.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Class.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Class.prototype" id="apidoc.module.livescript.ast.Class.prototype">module livescript.ast.Class.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.compile" id="apidoc.element.livescript.ast.Class.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj
, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
  fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
  CopyL(this, fun);
  boundFuncs = [];
  curriedBoundFuncs = [];
  decl = title != null ? title.varName() : void 8;
  name = decl || this.name;
  if (ID.test(name || &#x27;&#x27;)) {
    fun.cname = name;
  } else {
    name = &#x27;constructor&#x27;;
  }
  proto = Var(&#x27;prototype&#x27;);
  vname = fun.proto = Var(fun.bound = name);
  ctorName = &#x27;constructor$$&#x27;;
  importProtoObj = function(node, i){
    var j, prop, key, i$, ref$, len$, v;
    j = 0;
    for (; j &#x3c; node.items.length; j++) {
      prop = node.items[j];
      key = prop.key;
      if ((key instanceof Key &#x26;&#x26; key.name === ctorName) || (key instanceof Literal &#x26;&#x26; key.value === &#x22;&#x27;&#x22; + ctorName + &#x22;&#x27;&#x22;)) {
        if (ctor) {
          node.carp(&#x27;redundant constructor&#x27;);
        }
        ctor = prop.val;
        node.items.splice(j--, 1);
        ctorPlace = i;
      }
      if (!(prop.val instanceof Fun || prop.accessor)) {
        continue;
      }
      if (key.isComplex()) {
        key = Var(o.scope.temporary(&#x27;key&#x27;));
        prop.key = Assign(key, prop.key);
      }
      if (prop.val.bound) {
        if (prop.val.curried) {
          curriedBoundFuncs.push(prop.key);
        } else {
          boundFuncs.push(prop.key);
        }
        prop.val.bound = false;
        prop.val.classBound = true;
      }
      for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ &#x3c; len$; ++i$) {
        v = ref$[i$];
        v.meth = key;
      }
    }
    if (node.items.length) {
      return ref$ = Import(Chain(vname).add(Index(Key(&#x27;prototype&#x27;))), node), ref$.proto = true, ref$;
    } else {
      return Literal(&#x27;void&#x27;);
    }
  };
  for (i$ = 0, len$ = lines.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = lines[i$];
    if (node instanceof Obj) {
      lines[i] = importProtoObj(node, i);
    } else if (node instanceof Fun &#x26;&#x26; !node.statement) {
      ctor &#x26;&#x26; node.carp(&#x27;redundant constructor&#x27;);
      ctor = node;
    } else if (node instanceof Assign &#x26;&#x26; node.left instanceof Chain &#x26;&#x26; node.left.head.value === &#x27;this&#x27; &#x26;&#x26; node.right instanceof
Fun) {
      node.right.stat = node.left.tails[0].key;
    } else {
      node.traverseChildren(fn$);
    }
  }
  ctor || (ctor = lines[lines.length] = this.sup
    ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal(&#x27;arguments&#x27;))]))))
    : Fun());
  if (!(ctor instanceof Fun)) {
    lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
    lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat(&#x27;arguments&#x27;, true)]))))));
  }
  ctor.name = name;
  ctor.ctor = true;
  ctor.statement = true;
  for (i$ = 0, len$ = boundFuncs.length; i$ &#x3c; len$; ++i$) {
    f = boundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(f)), Chain(Var(util(&#x27;bind&#x27;))).add(Call([Literal(&#x27;this&#x27;), Literal
(&#x22;&#x27;&#x22; + f.name + &#x22;&#x27;&#x22;), Var(&#x27;prototype&#x27;)]))));
  }
  for (i$ = 0, len$ = curriedBoundFuncs.length; i$ &#x3c; len$; ++i$) {
    f = curriedBoundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(Key(&#x22;_&#x22; + f.name))), Chain(Var(util(&#x27;curry&#x27;))).add(Call([Chain
(Var(&#x27;prototype&#x27;)).add(Index(f)), Var(&#x27;true&#x27;)]))), Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(f)), Chain(Var(util(&#x27;bind&#x27;))).add(Call
([Literal(&#x27;this&#x27;), Literal(&#x22;&#x27;_&#x22; + f.name + &#x22;&#x27;&#x22;)]))));
  }
  lines.push(vname);
  args = [];
  if (that = this.sup) {
    args.push(that);
    imports = Chain(Import(Literal(&#x27;this&#x27;), Var(&#x27;superclass&#x27;)));
    fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key(&#x27;displayName&#x27;))), Literal(&#x22;&#x27;&#x22; + name + &#x22;&#x27;&#x22;)), Literal
(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var(&#x27;superclass&#x27;));
  }
  if (that = this.mixins) {
    res$ = [];
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      args[args.length] = that[i$];
      res$.push(Import(proto, JS(&#x22;arguments[&#x22; + (args.length - 1) + &#x22;]&#x22;), true));
    }
    import ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.constructor" id="apidoc.element.livescript.ast.Class.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>constructor
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.isCallable" id="apidoc.element.livescript.ast.Class.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.ripName" id="apidoc.element.livescript.ast.Class.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripName = function (it){
  this.name = it.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence" id="apidoc.module.livescript.ast.Existence">module livescript.ast.Existence</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.Existence" id="apidoc.element.livescript.ast.Existence.Existence">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Existence</span>($$[$0-1].unwrap
()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call[&#x27;let&#x27;]($$[$0-3], $$[$0]))));
break;
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.superclass" id="apidoc.element.livescript.ast.Existence.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence.prototype" id="apidoc.module.livescript.ast.Existence.prototype">module livescript.ast.Existence.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.compileNode" id="apidoc.element.livescript.ast.Existence.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var node, ref$, code, op, eq;
  node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
  code = [node.compile(o, LEVEL_OP + PREC[&#x27;==&#x27;])];
  if (node instanceof Var &#x26;&#x26; !o.scope.check(code.join(&#x22;&#x22;), true)) {
    ref$ = this.negated
      ? [&#x27;||&#x27;, &#x27;=&#x27;]
      : [&#x27;&#x26;&#x26;&#x27;, &#x27;!&#x27;], op = ref$[0], eq = ref$[1];
    code = [&#x22;typeof &#x22;].concat(slice$.call(code), [&#x22; &#x22; + eq + &#x22;= &#x27;undefined&#x27; &#x22; + op + &#x22; &#x22;], slice$.call(code), [&#x22; &#x22; + eq + &#x22;== null
&#x22;]);
  } else {
    code.push(&#x22; &#x22; + (op = this.negated ? &#x27;==&#x27; : &#x27;!=&#x27;) + &#x22; null&#x22;);
  }
  if (o.level &#x3c; LEVEL_OP + PREC[op]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn(this, &#x22;(&#x22;, code, &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.constructor" id="apidoc.element.livescript.ast.Existence.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.invert" id="apidoc.element.livescript.ast.Existence.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  this.negated = !this.negated;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.show" id="apidoc.element.livescript.ast.Existence.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.negated &#x26;&#x26; &#x27;!&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For" id="apidoc.module.livescript.ast.For">module livescript.ast.For</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.For" id="apidoc.element.livescript.ast.For.For">
        function <span class="apidocSignatureSpan">livescript.ast.</span>For
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &#x26;&#x26; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &#x3c; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &#x26;&#x26; !this.object) {
    this.carp(&#x27;`for own` requires `of`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 28:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var(&#x27;flip$&#x27;))).add(yy.L(_$[$0-3],_$[$0-3],yy
.Call([$$[$0-3]])))).flipIt().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 29:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">For</span>({
        from: $$[$0-3],
        op: $$[$0-2],
        to: $$[$0-1],
        inComprehension: true
      }))));
break;
case 30:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.superclass" id="apidoc.element.livescript.ast.For.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.For.</span>superclass
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &#x26;&#x26; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== &#x27;&#x27; + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For.prototype" id="apidoc.module.livescript.ast.For.prototype">module livescript.ast.For.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.addBody" id="apidoc.element.livescript.ast.For.prototype.addBody">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBody = function (body){
  var hasYield, ref$, x$, that, this$ = this;
  hasYield = !!body.traverseChildren(function(child){
    if (child instanceof Yield) {
      return true;
    }
  });
  if (this[&#x27;let&#x27;]) {
    if (ref$ = this.ref, delete this.ref, ref$) {
      this.item = Literal(&#x27;..&#x27;);
    }
    body = Block(Call[&#x27;let&#x27;]((x$ = [], (that = this.index) &#x26;&#x26; x$.push(Assign(Var(that), Literal(&#x27;index$$&#x27;))), (that = this.item) &#x26;&#x26;
x$.push(Assign(that, Literal(&#x27;item$$&#x27;))), x$), body, hasYield));
  }
  superclass.prototype.addBody.call(this, body);
  if (this.guard &#x26;&#x26; this[&#x27;let&#x27;] &#x26;&#x26; (this.index || this.item)) {
    this.body.lines[0][&#x27;if&#x27;].traverseChildren(function(it){
      if (it instanceof Var) {
        if (this$.index &#x26;&#x26; it.value === this$.index) {
          it.value = &#x27;index$$&#x27;;
        }
        if (this$.item &#x26;&#x26; it.value === this$.item.value) {
          it.value = &#x27;item$$&#x27;;
        }
      }
    });
  }
  if (this[&#x27;let&#x27;]) {
    if (hasYield) {
      this.body = Block(Yield(&#x27;yieldfrom&#x27;, body));
    }
    delete this.index;
    delete this.item;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
While.prototype.show = function(){
  return [this.un ? &#x27;!&#x27; : void 8, this.post ? &#x27;do&#x27; : void 8].join(&#x27;&#x27;);
};
prototype.isStatement = prototype.isArray = YES;
While.prototype.makeComprehension = function(toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().<span class="apidocCodeKeywordSpan">addBody</span>(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
};
While.prototype.getJump = function(ctx){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.compileNode" id="apidoc.element.livescript.ast.For.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
  o.loop = true;
  temps = this.temps = [];
  if (this.object &#x26;&#x26; this.index) {
    o.scope.declare(idx = this.index);
  } else {
    temps.push(idx = o.scope.temporary(&#x27;i&#x27;));
  }
  if (!this.body) {
    this.addBody(Block(Var(idx)));
  }
  if (!this.object) {
    ref$ = (this.step || Literal(1)).compileLoopReference(o, &#x27;step&#x27;), pvar = ref$[0], step = ref$[1];
    pvar === step || temps.push(pvar);
  }
  if (this.from) {
    if (this.ref) {
      this.item = Var(idx);
    }
    ref$ = this.to.compileLoopReference(o, &#x27;to&#x27;), tvar = ref$[0], tail = ref$[1];
    fvar = this.from.compile(o, LEVEL_LIST);
    vars = idx + &#x22; = &#x22; + fvar;
    if (tail !== tvar) {
      vars += &#x22;, &#x22; + tail;
      temps.push(tvar);
    }
    if (!this.step &#x26;&#x26; +fvar &#x3e; +tvar) {
      pvar = step = -1;
    }
    eq = this.op === &#x27;til&#x27; ? &#x27;&#x27; : &#x27;=&#x27;;
    cond = +pvar
      ? idx + &#x22; &#x22; + &#x27;&#x3c;&#x3e;&#x27;.charAt(pvar &#x3c; 0) + eq + &#x22; &#x22; + tvar
      : pvar + &#x22; &#x3c; 0 ? &#x22; + idx + &#x22; &#x3e;&#x22; + eq + &#x22; &#x22; + tvar + &#x22; : &#x22; + idx + &#x22; &#x3c;&#x22; + eq + &#x22; &#x22; + tvar;
  } else {
    if (this.ref) {
      this.item = Var(o.scope.temporary(&#x27;x&#x27;));
    }
    if (this.item || this.object &#x26;&#x26; this.own || this[&#x27;let&#x27;]) {
      ref$ = this.source.compileLoopReference(o, &#x27;ref&#x27;, !this.object, true), svar = ref$[0], srcPart = ref$[1];
      svar === srcPart || temps.push(svar);
    } else {
      svar = srcPart = this.source.compile(o, LEVEL_PAREN);
    }
    if (!this.object) {
      if (0 &#x3e; pvar &#x26;&#x26; ~~pvar === +pvar) {
        vars = idx + &#x22; = &#x22; + srcPart + &#x22;.length - 1&#x22;;
        cond = idx + &#x22; &#x3e;= 0&#x22;;
      } else {
        temps.push(lvar = o.scope.temporary(&#x27;len&#x27;));
        vars = idx + &#x22; = 0, &#x22; + lvar + &#x22; = &#x22; + srcPart + &#x22;.length&#x22;;
        cond = idx + &#x22; &#x3c; &#x22; + lvar;
      }
    }
  }
  this[&#x27;else&#x27;] &#x26;&#x26; (this.yet = o.scope.temporary(&#x27;yet&#x27;));
  head = [sn(this, &#x27;for (&#x27;)];
  if (this.object) {
    head.push(idx, &#x22; in &#x22;);
  }
  if (that = this.yet) {
    head.push(that, &#x22; = true, &#x22;);
  }
  if (this.object) {
    head.push(srcPart);
  } else {
    step === pvar || (vars += &#x27;, &#x27; + step);
    head.push(vars, &#x22;; &#x22;, cond, &#x22;; &#x22; + (1 == Math.abs(pvar)
      ? (pvar &#x3c; 0 ? &#x27;--&#x27; : &#x27;++&#x27;) + idx
      : idx + (pvar &#x3c; 0
        ? &#x27; -= &#x27; + pvar.toString().slice(1)
        : &#x27; += &#x27; + pvar)));
  }
  this.own &#x26;&#x26; head.push(sn(this, &#x22;) if (&#x22;), o.scope.assign(&#x27;own$&#x27;, &#x27;{}.hasOwnProperty&#x27;), &#x22;.call(&#x22;, svar, &#x22;, &#x22;, idx, &#x22;)&#x22;);
  head.push(sn(this, &#x27;) {&#x27;));
  if (this[&#x27;let&#x27;]) {
    this.body.traverseChildren(function(it){
      switch (it.value) {
      case &#x27;index$$&#x27;:
        it.value = idx;
        break;
      case &#x27;item$$&#x27;:
        it.value = svar + &#x22;[&#x22; + idx + &#x22;]&#x22;;
      }
    });
  }
  o.indent += TAB;
  if (this.index &#x26;&#x26; !this.object) {
    head.push(&#x27;\n&#x27; + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), &#x27;;&#x27;);
  }
  if (this.item &#x26;&#x26; !this.item.isEmpty() &#x26;&#x26; !this.from) {
    head.push(&#x27;\n&#x27; + o.indent, Assign(this.item, JS(svar + &#x22;[&#x22; + idx + &#x22;]&#x22;)).compile(o, LEVEL_TOP), &#x27;;&#x27;);
  }
  if (this.ref) {
    o.ref = this.item.value;
  }
  body = this.compileBody(o);
  if ((this.item || (this.index &#x26;&#x26; !this.object)) &#x26;&#x26; &#x27;}&#x27; === body.toString().charAt(0)) {
    head.push(&#x27;\n&#x27; + this.tab);
  }
  return sn.apply(null, [null].concat(slice$.call(head), [body]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.constructor" id="apidoc.element.livescript.ast.For.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &#x26;&#x26; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &#x3c; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &#x26;&#x26; !this.object) {
    this.carp(&#x27;`for own` requires `of`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.show" id="apidoc.element.livescript.ast.For.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return ((this.kind || []).concat(this.index)).join(&#x27; &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun" id="apidoc.module.livescript.ast.Fun">module livescript.ast.Fun</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.Fun" id="apidoc.element.livescript.ast.Fun.Fun">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &#x26;&#x26; &#x27;this$&#x27;;
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 113:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]));
break;
case 114:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Existence($$[$0-1].unwrap(), true));
break;
case 115:
this.$ = yy.L(_$[$0-5], _$[$0],yy.<span class="apidocCodeKeywordSpan">Fun</span>($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test
($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
break;
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.superclass" id="apidoc.element.livescript.ast.Fun.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype" id="apidoc.module.livescript.ast.Fun.prototype">module livescript.ast.Fun.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileNode" id="apidoc.element.livescript.ast.Fun.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this;
  pscope = o.scope;
  sscope = pscope.shared || pscope;
  scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper &#x26;&#x26; sscope);
  scope.fun = this;
  if (that = this.proto) {
    scope.assign(&#x27;prototype&#x27;, that.compile(o) + &#x22;.prototype&#x22;);
  }
  if (that = this.cname) {
    scope.assign(&#x27;constructor&#x27;, that);
  }
  if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
    o.indent = this.tab = &#x27;&#x27;;
  }
  o.indent += TAB;
  body = this.body, name = this.name, tab = this.tab;
  code = [&#x27;function&#x27;];
  if (this.generator) {
    this.ctor &#x26;&#x26; this.carp(&#x22;a constructor can&#x27;t be a generator&#x22;);
    o.inGenerator = true;
    code.push(&#x27;*&#x27;);
  } else if (!this.wrapper) {
    o.inGenerator = false;
  }
  if (this.bound === &#x27;this$&#x27;) {
    if (this.ctor) {
      scope.assign(&#x27;this$&#x27;, &#x27;this instanceof ctor$ ? this : new ctor$&#x27;);
      body.lines.push(Return(Literal(&#x27;this$&#x27;)));
    } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
      this.bound = that;
    } else {
      sscope.assign(&#x27;this$&#x27;, &#x27;this&#x27;);
    }
  }
  if (this.statement) {
    name || this.carp(&#x27;nameless function declaration&#x27;);
    pscope === o.block.scope || this.carp(&#x27;misplaced function declaration&#x27;);
    this.accessor &#x26;&#x26; this.carp(&#x27;named accessor&#x27;);
    pscope.add(name, &#x27;function&#x27;, this);
  }
  if (this.statement || name &#x26;&#x26; this.labeled) {
    code.push(&#x27; &#x27;, scope.add(name, &#x27;function&#x27;, this));
  }
  this.hushed || this.ctor || this.newed || body.makeReturn();
  code.push(&#x22;(&#x22;, this.compileParams(o, scope), &#x22;)&#x22;);
  code = [sn.apply(null, [this].concat(slice$.call(code)))];
  code.push(&#x22;{&#x22;);
  if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
    code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
  }
  code.push(&#x27;}&#x27;);
  curryCodeCheck = function(){
    if (this$.curried &#x26;&#x26; this$.hasSplats) {
      this$.carp(&#x27;cannot curry a function with a variable number of arguments&#x27;);
    }
    if (this$.curried &#x26;&#x26; this$.params.length &#x3e; 1 &#x26;&#x26; !this$.classBound) {
      if (this$.bound) {
        return [util(&#x27;curry&#x27;), &#x22;((&#x22;].concat(slice$.call(code), [&#x22;), true)&#x22;]);
      } else {
        return [util(&#x27;curry&#x27;), &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
      }
    } else {
      return code;
    }
  };
  if (inLoop) {
    return pscope.assign(pscope.temporary(&#x27;fn&#x27;), sn.apply(null, [null].concat(slice$.call(curryCodeCheck()))));
  }
  if (this.returns) {
    code.push(&#x22;\n&#x22; + tab + &#x22;return &#x22;, name, &#x22;;&#x22;);
  } else if (this.bound &#x26;&#x26; this.ctor) {
    code.push(&#x27; function ctor$(){} ctor$.prototype = prototype;&#x27;);
  }
  code = curryCodeCheck();
  if (this.front &#x26;&#x26; !this.statement) {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileParams" id="apidoc.element.livescript.ast.Fun.prototype.compileParams">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileParams
        <span class="apidocSignatureSpan">(o, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileParams = function (o, scope){
  var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
  params = this.params, length = params.length, body = this.body;
  for (i$ = params.length - 1; i$ &#x3e;= 0; --i$) {
    p = params[i$];
    if (!(p.isEmpty() || p.filler)) {
      break;
    }
    --params.length;
  }
  for (i$ = 0, len$ = params.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    p = params[i$];
    if (p.left instanceof Splat) {
      p.carp(&#x27;invalid splat&#x27;);
    }
    if (p instanceof Splat) {
      this.hasSplats = true;
      splace = i;
    } else if (p.op === &#x27;=&#x27;) {
      params[i] = Binary(p.logic || &#x27;?&#x27;, p.left, p.right);
    }
  }
  if (splace != null) {
    rest = params.splice(splace, 9e9);
  } else if (this.accessor) {
    if (that = params[1]) {
      that.carp(&#x27;excess accessor parameter&#x27;);
    }
  } else if (!(length || this.wrapper)) {
    if (body.traverseChildren(function(it){
      return it.value === &#x27;it&#x27; || null;
    })) {
      params[0] = Var(&#x27;it&#x27;);
    }
  }
  names = [];
  assigns = [];
  for (i$ = 0, len$ = params.length; i$ &#x3c; len$; ++i$) {
    p = params[i$];
    vr = p;
    if (df = vr.getDefault()) {
      vr = vr.first;
    }
    if (vr.isEmpty()) {
      vr = Var(scope.temporary(&#x27;arg&#x27;));
    } else if (vr.value === &#x27;..&#x27;) {
      vr = Var(o.ref = scope.temporary());
    } else if (!(vr instanceof Var)) {
      unaries = [];
      while (vr instanceof Unary) {
        hasUnary = true;
        unaries.push(vr);
        vr = vr.it;
      }
      v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary(&#x27;arg&#x27;));
      assigns.push(Assign(vr, (fn$())));
      vr = v;
    } else if (df) {
      assigns.push(Assign(vr, p.second, &#x27;=&#x27;, p.op, true));
    }
    names.push(scope.add(vr.value, &#x27;arg&#x27;, p), &#x27;, &#x27;);
  }
  if (rest) {
    while (splace--) {
      rest.unshift(Arr());
    }
    assigns.push(Assign(Arr(rest), Literal(&#x27;arguments&#x27;)));
  }
  if (assigns.length) {
    (ref$ = this.body).prepend.apply(ref$, assigns);
  }
  names.pop();
  return sn.apply(null, [null].concat(slice$.call(names)));
  function fn$(){
    switch (false) {
    case !df:
      return Binary(p.op, v, p.second);
    case !hasUnary:
      return fold(function(x, y){
        y.it = x;
        return y;
      }, v, unaries.reverse());
    default:
      return v;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.accessor &#x26;&#x26; this.carp(&#x27;named accessor&#x27;);
  pscope.add(name, &#x27;function&#x27;, this);
}
if (this.statement || name &#x26;&#x26; this.labeled) {
  code.push(&#x27; &#x27;, scope.add(name, &#x27;function&#x27;, this));
}
this.hushed || this.ctor || this.newed || body.makeReturn();
code.push(&#x22;(&#x22;, this.<span class="apidocCodeKeywordSpan">compileParams</span>(o, scope), &#x22;)&#x22;);
code = [sn.apply(null, [this].concat(slice$.call(code)))];
code.push(&#x22;{&#x22;);
if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
  code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
}
code.push(&#x27;}&#x27;);
curryCodeCheck = function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.constructor" id="apidoc.element.livescript.ast.Fun.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>constructor
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &#x26;&#x26; &#x27;this$&#x27;;
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.isCallable" id="apidoc.element.livescript.ast.Fun.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.isStatement" id="apidoc.element.livescript.ast.Fun.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStatement = function (){
  return !!this.statement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn" id="apidoc.element.livescript.ast.Fun.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  if (this.statement) {
    return this.returns = true, this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.named" id="apidoc.element.livescript.ast.Fun.prototype.named">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>named
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">named = function (it){
  return this.name = it, this.statement = true, this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
],
List: [
  o(&#x27;[ ArgList    OptComma ]&#x27;, function(){
    return Arr($2);
  }), o(&#x27;{ Properties OptComma }&#x27;, function(){
    return Obj($2);
  }), o(&#x27;[ ArgList    OptComma ] LABEL&#x27;, function(){
    return Arr($2).<span class="apidocCodeKeywordSpan">named</span>($5);
  }), o(&#x27;{ Properties OptComma } LABEL&#x27;, function(){
    return Obj($2).named($5);
  })
],
Key: [o(&#x27;KeyBase&#x27;), o(&#x27;Parenthetical&#x27;)],
KeyBase: [
  o(&#x27;ID&#x27;, function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.ripName" id="apidoc.element.livescript.ast.Fun.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripName = function (it){
  this.name || (this.name = it.varName());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.show" id="apidoc.element.livescript.ast.Fun.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return [this.name] + [(that = this.bound) ? &#x22;~&#x22; + that : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren" id="apidoc.element.livescript.ast.Fun.prototype.traverseChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>traverseChildren
        <span class="apidocSignatureSpan">(arg$, xscope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseChildren = function (arg$, xscope){
  if (xscope) {
    return superclass.prototype.traverseChildren.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.carp(&#x27;inconvertible statement&#x27;);
}
fun = Fun([], Block(this));
call = Call();
if (o.inGenerator) {
  fun.generator = true;
}
this.<span class="apidocCodeKeywordSpan">traverseChildren</span>(function(it){
  switch (it.value) {
  case &#x27;this&#x27;:
    hasThis = true;
    break;
  case &#x27;arguments&#x27;:
    hasArgs = it.value = &#x27;args$&#x27;;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If" id="apidoc.module.livescript.ast.If">module livescript.ast.If</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.If" id="apidoc.element.livescript.ast.If.If">
        function <span class="apidocSignatureSpan">livescript.ast.</span>If
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$[&#x27;if&#x27;] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
case 118:
this.$ = (yy.L(_$[$0-3],_$[$0-2], yy.<span class="apidocCodeKeywordSpan">If</span>($$[$0-2], $$[$0-1], $$[$0-3] === &#x27;unless
&#x27;)).addElse($$[$0]));
break;
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === &#x27;unless&#x27;)));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.superclass" id="apidoc.element.livescript.ast.If.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.If.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.unfoldSoak" id="apidoc.element.livescript.ast.If.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.If.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o, parent, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o, parent, name){
  var that;
  if (that = parent[name].unfoldSoak(o)) {
    parent[name] = that.then;
    return that.cond = parent.cond, that[&#x27;void&#x27;] = parent[&#x27;void&#x27;], that.then = Chain(parent), that;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype" id="apidoc.module.livescript.ast.If.prototype">module livescript.ast.If.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileExpression" id="apidoc.element.livescript.ast.If.prototype.compileExpression">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileExpression
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExpression = function (o){
  var thn, els, code, pad;
  thn = this.then, els = this[&#x27;else&#x27;] || Literal(&#x27;void&#x27;);
  this[&#x27;void&#x27;] &#x26;&#x26; (thn[&#x27;void&#x27;] = els[&#x27;void&#x27;] = true);
  if (!this[&#x27;else&#x27;] &#x26;&#x26; (this.cond || this[&#x27;void&#x27;])) {
    return Parens(Binary(&#x27;&#x26;&#x26;&#x27;, this[&#x27;if&#x27;], thn)).compile(o);
  }
  code = [sn(this, this[&#x27;if&#x27;].compile(o, LEVEL_COND))];
  pad = els.isComplex() ? &#x27;\n&#x27; + (o.indent += TAB) : &#x27; &#x27;;
  code.push(pad + &#x22;&#x22;, sn(thn, &#x22;? &#x22;), thn.compile(o, LEVEL_LIST), pad + &#x22;&#x22;, sn(els, &#x22;: &#x22;), els.compile(o, LEVEL_LIST));
  if (o.level &#x3c; LEVEL_COND) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, &#x22;(&#x22;, code, &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compileExistence = function(o){
  var x;
  if (this[&#x27;void&#x27;] || !o.level) {
    x = Binary(&#x27;&#x26;&#x26;&#x27;, Existence(this.first, true), this.second);
    return (x[&#x27;void&#x27;] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).<span class="apidocCodeKeywordSpan">compileExpression</span>(o));
};
Binary.prototype.compileAnyInstanceOf = function(o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary(&#x27;instanceof&#x27;, sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    item = items[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileNode" id="apidoc.element.livescript.ast.If.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  if (this.un) {
    this[&#x27;if&#x27;] = this[&#x27;if&#x27;].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.compileStatement(o);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileStatement" id="apidoc.element.livescript.ast.If.prototype.compileStatement">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileStatement
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileStatement = function (o){
  var code, els;
  code = [sn(this, &#x22;if (&#x22;, this[&#x27;if&#x27;].compile(o, LEVEL_PAREN), &#x22;) &#x22;)];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
  if (!(els = this[&#x27;else&#x27;])) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  return sn.apply(null, [null].concat(
    slice$.call(code), [
      sn(els, &#x27; else &#x27;), els instanceof constructor
        ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
        : this.compileBlock(o, els)
    ]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this[&#x27;if&#x27;] = this[&#x27;if&#x27;].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.<span class="apidocCodeKeywordSpan">compileStatement</span>(o);
  }
};
If.prototype.compileStatement = function(o){
  var code, els;
  code = [sn(this, &#x22;if (&#x22;, this[&#x27;if&#x27;].compile(o, LEVEL_PAREN), &#x22;) &#x22;)];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.constructor" id="apidoc.element.livescript.ast.If.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>constructor
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$[&#x27;if&#x27;] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.getJump" id="apidoc.element.livescript.ast.If.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var ref$;
  return this.then.getJump(it) || ((ref$ = this[&#x27;else&#x27;]) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isArray" id="apidoc.element.livescript.ast.If.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isCallable" id="apidoc.element.livescript.ast.If.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isRegex" id="apidoc.element.livescript.ast.If.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isString" id="apidoc.element.livescript.ast.If.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.makeReturn" id="apidoc.element.livescript.ast.If.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
  if (this[&#x27;else&#x27;] != null) {
    this[&#x27;else&#x27;] = (ref$ = this[&#x27;else&#x27;]).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.show" id="apidoc.element.livescript.ast.If.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.un &#x26;&#x26; &#x27;!&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import" id="apidoc.module.livescript.ast.Import">module livescript.ast.Import</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.Import" id="apidoc.element.livescript.ast.Import.Import">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Import
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
case 73:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Import</span>(yy.L(_$[$0-2],_$[$0-1], yy.Unary(&#x27;^^&#x27
;, $$[$0-2], {
  prec: &#x27;yy.UNARY&#x27;
})), $$[$0], false));
break;
case 74:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary(&#x27;^^&#x27;, $$[$0-2], {
  prec: &#x27;yy.UNARY&#x27;
})), $$[$0].unwrap(), false));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.superclass" id="apidoc.element.livescript.ast.Import.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Import.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype" id="apidoc.module.livescript.ast.Import.prototype">module livescript.ast.Import.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileAssign" id="apidoc.element.livescript.ast.Import.prototype.compileAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileAssign
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAssign = function (o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
    return this.left.compile(o);
  }
  top = !o.level;
  if (this.proto || (items.length &#x3c; 2 &#x26;&#x26; (top || this[&#x27;void&#x27;] || items[0] instanceof Splat))) {
    reft = this.left;
    if (reft.isComplex()) {
      reft = Parens(reft);
    }
  } else {
    ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
  }
  ref$ = top
    ? [&#x27;;&#x27;, &#x27;\n&#x27; + this.tab]
    : [&#x27;,&#x27;, &#x27; &#x27;], delim = ref$[0], space = ref$[1];
  delim += space;
  code = this.temps
    ? [left.compile(o, LEVEL_PAREN), delim]
    : [];
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    i &#x26;&#x26; code.push(com ? space : delim);
    if (com = node.comment) {
      code.push(node.compile(o));
      continue;
    }
    if (node instanceof Splat) {
      code.push(Import(reft, node.it).compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (dyna = node instanceof Parens) {
      ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
    } else if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        if (key instanceof Key) {
          key = JS(&#x22;&#x27;&#x22; + key.name + &#x22;&#x27;&#x22;);
        }
        code.push(&#x22;Object.defineProperty(&#x22;, reft.compile(o, LEVEL_LIST), &#x22;, &#x22;, key.compile(o, LEVEL_LIST), &#x22;, &#x22;, node.compileDescriptor
(o), &#x22;)&#x22;);
        continue;
      }
    } else {
      key = val = node;
    }
    dyna || (key = key.maybeKey());
    logic &#x26;&#x26; (val = (logic.first = val, logic));
    code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
  }
  if (top) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  this[&#x27;void&#x27;] || node instanceof Splat || code.push(com ? &#x27; &#x27; : &#x27;, &#x27;, reft.compile(o, LEVEL_PAREN));
  if (o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.<span class="apidocCodeKeywordSpan">compileAssign</span>(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util(&#x22;import&#x22; + (this.all || &#x27;&#x27;)), [this.left, right])).compileNode(o);
};
Import.prototype.compileAssign = function(o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileNode" id="apidoc.element.livescript.ast.Import.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.compileAssign(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util(&#x22;import&#x22; + (this.all || &#x27;&#x27;)), [this.left, right])).compileNode(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.constructor" id="apidoc.element.livescript.ast.Import.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>constructor
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isArray" id="apidoc.element.livescript.ast.Import.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isCallable" id="apidoc.element.livescript.ast.Import.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.show" id="apidoc.element.livescript.ast.Import.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.all;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Import.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var left, value, ref$, temps;
  left = this.left;
  if (left instanceof Existence &#x26;&#x26; !left.negated) {
    if ((left = left.it) instanceof Var) {
      value = (this.left = left).value;
      if (!o.scope.check(value, true)) {
        left = JS(&#x22;typeof &#x22; + value + &#x22; != &#x27;undefined&#x27; &#x26;&#x26; &#x22; + value);
      }
    } else {
      ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
    }
    return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$[&#x27;void&#x27;] = this[&#x27;void&#x27;], ref$;
  }
  return If.unfoldSoak(o, this, &#x27;left&#x27;) || (this[&#x27;void&#x27;] || !o.level) &#x26;&#x26; If.unfoldSoak(o, this, &#x27;right&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.In" id="apidoc.module.livescript.ast.In">module livescript.ast.In</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.In.In" id="apidoc.element.livescript.ast.In.In">
        function <span class="apidocSignatureSpan">livescript.ast.</span>In
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.superclass" id="apidoc.element.livescript.ast.In.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.In.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.In.prototype" id="apidoc.module.livescript.ast.In.prototype">module livescript.ast.In.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.compileNode" id="apidoc.element.livescript.ast.In.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var array, items, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
  items = (array = this.array.expandSlice(o).unwrap()).items;
  if (!(array instanceof Arr) || items.length &#x3c; 2) {
    return sn(this, this.negated ? &#x27;!&#x27; : &#x27;&#x27;, util(&#x27;in&#x27;), &#x22;(&#x22;, this.item.compile(o, LEVEL_LIST), &#x22;, &#x22;, array.compile(o, LEVEL_LIST
), &#x22;)&#x22;);
  }
  code = [];
  ref$ = this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
  ref$ = this.negated
    ? [&#x27; !== &#x27;, &#x27; &#x26;&#x26; &#x27;]
    : [&#x27; === &#x27;, &#x27; || &#x27;], cmp = ref$[0], cnj = ref$[1];
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    test = items[i$];
    if (code.length &#x3e; 0) {
      code.push(cnj);
    }
    if (test instanceof Splat) {
      code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
      if (!(i || sub === ref)) {
        code = [&#x22;(&#x22; + sub + &#x22;, &#x22;].concat(slice$.call(code), [&#x22;)&#x22;]);
      }
    } else {
      code.push(i || sub === ref
        ? ref
        : &#x22;(&#x22; + sub + &#x22;)&#x22;, cmp, test.compile(o, LEVEL_OP + PREC[&#x27;==&#x27;]));
    }
  }
  sub === ref || o.scope.free(ref);
  if (o.level &#x3c; LEVEL_OP + PREC[&#x27;||&#x27;]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.constructor" id="apidoc.element.livescript.ast.In.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>constructor
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.invert" id="apidoc.element.livescript.ast.In.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  this.negated = !this.negated;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.show" id="apidoc.element.livescript.ast.In.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.negated &#x26;&#x26; &#x27;!&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index" id="apidoc.module.livescript.ast.Index">module livescript.ast.Index</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.Index" id="apidoc.element.livescript.ast.Index.Index">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Index
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = &#x27;.&#x27;);
  if (init &#x26;&#x26; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case &#x27;[]&#x27;:
    this$.vivify = Arr;
    break;
  case &#x27;{}&#x27;:
    this$.vivify = Obj;
    break;
  default:
    if (&#x27;=&#x27; === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Index</span>($$[$0], $$[$
0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.superclass" id="apidoc.element.livescript.ast.Index.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Index.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype" id="apidoc.module.livescript.ast.Index.prototype">module livescript.ast.Index.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.compile" id="apidoc.element.livescript.ast.Index.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
    return sn(this, &#x22;[&#x22;, code, &#x22;]&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.constructor" id="apidoc.element.livescript.ast.Index.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>constructor
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = &#x27;.&#x27;);
  if (init &#x26;&#x26; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case &#x27;[]&#x27;:
    this$.vivify = Arr;
    break;
  case &#x27;{}&#x27;:
    this$.vivify = Obj;
    break;
  default:
    if (&#x27;=&#x27; === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.isComplex" id="apidoc.element.livescript.ast.Index.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.key.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.show" id="apidoc.element.livescript.ast.Index.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.varName" id="apidoc.element.livescript.ast.Index.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS" id="apidoc.module.livescript.ast.JS">module livescript.ast.JS</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.JS" id="apidoc.element.livescript.ast.JS.JS">
        function <span class="apidocSignatureSpan">livescript.ast.</span>JS
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 66:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], &#x27;cascade&#x27;));
break;
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">JS</span>($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.superclass" id="apidoc.element.livescript.ast.JS.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.JS.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS.prototype" id="apidoc.module.livescript.ast.JS.prototype">module livescript.ast.JS.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.compile" id="apidoc.element.livescript.ast.JS.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>compile
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (it){
  return sn(this, snSafe(this.literal
    ? entab(this.code, it.indent)
    : this.code));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.constructor" id="apidoc.element.livescript.ast.JS.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>constructor
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.isAssignable" id="apidoc.element.livescript.ast.JS.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAssignable = function (){
  return !this.comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.isCallable" id="apidoc.element.livescript.ast.JS.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  return !this.comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.show" id="apidoc.element.livescript.ast.JS.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.comment) {
    return this.code;
  } else {
    return &#x22;`&#x22; + this.code + &#x22;`&#x22;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump" id="apidoc.module.livescript.ast.Jump">module livescript.ast.Jump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.Jump" id="apidoc.element.livescript.ast.Jump.Jump">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
case 125:
this.$ = yy.L(_$[$0], _$[$0],yy.Jump[$$[$0]]());
break;
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Jump</span>($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.Switch($$[$0-2], $$[$0-1], $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.extended" id="apidoc.element.livescript.ast.Jump.extended">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>extended
        <span class="apidocSignatureSpan">(sub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extended = function (sub){
  sub.prototype.children = [&#x27;it&#x27;];
  this[sub.displayName.toLowerCase()] = sub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function THIS(){
return this;
}
function VOID(){}
UTILS = {
clone: &#x27;function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}&#x27;,
extend: &#x27;function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new
fun).constructor = sub;\n  if (typeof sup.extended == \&#x27;function\&#x27;) sup.<span class="apidocCodeKeywordSpan">extended</span>(sub);\n  return sub;\n}&#x27;,
bind: &#x27;function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}&#x27;,
&#x27;import&#x27;: &#x27;function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj
[key] = src[key];\n  return obj;\n}&#x27;,
importAll: &#x27;function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}&#x27;,
repeatString: &#x27;function(str, n){\n  for (var r = \&#x27;\&#x27;; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (str += str))
if (n &#x26; 1) r += str;\n  return r;\n}&#x27;,
repeatArray: &#x27;function(arr, n){\n  for (var r = []; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (arr = arr.concat(arr)))\n
    if (n &#x26; 1) r.push.apply(r, arr);\n  return r;\n}&#x27;,
&#x27;in&#x27;: &#x27;function(x, xs){\n  var i = -1, l = xs.length &#x3e;&#x3e;&#x3e; 0;\n  while (++i &#x3c; l) if (x === xs[i
]) return true;\n  return false;\n}&#x27;,
out: &#x27;typeof exports != \&#x27;undefined\&#x27; &#x26;&#x26; exports || this&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.return" id="apidoc.element.livescript.ast.Jump.return">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &#x26;&#x26; it.value !== &#x27;void&#x27;) {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.superclass" id="apidoc.element.livescript.ast.Jump.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.throw" id="apidoc.element.livescript.ast.Jump.throw">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype" id="apidoc.module.livescript.ast.Jump.prototype">module livescript.ast.Jump.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.compileNode" id="apidoc.element.livescript.ast.Jump.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that, ref$;
  if (that = this.label) {
    in$(that, (ref$ = o.labels) != null
      ? ref$
      : o.labels = []) || this.carp(&#x22;unknown label \&#x22;&#x22; + that + &#x22;\&#x22;&#x22;);
  } else {
    o[this.verb] || this.carp(&#x22;stray &#x22; + this.verb);
  }
  return sn(this, this.show() + &#x27;;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.constructor" id="apidoc.element.livescript.ast.Jump.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>constructor
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.getJump" id="apidoc.element.livescript.ast.Jump.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var that, ref$;
  ctx || (ctx = {});
  if (!ctx[this.verb]) {
    return this;
  }
  if (that = this.label) {
    return !in$(that, (ref$ = ctx.labels) != null
      ? ref$
      : ctx.labels = []) &#x26;&#x26; this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.isStatement" id="apidoc.element.livescript.ast.Jump.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn" id="apidoc.element.livescript.ast.Jump.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.show" id="apidoc.element.livescript.ast.Jump.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return (this.verb || &#x27;&#x27;) + ((that = this.label) ? &#x27; &#x27; + that : &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key" id="apidoc.module.livescript.ast.Key">module livescript.ast.Key</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.Key" id="apidoc.element.livescript.ast.Key.Key">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Key
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = &#x27;&#x27; + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
case 49:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Key</span>($$[$0]));
break;
case 50:
this.$ = yy.L(_$[$0], _$[$0],yy.Literal($$[$0]));
break;
case 51: case 164:
this.$ = yy.L(_$[$0], _$[$0],[]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.superclass" id="apidoc.element.livescript.ast.Key.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Key.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype" id="apidoc.module.livescript.ast.Key.prototype">module livescript.ast.Key.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.assigns" id="apidoc.element.livescript.ast.Key.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return it === this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.compile" id="apidoc.element.livescript.ast.Key.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return sn(this, this.show());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.constructor" id="apidoc.element.livescript.ast.Key.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = &#x27;&#x27; + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.isComplex" id="apidoc.element.livescript.ast.Key.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.show" id="apidoc.element.livescript.ast.Key.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.reserved) {
    return &#x22;&#x27;&#x22; + this.name + &#x22;&#x27;&#x22;;
  } else {
    return this.name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.varName" id="apidoc.element.livescript.ast.Key.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var name;
  name = this.name;
  if (this.reserved || (name === &#x27;arguments&#x27; || name === &#x27;eval&#x27;)) {
    return &#x22;$&#x22; + name;
  } else {
    return name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label" id="apidoc.module.livescript.ast.Label">module livescript.ast.Label</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.Label" id="apidoc.element.livescript.ast.Label.Label">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Label
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || &#x27;_&#x27;;
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &#x26;&#x26; it || it.calling &#x26;&#x26; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        body: $$[$0]
      }));
break;
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Label</span>($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27;arguments&#x27; &#x26;&#x26; $$[$0] !== &#
x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.superclass" id="apidoc.element.livescript.ast.Label.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Label.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype" id="apidoc.module.livescript.ast.Label.prototype">module livescript.ast.Label.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.compileNode" id="apidoc.element.livescript.ast.Label.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var label, it, labels;
  label = this.label, it = this.it;
  labels = o.labels = slice$.call(o.labels || []);
  if (in$(label, labels)) {
    this.carp(&#x22;duplicate label \&#x22;&#x22; + label + &#x22;\&#x22;&#x22;);
  }
  labels.push(label);
  it.isStatement() || (it = Block(it));
  return sn(null, sn(this, label, &#x22;: &#x22;), it instanceof Block
    ? (o.indent += TAB, this.compileBlock(o, it))
    : it.compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.constructor" id="apidoc.element.livescript.ast.Label.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>constructor
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || &#x27;_&#x27;;
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &#x26;&#x26; it || it.calling &#x26;&#x26; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.getJump" id="apidoc.element.livescript.ast.Label.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var ref$;
  ctx || (ctx = {});
  ((ref$ = ctx.labels) != null
    ? ref$
    : ctx.labels = []).push(this.label);
  return this.it.getJump((ctx[&#x27;break&#x27;] = true, ctx));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isArray" id="apidoc.element.livescript.ast.Label.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isCallable" id="apidoc.element.livescript.ast.Label.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isStatement" id="apidoc.element.livescript.ast.Label.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.makeReturn" id="apidoc.element.livescript.ast.Label.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.show" id="apidoc.element.livescript.ast.Label.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal" id="apidoc.module.livescript.ast.Literal">module livescript.ast.Literal</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.Literal" id="apidoc.element.livescript.ast.Literal.Literal">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + &#x22;&#x22;, true);
  }
  if (value === &#x27;super&#x27;) {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Literal</span>($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass" id="apidoc.element.livescript.ast.Literal.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(){
  Atom.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype" id="apidoc.module.livescript.ast.Literal.prototype">module livescript.ast.Literal.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.compile" id="apidoc.element.livescript.ast.Literal.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var val, ref$;
  level == null &#x26;&#x26; (level = o.level);
  switch (val = this.value + &#x22;&#x22;) {
  case &#x27;this&#x27;:
    return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
  case &#x27;void&#x27;:
    if (!level) {
      return sn(this, &#x27;&#x27;);
    }
    val += &#x27; 8&#x27;;
    // fallthrough
  case &#x27;null&#x27;:
    if (level === LEVEL_CALL) {
      this.carp(&#x27;invalid use of &#x27; + this.value);
    }
    break;
  case &#x27;on&#x27;:
  case &#x27;yes&#x27;:
    val = &#x27;true&#x27;;
    break;
  case &#x27;off&#x27;:
  case &#x27;no&#x27;:
    val = &#x27;false&#x27;;
    break;
  case &#x27;*&#x27;:
    this.carp(&#x27;stray star&#x27;);
    break;
  case &#x27;..&#x27;:
    if (!(val = o.ref)) {
      this.carp(&#x27;stray reference&#x27;);
    }
    this.cascadee || (val.erred = true);
    break;
  case &#x27;debugger&#x27;:
    if (level) {
      return sn(this, &#x22;(function(){ debugger; }())&#x22;);
    }
  }
  return sn(this, snSafe(val));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.constructor" id="apidoc.element.livescript.ast.Literal.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + &#x22;&#x22;, true);
  }
  if (value === &#x27;super&#x27;) {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isCallable" id="apidoc.element.livescript.ast.Literal.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return (ref$ = this.value) === &#x27;this&#x27; || ref$ === &#x27;eval&#x27; || ref$ === &#x27;..&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isComplex" id="apidoc.element.livescript.ast.Literal.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty" id="apidoc.element.livescript.ast.Literal.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (){
  var ref$;
  return (ref$ = this.value) === &#x27;void&#x27; || ref$ === &#x27;null&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isRegex" id="apidoc.element.livescript.ast.Literal.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (){
  return (this.value + &#x22;&#x22;).charAt() === &#x27;/&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isString" id="apidoc.element.livescript.ast.Literal.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  return 0 &#x3c;= &#x27;\&#x27;&#x22;&#x27;.indexOf((this.value + &#x22;&#x22;).charAt());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isWhat" id="apidoc.element.livescript.ast.Literal.prototype.isWhat">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isWhat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isWhat = function (){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.isCallable():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
  default:

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    default:
if (COMPARER.test(this.op)) {
  if (that = ((ref$ = this.op) === &#x27;===&#x27; || ref$ === &#x27;!==&#x27;) &#x26;&#x26; this.xorChildren(function(it){
    return it.isRegex();
  })) {
    return this.compileRegexEquals(o, that);
  }
  if (this.op === &#x27;===&#x27; &#x26;&#x26; (this.first instanceof Literal &#x26;&#x26; this.second instanceof Literal) &#x26
;&#x26; this.first.<span class="apidocCodeKeywordSpan">isWhat</span>() !== this.second.isWhat()) {
    if (typeof console != &#x27;undefined&#x27; &#x26;&#x26; console !== null) {
      console.warn(&#x22;WARNING: strict comparison of two different types will always be false: &#x22; + this.first.value + &#x22
; == &#x22; + this.second.value);
    }
  }
}
if (COMPARER.test(this.op) &#x26;&#x26; COMPARER.test(this.second.op)) {
  return this.compileChain(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn" id="apidoc.element.livescript.ast.Literal.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (it){
  if (!it &#x26;&#x26; this.value === &#x27;debugger&#x27;) {
    return this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey" id="apidoc.element.livescript.ast.Literal.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeKey = function (){
  if (ID.test(this.value)) {
    return Key(this.value);
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.varName" id="apidoc.element.livescript.ast.Literal.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  if (/^\w+$/.test(this.value)) {
    return &#x27;$&#x27; + this.value;
  } else {
    return &#x27;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.superclass.prototype" id="apidoc.module.livescript.ast.Literal.superclass.prototype">module livescript.ast.Literal.superclass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass.prototype.constructor" id="apidoc.element.livescript.ast.Literal.superclass.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(){
  Atom.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass.prototype.isComplex" id="apidoc.element.livescript.ast.Literal.superclass.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass.prototype.show" id="apidoc.element.livescript.ast.Literal.superclass.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Obj" id="apidoc.module.livescript.ast.Obj">module livescript.ast.Obj</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.Obj" id="apidoc.element.livescript.ast.Obj.Obj">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ref: true
      }).addBody($$[$0]))));
break;
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.<span class="apidocCodeKeywordSpan">Obj</span>($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).named($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.compile" id="apidoc.element.livescript.ast.Obj.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>compile
        <span class="apidocSignatureSpan">(o, items, deepEq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
  case 0:
    return &#x27;&#x27;;
  case 1:
    return items[0].compile(o, LEVEL_LIST);
  }
  indent = o.indent, level = o.level;
  o.indent = indent + TAB;
  o.level = LEVEL_LIST;
  code = [items[i = 0].compile(o)];
  while (that = items[++i]) {
    code.push(&#x27;, &#x27;);
    target = that;
    if (deepEq) {
      if (target instanceof Var &#x26;&#x26; target.value === &#x27;_&#x27;) {
        target = Obj([Prop(Key(&#x27;__placeholder__&#x27;), Literal(true))]);
      } else if (target instanceof Obj || target instanceof Arr) {
        target.deepEq = true;
      }
    }
    code.push(target.compile(o));
  }
  if (~code.join(&#x22;&#x22;).indexOf(&#x27;\n&#x27;)) {
    code = [&#x22;\n&#x22; + o.indent].concat(slice$.call(code), [&#x22;\n&#x22; + indent]);
  }
  o.indent = indent;
  o.level = level;
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.superclass" id="apidoc.element.livescript.ast.Obj.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(){
  List.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Obj.prototype" id="apidoc.module.livescript.ast.Obj.prototype">module livescript.ast.Obj.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.asObj" id="apidoc.element.livescript.ast.Obj.prototype.asObj">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>asObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prototype = extend$((import$(Import, superclass).displayName = &#x27;Import&#x27;, Import), superclass).prototype, constructor
 = Import;
function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &#x26;&#x26; &#x27;All&#x27;;
  if (!all &#x26;&#x26; left instanceof Obj &#x26;&#x26; right.items) {
    return Obj(left.items.concat(right.<span class="apidocCodeKeywordSpan">asObj</span>().items));
  }
  return this$;
} function ctor$(){} ctor$.prototype = prototype;
Import.prototype.children = [&#x27;left&#x27;, &#x27;right&#x27;];
Import.prototype.show = function(){
  return this.all;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.compileNode" id="apidoc.element.livescript.ast.Obj.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var items, code, idt, dic, i$, len$, i, node, logic, rest, ref$, multi, key, val;
  items = this.items;
  if (!items.length) {
    return sn(this, this.front ? &#x27;({})&#x27; : &#x27;{}&#x27;);
  }
  code = [];
  idt = &#x27;\n&#x27; + (o.indent += TAB);
  dic = {};
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      code.push(idt, node.compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Splat || (node.key || node) instanceof Parens) {
      rest = items.slice(i);
      break;
    }
    if (logic) {
      if (node instanceof Prop) {
        node.val = (logic.first = node.val, logic);
      } else {
        node = Prop(node, (logic.first = node, logic));
      }
    }
    if (this.deepEq &#x26;&#x26; node instanceof Prop) {
      if (node.val instanceof Var &#x26;&#x26; node.val.value === &#x27;_&#x27;) {
        node.val = Obj([Prop(Key(&#x27;__placeholder__&#x27;), Literal(true))]);
      } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
        node.val.deepEq = true;
      }
    }
    if (multi) {
      code.push(&#x27;,&#x27;);
    } else {
      multi = true;
    }
    code.push(idt);
    if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        code.push(node.compileAccessor(o, key = key.compile(o)));
      } else {
        val.ripName(key);
        code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
      }
    } else {
      code.push(key = node.compile(o), &#x22;: &#x22;, key);
    }
    ID.test(key) || (key = Function(&#x22;return &#x22; + key)());
    if (!(dic[key + &#x22;.&#x22;] ^= 1)) {
      node.carp(&#x22;duplicate property \&#x22;&#x22; + key + &#x22;\&#x22;&#x22;);
    }
  }
  if (code.join(&#x22;&#x22;)) {
    code.push(&#x27;\n&#x27; + this.tab);
  }
  code = sn.apply(null, [null, sn(this, &#x22;{&#x22;)].concat(slice$.call(code), [sn(this, &#x22;}&#x22;)]));
  rest &#x26;&#x26; (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
  if (this.front &#x26;&#x26; &#x27;{&#x27; === code.toString().charAt()) {
    return sn(null, &#x22;(&#x22;, code, &#x22;)&#x22;);
  } else {
    return code;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.constructor" id="apidoc.element.livescript.ast.Obj.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>constructor
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.toSlice" id="apidoc.element.livescript.ast.Obj.prototype.toSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>toSlice
        <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSlice = function (o, base, symbol, assign){
  var items, ref$, ref, temps, i$, len$, i, node, name, chain, logic, key, val;
  items = this.items;
  if (items.length &#x3e; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      continue;
    }
    if (node instanceof Prop || node instanceof Splat) {
      node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
    } else {
      if (logic = node.getDefault()) {
        node = node.first;
      }
      if (node instanceof Parens) {
        ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
        if (assign) {
          ref$ = [node, key], key = ref$[0], node = ref$[1];
        }
        key = Parens(key);
      } else {
        key = node;
      }
      val = chain = Chain(base, [Index(node.maybeKey(), symbol)]);
      if (logic) {
        val = (logic.first = val, logic);
      }
      items[i] = Prop(key, val);
    }
    base = ref;
  }
  chain || this.carp(&#x27;empty slice&#x27;);
  if (temps) {
    (chain.head = Var(temps[0])).temp = true;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &#x26;&#x26; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp(&#x27;calling a slice&#x27;);
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.<span class="apidocCodeKeywordSpan">toSlice</span>(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
};
return Chain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens" id="apidoc.module.livescript.ast.Parens">module livescript.ast.Parens</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.Parens" id="apidoc.element.livescript.ast.Parens.Parens">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 161:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], true)), yy.L(_$[$0-1],_$[$0-1],yy.Literal($$[$0-1] === &#
x27;+&#x27;))));
break;
case 168:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-2]);
break;
case 169:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Parens</span>($$[$0-1].chomp().unwrap(), false, $$[$0-2] === &#
x27;&#x22;&#x27;, yy.L(_$[$0-2],_$[$0-2],{}), yy.L(_$[$0],_$[$0],{})));
break;
case 173: case 209: case 211:
this.$ = yy.L(_$[$0], _$[$0],null);
break;
case 174: case 208: case 210:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.superclass" id="apidoc.element.livescript.ast.Parens.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype" id="apidoc.module.livescript.ast.Parens.prototype">module livescript.ast.Parens.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.compile" id="apidoc.element.livescript.ast.Parens.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var it;
  level == null &#x26;&#x26; (level = o.level);
  it = this.it;
  it.cond || (it.cond = this.cond), it[&#x27;void&#x27;] || (it[&#x27;void&#x27;] = this[&#x27;void&#x27;]);
  if (this.calling &#x26;&#x26; (!level || this[&#x27;void&#x27;])) {
    it.head.hushed = true;
  }
  if (!(this.keep || this.newed || level &#x3e;= LEVEL_OP + PREC[it.op])) {
    return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
  }
  if (it.isStatement()) {
    return it.compileClosure(o);
  } else {
    return sn(null, sn(this.lb, &#x22;(&#x22;), it.compile(o, LEVEL_PAREN), sn(this.rb, &#x22;)&#x22;));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.constructor" id="apidoc.element.livescript.ast.Parens.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isArray" id="apidoc.element.livescript.ast.Parens.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isCallable" id="apidoc.element.livescript.ast.Parens.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isComplex" id="apidoc.element.livescript.ast.Parens.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isComplex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isRegex" id="apidoc.element.livescript.ast.Parens.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isString" id="apidoc.element.livescript.ast.Parens.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  return this.string || this.it.isString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.show" id="apidoc.element.livescript.ast.Parens.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.string &#x26;&#x26; &#x27;&#x22;&#x22;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.unparen" id="apidoc.element.livescript.ast.Parens.prototype.unparen">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>unparen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unparen = function (){
  if (this.keep) {
    return this;
  } else {
    return this.it.unparen();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Block.prototype.children = [&#x27;lines&#x27;];
Block.prototype.toJSON = function(){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
};
Block.prototype.add = function(it){
  var that, ref$;
  it = it.<span class="apidocCodeKeywordSpan">unparen</span>();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop" id="apidoc.module.livescript.ast.Prop">module livescript.ast.Prop</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.Prop" id="apidoc.element.livescript.ast.Prop.Prop">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === &#x27;...&#x27;) {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
    }
    this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Prop</span>(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== &#x27
;arguments&#x27; &#x26;&#x26; $$[$0] !== &#x27;eval&#x27;)), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
case 152:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Literal($$[$0-2])), [yy.L(_$[$0-1],_$[$0], yy.
Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.superclass" id="apidoc.element.livescript.ast.Prop.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype" id="apidoc.module.livescript.ast.Prop.prototype">module livescript.ast.Prop.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.assigns" id="apidoc.element.livescript.ast.Prop.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  var ref$;
  return typeof (ref$ = this.val).assigns == &#x27;function&#x27; ? ref$.assigns(it) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor" id="apidoc.element.livescript.ast.Prop.prototype.compileAccessor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileAccessor
        <span class="apidocSignatureSpan">(o, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAccessor = function (o, key){
  var funs, code, i$, len$, fun;
  funs = this.val;
  if (funs[1] &#x26;&#x26; funs[0].params.length + funs[1].params.length !== 1) {
    funs[0].carp(&#x27;invalid accessor parameter&#x27;);
  }
  code = [];
  for (i$ = 0, len$ = funs.length; i$ &#x3c; len$; ++i$) {
    fun = funs[i$];
    fun.accessor = true;
    code.push(fun.x, &#x22;et &#x22;, key, fun.compile(o, LEVEL_LIST).toString().slice(8), &#x27;,\n&#x27; + o.indent);
  }
  code.pop();
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  multi = true;
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.<span class="apidocCodeKeywordSpan">compileAccessor</span>(o, key = key.compile(o)));
  } else {
    val.ripName(key);
    code.push(key = key.compile(o), &#x22;: &#x22;, val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), &#x22;: &#x22;, key);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor" id="apidoc.element.livescript.ast.Prop.prototype.compileDescriptor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileDescriptor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDescriptor = function (o){
  var obj, i$, ref$, len$, fun;
  obj = Obj();
  for (i$ = 0, len$ = (ref$ = this.val).length; i$ &#x3c; len$; ++i$) {
    fun = ref$[i$];
    obj.items.push(Prop(Key(fun.x + &#x27;et&#x27;), fun));
  }
  obj.items.push(Prop(Key(&#x27;configurable&#x27;), Literal(true)));
  obj.items.push(Prop(Key(&#x27;enumerable&#x27;), Literal(true)));
  return obj.compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
} else if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    if (key instanceof Key) {
      key = JS(&#x22;&#x27;&#x22; + key.name + &#x22;&#x27;&#x22;);
    }
    code.push(&#x22;Object.defineProperty(&#x22;, reft.compile(o, LEVEL_LIST), &#x22;, &#x22;, key.compile(o, LEVEL_LIST), &#x22
;, &#x22;, node.<span class="apidocCodeKeywordSpan">compileDescriptor</span>(o), &#x22;)&#x22;);
    continue;
  }
} else {
  key = val = node;
}
dyna || (key = key.maybeKey());
logic &#x26;&#x26; (val = (logic.first = val, logic));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.constructor" id="apidoc.element.livescript.ast.Prop.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>constructor
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === &#x27;...&#x27;) {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
    }
    this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.show" id="apidoc.element.livescript.ast.Prop.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.accessor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Require" id="apidoc.module.livescript.ast.Require">module livescript.ast.Require</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Require.Require" id="apidoc.element.livescript.ast.Require.Require">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Require
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Require</span>($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require.superclass" id="apidoc.element.livescript.ast.Require.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Require.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Require.prototype" id="apidoc.module.livescript.ast.Require.prototype">module livescript.ast.Require.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Require.prototype.compile" id="apidoc.element.livescript.ast.Require.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
  getValue = function(item, throwError){
    switch (false) {
    case !(item instanceof Key):
      return item.name;
    case !(item instanceof Var):
      return item.value;
    case !(item instanceof Literal):
      return item.value;
    default:
      if (throwError) {
        return this$.carp(&#x27;invalid require! argument&#x27;);
      } else {
        return item;
      }
    }
  };
  processItem = function(item){
    var ref$, asg, value, asgValue, toAsg, main;
    ref$ = (function(){
      switch (false) {
      case !(item instanceof Prop):
        return [item.val, item.key];
      default:
        return [item, item];
      }
    }()), asg = ref$[0], value = ref$[1];
    asgValue = getValue(asg);
    toAsg = toString$.call(asgValue).slice(8, -1) === &#x27;String&#x27; ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
    value = stripString(getValue(value, true));
    main = Chain(CopyL(this, Var(&#x27;require&#x27;))).add(Call([Literal(&#x22;&#x27;&#x22; + value + &#x22;&#x27;&#x22;)]));
    return sn(item, Assign(toAsg, main).compile(o));
  };
  if (this.body.items != null) {
    code = [];
    for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ &#x3c; len$; ++i$) {
      item = ref$[i$];
      code.push(processItem(item), &#x22;;\n&#x22; + o.indent);
    }
    code.pop();
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, processItem(this.body));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require.prototype.constructor" id="apidoc.element.livescript.ast.Require.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>constructor
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Return" id="apidoc.module.livescript.ast.Return">module livescript.ast.Return</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Return.Return" id="apidoc.element.livescript.ast.Return.Return">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &#x26;&#x26; it.value !== &#x27;void&#x27;) {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.extended" id="apidoc.element.livescript.ast.Return.extended">
        function <span class="apidocSignatureSpan">livescript.ast.Return.</span>extended
        <span class="apidocSignatureSpan">(sub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extended = function (sub){
  sub.prototype.children = [&#x27;it&#x27;];
  this[sub.displayName.toLowerCase()] = sub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function THIS(){
return this;
}
function VOID(){}
UTILS = {
clone: &#x27;function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}&#x27;,
extend: &#x27;function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new
fun).constructor = sub;\n  if (typeof sup.extended == \&#x27;function\&#x27;) sup.<span class="apidocCodeKeywordSpan">extended</span>(sub);\n  return sub;\n}&#x27;,
bind: &#x27;function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}&#x27;,
&#x27;import&#x27;: &#x27;function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj
[key] = src[key];\n  return obj;\n}&#x27;,
importAll: &#x27;function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}&#x27;,
repeatString: &#x27;function(str, n){\n  for (var r = \&#x27;\&#x27;; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (str += str))
if (n &#x26; 1) r += str;\n  return r;\n}&#x27;,
repeatArray: &#x27;function(arr, n){\n  for (var r = []; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (arr = arr.concat(arr)))\n
    if (n &#x26; 1) r.push.apply(r, arr);\n  return r;\n}&#x27;,
&#x27;in&#x27;: &#x27;function(x, xs){\n  var i = -1, l = xs.length &#x3e;&#x3e;&#x3e; 0;\n  while (++i &#x3c; l) if (x === xs[i
]) return true;\n  return false;\n}&#x27;,
out: &#x27;typeof exports != \&#x27;undefined\&#x27; &#x26;&#x26; exports || this&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.superclass" id="apidoc.element.livescript.ast.Return.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Return.</span>superclass
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.throw" id="apidoc.element.livescript.ast.Return.throw">
        function <span class="apidocSignatureSpan">livescript.ast.Return.</span>throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Return.prototype" id="apidoc.module.livescript.ast.Return.prototype">module livescript.ast.Return.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.compileNode" id="apidoc.element.livescript.ast.Return.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that;
  return sn.apply(null, [this, &#x22;return&#x22;].concat(
    (that = this.it)
      ? [&#x27; &#x27;, that.compile(o, LEVEL_PAREN)]
      : [], [&#x22;;&#x22;]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.constructor" id="apidoc.element.livescript.ast.Return.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &#x26;&#x26; it.value !== &#x27;void&#x27;) {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.getJump" id="apidoc.element.livescript.ast.Return.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Slice" id="apidoc.module.livescript.ast.Slice">module livescript.ast.Slice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.Slice" id="apidoc.element.livescript.ast.Slice.Slice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &#x26;&#x26; (this$.from = Literal(0));
  if (this$.to &#x26;&#x26; this$.type === &#x27;to&#x27;) {
    this$.to = Binary(&#x27;+&#x27;, this$.to, Literal(&#x27;1&#x27;));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        target: $$[$0-7],
        from: yy.Literal(0),
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
case 37:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], yy.<span class="apidocCodeKeywordSpan">Slice</span>({
        type: $$[$0-2],
        target: $$[$0-6],
        from: $$[$0-3],
        to: $$[$0-1]
      }))));
break;
case 38:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.superclass" id="apidoc.element.livescript.ast.Slice.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Slice.prototype" id="apidoc.module.livescript.ast.Slice.prototype">module livescript.ast.Slice.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.compileNode" id="apidoc.element.livescript.ast.Slice.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var args;
  if (this.to &#x26;&#x26; this.type === &#x27;to&#x27;) {
    this.to = Binary(&#x27;||&#x27;, this.to, Literal(&#x27;9e9&#x27;));
  }
  args = [this.target, this.from];
  if (this.to) {
    args.push(this.to);
  }
  return Chain(Var(util(&#x27;slice&#x27;))).add(Index(Key(&#x27;call&#x27;), &#x27;.&#x27;, true)).add(Call(args)).compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.constructor" id="apidoc.element.livescript.ast.Slice.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>constructor
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &#x26;&#x26; (this$.from = Literal(0));
  if (this$.to &#x26;&#x26; this$.type === &#x27;to&#x27;) {
    this$.to = Binary(&#x27;+&#x27;, this$.to, Literal(&#x27;1&#x27;));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.show" id="apidoc.element.livescript.ast.Slice.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Splat" id="apidoc.module.livescript.ast.Splat">module livescript.ast.Splat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.Splat" id="apidoc.element.livescript.ast.Splat.Splat">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 54: case 167:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat($$[$0]));
break;
case 55:
this.$ = yy.L(_$[$0-5], _$[$0-2],$$[$0-5].concat($$[$0-2]));
break;
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Splat</span>($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.Block());
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.compileArray" id="apidoc.element.livescript.ast.Splat.compileArray">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>compileArray
        <span class="apidocSignatureSpan">(o, list, apply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileArray = function (o, list, apply){
  var index, i$, len$, node, args, atoms, ref$;
  expand(list);
  index = 0;
  for (i$ = 0, len$ = list.length; i$ &#x3c; len$; ++i$) {
    node = list[i$];
    if (node instanceof Splat) {
      break;
    }
    ++index;
  }
  if (index &#x3e;= list.length) {
    return sn(this, &#x27;&#x27;);
  }
  if (!list[1]) {
    return sn(this, (apply ? Object : ensureArray)(list[0].it).compile(o, LEVEL_LIST));
  }
  args = [];
  atoms = [];
  for (i$ = 0, len$ = (ref$ = list.splice(index, 9e9)).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node instanceof Splat) {
      if (atoms.length) {
        args.push(Arr(atoms.splice(0, 9e9)));
      }
      args.push(ensureArray(node.it));
    } else {
      atoms.push(node);
    }
  }
  if (atoms.length) {
    args.push(Arr(atoms));
  }
  return sn(null, (index
    ? Arr(list)
    : args.shift()).compile(o, LEVEL_CALL), sn(this, &#x22;.concat(&#x22;), List.compile(o, args), sn(this, &#x22;)&#x22;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
tails = this.tails;
i = -1;
while (call = tails[++i]) {
  if (!(args = call.args)) {
    continue;
  }
  ctx = call.method === &#x27;.call&#x27; &#x26;&#x26; (args = args.concat()).shift();
  if (!!snEmpty(args = Splat.<span class="apidocCodeKeywordSpan">compileArray</span>(o, args, true))) {
    continue;
  }
  if (call[&#x27;new&#x27;]) {
    this.splattedNewArgs = args;
  } else {
    if (!ctx &#x26;&#x26; tails[i - 1] instanceof Index) {
      ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.superclass" id="apidoc.element.livescript.ast.Splat.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Splat.prototype" id="apidoc.module.livescript.ast.Splat.prototype">module livescript.ast.Splat.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.assigns" id="apidoc.element.livescript.ast.Splat.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return this.it.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.compile" id="apidoc.element.livescript.ast.Splat.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return this.carp(&#x27;invalid splat&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.constructor" id="apidoc.element.livescript.ast.Splat.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.isAssignable" id="apidoc.element.livescript.ast.Splat.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.isComplex" id="apidoc.element.livescript.ast.Splat.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isComplex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$[&#x27;void&#x27;] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.StepSlice" id="apidoc.module.livescript.ast.StepSlice">module livescript.ast.StepSlice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.StepSlice" id="apidoc.element.livescript.ast.StepSlice.StepSlice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        op: $$[$0-4],
        to: $$[$0-3],
        step: $$[$0-1],
        inComprehension: true
      }))));
break;
case 35:
this.$ = yy.L(_$[$0-8], _$[$0],yy.Chain(yy.L(_$[$0-8],_$[$0], new yy.<span class="apidocCodeKeywordSpan">StepSlice</span>({
        op: $$[$0-4],
        target: $$[$0-8],
        from: $$[$0-5],
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.superclass" id="apidoc.element.livescript.ast.StepSlice.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.</span>superclass
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &#x26;&#x26; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &#x3c; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &#x26;&#x26; !this.object) {
    this.carp(&#x27;`for own` requires `of`&#x27;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.StepSlice.prototype" id="apidoc.module.livescript.ast.StepSlice.prototype">module livescript.ast.StepSlice.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode" id="apidoc.element.livescript.ast.StepSlice.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var ref$, sub, ref, temps, code;
  this.index = o.scope.temporary(&#x27;x&#x27;);
  ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
  this.guard = Binary(&#x27;&#x3c;&#x27;, Literal(this.index), Chain(ref).add(Index(Key(&#x27;length&#x27;))));
  this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
  if (this.makeReturnArg != null) {
    this.makeReturn(this.makeReturnArg);
  }
  code = [];
  if (temps) {
    code.push(sub.compile(o), &#x27;;&#x27; + &#x27;\n&#x27; + o.indent);
  }
  code.push(superclass.prototype.compileNode.apply(this, arguments));
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.constructor" id="apidoc.element.livescript.ast.StepSlice.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn" id="apidoc.element.livescript.ast.StepSlice.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(makeReturnArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (makeReturnArg){
  this.makeReturnArg = makeReturnArg;
  return superclass.prototype.makeReturn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Super" id="apidoc.module.livescript.ast.Super">module livescript.ast.Super</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Super.Super" id="apidoc.element.livescript.ast.Super.Super">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.superclass" id="apidoc.element.livescript.ast.Super.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Super.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Super.prototype" id="apidoc.module.livescript.ast.Super.prototype">module livescript.ast.Super.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.compile" id="apidoc.element.livescript.ast.Super.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var scope, that, result, ref$;
  scope = o.scope;
  if (!this.sproto) {
    for (; that = !scope.get(&#x27;superclass&#x27;) &#x26;&#x26; scope.fun; scope = scope.parent) {
      result = that;
      if (that = result.meth) {
        return sn(this, &#x27;superclass.prototype&#x27;, Index(that).compile(o));
      }
      if (that = result.stat) {
        return sn(this, &#x27;superclass&#x27;, Index(that).compile(o));
      }
      if (that = scope.fun.inClass) {
        return sn(this, that, &#x22;.superclass.prototype.&#x22;, scope.fun.name);
      } else if (that = scope.fun.inClassStatic) {
        return sn(this, that, &#x22;.superclass.&#x22;, scope.fun.name);
      }
    }
    if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
      return sn(this, that, &#x22;.superclass&#x22;);
    }
  }
  return sn(this, &#x27;superclass&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.constructor" id="apidoc.element.livescript.ast.Super.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.isCallable" id="apidoc.element.livescript.ast.Super.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch" id="apidoc.module.livescript.ast.Switch">module livescript.ast.Switch</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.Switch" id="apidoc.element.livescript.ast.Switch.Switch">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this[&#x27;default&#x27;] = $default;
  if (type === &#x27;match&#x27;) {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &#x3e; 1) {
        throw &#x22;can&#x27;t have more than one topic in switch statement&#x22;;
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &#x26;&#x26; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &#x26;&#x26; last.tests[0] instanceof Var &#x26;&#x26; last
.tests[0].value === &#x27;_&#x27;) {
    this.cases.pop();
    this[&#x27;default&#x27;] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.Jump($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Switch</span>($$[$0-2], $$[$0-1], $$[$0]));
break;
case 129: case 130:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]));
break;
case 131:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.superclass" id="apidoc.element.livescript.ast.Switch.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype" id="apidoc.module.livescript.ast.Switch.prototype">module livescript.ast.Switch.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.compileNode" id="apidoc.element.livescript.ast.Switch.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var tab, ref$, targetNode, target, topic, t, code, stop, i$, len$, i, c, that;
  tab = this.tab;
  if (this.target) {
    ref$ = Chain(this.target).cacheReference(o), targetNode = ref$[0], target = ref$[1];
  }
  topic = this.type === &#x27;match&#x27;
    ? (t = target
      ? [targetNode]
      : [], Block(t.concat([Literal(&#x27;false&#x27;)])).compile(o, LEVEL_PAREN))
    : !!this.topic &#x26;&#x26; this.anaphorize().compile(o, LEVEL_PAREN);
  code = [sn(this, &#x22;switch (&#x22;, snSafe(topic), &#x22;) {\n&#x22;)];
  stop = this[&#x27;default&#x27;] || this.cases.length - 1;
  o[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    i = i$;
    c = ref$[i$];
    code.push(c.compileCase(o, tab, i === stop, this.type === &#x27;match&#x27; || !topic, this.type, target));
  }
  if (this[&#x27;default&#x27;]) {
    o.indent = tab + TAB;
    if (that = this[&#x27;default&#x27;].compile(o, LEVEL_TOP)) {
      code.push(tab + &#x22;default:\n&#x22;, that, &#x22;\n&#x22;);
    }
  }
  return sn.apply(null, [null].concat(slice$.call(code), [tab + &#x27;}&#x27;]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.constructor" id="apidoc.element.livescript.ast.Switch.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>constructor
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this[&#x27;default&#x27;] = $default;
  if (type === &#x27;match&#x27;) {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &#x3e; 1) {
        throw &#x22;can&#x27;t have more than one topic in switch statement&#x22;;
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &#x26;&#x26; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &#x26;&#x26; last.tests[0] instanceof Var &#x26;&#x26; last
.tests[0].value === &#x27;_&#x27;) {
    this.cases.pop();
    this[&#x27;default&#x27;] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.getJump" id="apidoc.element.livescript.ast.Switch.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var i$, ref$, len$, c, that;
  ctx || (ctx = {});
  ctx[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    if (that = c.body.getJump(ctx)) {
      return that;
    }
  }
  return (ref$ = this[&#x27;default&#x27;]) != null ? ref$.getJump(ctx) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.isCallable" id="apidoc.element.livescript.ast.Switch.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    if (!c.isCallable()) {
      return false;
    }
  }
  if (this[&#x27;default&#x27;]) {
    return this[&#x27;default&#x27;].isCallable();
  } else {
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.isStatement" id="apidoc.element.livescript.ast.Switch.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn" id="apidoc.element.livescript.ast.Switch.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &#x3c; len$; ++i$) {
    c = ref$[i$];
    c.makeReturn.apply(c, arguments);
  }
  if ((ref$ = this[&#x27;default&#x27;]) != null) {
    ref$.makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.show" id="apidoc.element.livescript.ast.Switch.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Throw" id="apidoc.module.livescript.ast.Throw">module livescript.ast.Throw</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.Throw" id="apidoc.element.livescript.ast.Throw.Throw">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Throw</span>(yy.L(_$[$0],_$[$0],yy.JS(&#x22;Error(&#x27;unimplemented
&#x27;)&#x22;))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.extended" id="apidoc.element.livescript.ast.Throw.extended">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>extended
        <span class="apidocSignatureSpan">(sub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extended = function (sub){
  sub.prototype.children = [&#x27;it&#x27;];
  this[sub.displayName.toLowerCase()] = sub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function THIS(){
return this;
}
function VOID(){}
UTILS = {
clone: &#x27;function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}&#x27;,
extend: &#x27;function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new
fun).constructor = sub;\n  if (typeof sup.extended == \&#x27;function\&#x27;) sup.<span class="apidocCodeKeywordSpan">extended</span>(sub);\n  return sub;\n}&#x27;,
bind: &#x27;function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}&#x27;,
&#x27;import&#x27;: &#x27;function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj
[key] = src[key];\n  return obj;\n}&#x27;,
importAll: &#x27;function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}&#x27;,
repeatString: &#x27;function(str, n){\n  for (var r = \&#x27;\&#x27;; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (str += str))
if (n &#x26; 1) r += str;\n  return r;\n}&#x27;,
repeatArray: &#x27;function(arr, n){\n  for (var r = []; n &#x3e; 0; (n &#x3e;&#x3e;= 1) &#x26;&#x26; (arr = arr.concat(arr)))\n
    if (n &#x26; 1) r.push.apply(r, arr);\n  return r;\n}&#x27;,
&#x27;in&#x27;: &#x27;function(x, xs){\n  var i = -1, l = xs.length &#x3e;&#x3e;&#x3e; 0;\n  while (++i &#x3c; l) if (x === xs[i
]) return true;\n  return false;\n}&#x27;,
out: &#x27;typeof exports != \&#x27;undefined\&#x27; &#x26;&#x26; exports || this&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.superclass" id="apidoc.element.livescript.ast.Throw.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>superclass
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Throw.prototype" id="apidoc.module.livescript.ast.Throw.prototype">module livescript.ast.Throw.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.compileNode" id="apidoc.element.livescript.ast.Throw.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var ref$;
  return sn(this, &#x22;throw &#x22;, ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;null&#x27;, &#x22;;&#x22;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.constructor" id="apidoc.element.livescript.ast.Throw.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.getJump" id="apidoc.element.livescript.ast.Throw.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try" id="apidoc.module.livescript.ast.Try">module livescript.ast.Try</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.Try" id="apidoc.element.livescript.ast.Try.Try">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Try
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var(&#x27;e&#x27;), Var(&#x27;e$&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 132: case 133:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]));
break;
case 134:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, [], $$[$0]));
break;
case 135:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Try</span>($$[$0]));
break;
case 136:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 137:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.Try($$[$0-4], void 8, yy.L(_$[$0-3],_$[$0-3],$$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.superclass" id="apidoc.element.livescript.ast.Try.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Try.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype" id="apidoc.module.livescript.ast.Try.prototype">module livescript.ast.Try.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.compileNode" id="apidoc.element.livescript.ast.Try.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var code, that;
  o.indent += TAB;
  code = [sn(this, &#x27;try &#x27;), this.compileBlock(o, this.attempt)];
  if (that = this.recovery || !this.ensure &#x26;&#x26; JS(&#x27;&#x27;)) {
    code.push(sn(that, &#x27; catch (e$) &#x27;), this.compileBlock(o, that));
  }
  if (that = this.ensure) {
    code.push(sn(that, &#x27; finally &#x27;), this.compileBlock(o, that));
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.constructor" id="apidoc.element.livescript.ast.Try.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>constructor
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var(&#x27;e&#x27;), Var(&#x27;e$&#x27;)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.getJump" id="apidoc.element.livescript.ast.Try.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var ref$;
  return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.isCallable" id="apidoc.element.livescript.ast.Try.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) &#x26;&#x26; this.attempt.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.isStatement" id="apidoc.element.livescript.ast.Try.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.makeReturn" id="apidoc.element.livescript.ast.Try.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
  if (this.recovery != null) {
    this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.show" id="apidoc.element.livescript.ast.Try.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.thrown;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary" id="apidoc.module.livescript.ast.Unary">module livescript.ast.Unary</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.Unary" id="apidoc.element.livescript.ast.Unary.Unary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &#x26;&#x26; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case &#x27;!&#x27;:
      if (flag) {
        break;
      }
      if (it instanceof Fun &#x26;&#x26; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case &#x27;++&#x27;:
    case &#x27;--&#x27;:
      if (flag) {
        this$.post = true;
      }
      break;
    case &#x27;new&#x27;:
      if (it instanceof Existence &#x26;&#x26; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || &#x27;&#x27;).length; i$ &#x3c; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &#x26;&#x26; !node[&#x27;new&#x27;]) {
          if (node.method === &#x27;.call&#x27;) {
            node.args.shift();
          }
          node[&#x27;new&#x27;] = &#x27;new&#x27;;
          node.method = &#x27;&#x27;;
          return it;
        }
      }
      break;
    case &#x27;~&#x27;:
      if (it instanceof Fun &#x26;&#x26; it.statement &#x26;&#x26; !it.bound) {
        return it.bound = &#x27;this$&#x27;, it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 21:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-5],yy.Binary($$[$0-5], void 8, $$[$0-3]))));
break;
case 23:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-4]))));
break;
case 24: case 25:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Unary</span>($$[$0-1]))));
break;
case 26:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.superclass" id="apidoc.element.livescript.ast.Unary.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype" id="apidoc.module.livescript.ast.Unary.prototype">module livescript.ast.Unary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc" id="apidoc.element.livescript.ast.Unary.prototype.compileAsFunc">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileAsFunc
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAsFunc = function (o){
  if (this.op === &#x27;!&#x27;) {
    return sn(this, util(&#x27;not&#x27;));
  } else {
    return sn(this, &#x22;(&#x22;, Fun([], Block(Unary(this.op, Chain(Var(&#x27;it&#x27;))))).compile(o), &#x22;)&#x22;);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;++&#x27;: &#x27;in&#x27;,
    &#x27;--&#x27;: &#x27;de&#x27;
  }[it] + &#x27;crement&#x27;;
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.<span class="apidocCodeKeywordSpan">compileAsFunc</span>(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileNode" id="apidoc.element.livescript.ast.Unary.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
    it.cond = true;
    break;
  case &#x27;new&#x27;:
    it.isCallable() || it.carp(&#x27;invalid constructor&#x27;);
    break;
  case &#x27;do&#x27;:
    if (o.level === LEVEL_TOP &#x26;&#x26; it instanceof Fun &#x26;&#x26; it.isStatement()) {
      return sn(this, it.compile(o), &#x22; &#x22;, Unary(&#x27;do&#x27;, Var(it.name)).compile(o));
    }
    x = Parens(it instanceof Existence &#x26;&#x26; !it.negated
      ? Chain(it).add(Call())
      : Call.make(it));
    return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
  case &#x27;delete&#x27;:
    if (it instanceof Var || !it.isAssignable()) {
      this.carp(&#x27;invalid delete&#x27;);
    }
    if (o.level &#x26;&#x26; !this[&#x27;void&#x27;]) {
      return this.compilePluck(o);
    }
    break;
  case &#x27;++&#x27;:
  case &#x27;--&#x27;:
    it.isAssignable() || this.carp(&#x27;invalid &#x27; + crement(op));
    if (that = it instanceof Var &#x26;&#x26; o.scope.checkReadOnly(it.value)) {
      this.carp(crement(op) + &#x22; of &#x22; + that + &#x22; \&#x22;&#x22; + it.value + &#x22;\&#x22;&#x22;, ReferenceError);
    }
    if (this.post) {
      it.front = this.front;
    }
    break;
  case &#x27;^^&#x27;:
    return sn(this, util(&#x27;clone&#x27;), &#x22;(&#x22;, it.compile(o, LEVEL_LIST), &#x22;)&#x22;);
  case &#x27;jsdelete&#x27;:
    return sn(this, &#x22;delete &#x22;, it.compile(o, LEVEL_LIST));
  case &#x27;classof&#x27;:
    return sn(this, util(&#x27;toString&#x27;), &#x22;.call(&#x22;, it.compile(o, LEVEL_LIST), &#x22;).slice(8, -1)&#x22;);
  }
  code = [it.compile(o, LEVEL_OP + PREC.unary)];
  if (this.post) {
    code.push(op);
  } else {
    if ((op === &#x27;new&#x27; || op === &#x27;typeof&#x27; || op === &#x27;delete&#x27;) || (op === &#x27;+&#x27; || op === &#x27;-&#x27;) &#x26;&#x26; op === code.join(&#x22;&#x22;).charAt()) {
      op += &#x27; &#x27;;
    }
    code.unshift(op);
  }
  if (o.level &#x3c; LEVEL_CALL) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck" id="apidoc.element.livescript.ast.Unary.prototype.compilePluck">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compilePluck
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePluck = function (o){
  var ref$, get, del, code, ref;
  ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
  code = [ref = o.scope.temporary(), &#x22; = &#x22;, get.compile(o, LEVEL_LIST), &#x22;, delete &#x22;, del.compile(o, LEVEL_LIST), &#x22;, &#x22;, o.scope.free
(ref)];
  if (o.level &#x3c; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    : Call.make(it));
  return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
case &#x27;delete&#x27;:
  if (it instanceof Var || !it.isAssignable()) {
    this.carp(&#x27;invalid delete&#x27;);
  }
  if (o.level &#x26;&#x26; !this[&#x27;void&#x27;]) {
    return this.<span class="apidocCodeKeywordSpan">compilePluck</span>(o);
  }
  break;
case &#x27;++&#x27;:
case &#x27;--&#x27;:
  it.isAssignable() || this.carp(&#x27;invalid &#x27; + crement(op));
  if (that = it instanceof Var &#x26;&#x26; o.scope.checkReadOnly(it.value)) {
    this.carp(crement(op) + &#x22; of &#x22; + that + &#x22; \&#x22;&#x22; + it.value + &#x22;\&#x22;&#x22;, ReferenceError);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread" id="apidoc.element.livescript.ast.Unary.prototype.compileSpread">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileSpread
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpread = function (o){
  var it, ops;
  it = this.it;
  ops = [this];
  for (; it instanceof constructor; it = it.it) {
    ops.push(it);
  }
  if (!(it instanceof Splat &#x26;&#x26; (it = it.it.expandSlice(o).unwrap()) instanceof List)) {
    return &#x27;&#x27;;
  }
  return this.compileSpreadOver(o, it, function(node){
    var i$, ref$, op;
    for (i$ = (ref$ = ops).length - 1; i$ &#x3e;= 0; --i$) {
      op = ref$[i$];
      node = constructor(op.op, node, op.post);
    }
    return node;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }[it] + &#x27;crement&#x27;;
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.<span class="apidocCodeKeywordSpan">compileSpread</span>(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case &#x27;!&#x27;:
    it.cond = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.constructor" id="apidoc.element.livescript.ast.Unary.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>constructor
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &#x26;&#x26; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case &#x27;!&#x27;:
      if (flag) {
        break;
      }
      if (it instanceof Fun &#x26;&#x26; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case &#x27;++&#x27;:
    case &#x27;--&#x27;:
      if (flag) {
        this$.post = true;
      }
      break;
    case &#x27;new&#x27;:
      if (it instanceof Existence &#x26;&#x26; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || &#x27;&#x27;).length; i$ &#x3c; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &#x26;&#x26; !node[&#x27;new&#x27;]) {
          if (node.method === &#x27;.call&#x27;) {
            node.args.shift();
          }
          node[&#x27;new&#x27;] = &#x27;new&#x27;;
          node.method = &#x27;&#x27;;
          return it;
        }
      }
      break;
    case &#x27;~&#x27;:
      if (it instanceof Fun &#x26;&#x26; it.statement &#x26;&#x26; !it.bound) {
        return it.bound = &#x27;this$&#x27;, it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors" id="apidoc.element.livescript.ast.Unary.prototype.getAccessors">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>getAccessors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAccessors = function (){
  var items;
  if (this.op !== &#x27;~&#x27;) {
    return;
  }
  if (this.it instanceof Fun) {
    return [this.it];
  }
  if (this.it instanceof Arr) {
    items = this.it.items;
    if (!items[2] &#x26;&#x26; items[0] instanceof Fun &#x26;&#x26; items[1] instanceof Fun) {
      return items;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function Prop(key, val){
var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
this$.key = key;
this$.val = val;
if (key.value === &#x27;...&#x27;) {
  return Splat(this$.val);
}
if (that = val.<span class="apidocCodeKeywordSpan">getAccessors</span>()) {
  this$.val = that;
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    fun = that[i$];
    fun.x = (fun.hushed = fun.params.length) ? &#x27;s&#x27; : &#x27;g&#x27;;
  }
  this$[&#x27;accessor&#x27;] = &#x27;accessor&#x27;;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.invert" id="apidoc.element.livescript.ast.Unary.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  var ref$;
  if (this.op === &#x27;!&#x27; &#x26;&#x26; ((ref$ = this.it.op) === &#x27;!&#x27; || ref$ === &#x27;&#x3c;&#x27; || ref$ === &#x27;&#x3e;&#x27; || ref$ === &#x27;&#x3c;=&#x27; || ref$ === &#x27;&#x3e;=&#x27; || ref$ === &#x27;
of&#x27; || ref$ === &#x27;instanceof&#x27;)) {
    return this.it;
  }
  return constructor(&#x27;!&#x27;, this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary(&#x27;!&#x27;, this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this[&#x27;else&#x27;] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isArray" id="apidoc.element.livescript.ast.Unary.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  return this.it instanceof Arr &#x26;&#x26; this.it.items.length || this.it instanceof Chain &#x26;&#x26; this.it.isArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isCallable" id="apidoc.element.livescript.ast.Unary.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return ((ref$ = this.op) === &#x27;do&#x27; || ref$ === &#x27;new&#x27; || ref$ === &#x27;delete&#x27;) || this.it == null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isString" id="apidoc.element.livescript.ast.Unary.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  var ref$;
  return (ref$ = this.op) === &#x27;typeof&#x27; || ref$ === &#x27;classof&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.show" id="apidoc.element.livescript.ast.Unary.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.post ? &#x27;@&#x27; : void 8] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Unary.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var ref$;
  return ((ref$ = this.op) === &#x27;++&#x27; || ref$ === &#x27;--&#x27; || ref$ === &#x27;delete&#x27;) &#x26;&#x26; this.it != null &#x26;&#x26; If.unfoldSoak(o, this, &#x27;it&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &#x26;&#x26; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Util" id="apidoc.module.livescript.ast.Util">module livescript.ast.Util</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Util.Util" id="apidoc.element.livescript.ast.Util.Util">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Util
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.Extends" id="apidoc.element.livescript.ast.Util.Extends">
        function <span class="apidocSignatureSpan">livescript.ast.Util.</span>Extends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Extends = function (){
  return Call.make(Util(&#x27;extend&#x27;), [arguments[0], arguments[1]]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctor.body.lines.unshift(Assign(Chain(Literal(&#x27;this&#x27;)).add(Index(Key(&#x22;_&#x22; + f.name))), Chain(Var(util(&#x27;
curry&#x27;))).add(Call([Chain(Var(&#x27;prototype&#x27;)).add(Index(f)), Var(&#x27;true&#x27;)]))), Assign(Chain(Literal(&#x27;
this&#x27;)).add(Index(f)), Chain(Var(util(&#x27;bind&#x27;))).add(Call([Literal(&#x27;this&#x27;), Literal(&#x22;&#x27;_&#x22; +
f.name + &#x22;&#x27;&#x22;)]))));
}
lines.push(vname);
args = [];
if (that = this.sup) {
  args.push(that);
  imports = Chain(Import(Literal(&#x27;this&#x27;), Var(&#x27;superclass&#x27;)));
  fun.proto = Util.<span class="apidocCodeKeywordSpan">Extends</span>(fun.cname ? Block([Assign(imports.add(Index(Key(&#x27;displayName
&#x27;))), Literal(&#x22;&#x27;&#x22; + name + &#x22;&#x27;&#x22;)), Literal(name)]) : imports, (ref$ = fun.params)[ref$.length] =
Var(&#x27;superclass&#x27;));
}
if (that = this.mixins) {
  res$ = [];
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    args[args.length] = that[i$];
    res$.push(Import(proto, JS(&#x22;arguments[&#x22; + (args.length - 1) + &#x22;]&#x22;), true));
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.superclass" id="apidoc.element.livescript.ast.Util.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Util.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Util.prototype" id="apidoc.module.livescript.ast.Util.prototype">module livescript.ast.Util.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.compile" id="apidoc.element.livescript.ast.Util.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return sn(this, util(this.verb));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.constructor" id="apidoc.element.livescript.ast.Util.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>constructor
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.isCallable" id="apidoc.element.livescript.ast.Util.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.show" id="apidoc.element.livescript.ast.Util.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return (this.verb || &#x27;&#x27;) + ((that = this.label) ? &#x27; &#x27; + that : &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var" id="apidoc.module.livescript.ast.Var">module livescript.ast.Var</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.Var" id="apidoc.element.livescript.ast.Var.Var">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Var
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Var</span>($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.superclass" id="apidoc.element.livescript.ast.Var.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Var.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(){
  Atom.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype" id="apidoc.module.livescript.ast.Var.prototype">module livescript.ast.Var.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.assigns" id="apidoc.element.livescript.ast.Var.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return it === this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.compile" id="apidoc.element.livescript.ast.Var.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  return sn(this, this.temp
    ? o.scope.free(this.value)
    : this.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.constructor" id="apidoc.element.livescript.ast.Var.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.isAssignable" id="apidoc.element.livescript.ast.Var.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === &#x27;.~&#x27;) {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &#x3c; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.isCallable" id="apidoc.element.livescript.ast.Var.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.maybeKey" id="apidoc.element.livescript.ast.Var.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeKey = function (){
  var ref$;
  return ref$ = Key(this.value), ref$.line = this.line, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &#x3c; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.varName" id="apidoc.element.livescript.ast.Var.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? &#x27;?&#x27; : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &#x26;&#x26; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &#x26;&#x26; &#x27;\&#x27;&#x27; !== code.toString().charAt(0)) {
    return sn(this, &#x22;.&#x22;, code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Vars" id="apidoc.module.livescript.ast.Vars">module livescript.ast.Vars</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.Vars" id="apidoc.element.livescript.ast.Vars.Vars">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.superclass" id="apidoc.element.livescript.ast.Vars.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Vars.prototype" id="apidoc.module.livescript.ast.Vars.prototype">module livescript.ast.Vars.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.compile" id="apidoc.element.livescript.ast.Vars.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var i$, ref$, len$, v, value;
  for (i$ = 0, len$ = (ref$ = this.vars).length; i$ &#x3c; len$; ++i$) {
    v = ref$[i$], value = v.value;
    if (!(v instanceof Var)) {
      v.carp(&#x27;invalid variable declaration&#x27;);
    }
    if (o.scope.check(value)) {
      v.carp(&#x22;redeclaration of \&#x22;&#x22; + value + &#x22;\&#x22;&#x22;);
    }
    o.scope.declare(value, v);
  }
  return sn(this, Literal(&#x27;void&#x27;).compile(o, level));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal(&#x27;arguments&#x27;));
    fun.params.push(Var(&#x27;args$&#x27;));
  }
  out = Parens(Chain((fun.wrapper = true, fun[&#x27;void&#x27;] = this[&#x27;void&#x27;], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield(&#x27;yieldfrom&#x27;, out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, &#x22;{\n&#x22;, code, &#x22;\n&#x22; + this.tab + &#x22;}&#x22;);
  } else {
    return sn(node, &#x27;{}&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.constructor" id="apidoc.element.livescript.ast.Vars.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>constructor
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.makeReturn" id="apidoc.element.livescript.ast.Vars.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While" id="apidoc.module.livescript.ast.While">module livescript.ast.While</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.While" id="apidoc.element.livescript.ast.While.While">
        function <span class="apidocSignatureSpan">livescript.ast.</span>While
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &#x26;&#x26; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== &#x27;&#x27; + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === &#x27;unless&#x27;)));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.<span class="apidocCodeKeywordSpan">While</span>($$[$0], $$[$0-1] === &#x27;until&#x27;, true
).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === &#x27;until&#x27;, true).addGuard($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.superclass" id="apidoc.element.livescript.ast.While.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.While.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype" id="apidoc.module.livescript.ast.While.prototype">module livescript.ast.While.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addBody" id="apidoc.element.livescript.ast.While.prototype.addBody">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBody = function (body){
  var top;
  this.body = body;
  if (this.guard) {
    this.body = Block(If(this.guard, this.body));
  }
  top = this.body.lines[0];
  if ((top != null ? top.verb : void 8) === &#x27;continue&#x27; &#x26;&#x26; !top.label) {
    this.body.lines.length = 0;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
While.prototype.show = function(){
  return [this.un ? &#x27;!&#x27; : void 8, this.post ? &#x27;do&#x27; : void 8].join(&#x27;&#x27;);
};
prototype.isStatement = prototype.isArray = YES;
While.prototype.makeComprehension = function(toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().<span class="apidocCodeKeywordSpan">addBody</span>(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
};
While.prototype.getJump = function(ctx){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addGuard" id="apidoc.element.livescript.ast.While.prototype.addGuard">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addGuard
        <span class="apidocSignatureSpan">(guard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addGuard = function (guard){
  this.guard = guard;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}), o(&#x27;Expression POST_IF Expression&#x27;, function(){
  return L(2, 3, If($3, $1, $2 === &#x27;unless&#x27;));
}), o(&#x27;LoopHead Block Else&#x27;, function(){
  return $1.addBody($2).addElse($3);
}), o(&#x27;DO Block WHILE Expression&#x27;, function(){
  return new While($4, $3 === &#x27;until&#x27;, true).addBody($2);
}), o(&#x27;DO Block WHILE Expression CASE Expression&#x27;, function(){
  return new While($4, $3 === &#x27;until&#x27;, true).<span class="apidocCodeKeywordSpan">addGuard</span>($6).addBody($2);
}), o(&#x27;HURL Expression&#x27;, function(){
  return Jump[$1]($2);
}), o(&#x27;HURL INDENT ArgList OptComma DEDENT&#x27;, function(){
  return Jump[$1](Arr.maybe($3));
}), o(&#x27;HURL&#x27;, function(){
  return Jump[$1]();
}), o(&#x27;JUMP&#x27;, function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addObjComp" id="apidoc.element.livescript.ast.While.prototype.addObjComp">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addObjComp
        <span class="apidocSignatureSpan">(objComp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addObjComp = function (objComp){
  this.objComp = objComp != null ? objComp : true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}), o(&#x27;LET CALL( ArgList OptComma )CALL Block&#x27;, function(){
  return Chain(L(1, 5, Call[&#x27;let&#x27;]($3, $6)));
}), o(&#x27;[ Expression LoopHeads ]&#x27;, function(){
  return Chain(L(1, 4, $3[0].makeComprehension($2, $3.slice(1))));
}), o(&#x27;[ Expression LoopHeads DEDENT ]&#x27;, function(){
  return Chain(L(1, 5, $3[0].makeComprehension($2, $3.slice(1))));
}), o(&#x27;{ [ ArgList OptComma ] LoopHeads }&#x27;, function(){
  return Chain(L(1, 7, $6[0].<span class="apidocCodeKeywordSpan">addObjComp</span>().makeComprehension(L(3, Arr($3)), $6.slice(1
))));
}), o(&#x27;( BIOP )&#x27;, function(){
  return Chain(L(2, Binary($2)));
}), o(&#x27;( BIOP Expression )&#x27;, function(){
  return Chain(L(2, Binary($2, void 8, $3)));
}), o(&#x27;( Expression BIOP )&#x27;, function(){
  return Chain(L(3, Binary($3, $2)));
}), o(&#x27;( BIOPR )&#x27;, function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileBody" id="apidoc.element.livescript.ast.While.prototype.compileBody">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileBody
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileBody = function (o){
  var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ =
this;
  o[&#x27;break&#x27;] = o[&#x27;continue&#x27;] = true;
  lines = this.body.lines, yet = this.yet, tab = this.tab;
  code = [];
  ret = [];
  mid = [];
  empty = this.objComp ? &#x27;{}&#x27; : &#x27;[]&#x27;;
  getResultName = function(){
    return _resultName != null
      ? _resultName
      : _resultName = o.scope.temporary(this$.objComp ? &#x27;resultObj&#x27; : &#x27;results&#x27;);
  };
  last = lines != null ? lines[lines.length - 1] : void 8;
  if (!(this.isComprehension || this.inComprehension) || (last != null &#x26;&#x26; last.isComprehension)) {
    hasLoop = false;
    if (last != null) {
      last.traverseChildren(function(it){
        var ref$;
        if (it instanceof Block &#x26;&#x26; (ref$ = it.lines)[ref$.length - 1] instanceof While) {
          hasLoop = true;
        }
      });
    }
    if (this.returns &#x26;&#x26; !this.resVar) {
      this.resVar = res = o.scope.assign(getResultName(), empty);
    }
    if (this.resVar &#x26;&#x26; (last instanceof While || hasLoop)) {
      temp = o.scope.temporary(&#x27;lresult&#x27;);
      lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
        ? Obj()
        : Arr(), &#x27;=&#x27;));
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(temp);
      }
      mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key(&#x27;push&#x27;), &#x27;.&#x27;, true)).add(Call([Chain(Var(temp))])).compile(o), &#x22;;\n&#x22; +
this.tab);
    } else {
      this.hasReturned = true;
      if (this.resVar) {
        this.body.makeReturn(this.resVar);
      }
    }
  }
  if (this.returns) {
    if ((!last instanceof While &#x26;&#x26; !this.hasReturned) || this.isComprehension || this.inComprehension) {
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
      }
    }
    ret.push(&#x22;\n&#x22; + this.tab + &#x22;return &#x22;, res || empty, &#x22;;&#x22;);
    if ((ref$ = this[&#x27;else&#x27;]) != null) {
      ref$.makeReturn();
    }
  }
  yet &#x26;&#x26; lines.unshift(JS(yet + &#x22; = false;&#x22;));
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(&#x22;\n&#x22;, bodyCode, &#x22;\n&#x22; + tab);
  }
  code.push.apply(code, mid);
  code.push(&#x27;}&#x27;);
  if (this.post) {
    code.push(sn(this, &#x22; while (&#x22;), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, &#x22;);&#x22;));
  }
  if (yet) {
    code.push(sn(this, &#x22; if (&#x22;), yet, sn(this, &#x22;) &#x22;), this.compileBlock(o, Block(this[&#x27;else&#x27;])));
    o.scope.free(yet);
  }
  return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  While.prototype.compileNode = function(o){
var test, ref$, head, that;
o.loop = true;
this.test &#x26;&#x26; (this.un
  ? this.test = this.test.invert()
  : this.anaphorize());
if (this.post) {
  return sn(null, sn(this, &#x27;do {&#x27;), this.<span class="apidocCodeKeywordSpan">compileBody</span>((o.indent += TAB, o)));
}
test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;&#x27;;
if (!(this.update || this[&#x27;else&#x27;])) {
  head = !snEmpty(test)
    ? [sn(this, &#x22;while (&#x22;), test]
    : [sn(this, &#x27;for (;;&#x27;)];
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileNode" id="apidoc.element.livescript.ast.While.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var test, ref$, head, that;
  o.loop = true;
  this.test &#x26;&#x26; (this.un
    ? this.test = this.test.invert()
    : this.anaphorize());
  if (this.post) {
    return sn(null, sn(this, &#x27;do {&#x27;), this.compileBody((o.indent += TAB, o)));
  }
  test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || &#x27;&#x27;;
  if (!(this.update || this[&#x27;else&#x27;])) {
    head = !snEmpty(test)
      ? [sn(this, &#x22;while (&#x22;), test]
      : [sn(this, &#x27;for (;;&#x27;)];
  } else {
    head = [sn(this, &#x27;for (&#x27;)];
    if (this[&#x27;else&#x27;]) {
      head.push(this.yet = o.scope.temporary(&#x27;yet&#x27;), &#x22; = true&#x22;);
    }
    head.push(sn(this, &#x22;;&#x22;), test.toString() &#x26;&#x26; &#x27; &#x27;, test, sn(this, &#x22;;&#x22;));
    if (that = this.update) {
      head.push(&#x27; &#x27;, that.compile(o, LEVEL_PAREN));
    }
  }
  return sn.apply(null, [null].concat(slice$.call(head), [sn(this, &#x27;) {&#x27;), this.compileBody((o.indent += TAB, o))]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.constructor" id="apidoc.element.livescript.ast.While.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>constructor
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &#x26;&#x26; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== &#x27;&#x27; + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.getJump" id="apidoc.element.livescript.ast.While.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var i$, ref$, ref1$, len$, node;
  ctx || (ctx = {});
  ctx[&#x27;continue&#x27;] = true;
  ctx[&#x27;break&#x27;] = true;
  for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ &#x3c; len$; ++i$) {
    node = ref$[i$];
    if (node.getJump(ctx)) {
      return node;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp(&#x27;inconvertible statement&#x27;);
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.isArray" id="apidoc.element.livescript.ast.While.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === &#x27;RegExp&#x27; &#x26;&#x26; !this.tails[1] &#x26;&#x26; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.isStatement" id="apidoc.element.livescript.ast.While.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeComprehension" id="apidoc.element.livescript.ast.While.prototype.makeComprehension">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeComprehension
        <span class="apidocSignatureSpan">(toAdd, loops)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeComprehension = function (toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().addBody(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
function argsSlice(begin, end){
  return new For({
    ref: true,
    from: begin,
    op: &#x27;til&#x27;,
    to: end
  }).<span class="apidocCodeKeywordSpan">makeComprehension</span>(Chain(Var(&#x27;arguments&#x27;)).add(Index(Literal(&#x27;..&#
x27;))), []);
}
ret = [];
for (i$ = 0, len$ = nodes.length; i$ &#x3c; len$; ++i$) {
  i = i$;
  node = nodes[i$];
  if (node.isEmpty()) {
    continue;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeReturn" id="apidoc.element.livescript.ast.While.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (it){
  var last, ref$, ref1$, ref2$;
  if (this.hasReturned) {
    return this;
  }
  if (it) {
    if (this.objComp) {
      this.body = Block(this.body.makeReturn(it, true));
    } else {
      if (!(this.body || this.index)) {
        this.addBody(Block(Var(this.index = &#x27;ridx$&#x27;)));
      }
      last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
      if ((this.isComprehension || this.inComprehension) &#x26;&#x26; !(last != null &#x26;&#x26; last.isComprehension)) {
        (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
        if ((ref1$ = this[&#x27;else&#x27;]) != null) {
          ref1$.makeReturn.apply(ref1$, arguments);
        }
        this.hasReturned = true;
      } else {
        this.resVar = it;
        if ((ref2$ = this[&#x27;else&#x27;]) != null) {
          ref2$.makeReturn.apply(ref2$, arguments);
        }
      }
    }
  } else {
    this.getJump() || (this.returns = true);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + &#x27;\n&#x27;;
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &#x26;&#x26; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = [&#x22;(function(){\n&#x22;].concat(slice$.call(code), [&#x22;\n}).call(this);\n&#x22;]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.show" id="apidoc.element.livescript.ast.While.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.un ? &#x27;!&#x27; : void 8, this.post ? &#x27;do&#x27; : void 8].join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield" id="apidoc.module.livescript.ast.Yield">module livescript.ast.Yield</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.Yield" id="apidoc.element.livescript.ast.Yield.Yield">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 98:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Unary($$[$0-5], yy.Splat(yy.Arr($$[$0-2]))));
break;
case 99:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2])));
break;
case 100:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Yield</span>($$[$0]));
break;
case 101:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Yield($$[$0-1], $$[$0]));
break;
case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 158:
this.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.superclass" id="apidoc.element.livescript.ast.Yield.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error(&#x27;unimplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield.prototype" id="apidoc.module.livescript.ast.Yield.prototype">module livescript.ast.Yield.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.compileNode" id="apidoc.element.livescript.ast.Yield.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var code;
  code = [];
  if (this.op === &#x27;yieldfrom&#x27;) {
    code.push(&#x27;yield*&#x27;);
  } else {
    code.push(&#x27;yield&#x27;);
  }
  if (this.it) {
    code.push(&#x22; &#x22; + this.it.compile(o, LEVEL_OP + PREC.unary));
  }
  return sn.apply(null, [this, &#x22;(&#x22;].concat(slice$.call(code), [&#x22;)&#x22;]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &#x26;&#x26; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &#x3c; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.constructor" id="apidoc.element.livescript.ast.Yield.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>constructor
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === &#x22;object&#x22;) {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError(&#x22;empty &#x22; + type + &#x22; on line &#x22; + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.isCallable" id="apidoc.element.livescript.ast.Yield.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === &#x27;debugger&#x27;;
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return &#x27;empty&#x27;;
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return &#x27;callable&#x27;;
  case !this.isString():
    return &#x27;string&#x27;;
  case !this.isRegex():
    return &#x27;regex&#x27;;
  case !this.isComplex():
    return &#x27;complex&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.show" id="apidoc.element.livescript.ast.Yield.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.op === &#x27;yieldfrom&#x27;) {
    return &#x27;from&#x27;;
  } else {
    return &#x27;&#x27;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = &#x27;&#x27;);
  tree = &#x27;\n&#x27; + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += &#x27; &#x27; + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.tokens" id="apidoc.module.livescript.tokens">module livescript.tokens</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.tokens.tokens" id="apidoc.element.livescript.tokens.tokens">
        function <span class="apidocSignatureSpan">livescript.</span>tokens
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokens = function (code, options){
  return clone$(exports).tokenize(code || &#x27;&#x27;, options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
t = {
  input: input,
  options: options
};
try {
  if (o.lex || o.tokens || o.ast) {
    LiveScript.emit(&#x27;lex&#x27;, t);
    t.tokens = LiveScript.<span class="apidocCodeKeywordSpan">tokens</span>(t.input, {
      raw: o.lex
    });
    if (o.lex || o.tokens) {
      printTokens(t.tokens);
      throw null;
    }
    LiveScript.emit(&#x27;parse&#x27;, t);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.tokens.rewrite" id="apidoc.element.livescript.tokens.rewrite">
        function <span class="apidocSignatureSpan">livescript.tokens.</span>rewrite
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rewrite = function (it){
  var ref$;
  it || (it = this.tokens);
  firstPass(it);
  addImplicitIndentation(it);
  rewriteBlockless(it);
  addImplicitParentheses(it);
  addImplicitBraces(it);
  expandLiterals(it);
  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === &#x27;NEWLINE&#x27;) {
    it.shift();
  }
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (this.inter) {
  this.rest == null &#x26;&#x26; this.carp(&#x27;unterminated interpolation&#x27;);
} else {
  this.last.spaced = true;
  this.newline();
}
o.raw || this.<span class="apidocCodeKeywordSpan">rewrite</span>();
return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.hasOwn = Object.prototype.hasOwnProperty;
exports.checkConsistency = function(camel, id){
if (this.hasOwn.call(this.identifiers, camel) &#x26;&#x26; this.identifiers[camel] !== id) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
