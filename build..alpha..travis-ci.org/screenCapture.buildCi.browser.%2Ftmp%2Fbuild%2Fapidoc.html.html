<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://livescript.net">livescript (v1.5.0)</a>
</h1>
<h4>LiveScript is a language which compiles to JavaScript. It has a straightforward mapping to JavaScript and allows you to write expressive code devoid of repetitive boilerplate. While LiveScript adds many features to assist in functional style programming, </h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript">module livescript</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.addListener">
            function <span class="apidocSignatureSpan">livescript.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast">
            function <span class="apidocSignatureSpan">livescript.</span>ast
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.asObj">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.asObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.toSlice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.toSlice
            <span class="apidocSignatureSpan">(o, base, symbol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileConditional
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileDestructuring
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileMinMax
            <span class="apidocSignatureSpan">(o, left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileSplice
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileSpread
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendArr">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.rendArr
            <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendObj">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.rendObj
            <span class="apidocSignatureSpan">(o, nodes, rite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.unfoldAssign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileAnyInstanceOf
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileChain">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileChain
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileCompose
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileConcat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileDeepEq
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileExistence
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileJoin
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMethod
            <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMinMax
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMod">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMod
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compilePartial
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePow">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compilePow
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRegexEquals
            <span class="apidocSignatureSpan">(o, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRemove
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRepeat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileSplit
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileXor">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileXor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.getDefault">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.getDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invertIt">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.invertIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.mapOp">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.mapOp
            <span class="apidocSignatureSpan">(op)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.xorChildren
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.add">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.chomp">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.chomp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileExpressions
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileRoot">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileRoot
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileWithDeclarations
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.neck">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.neck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.pipe">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.pipe
            <span class="apidocSignatureSpan">(target, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.prepend">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.prepend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.toJSON">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Box">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Box
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Call
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.makeReturn
            <span class="apidocSignatureSpan">(ret)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Case
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.compileCase">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.compileCase
            <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.add">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.autoCompare
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.cacheReference
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandBind">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandBind
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandSlice
            <span class="apidocSignatureSpan">(o, assign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandSplat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandStar">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandStar
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandVivify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.flipIt">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.flipIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getCall">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.getCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isSimpleAccess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isStatement
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unfoldAssign
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Class
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype.compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype.ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.CopyL">
            function <span class="apidocSignatureSpan">livescript.</span>ast.CopyL
            <span class="apidocSignatureSpan">(a, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Decl">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Decl
            <span class="apidocSignatureSpan">(type, nodes, lno)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Existence
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For">
            function <span class="apidocSignatureSpan">livescript.</span>ast.For
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.addBody">
            function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileParams">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.compileParams
            <span class="apidocSignatureSpan">(o, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.named">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.named
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.traverseChildren
            <span class="apidocSignatureSpan">(arg$, xscope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileExpression">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileExpression
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileStatement">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileStatement
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileAssign">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.compileAssign
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In">
            function <span class="apidocSignatureSpan">livescript.</span>ast.In
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.In.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS">
            function <span class="apidocSignatureSpan">livescript.</span>ast.JS
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.compile
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.L">
            function <span class="apidocSignatureSpan">livescript.</span>ast.L
            <span class="apidocSignatureSpan">(a, b, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isWhat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isWhat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Obj
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.toSlice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype.toSlice
            <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isComplex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.unparen">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.unparen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.compileAccessor
            <span class="apidocSignatureSpan">(o, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.compileDescriptor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Require
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Require.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Return.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Slice
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Splat
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype.compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice">
            function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype.makeReturn
            <span class="apidocSignatureSpan">(makeReturnArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Super.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype.getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileAsFunc
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compilePluck
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileSpread
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.getAccessors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Util
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Util.prototype.compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Vars
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Vars.prototype.compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addBody">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addGuard">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addGuard
            <span class="apidocSignatureSpan">(guard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addObjComp">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addObjComp
            <span class="apidocSignatureSpan">(objComp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileBody">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.compileBody
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeComprehension">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.makeComprehension
            <span class="apidocSignatureSpan">(toAdd, loops)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Yield
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.show">
            function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.fromJSON">
            function <span class="apidocSignatureSpan">livescript.</span>ast.fromJSON
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.parse">
            function <span class="apidocSignatureSpan">livescript.</span>ast.parse
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.command">
            function <span class="apidocSignatureSpan">livescript.</span>command
            <span class="apidocSignatureSpan">(args, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.compile">
            function <span class="apidocSignatureSpan">livescript.</span>compile
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.emit">
            function <span class="apidocSignatureSpan">livescript.</span>emit
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.eventNames">
            function <span class="apidocSignatureSpan">livescript.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.getMaxListeners">
            function <span class="apidocSignatureSpan">livescript.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.go">
            function <span class="apidocSignatureSpan">livescript.</span>go
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lex">
            function <span class="apidocSignatureSpan">livescript.</span>lex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.listenerCount">
            function <span class="apidocSignatureSpan">livescript.</span>listenerCount
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.listeners">
            function <span class="apidocSignatureSpan">livescript.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.load">
            function <span class="apidocSignatureSpan">livescript.</span>load
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.node">
            function <span class="apidocSignatureSpan">livescript.</span>node
            <span class="apidocSignatureSpan">(LiveScript)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.on">
            function <span class="apidocSignatureSpan">livescript.</span>on
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.once">
            function <span class="apidocSignatureSpan">livescript.</span>once
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.prependListener">
            function <span class="apidocSignatureSpan">livescript.</span>prependListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.prependOnceListener">
            function <span class="apidocSignatureSpan">livescript.</span>prependOnceListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.removeAllListeners">
            function <span class="apidocSignatureSpan">livescript.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.removeListener">
            function <span class="apidocSignatureSpan">livescript.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.run">
            function <span class="apidocSignatureSpan">livescript.</span>run
            <span class="apidocSignatureSpan">(code, options, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.setMaxListeners">
            function <span class="apidocSignatureSpan">livescript.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.stab">
            function <span class="apidocSignatureSpan">livescript.</span>stab
            <span class="apidocSignatureSpan">(code, callback, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens">
            function <span class="apidocSignatureSpan">livescript.</span>tokens
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens.rewrite">
            function <span class="apidocSignatureSpan">livescript.</span>tokens.rewrite
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Arr.superclass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Assign.superclass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.In.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Literal.superclass.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Require.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Return.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Super.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Util.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Vars.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>lexer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.addListener">module livescript.addListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.addListener.addListener">
            function <span class="apidocSignatureSpan">livescript.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast">module livescript.ast</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.ast">
            function <span class="apidocSignatureSpan">livescript.</span>ast
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Block
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Box">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Box
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Call
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Case
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Class
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.CopyL">
            function <span class="apidocSignatureSpan">livescript.ast.</span>CopyL
            <span class="apidocSignatureSpan">(a, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Decl">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Decl
            <span class="apidocSignatureSpan">(type, nodes, lno)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For">
            function <span class="apidocSignatureSpan">livescript.ast.</span>For
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If">
            function <span class="apidocSignatureSpan">livescript.ast.</span>If
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Import
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In">
            function <span class="apidocSignatureSpan">livescript.ast.</span>In
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Index
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS">
            function <span class="apidocSignatureSpan">livescript.ast.</span>JS
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Key
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.L">
            function <span class="apidocSignatureSpan">livescript.ast.</span>L
            <span class="apidocSignatureSpan">(a, b, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Label
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Require
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Try
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Util
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Var
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While">
            function <span class="apidocSignatureSpan">livescript.ast.</span>While
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.fromJSON">
            function <span class="apidocSignatureSpan">livescript.ast.</span>fromJSON
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.parse">
            function <span class="apidocSignatureSpan">livescript.ast.</span>parse
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr">module livescript.ast.Arr</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.Arr">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>compile
            <span class="apidocSignatureSpan">(o, items, deepEq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.maybe">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>maybe
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.wrap">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>wrap
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Arr.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype">module livescript.ast.Arr.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.asObj">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>asObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>constructor
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.toSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>toSlice
            <span class="apidocSignatureSpan">(o, base, symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype.asObj">module livescript.ast.Arr.prototype.asObj</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.asObj.asObj">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>asObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype.compile">module livescript.ast.Arr.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype.isArray">module livescript.ast.Arr.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.prototype.toSlice">module livescript.ast.Arr.prototype.toSlice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.prototype.toSlice.toSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>toSlice
            <span class="apidocSignatureSpan">(o, base, symbol)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Arr.superclass.prototype">module livescript.ast.Arr.superclass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.named">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>named
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Arr.superclass.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign">module livescript.ast.Assign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.Assign">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Assign.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype">module livescript.ast.Assign.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileConditional
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileDestructuring
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileMinMax
            <span class="apidocSignatureSpan">(o, left, right)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSplice
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSpread
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>constructor
            <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendArr">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendArr
            <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendObj">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendObj
            <span class="apidocSignatureSpan">(o, nodes, rite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.assigns">module livescript.ast.Assign.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileConditional">module livescript.ast.Assign.prototype.compileConditional</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional.compileConditional">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileConditional
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileDestructuring">module livescript.ast.Assign.prototype.compileDestructuring</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring.compileDestructuring">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileDestructuring
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileMinMax">module livescript.ast.Assign.prototype.compileMinMax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileMinMax
            <span class="apidocSignatureSpan">(o, left, right)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileNode">module livescript.ast.Assign.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileSplice">module livescript.ast.Assign.prototype.compileSplice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice.compileSplice">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSplice
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.compileSpread">module livescript.ast.Assign.prototype.compileSpread</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread.compileSpread">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSpread
            <span class="apidocSignatureSpan">(o, left)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.isArray">module livescript.ast.Assign.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.isCallable">module livescript.ast.Assign.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.isRegex">module livescript.ast.Assign.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.isString">module livescript.ast.Assign.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.rendArr">module livescript.ast.Assign.prototype.rendArr</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendArr.rendArr">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendArr
            <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.rendObj">module livescript.ast.Assign.prototype.rendObj</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.rendObj.rendObj">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendObj
            <span class="apidocSignatureSpan">(o, nodes, rite)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.show">module livescript.ast.Assign.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.unfoldAssign">module livescript.ast.Assign.prototype.unfoldAssign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.prototype.unfoldSoak">module livescript.ast.Assign.prototype.unfoldSoak</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Assign.superclass.prototype">module livescript.ast.Assign.superclass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.addElse">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>addElse
            <span class="apidocSignatureSpan">($else)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.anaphorize">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>anaphorize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>assigns
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.cache">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>cache
            <span class="apidocSignatureSpan">(o, once, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.carp">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>carp
            <span class="apidocSignatureSpan">(msg, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compile
            <span class="apidocSignatureSpan">(options, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileBlock">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileBlock
            <span class="apidocSignatureSpan">(o, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileClosure">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileClosure
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileLoopReference">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileLoopReference
            <span class="apidocSignatureSpan">(o, name, ret, safeAccess)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileSpreadOver">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileSpreadOver
            <span class="apidocSignatureSpan">(o, list, transform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.delegate">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>delegate
            <span class="apidocSignatureSpan">(names, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.eachChild">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>eachChild
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.expandSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>expandSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getAccessors">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getAccessors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getCall">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getDefault">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invertCheck">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invertCheck
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isMatcher">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isMatcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(ref, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>ripName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.stringify">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>stringify
            <span class="apidocSignatureSpan">(space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toJSON">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toString">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toString
            <span class="apidocSignatureSpan">(idt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.traverseChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>traverseChildren
            <span class="apidocSignatureSpan">(fn, xscope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unparen">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unparen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Assign.superclass.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary">module livescript.ast.Binary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.Binary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Binary.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype">module livescript.ast.Binary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileAnyInstanceOf
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileChain">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileChain
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileCompose
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileConcat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileDeepEq
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileExistence
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileJoin
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMethod
            <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMinMax
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMod">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMod
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePartial
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePow">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePow
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRegexEquals
            <span class="apidocSignatureSpan">(o, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRemove
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRepeat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileSplit
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileXor">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileXor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>constructor
            <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.getDefault">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>getDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invertIt">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invertIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.mapOp">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>mapOp
            <span class="apidocSignatureSpan">(op)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>xorChildren
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileAnyInstanceOf">module livescript.ast.Binary.prototype.compileAnyInstanceOf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf.compileAnyInstanceOf">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileAnyInstanceOf
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileChain">module livescript.ast.Binary.prototype.compileChain</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileChain.compileChain">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileChain
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileCompose">module livescript.ast.Binary.prototype.compileCompose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose.compileCompose">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileCompose
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileConcat">module livescript.ast.Binary.prototype.compileConcat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat.compileConcat">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileConcat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileDeepEq">module livescript.ast.Binary.prototype.compileDeepEq</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq.compileDeepEq">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileDeepEq
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileExistence">module livescript.ast.Binary.prototype.compileExistence</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence.compileExistence">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileExistence
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileJoin">module livescript.ast.Binary.prototype.compileJoin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin.compileJoin">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileJoin
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMethod">module livescript.ast.Binary.prototype.compileMethod</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod.compileMethod">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMethod
            <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMinMax">module livescript.ast.Binary.prototype.compileMinMax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax.compileMinMax">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMinMax
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMod">module livescript.ast.Binary.prototype.compileMod</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileMod.compileMod">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMod
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileNode">module livescript.ast.Binary.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compilePartial">module livescript.ast.Binary.prototype.compilePartial</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial.compilePartial">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePartial
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compilePow">module livescript.ast.Binary.prototype.compilePow</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compilePow.compilePow">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePow
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRegexEquals">module livescript.ast.Binary.prototype.compileRegexEquals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals.compileRegexEquals">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRegexEquals
            <span class="apidocSignatureSpan">(o, arg$)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRemove">module livescript.ast.Binary.prototype.compileRemove</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove.compileRemove">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRemove
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRepeat">module livescript.ast.Binary.prototype.compileRepeat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat.compileRepeat">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRepeat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileSplit">module livescript.ast.Binary.prototype.compileSplit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit.compileSplit">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileSplit
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.compileXor">module livescript.ast.Binary.prototype.compileXor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.compileXor.compileXor">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileXor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.getDefault">module livescript.ast.Binary.prototype.getDefault</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.getDefault.getDefault">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>getDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.invert">module livescript.ast.Binary.prototype.invert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invert.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.invertIt">module livescript.ast.Binary.prototype.invertIt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.invertIt.invertIt">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invertIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.isArray">module livescript.ast.Binary.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.isCallable">module livescript.ast.Binary.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.isString">module livescript.ast.Binary.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.mapOp">module livescript.ast.Binary.prototype.mapOp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.mapOp.mapOp">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>mapOp
            <span class="apidocSignatureSpan">(op)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.show">module livescript.ast.Binary.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Binary.prototype.xorChildren">module livescript.ast.Binary.prototype.xorChildren</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren.xorChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>xorChildren
            <span class="apidocSignatureSpan">(test)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block">module livescript.ast.Block</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.Block">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Block
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Block.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Block.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype">module livescript.ast.Block.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.add">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.chomp">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>chomp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileExpressions
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileRoot">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileRoot
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileWithDeclarations
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>constructor
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.neck">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>neck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.pipe">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>pipe
            <span class="apidocSignatureSpan">(target, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.prepend">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>prepend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.toJSON">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.add">module livescript.ast.Block.prototype.add</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.add.add">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.chomp">module livescript.ast.Block.prototype.chomp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.chomp.chomp">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>chomp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.compile">module livescript.ast.Block.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.compileExpressions">module livescript.ast.Block.prototype.compileExpressions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions.compileExpressions">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileExpressions
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.compileRoot">module livescript.ast.Block.prototype.compileRoot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileRoot.compileRoot">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileRoot
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.compileWithDeclarations">module livescript.ast.Block.prototype.compileWithDeclarations</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations.compileWithDeclarations">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileWithDeclarations
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.getJump">module livescript.ast.Block.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.isArray">module livescript.ast.Block.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.isCallable">module livescript.ast.Block.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.isComplex">module livescript.ast.Block.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.isRegex">module livescript.ast.Block.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.isString">module livescript.ast.Block.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.makeReturn">module livescript.ast.Block.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.neck">module livescript.ast.Block.prototype.neck</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.neck.neck">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>neck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.pipe">module livescript.ast.Block.prototype.pipe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.pipe.pipe">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>pipe
            <span class="apidocSignatureSpan">(target, type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.prepend">module livescript.ast.Block.prototype.prepend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.prepend.prepend">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>prepend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.toJSON">module livescript.ast.Block.prototype.toJSON</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.toJSON.toJSON">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Block.prototype.unwrap">module livescript.ast.Block.prototype.unwrap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Block.prototype.unwrap.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Box">module livescript.ast.Box</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Box.Box">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Box
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Call">module livescript.ast.Call</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.Call">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Call
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.back">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>back
            <span class="apidocSignatureSpan">(params, node, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.block">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>block
            <span class="apidocSignatureSpan">(fun, args, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.let">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>let
            <span class="apidocSignatureSpan">(args, body, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.make">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>make
            <span class="apidocSignatureSpan">(callee, args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Call.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Call.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Call.prototype">module livescript.ast.Call.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>constructor
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Call.prototype.compile">module livescript.ast.Call.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Call.prototype.show">module livescript.ast.Call.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Call.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade">module livescript.ast.Cascade</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.Cascade">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Cascade.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype">module livescript.ast.Cascade.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>constructor
            <span class="apidocSignatureSpan">(input, output, prog1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(ret)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.compileNode">module livescript.ast.Cascade.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.getJump">module livescript.ast.Cascade.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.isArray">module livescript.ast.Cascade.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.isCallable">module livescript.ast.Cascade.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.isRegex">module livescript.ast.Cascade.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.isString">module livescript.ast.Cascade.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.makeReturn">module livescript.ast.Cascade.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(ret)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Cascade.prototype.show">module livescript.ast.Cascade.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Cascade.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case">module livescript.ast.Case</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.Case">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Case
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Case.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Case.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case.prototype">module livescript.ast.Case.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.compileCase">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>compileCase
            <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>constructor
            <span class="apidocSignatureSpan">(tests, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case.prototype.compileCase">module livescript.ast.Case.prototype.compileCase</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.compileCase.compileCase">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>compileCase
            <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case.prototype.isCallable">module livescript.ast.Case.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Case.prototype.makeReturn">module livescript.ast.Case.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Case.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain">module livescript.ast.Chain</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.Chain">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Chain.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype">module livescript.ast.Chain.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.add">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>autoCompare
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>cacheReference
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>constructor
            <span class="apidocSignatureSpan">(head, tails)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandBind">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandBind
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSlice
            <span class="apidocSignatureSpan">(o, assign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSplat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandStar">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandStar
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandVivify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.flipIt">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>flipIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getCall">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isSimpleAccess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isStatement
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.add">module livescript.ast.Chain.prototype.add</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.add.add">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>add
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.assigns">module livescript.ast.Chain.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.autoCompare">module livescript.ast.Chain.prototype.autoCompare</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare.autoCompare">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>autoCompare
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.cacheReference">module livescript.ast.Chain.prototype.cacheReference</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference.cacheReference">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>cacheReference
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.compileNode">module livescript.ast.Chain.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.expandBind">module livescript.ast.Chain.prototype.expandBind</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandBind.expandBind">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandBind
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.expandSlice">module livescript.ast.Chain.prototype.expandSlice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice.expandSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSlice
            <span class="apidocSignatureSpan">(o, assign)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.expandSplat">module livescript.ast.Chain.prototype.expandSplat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat.expandSplat">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSplat
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.expandStar">module livescript.ast.Chain.prototype.expandStar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandStar.expandStar">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandStar
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.expandVivify">module livescript.ast.Chain.prototype.expandVivify</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify.expandVivify">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandVivify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.flipIt">module livescript.ast.Chain.prototype.flipIt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.flipIt.flipIt">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>flipIt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.getCall">module livescript.ast.Chain.prototype.getCall</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getCall.getCall">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getCall
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.getJump">module livescript.ast.Chain.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isArray">module livescript.ast.Chain.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isAssignable">module livescript.ast.Chain.prototype.isAssignable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isCallable">module livescript.ast.Chain.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isComplex">module livescript.ast.Chain.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isRegex">module livescript.ast.Chain.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isSimpleAccess">module livescript.ast.Chain.prototype.isSimpleAccess</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess.isSimpleAccess">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isSimpleAccess
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isStatement">module livescript.ast.Chain.prototype.isStatement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isStatement.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isStatement
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.isString">module livescript.ast.Chain.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.makeReturn">module livescript.ast.Chain.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.unfoldAssign">module livescript.ast.Chain.prototype.unfoldAssign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign.unfoldAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldAssign
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.unfoldSoak">module livescript.ast.Chain.prototype.unfoldSoak</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.unwrap">module livescript.ast.Chain.prototype.unwrap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.unwrap.unwrap">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unwrap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Chain.prototype.varName">module livescript.ast.Chain.prototype.varName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Chain.prototype.varName.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Class">module livescript.ast.Class</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.Class">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Class
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Class.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Class.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Class.prototype">module livescript.ast.Class.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>constructor
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Class.prototype.compile">module livescript.ast.Class.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Class.prototype.ripName">module livescript.ast.Class.prototype.ripName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Class.prototype.ripName.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.CopyL">module livescript.ast.CopyL</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.CopyL.CopyL">
            function <span class="apidocSignatureSpan">livescript.ast.</span>CopyL
            <span class="apidocSignatureSpan">(a, node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Decl">module livescript.ast.Decl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Decl.Decl">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Decl
            <span class="apidocSignatureSpan">(type, nodes, lno)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence">module livescript.ast.Existence</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.Existence">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Existence.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence.prototype">module livescript.ast.Existence.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it, negated)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence.prototype.compileNode">module livescript.ast.Existence.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence.prototype.invert">module livescript.ast.Existence.prototype.invert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.invert.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Existence.prototype.show">module livescript.ast.Existence.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Existence.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For">module livescript.ast.For</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.For">
            function <span class="apidocSignatureSpan">livescript.ast.</span>For
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.For.</span>superclass
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.For.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For.prototype">module livescript.ast.For.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.addBody">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>aSource</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For.prototype.addBody">module livescript.ast.For.prototype.addBody</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.addBody.addBody">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For.prototype.compileNode">module livescript.ast.For.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.For.prototype.show">module livescript.ast.For.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.For.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun">module livescript.ast.Fun</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.Fun">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Fun.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype">module livescript.ast.Fun.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileParams">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileParams
            <span class="apidocSignatureSpan">(o, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>constructor
            <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.named">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>named
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>traverseChildren
            <span class="apidocSignatureSpan">(arg$, xscope)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.compileNode">module livescript.ast.Fun.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.compileParams">module livescript.ast.Fun.prototype.compileParams</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.compileParams.compileParams">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileParams
            <span class="apidocSignatureSpan">(o, scope)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.isStatement">module livescript.ast.Fun.prototype.isStatement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.isStatement.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.makeReturn">module livescript.ast.Fun.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.named">module livescript.ast.Fun.prototype.named</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.named.named">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>named
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.ripName">module livescript.ast.Fun.prototype.ripName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.ripName.ripName">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>ripName
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.show">module livescript.ast.Fun.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Fun.prototype.traverseChildren">module livescript.ast.Fun.prototype.traverseChildren</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren.traverseChildren">
            function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>traverseChildren
            <span class="apidocSignatureSpan">(arg$, xscope)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If">module livescript.ast.If</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.If">
            function <span class="apidocSignatureSpan">livescript.ast.</span>If
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.If.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.If.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o, parent, name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.If.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype">module livescript.ast.If.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileExpression">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileExpression
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileStatement">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileStatement
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>constructor
            <span class="apidocSignatureSpan">($if, then, un)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>aTargets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>aSource</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.compileExpression">module livescript.ast.If.prototype.compileExpression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileExpression.compileExpression">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileExpression
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.compileNode">module livescript.ast.If.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.compileStatement">module livescript.ast.If.prototype.compileStatement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.compileStatement.compileStatement">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileStatement
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.getJump">module livescript.ast.If.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.isArray">module livescript.ast.If.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.isCallable">module livescript.ast.If.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.isRegex">module livescript.ast.If.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.isString">module livescript.ast.If.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isString
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.makeReturn">module livescript.ast.If.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.If.prototype.show">module livescript.ast.If.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.If.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import">module livescript.ast.Import</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.Import">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Import
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Import.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Import.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype">module livescript.ast.Import.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileAssign
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>constructor
            <span class="apidocSignatureSpan">(left, right, all)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.compileAssign">module livescript.ast.Import.prototype.compileAssign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileAssign.compileAssign">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileAssign
            <span class="apidocSignatureSpan">(o, items)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.compileNode">module livescript.ast.Import.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.isArray">module livescript.ast.Import.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.isCallable">module livescript.ast.Import.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.show">module livescript.ast.Import.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Import.prototype.unfoldSoak">module livescript.ast.Import.prototype.unfoldSoak</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.In">module livescript.ast.In</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.In">
            function <span class="apidocSignatureSpan">livescript.ast.</span>In
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.In.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.In.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.In.prototype">module livescript.ast.In.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>constructor
            <span class="apidocSignatureSpan">(item, array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.In.prototype.compileNode">module livescript.ast.In.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.In.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index">module livescript.ast.Index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.Index">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Index
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Index.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Index.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype">module livescript.ast.Index.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>constructor
            <span class="apidocSignatureSpan">(key, symbol, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype.compile">module livescript.ast.Index.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype.isComplex">module livescript.ast.Index.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype.show">module livescript.ast.Index.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Index.prototype.varName">module livescript.ast.Index.prototype.varName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Index.prototype.varName.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS">module livescript.ast.JS</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.JS">
            function <span class="apidocSignatureSpan">livescript.ast.</span>JS
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.JS.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.JS.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS.prototype">module livescript.ast.JS.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>compile
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>constructor
            <span class="apidocSignatureSpan">(code, literal, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>terminator</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS.prototype.compile">module livescript.ast.JS.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>compile
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS.prototype.isCallable">module livescript.ast.JS.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.JS.prototype.show">module livescript.ast.JS.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.JS.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump">module livescript.ast.Jump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.Jump">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.extended">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>extended
            <span class="apidocSignatureSpan">(sub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.return">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.throw">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Jump.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype">module livescript.ast.Jump.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>constructor
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype.compileNode">module livescript.ast.Jump.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype.getJump">module livescript.ast.Jump.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype.makeReturn">module livescript.ast.Jump.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Jump.prototype.show">module livescript.ast.Jump.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Jump.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key">module livescript.ast.Key</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.Key">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Key
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Key.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Key.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype">module livescript.ast.Key.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, reserved)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype.assigns">module livescript.ast.Key.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype.compile">module livescript.ast.Key.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype.isComplex">module livescript.ast.Key.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype.show">module livescript.ast.Key.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Key.prototype.varName">module livescript.ast.Key.prototype.varName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Key.prototype.varName.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.L">module livescript.ast.L</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.L.L">
            function <span class="apidocSignatureSpan">livescript.ast.</span>L
            <span class="apidocSignatureSpan">(a, b, node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label">module livescript.ast.Label</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.Label">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Label
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Label.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Label.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype">module livescript.ast.Label.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>constructor
            <span class="apidocSignatureSpan">(label, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.compileNode">module livescript.ast.Label.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.getJump">module livescript.ast.Label.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.isArray">module livescript.ast.Label.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.isCallable">module livescript.ast.Label.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.makeReturn">module livescript.ast.Label.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Label.prototype.show">module livescript.ast.Label.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Label.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal">module livescript.ast.Literal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.Literal">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Literal.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype">module livescript.ast.Literal.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isWhat">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isWhat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.compile">module livescript.ast.Literal.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isCallable">module livescript.ast.Literal.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isComplex">module livescript.ast.Literal.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isEmpty">module livescript.ast.Literal.prototype.isEmpty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty.isEmpty">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isRegex">module livescript.ast.Literal.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isRegex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isString">module livescript.ast.Literal.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.isWhat">module livescript.ast.Literal.prototype.isWhat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.isWhat.isWhat">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isWhat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.makeReturn">module livescript.ast.Literal.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.maybeKey">module livescript.ast.Literal.prototype.maybeKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.prototype.varName">module livescript.ast.Literal.prototype.varName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.prototype.varName.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Literal.superclass.prototype">module livescript.ast.Literal.superclass.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>isComplex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Literal.superclass.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Obj">module livescript.ast.Obj</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.Obj">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>compile
            <span class="apidocSignatureSpan">(o, items, deepEq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Obj.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Obj.prototype">module livescript.ast.Obj.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.asObj">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>asObj
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>constructor
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.toSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>toSlice
            <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Obj.prototype.compileNode">module livescript.ast.Obj.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Obj.prototype.toSlice">module livescript.ast.Obj.prototype.toSlice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Obj.prototype.toSlice.toSlice">
            function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>toSlice
            <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens">module livescript.ast.Parens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.Parens">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Parens.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype">module livescript.ast.Parens.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isArray
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isComplex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.unparen">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>unparen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.compile">module livescript.ast.Parens.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.isComplex">module livescript.ast.Parens.prototype.isComplex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isComplex.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isComplex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.isRegex">module livescript.ast.Parens.prototype.isRegex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isRegex.isRegex">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isRegex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.isString">module livescript.ast.Parens.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.show">module livescript.ast.Parens.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Parens.prototype.unparen">module livescript.ast.Parens.prototype.unparen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Parens.prototype.unparen.unparen">
            function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>unparen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop">module livescript.ast.Prop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.Prop">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Prop.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype">module livescript.ast.Prop.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileAccessor
            <span class="apidocSignatureSpan">(o, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileDescriptor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>constructor
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype.assigns">module livescript.ast.Prop.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype.compileAccessor">module livescript.ast.Prop.prototype.compileAccessor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor.compileAccessor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileAccessor
            <span class="apidocSignatureSpan">(o, key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype.compileDescriptor">module livescript.ast.Prop.prototype.compileDescriptor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor.compileDescriptor">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileDescriptor
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Prop.prototype.show">module livescript.ast.Prop.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Prop.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Require">module livescript.ast.Require</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.Require">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Require
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Require.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Require.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Require.prototype">module livescript.ast.Require.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>constructor
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Require.prototype.compile">module livescript.ast.Require.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Require.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Return">module livescript.ast.Return</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.Return">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Return
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.extended">
            function <span class="apidocSignatureSpan">livescript.ast.Return.</span>extended
            <span class="apidocSignatureSpan">(sub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Return.</span>superclass
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.throw">
            function <span class="apidocSignatureSpan">livescript.ast.Return.</span>throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Return.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Return.prototype">module livescript.ast.Return.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Return.prototype.compileNode">module livescript.ast.Return.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Return.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Slice">module livescript.ast.Slice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.Slice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Slice.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Slice.prototype">module livescript.ast.Slice.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>constructor
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Slice.prototype.compileNode">module livescript.ast.Slice.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Slice.prototype.show">module livescript.ast.Slice.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Slice.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Splat">module livescript.ast.Splat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.Splat">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.compileArray">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>compileArray
            <span class="apidocSignatureSpan">(o, list, apply)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Splat.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Splat.prototype">module livescript.ast.Splat.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it, filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.isComplex">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isComplex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Splat.prototype.assigns">module livescript.ast.Splat.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Splat.prototype.compile">module livescript.ast.Splat.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Splat.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.StepSlice">module livescript.ast.StepSlice</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.StepSlice">
            function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.</span>superclass
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.StepSlice.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.StepSlice.prototype">module livescript.ast.StepSlice.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(makeReturnArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.StepSlice.prototype.compileNode">module livescript.ast.StepSlice.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.StepSlice.prototype.makeReturn">module livescript.ast.StepSlice.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(makeReturnArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Super">module livescript.ast.Super</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.Super">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Super.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Super.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Super.prototype">module livescript.ast.Super.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Super.prototype.compile">module livescript.ast.Super.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Super.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch">module livescript.ast.Switch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.Switch">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Switch.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype">module livescript.ast.Switch.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>constructor
            <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>aTargets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>aSource</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype.compileNode">module livescript.ast.Switch.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype.getJump">module livescript.ast.Switch.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype.isCallable">module livescript.ast.Switch.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype.makeReturn">module livescript.ast.Switch.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Switch.prototype.show">module livescript.ast.Switch.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Switch.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Throw">module livescript.ast.Throw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.Throw">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.extended">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>extended
            <span class="apidocSignatureSpan">(sub)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>superclass
            <span class="apidocSignatureSpan">(verb, label)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Throw.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Throw.prototype">module livescript.ast.Throw.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>constructor
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Throw.prototype.compileNode">module livescript.ast.Throw.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Throw.prototype.getJump">module livescript.ast.Throw.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Throw.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>getJump
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try">module livescript.ast.Try</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.Try">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Try
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Try.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Try.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype">module livescript.ast.Try.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>constructor
            <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype.compileNode">module livescript.ast.Try.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype.getJump">module livescript.ast.Try.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>getJump
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype.isCallable">module livescript.ast.Try.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype.makeReturn">module livescript.ast.Try.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Try.prototype.show">module livescript.ast.Try.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Try.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary">module livescript.ast.Unary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.Unary">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Unary.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype">module livescript.ast.Unary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileAsFunc
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compilePluck
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileSpread
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>constructor
            <span class="apidocSignatureSpan">(op, it, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>getAccessors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.compileAsFunc">module livescript.ast.Unary.prototype.compileAsFunc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc.compileAsFunc">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileAsFunc
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.compileNode">module livescript.ast.Unary.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.compilePluck">module livescript.ast.Unary.prototype.compilePluck</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck.compilePluck">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compilePluck
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.compileSpread">module livescript.ast.Unary.prototype.compileSpread</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread.compileSpread">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileSpread
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.getAccessors">module livescript.ast.Unary.prototype.getAccessors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors.getAccessors">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>getAccessors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.invert">module livescript.ast.Unary.prototype.invert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.invert.invert">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>invert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.isArray">module livescript.ast.Unary.prototype.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isArray.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.isCallable">module livescript.ast.Unary.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.isString">module livescript.ast.Unary.prototype.isString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.isString.isString">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.show">module livescript.ast.Unary.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Unary.prototype.unfoldSoak">module livescript.ast.Unary.prototype.unfoldSoak</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak.unfoldSoak">
            function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>unfoldSoak
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Util">module livescript.ast.Util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.Util">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Util
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.Extends">
            function <span class="apidocSignatureSpan">livescript.ast.Util.</span>Extends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Util.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Util.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Util.prototype">module livescript.ast.Util.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>constructor
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Util.prototype.compile">module livescript.ast.Util.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Util.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var">module livescript.ast.Var</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.Var">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Var
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Var.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Var.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype">module livescript.ast.Var.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.isAssignable">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isAssignable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isCallable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype.assigns">module livescript.ast.Var.prototype.assigns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.assigns.assigns">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>assigns
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype.compile">module livescript.ast.Var.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>compile
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype.maybeKey">module livescript.ast.Var.prototype.maybeKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.maybeKey.maybeKey">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>maybeKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Var.prototype.varName">module livescript.ast.Var.prototype.varName</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Var.prototype.varName.varName">
            function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>varName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Vars">module livescript.ast.Vars</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.Vars">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Vars.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Vars.prototype">module livescript.ast.Vars.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>constructor
            <span class="apidocSignatureSpan">(vars)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Vars.prototype.compile">module livescript.ast.Vars.prototype.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Vars.prototype.compile.compile">
            function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>compile
            <span class="apidocSignatureSpan">(o, level)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While">module livescript.ast.While</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.While">
            function <span class="apidocSignatureSpan">livescript.ast.</span>While
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.While.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.While.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype">module livescript.ast.While.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addBody">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addGuard">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addGuard
            <span class="apidocSignatureSpan">(guard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addObjComp">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addObjComp
            <span class="apidocSignatureSpan">(objComp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileBody">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileBody
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>constructor
            <span class="apidocSignatureSpan">(test, un, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.isArray">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.isStatement">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeComprehension">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeComprehension
            <span class="apidocSignatureSpan">(toAdd, loops)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>aTargets</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>children</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>aSource</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.addBody">module livescript.ast.While.prototype.addBody</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addBody.addBody">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addBody
            <span class="apidocSignatureSpan">(body)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.addGuard">module livescript.ast.While.prototype.addGuard</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addGuard.addGuard">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addGuard
            <span class="apidocSignatureSpan">(guard)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.addObjComp">module livescript.ast.While.prototype.addObjComp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.addObjComp.addObjComp">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addObjComp
            <span class="apidocSignatureSpan">(objComp)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.compileBody">module livescript.ast.While.prototype.compileBody</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileBody.compileBody">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileBody
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.compileNode">module livescript.ast.While.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.getJump">module livescript.ast.While.prototype.getJump</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.getJump.getJump">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>getJump
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.makeComprehension">module livescript.ast.While.prototype.makeComprehension</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeComprehension.makeComprehension">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeComprehension
            <span class="apidocSignatureSpan">(toAdd, loops)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.makeReturn">module livescript.ast.While.prototype.makeReturn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.makeReturn.makeReturn">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeReturn
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.While.prototype.show">module livescript.ast.While.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.While.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield">module livescript.ast.Yield</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.Yield">
            function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.superclass">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.</span>superclass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">livescript.ast.Yield.</span>displayName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield.prototype">module livescript.ast.Yield.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.constructor">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>constructor
            <span class="apidocSignatureSpan">(op, it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.show">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>children</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield.prototype.compileNode">module livescript.ast.Yield.prototype.compileNode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.compileNode.compileNode">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>compileNode
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield.prototype.isCallable">module livescript.ast.Yield.prototype.isCallable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.isCallable.isCallable">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>isCallable
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.Yield.prototype.show">module livescript.ast.Yield.prototype.show</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.Yield.prototype.show.show">
            function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>show
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.fromJSON">module livescript.ast.fromJSON</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.fromJSON.fromJSON">
            function <span class="apidocSignatureSpan">livescript.ast.</span>fromJSON
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.ast.parse">module livescript.ast.parse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.ast.parse.parse">
            function <span class="apidocSignatureSpan">livescript.ast.</span>parse
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.command">module livescript.command</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.command.command">
            function <span class="apidocSignatureSpan">livescript.</span>command
            <span class="apidocSignatureSpan">(args, arg$)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.compile">module livescript.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.compile.compile">
            function <span class="apidocSignatureSpan">livescript.</span>compile
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.emit">module livescript.emit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.emit.emit">
            function <span class="apidocSignatureSpan">livescript.</span>emit
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.eventNames">module livescript.eventNames</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.eventNames.eventNames">
            function <span class="apidocSignatureSpan">livescript.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.getMaxListeners">module livescript.getMaxListeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.getMaxListeners.getMaxListeners">
            function <span class="apidocSignatureSpan">livescript.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.go">module livescript.go</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.go.go">
            function <span class="apidocSignatureSpan">livescript.</span>go
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.lex">module livescript.lex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lex.lex">
            function <span class="apidocSignatureSpan">livescript.</span>lex
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.lexer">module livescript.lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.able">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>able
            <span class="apidocSignatureSpan">(call)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.addInterpolated">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>addInterpolated
            <span class="apidocSignatureSpan">(parts, nlines)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.adi">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>adi
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.carp">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>carp
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.checkConsistency">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>checkConsistency
            <span class="apidocSignatureSpan">(camel, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.countLines">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>countLines
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.dedent">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>dedent
            <span class="apidocSignatureSpan">(debt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doBackslash">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doBackslash
            <span class="apidocSignatureSpan">(code, lastIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doCase">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doCase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doComment">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doComment
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doHeredoc">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doHeredoc
            <span class="apidocSignatureSpan">(code, index, q)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doHeregex">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doHeregex
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doID">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doID
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doJS">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doJS
            <span class="apidocSignatureSpan">(code, lastIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doLine">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doLine
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doLiteral">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doLiteral
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doNumber">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doNumber
            <span class="apidocSignatureSpan">(code, lastIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doRegex">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doRegex
            <span class="apidocSignatureSpan">(code, index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doSpace">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doSpace
            <span class="apidocSignatureSpan">(code, lastIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.doString">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>doString
            <span class="apidocSignatureSpan">(code, index, q)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.dotcat">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>dotcat
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.fget">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>fget
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.forange">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>forange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.fset">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>fset
            <span class="apidocSignatureSpan">(key, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.hasOwn">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>hasOwn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.indent">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>indent
            <span class="apidocSignatureSpan">(delta)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.interpolate">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>interpolate
            <span class="apidocSignatureSpan">(str, idx, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.lex">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>lex
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.newline">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>newline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.pair">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>pair
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.parameters">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>parameters
            <span class="apidocSignatureSpan">(arrow, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.regex">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>regex
            <span class="apidocSignatureSpan">(body, flag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.rewrite">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>rewrite
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.string">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>string
            <span class="apidocSignatureSpan">(q, body)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.strnum">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>strnum
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.token">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>token
            <span class="apidocSignatureSpan">(tag, value, callable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.tokenize">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>tokenize
            <span class="apidocSignatureSpan">(code, o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.unline">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>unline
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.lexer.validate">
            function <span class="apidocSignatureSpan">livescript.lexer.</span>validate
            <span class="apidocSignatureSpan">(flag)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">livescript.lexer.</span>dent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.lexer.</span>identifiers</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.listenerCount">module livescript.listenerCount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.listenerCount.listenerCount">
            function <span class="apidocSignatureSpan">livescript.</span>listenerCount
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.listeners">module livescript.listeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.listeners.listeners">
            function <span class="apidocSignatureSpan">livescript.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.load">module livescript.load</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.load.load">
            function <span class="apidocSignatureSpan">livescript.</span>load
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.node">module livescript.node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.node.node">
            function <span class="apidocSignatureSpan">livescript.</span>node
            <span class="apidocSignatureSpan">(LiveScript)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.once">module livescript.once</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.once.once">
            function <span class="apidocSignatureSpan">livescript.</span>once
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.options">module livescript.options</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.options.generateHelp">
            function <span class="apidocSignatureSpan">livescript.options.</span>generateHelp
            <span class="apidocSignatureSpan">(arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.options.generateHelpForOption">
            function <span class="apidocSignatureSpan">livescript.options.</span>generateHelpForOption
            <span class="apidocSignatureSpan">(optionName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.options.parse">
            function <span class="apidocSignatureSpan">livescript.options.</span>parse
            <span class="apidocSignatureSpan">(input, arg$)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.options.parseArgv">
            function <span class="apidocSignatureSpan">livescript.options.</span>parseArgv
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.parser">module livescript.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.parser.Parser">
            function <span class="apidocSignatureSpan">livescript.parser.</span>Parser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.parser.main">
            function <span class="apidocSignatureSpan">livescript.parser.</span>main
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.parser.parse">
            function <span class="apidocSignatureSpan">livescript.parser.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">livescript.</span>parser</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.prependListener">module livescript.prependListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.prependListener.prependListener">
            function <span class="apidocSignatureSpan">livescript.</span>prependListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.prependOnceListener">module livescript.prependOnceListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.prependOnceListener.prependOnceListener">
            function <span class="apidocSignatureSpan">livescript.</span>prependOnceListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.removeAllListeners">module livescript.removeAllListeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.removeAllListeners.removeAllListeners">
            function <span class="apidocSignatureSpan">livescript.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.removeListener">module livescript.removeListener</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.removeListener.removeListener">
            function <span class="apidocSignatureSpan">livescript.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.run">module livescript.run</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.run.run">
            function <span class="apidocSignatureSpan">livescript.</span>run
            <span class="apidocSignatureSpan">(code, options, arg$)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.setMaxListeners">module livescript.setMaxListeners</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.setMaxListeners.setMaxListeners">
            function <span class="apidocSignatureSpan">livescript.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.stab">module livescript.stab</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.stab.stab">
            function <span class="apidocSignatureSpan">livescript.</span>stab
            <span class="apidocSignatureSpan">(code, callback, filename)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.tokens">module livescript.tokens</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens.tokens">
            function <span class="apidocSignatureSpan">livescript.</span>tokens
            <span class="apidocSignatureSpan">(code, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens.rewrite">
            function <span class="apidocSignatureSpan">livescript.tokens.</span>rewrite
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.tokens.rewrite">module livescript.tokens.rewrite</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.tokens.rewrite.rewrite">
            function <span class="apidocSignatureSpan">livescript.tokens.</span>rewrite
            <span class="apidocSignatureSpan">(it)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.livescript.util">module livescript.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.util.nameFromPath">
            function <span class="apidocSignatureSpan">livescript.util.</span>nameFromPath
            <span class="apidocSignatureSpan">(modulePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.livescript.util.stripString">
            function <span class="apidocSignatureSpan">livescript.util.</span>stripString
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript" id="apidoc.module.livescript">module livescript</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.addListener" id="apidoc.element.livescript.addListener">
        function <span class="apidocSignatureSpan">livescript.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast" id="apidoc.element.livescript.ast">
        function <span class="apidocSignatureSpan">livescript.</span>ast
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast = function (it){
  return parser.parse(typeof it === 'string' ? lexer.lex(it) : it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    raw: o.lex
  });
  if (o.lex || o.tokens) {
    printTokens(t.tokens);
    throw null;
  }
  LiveScript.emit('parse', t);
  t.ast = LiveScript.<span class="apidocCodeKeywordSpan">ast</span>(t.tokens);
  say(o.json
    ? t.ast.stringify(2)
    : ''.trim.call(t.ast));
  throw null;
}
json = o.json || /\.json\.ls$/.test(filename);
run = o.run || o.eval;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr" id="apidoc.element.livescript.ast.Arr">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.asObj" id="apidoc.element.livescript.ast.Arr.prototype.asObj">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.asObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Arr.prototype.asObj = function (){
  var i, item;
  return Obj((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
      i = i$;
      item = ref$[i$];
      results$.push(Prop(Literal(i), item));
    }
    return results$;
  }.call(this)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.compile" id="apidoc.element.livescript.ast.Arr.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Arr.prototype.compile = function (o){
  var items, code;
  items = this.items;
  if (!items.length) {
    return sn(this, '[]');
  }
  if (!snEmpty(code = Splat.compileArray(o, items))) {
    return this.newed
      ? sn(this, "(", code, ")")
      : sn(this, code);
  }
  return sn(null, sn(this, "["), List.compile(o, items, this.deepEq), sn(this, "]"));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.isArray" id="apidoc.element.livescript.ast.Arr.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.toSlice" id="apidoc.element.livescript.ast.Arr.prototype.toSlice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Arr.prototype.toSlice
        <span class="apidocSignatureSpan">(o, base, symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Arr.prototype.toSlice = function (o, base, symbol){
  var items, ref$, ref, i$, len$, i, item, splat, chain;
  items = this.items;
  if (items.length &gt; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    item = items[i$];
    if (splat = item instanceof Splat) {
      item = item.it;
    }
    if (item.isEmpty()) {
      continue;
    }
    chain = Chain(base, [Index(item, symbol)]);
    items[i] = splat ? Splat(chain) : chain;
    base = ref;
  }
  chain || this.carp('empty slice');
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign" id="apidoc.element.livescript.ast.Assign">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || '=';
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += '';
  this$[rite instanceof Node ? 'right' : 'unaries'] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.assigns" id="apidoc.element.livescript.ast.Assign.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.assigns = function (it){
  return this.left.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional" id="apidoc.element.livescript.ast.Assign.prototype.compileConditional">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileConditional
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileConditional = function (o, left){
  var lefts, morph;
  if (left instanceof Var &amp;&amp; in$(this.logic, ['?']) &amp;&amp; this.op === '=') {
    o.scope.declare(left.value, left);
  }
  lefts = Chain(left).cacheReference(o);
  o.level += LEVEL_OP &lt; o.level;
  morph = Binary(this.logic, lefts[0], (this.logic = false, this.left = lefts[1], this));
  return sn(this, (morph['void'] = this['void'], morph).compileNode(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring" id="apidoc.element.livescript.ast.Assign.prototype.compileDestructuring">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileDestructuring
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileDestructuring = function (o, left){
  var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
  items = left.items, len = items.length;
  ret = o.level &amp;&amp; !this['void'];
  rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
  if (that = left.name) {
    cache = sn(this, that, " = ", rite);
    o.scope.declare(rite = that, left);
  } else if ((ret || len &gt; 1) &amp;&amp; (!ID.test(rite.toString()) || left.assigns(rite.toString()))) {
    cache = sn(this, rref = o.scope.temporary(), " = ", rite);
    rite = rref;
  }
  if (rite.toString() === 'arguments' &amp;&amp; !ret) {
    destructureArgs = true;
    if (!(left instanceof Arr)) {
      this.carp('arguments can only destructure to array');
    }
  }
  list = this["rend" + left.constructor.displayName](o, items, rite, destructureArgs);
  if (rref) {
    o.scope.free(rref);
  }
  if (cache) {
    list.unshift(cache);
  }
  if (ret || !list.length) {
    list.push(rite);
  }
  code = [];
  sep = destructureArgs ? '; ' : ', ';
  for (i$ = 0, len$ = list.length; i$ &lt; len$; ++i$) {
    item = list[i$];
    code.push(item, sep);
  }
  code.pop();
  if (list.length &lt; 2 || o.level &lt; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax" id="apidoc.element.livescript.ast.Assign.prototype.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileMinMax
        <span class="apidocSignatureSpan">(o, left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileMinMax = function (o, left, right){
  var lefts, rites, test, put, ref$;
  lefts = Chain(left).cacheReference(o);
  rites = right.cache(o, true);
  test = Binary(this.op.replace('?', ''), lefts[0], rites[0]);
  put = Assign(lefts[1], rites[1], ':=');
  if (this['void'] || !o.level) {
    return Parens(Binary('||', test, put)).compile(o);
  }
  ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
  return sn(this, If(test, left).addElse(put).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileNode" id="apidoc.element.livescript.ast.Assign.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileNode = function (o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &amp;&amp; this.op === '=') {
    return this.compileSplice(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
    left instanceof List || this.left.carp('invalid splat');
    return this.compileSpread(o, left);
  }
  if (!this.right) {
    left.isAssignable() || left.carp('invalid unary assign');
    ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
    for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ &lt; len$; ++i$) {
      op = ref$[i$];
      this.right = Unary(op, this.right);
    }
  }
  if (left.isEmpty()) {
    return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
  }
  if (left.getDefault()) {
    this.right = Binary(left.op, this.right, left.second);
    left = left.first;
  }
  if (left.items) {
    return this.compileDestructuring(o, left);
  }
  left.isAssignable() || left.carp('invalid assign');
  if (this.logic) {
    return this.compileConditional(o, left);
  }
  op = this.op, right = this.right;
  if (op === '&lt;?=' || op === '&gt;?=') {
    return this.compileMinMax(o, left, right);
  }
  if ((op === '**=' || op === '^=' || op === '%%=' || op === '++=' || op === '|&gt;=') || op === '*=' &amp;&amp; right.isString() || (op === '-=' ||
op === '/=') &amp;&amp; right.isMatcher()) {
    ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
    right = Binary(op.slice(0, -1), reft, right);
    op = ':=';
  }
  if (op === '.&amp;.=' || op === '.|.=' || op === '.^.=' || op === '.&lt;&lt;.=' || op === '.&gt;&gt;.=' || op === '.&gt;&gt;&gt;.=') {
    op = op.slice(1, -2) + '=';
  }
  (right = right.unparen()).ripName(left = left.unwrap());
  sign = sn(this.opLoc, " ", op.replace(':', ''), " ");
  name = (left.front = true, left).compile(o, LEVEL_LIST);
  if (lvar = left instanceof Var) {
    if (op === '=') {
      o.scope.declare(name.toString(), left, this['const'] || !this.defParam &amp;&amp; o['const'] &amp;&amp; '$' !== name.toString().slice(-1));
    } else if (that = o.scope.checkReadOnly(name.toString())) {
      left.carp("assignment to " + that + " \"" + name + "\"", ReferenceError);
    }
  }
  if (left instanceof Chain &amp;&amp; right instanceof Fun) {
    protoSplit = name.toString().split('.prototype.');
    dotSplit = name.toString().split('.');
    if (protoSplit.length &gt; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &gt; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');
    }
  }
  code = !o.level &amp;&amp; right instanceof While &amp;&amp; !right['else'] &amp;&amp; (lvar || left instanceof Chain &amp;&amp; left.isSimpleAccess())
    ? (empty = right.objComp ? '{}' : '[]', [res = o.scope.temporary('res'), " = " + empty + ";\n" + this.tab, right.makeReturn(
res).compile(o), "\n" + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &gt; LEVEL_LIST) {
    code = ["("].concat(slice$.call(code), [")"]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice" id="apidoc.element.livescript.ast.Assign.prototype.compileSplice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileSplice
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileSplice = function (o){
  var ref$, fromExpNode, fromExp, rightNode, right, toExp;
  ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
  ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
  toExp = Binary('-', this.left.to, fromExp);
  return sn(this, Block([Chain(Var(util('splice'))).add(Index(Key('apply'), '.', true)).add(Call([this.left.target, Chain(Arr([fromExpNode
, toExp])).add(Index(Key('concat'), '.', true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread" id="apidoc.element.livescript.ast.Assign.prototype.compileSpread">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.compileSpread
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.compileSpread = function (o, left){
  var that, ref$, rite, rref, this$ = this;
  ref$ = (that = this.unaries)
    ? [that, that]
    : left.items.length &lt;= 1
      ? [ref$ = this.right, ref$]
      : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
  return this.compileSpreadOver(o, left, function(it){
    var result;
    result = constructor(it, rite, this$.op, this$.logic);
    rite = rref;
    return result;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isArray" id="apidoc.element.livescript.ast.Assign.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.isArray = function (){
  switch (this.op) {
  case '=':
  case ':=':
    return this.right &amp;&amp; this.right.isArray();
  case '/=':
    return this.right &amp;&amp; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isCallable" id="apidoc.element.livescript.ast.Assign.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isRegex" id="apidoc.element.livescript.ast.Assign.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isString" id="apidoc.element.livescript.ast.Assign.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.isString = function (){
  switch (this.op) {
  case '=':
  case ':=':
  case '+=':
  case '*=':
    return this.right &amp;&amp; this.right.isString();
  case '-=':
    return this.right &amp;&amp; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendArr" id="apidoc.element.livescript.ast.Assign.prototype.rendArr">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.rendArr
        <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.rendArr = function (o, nodes, rite, destructureArgs){
  var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
  function argsSlice(begin, end){
    return new For({
      ref: true,
      from: begin,
      op: 'til',
      to: end
    }).makeComprehension(Chain(Var('arguments')).add(Index(Literal('..'))), []);
  }
  ret = [];
  for (i$ = 0, len$ = nodes.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = nodes[i$];
    if (node.isEmpty()) {
      continue;
    }
    if (node instanceof Splat) {
      len &amp;&amp; node.carp('multiple splat in an assignment');
      skip = (node = node.it).isEmpty();
      if (i + 1 === (len = nodes.length)) {
        if (skip) {
          break;
        }
        if (destructureArgs) {
          val = argsSlice(Literal(i), Chain(Var('arguments')).add(Index(Key('length'))));
        } else {
          val = Arr.wrap(JS(util('slice') + '.call(' + rite + (i ? ", " + i + ")" : ')')));
        }
      } else {
        val = ivar = rite + ".length - " + (len - i - 1);
        if (skip &amp;&amp; i + 2 === len) {
          continue;
        }
        start = i + 1;
        (this.temps || (this.temps = [])).push(ivar = o.scope.temporary('i'));
        val = (fn$());
      }
    } else {
      (inc = ivar) &amp;&amp; start &lt; i &amp;&amp; (inc += " + " + (i - start));
      val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
    }
    if (node instanceof Assign) {
      node = Binary(node.op, node.left, node.right, node.logic || true);
    }
    if (destructureArgs) {
      if (!(node instanceof Var) &amp;&amp; val instanceof For) {
        (this.temps || (this.temps = [])).push(tmp = o.scope.temporary('ref'));
        vtmp = Var(tmp);
        ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
      } else {
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
      }
    } else {
      ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
    }
  }
  return ret;
  function fn$(){
    switch (false) {
    case !skip:
      return Arr.wrap(JS(i + " &lt; (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"));
    case !destructureArgs:
      return argsSlice(JS(i + " &lt; (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"), Var(ivar));
    default:
      return Arr.wrap(JS(i + " &lt; (" + ivar + " = " + val + ")\ ? " + util('slice') + ".call(" + rite + ", " + i + ", " + ivar + ")\ : (" + ivar + " = " + i + ", [])"));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendObj" id="apidoc.element.livescript.ast.Assign.prototype.rendObj">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.rendObj
        <span class="apidocSignatureSpan">(o, nodes, rite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.rendObj = function (o, nodes, rite){
  var i$, len$, node, splat, logic, ref$, key, val, rcache, results$ = [];
  for (i$ = 0, len$ = nodes.length; i$ &lt; len$; ++i$) {
    node = nodes[i$];
    if (splat = node instanceof Splat) {
      node = node.it;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Parens) {
      ref$ = Chain(node.it).cacheReference(o), node = ref$[0], key = ref$[1];
    } else if (node instanceof Prop) {
      node = (key = node.key, node).val;
    } else {
      key = node;
    }
    if (node instanceof Key) {
      node = CopyL(node, Var(node.name));
    }
    if (logic) {
      node = (logic.first = node, logic);
    }
    val = Chain(rcache || (rcache = Var(rite)), [Index(key.maybeKey())]);
    if (splat) {
      val = Import(Obj(), val);
    }
    results$.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
  }
  return results$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.show" id="apidoc.element.livescript.ast.Assign.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.show = function (){
  return [void 8].concat(this.unaries).reverse().join(' ') + [this.logic] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Assign.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.unfoldAssign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.unfoldAssign = function (){
  return this.access &amp;&amp; this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Assign.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Assign.prototype.unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Assign.prototype.unfoldSoak = function (o){
  var that, ref$, ref1$, rite, temps;
  if (this.left instanceof Existence) {
    if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
      rite = this.right;
      rite = Assign(this.right = Var(that), rite);
    } else {
      ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
    }
    return ref$ = If(Existence(rite), this), ref$.temps = temps, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
  }
  return If.unfoldSoak(o, this, 'left');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary" id="apidoc.element.livescript.ast.Binary">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === 'String') {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== '=':
        return '?';
      default:
        return '=';
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if ('=' === op.charAt(op.length - 1) &amp;&amp; ((ref$ = op.charAt(op.length - 2)) !== '=' &amp;&amp; ref$ !== '&lt;' &amp;&amp; ref$ !== '&gt;' &amp;&amp; ref$ !== '!')) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case 'in':
      return new In(first, second);
    case 'with':
      return new Import(Unary('^^', first), second, false);
    case '&lt;&lt;&lt;':
    case '&lt;&lt;&lt;&lt;':
      return Import(first, second, op === '&lt;&lt;&lt;&lt;');
    case '&lt;|':
      return Block(first).pipe(second, op);
    case '|&gt;':
      return Block(second).pipe(first, '&lt;|');
    case '.':
    case '.~':
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf" id="apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileAnyInstanceOf
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileAnyInstanceOf = function (o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary('instanceof', sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    item = items[i$];
    test = Binary('||', test, Binary('instanceof', ref, item));
  }
  return sn(this, Parens(test).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileChain" id="apidoc.element.livescript.ast.Binary.prototype.compileChain">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileChain
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileChain = function (o){
  var code, level, ref$, sub;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
  ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
  code.push(" ", this.op, " ", sub.compile(o, level), " &amp;&amp; ", this.second.compile(o, LEVEL_OP));
  if (o.level &lt;= LEVEL_OP) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose" id="apidoc.element.livescript.ast.Binary.prototype.compileCompose">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileCompose
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileCompose = function (o){
  var op, functions, x;
  op = this.op;
  functions = [this.first];
  x = this.second;
  while (x instanceof Binary &amp;&amp; x.op === op &amp;&amp; !x.partial) {
    functions.push(x.first);
    x = x.second;
  }
  functions.push(x);
  if (op === '&lt;&lt;') {
    functions.reverse();
  }
  return sn(this, Chain(Var(util('compose'))).add(Call(functions)).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat" id="apidoc.element.livescript.ast.Binary.prototype.compileConcat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileConcat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileConcat = function (o){
  var f;
  f = function(x){
    switch (false) {
    case !(x instanceof Binary &amp;&amp; x.op === '++'):
      return f(x.first).concat(f(x.second));
    default:
      return [x];
    }
  };
  return sn(null, Chain(this.first).add(CopyL(this, Index(Key('concat'), '.', true))).add(Call(f(this.second))).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq" id="apidoc.element.livescript.ast.Binary.prototype.compileDeepEq">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileDeepEq
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileDeepEq = function (o){
  var ref$, negate, i$, len$, x, r;
  if ((ref$ = this.op) === '&gt;==' || ref$ === '&gt;&gt;=') {
    ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
    this.op = this.op === '&gt;==' ? '&lt;==' : '&lt;&lt;=';
  }
  if (this.op === '!==') {
    this.op = '===';
    negate = true;
  }
  for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ &lt; len$; ++i$) {
    x = ref$[i$];
    if (x instanceof Obj || x instanceof Arr) {
      x.deepEq = true;
    }
  }
  r = Chain(Var(util('deepEq'))).add(Call([this.first, this.second, Literal("'" + this.op + "'")]));
  return sn(this, (negate ? Unary('!', r) : r).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence" id="apidoc.element.livescript.ast.Binary.prototype.compileExistence">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileExistence
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileExistence = function (o){
  var x;
  if (this['void'] || !o.level) {
    x = Binary('&amp;&amp;', Existence(this.first, true), this.second);
    return (x['void'] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin" id="apidoc.element.livescript.ast.Binary.prototype.compileJoin">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileJoin
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileJoin = function (it){
  return this.compileMethod(it, 'Array', 'join');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod" id="apidoc.element.livescript.ast.Binary.prototype.compileMethod">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMethod
        <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileMethod = function (o, klass, method, arg){
  var args;
  args = [this.second].concat(arg || []);
  if (this.first["is" + klass]()) {
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + '.call'), args).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax" id="apidoc.element.livescript.ast.Binary.prototype.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMinMax
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileMinMax = function (o){
  var lefts, rites, x;
  lefts = this.first.cache(o, true);
  rites = this.second.cache(o, true);
  x = Binary(this.op.charAt(), lefts[0], rites[0]);
  return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMod" id="apidoc.element.livescript.ast.Binary.prototype.compileMod">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileMod
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileMod = function (o){
  var ref, code;
  ref = o.scope.temporary();
  code = [sn(this, "((("), this.first.compile(o), sn(this, ") % ("), sn(this, ref, " = "), this.second.compile(o), sn(this, ") + ",
ref, ") % ", ref, ")")];
  o.scope.free(ref);
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileNode" id="apidoc.element.livescript.ast.Binary.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileNode = function (o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.compilePartial(o);
  }
  switch (this.op) {
  case '?':
    return this.compileExistence(o);
  case '*':
    if (this.second.isString()) {
      return this.compileJoin(o);
    }
    if (this.first.isString() || this.first.isArray()) {
      return this.compileRepeat(o);
    }
    break;
  case '-':
    if (this.second.isMatcher()) {
      return this.compileRemove(o);
    }
    break;
  case '/':
    if (this.second.isMatcher()) {
      return this.compileSplit(o);
    }
    break;
  case '**':
  case '^':
    return this.compilePow(o);
  case '&lt;?':
  case '&gt;?':
    return this.compileMinMax(o);
  case '&lt;&lt;':
  case '&gt;&gt;':
    return this.compileCompose(o);
  case '++':
    return this.compileConcat(o);
  case '%%':
    return this.compileMod(o);
  case 'xor':
    return this.compileXor(o);
  case '&amp;&amp;':
  case '||':
    if (top = this['void'] || !o.level) {
      this.second['void'] = true;
    }
    if (top || this.cond) {
      this.first.cond = true;
      this.second.cond = true;
    }
    break;
  case 'instanceof':
    rite = this.second.expandSlice(o).unwrap(), items = rite.items;
    if (rite instanceof Arr) {
      if (items[1]) {
        return this.compileAnyInstanceOf(o, items);
      }
      this.second = items[0] || rite;
    }
    this.second.isCallable() || this.second.carp('invalid instanceof operand');
    break;
  case '====':
  case '!===':
    this.op = this.op.slice(0, 3);
    // fallthrough
  case '&lt;==':
  case '&gt;==':
  case '&lt;&lt;=':
  case '&gt;&gt;=':
    return this.compileDeepEq(o);
  default:
    if (COMPARER.test(this.op)) {
      if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.xorChildren(function(it){
        return it.isRegex();
      })) {
        return this.compileRegexEquals(o, that);
      }
      if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;&amp; this.first.isWhat() !== this
.second.isWhat()) {
        if (typeof console != 'undefined' &amp;&amp; console !== null) {
          console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + " == " +
this.second.value);
        }
      }
    }
    if (COMPARER.test(this.op) &amp;&amp; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.mapOp(this.op), " ", this.second.compile(o, level)];
  if (o.level &lt;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial" id="apidoc.element.livescript.ast.Binary.prototype.compilePartial">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compilePartial
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compilePartial = function (o){
  var vit, x, y;
  vit = Var('it');
  switch (false) {
  case !(this.first == null &amp;&amp; this.second == null):
    x = Var('x$');
    y = Var('y$');
    return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));
  case this.first == null:
    return sn(this, "(", Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), ")");
  default:
    return sn(this, "(", Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePow" id="apidoc.element.livescript.ast.Binary.prototype.compilePow">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compilePow
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compilePow = function (o){
  return sn(null, Call.make(CopyL(this, JS('Math.pow')), [this.first, this.second]).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals" id="apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRegexEquals
        <span class="apidocSignatureSpan">(o, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileRegexEquals = function (o, arg$){
  var regex, target, method;
  regex = arg$[0], target = arg$[1];
  if (this.op === '===') {
    method = this.wasInverted ? 'test' : 'exec';
    return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
  } else {
    return sn(this, Unary('!', Chain(regex).add(Index(Key('test'))).add(Call([target]))).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove" id="apidoc.element.livescript.ast.Binary.prototype.compileRemove">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRemove
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileRemove = function (it){
  return this.compileMethod(it, 'String', 'replace', JS("''"));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat" id="apidoc.element.livescript.ast.Binary.prototype.compileRepeat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileRepeat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileRepeat = function (o){
  var x, n, items, arr, arrCode, refs, i$, len$, i, item, ref$, q;
  x = this.first, n = this.second;
  items = (x = x.expandSlice(o).unwrap()).items;
  arr = x.isArray() &amp;&amp; 'Array';
  if (items &amp;&amp; !snEmpty(arrCode = Splat.compileArray(o, items))) {
    x = JS(arrCode);
    items = null;
  }
  if (arr &amp;&amp; !items || !(n instanceof Literal &amp;&amp; n.value &lt; 0x20)) {
    return sn(this, Call.make(Util('repeat' + (arr || 'String')), [x, n]).compile(o));
  }
  n = +n.value;
  if (1 &lt;= n &amp;&amp; n &lt; 2) {
    return sn(this, x.compile(o));
  }
  if (items) {
    if (n &lt; 1) {
      return sn(this, Block(items).add(JS('[]')).compile(o));
    }
    refs = [];
    for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
      i = i$;
      item = items[i$];
      ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
    }
    items.push((ref$ = JS(), ref$.compile = function(){
      return sn.apply(null, [this].concat(slice$.call((repeatArray$([", ", List.compile(o, refs)], n - 1)).slice(1))));
    }, ref$));
    return sn(this, x.compile(o));
  } else if (x instanceof Literal) {
    return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + "", n) + q);
  } else {
    if (n &lt; 1) {
      return sn(this, Block(x.it).add(JS("''")).compile(o));
    }
    x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(" + " + refs[1], n - 1);
    if (o.level &lt; LEVEL_OP + PREC['+']) {
      return sn(this, x);
    } else {
      return sn(this, "(", x, ")");
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit" id="apidoc.element.livescript.ast.Binary.prototype.compileSplit">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileSplit
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileSplit = function (it){
  return this.compileMethod(it, 'String', 'split');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileXor" id="apidoc.element.livescript.ast.Binary.prototype.compileXor">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.compileXor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.compileXor = function (o){
  var left, right;
  left = Chain(this.first).cacheReference(o);
  right = Chain(this.second).cacheReference(o);
  return sn(this, Binary('&amp;&amp;', Binary('!==', Unary('!', left[0]), Unary('!', right[0])), Parens(Binary('||', left[1], right[1]))).
compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.getDefault" id="apidoc.element.livescript.ast.Binary.prototype.getDefault">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.getDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.getDefault = function (){
  switch (this.op) {
  case '?':
  case '||':
  case '&amp;&amp;':
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invert" id="apidoc.element.livescript.ast.Binary.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.invert = function (){
  var that;
  if (that = !COMPARER.test(this.second.op) &amp;&amp; INVERSIONS[this.op]) {
    this.op = that;
    this.wasInverted = true;
    return this;
  }
  return Unary('!', Parens(this), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invertIt" id="apidoc.element.livescript.ast.Binary.prototype.invertIt">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.invertIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.invertIt = function (){
  this.inverted = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isArray" id="apidoc.element.livescript.ast.Binary.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.isArray = function (){
  switch (this.op) {
  case '*':
    return this.first.isArray();
  case '/':
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isCallable" id="apidoc.element.livescript.ast.Binary.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.isCallable = function (){
  var ref$;
  return this.partial || ((ref$ = this.op) === '&amp;&amp;' || ref$ === '||' || ref$ === '?' || ref$ === '&lt;&lt;' || ref$ === '&gt;&gt;') &amp;&amp; this.
first.isCallable() &amp;&amp; this.second.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isString" id="apidoc.element.livescript.ast.Binary.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.isString = function (){
  switch (this.op) {
  case '+':
  case '*':
    return this.first.isString() || this.second.isString();
  case '-':
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.mapOp" id="apidoc.element.livescript.ast.Binary.prototype.mapOp">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.mapOp
        <span class="apidocSignatureSpan">(op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.mapOp = function (op){
  var that;
  switch (false) {
  case !(that = op.match(/\.([&amp;\|\^]|&lt;&lt;|&gt;&gt;&gt;?)\./)):
    return that[1];
  case op !== 'of':
    return 'in';
  default:
    return op;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.show" id="apidoc.element.livescript.ast.Binary.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.show = function (){
  return this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren" id="apidoc.element.livescript.ast.Binary.prototype.xorChildren">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Binary.prototype.xorChildren
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Binary.prototype.xorChildren = function (test){
  var ref$, ref1$, first;
  if (!(!(ref$ = first = test(this.first)) !== !(ref1$ = test(this.second)) &amp;&amp; (ref$ || ref1$))) {
    return false;
  }
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block" id="apidoc.element.livescript.ast.Block">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if ('length' in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.add" id="apidoc.element.livescript.ast.Block.prototype.add">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.add = function (it){
  var that, ref$;
  it = it.unparen();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
  default:
    this.lines.push(it);
    if (that = (ref$ = it.back, delete it.back, ref$)) {
      this.back = that;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.chomp" id="apidoc.element.livescript.ast.Block.prototype.chomp">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.chomp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.chomp = function (){
  var lines, i, that;
  lines = this.lines;
  i = lines.length;
  while (that = lines[--i]) {
    if (!that.comment) {
      break;
    }
  }
  lines.length = i + 1;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compile" id="apidoc.element.livescript.ast.Block.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.compile = function (o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &amp;&amp; (level = o.level);
  if (level) {
    return this.compileExpressions(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
    if (snEmpty(code = (node.front = true, node).compile(o, level))) {
      continue;
    }
    codes.push(tab);
    codes.push(code);
    node.isStatement() || codes.push(node.terminator);
    codes.push('\n');
  }
  codes.pop();
  return sn.apply(null, [null].concat(slice$.call(codes)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions" id="apidoc.element.livescript.ast.Block.prototype.compileExpressions">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileExpressions
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.compileExpressions = function (o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
      lines.splice(i--, 1);
    }
  }
  if (!lines.length) {
    lines.push(Literal('void'));
  }
  lines[0].front = this.front;
  lines[lines.length - 1]['void'] = this['void'];
  if (!lines[1]) {
    return lines[0].compile(o, level);
  }
  code = [];
  last = lines.pop();
  for (i$ = 0, len$ = lines.length; i$ &lt; len$; ++i$) {
    node = lines[i$];
    code.push((node['void'] = true, node).compile(o, LEVEL_PAREN), ', ');
  }
  code.push(last.compile(o, LEVEL_PAREN));
  if (level &lt; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileRoot" id="apidoc.element.livescript.ast.Block.prototype.compileRoot">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileRoot
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.compileRoot = function (options){
  var o, that, ref$, bare, prefix, ref1$, code, result;
  o = (import$({
    level: LEVEL_TOP,
    scope: this.scope = Scope.root = new Scope
  }, options));
  if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
    this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
  }
  delete o.filename;
  o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? '' : TAB;
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations" id="apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.compileWithDeclarations
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.compileWithDeclarations = function (o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
  if (i = this.neck()) {
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), "\n"];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.emit(post, o.indent) : post]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.getJump" id="apidoc.element.livescript.ast.Block.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.getJump = function (it){
  var i$, ref$, len$, node, that;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (that = node.getJump(it)) {
      return that;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isArray" id="apidoc.element.livescript.ast.Block.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isCallable" id="apidoc.element.livescript.ast.Block.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isComplex" id="apidoc.element.livescript.ast.Block.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.isComplex = function (){
  var ref$;
  return this.lines.length &gt; 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isRegex" id="apidoc.element.livescript.ast.Block.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isString" id="apidoc.element.livescript.ast.Block.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.makeReturn" id="apidoc.element.livescript.ast.Block.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.makeReturn = function (){
  var that, ref$, key$, ref1$;
  this.chomp();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &amp;&amp; !that.it) {
      --this.lines.length;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.neck" id="apidoc.element.livescript.ast.Block.prototype.neck">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.neck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.neck = function (){
  var pos, i$, ref$, len$, x;
  pos = 0;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    x = ref$[i$];
    if (!(x.comment || x instanceof Literal)) {
      break;
    }
    ++pos;
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.pipe" id="apidoc.element.livescript.ast.Block.prototype.pipe">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.pipe
        <span class="apidocSignatureSpan">(target, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.pipe = function (target, type){
  var args;
  args = type === '|&gt;' ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== 'Array') {
    args = [args];
  }
  switch (type) {
  case '|&gt;':
    this.lines.push(Call.make(target, args, {
      pipe: true
    }));
    break;
  case '&lt;|':
    this.lines.push(Call.make(this.lines.pop(), args));
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.prepend" id="apidoc.element.livescript.ast.Block.prototype.prepend">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.prepend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.prepend = function (){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(slice$.call(arguments)));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.toJSON" id="apidoc.element.livescript.ast.Block.prototype.toJSON">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.toJSON = function (){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.unwrap" id="apidoc.element.livescript.ast.Block.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Block.prototype.unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Block.prototype.unwrap = function (){
  if (this.lines.length === 1) {
    return this.lines[0];
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Box" id="apidoc.element.livescript.ast.Box">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Box
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Box = function (v){
  if (typeof v === "object") {
    return v;
  } else {
    return new v.constructor(v);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call" id="apidoc.element.livescript.ast.Call">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Call
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &amp;&amp; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = '.call';
      args[0] = Literal('this');
      args[1] = Splat(Literal('arguments'));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &lt; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === '_') {
        args[i] = Chain(Literal('void'));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.compile" id="apidoc.element.livescript.ast.Call.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Call.prototype.compile = function (o){
  var code, i$, ref$, len$, i, a;
  code = [sn(this, this.method || '', '(') + (this.pipe ? "\n" + o.indent : '')];
  for (i$ = 0, len$ = (ref$ = this.args).length; i$ &lt; len$; ++i$) {
    i = i$;
    a = ref$[i$];
    code.push(i ? ', ' : '', a.compile(o, LEVEL_LIST));
  }
  code.push(sn(this, ')'));
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.show" id="apidoc.element.livescript.ast.Call.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Call.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Call.prototype.show = function (){
  return [this['new']] + [this.method] + [this.soak ? '?' : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade" id="apidoc.element.livescript.ast.Cascade">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode" id="apidoc.element.livescript.ast.Cascade.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.compileNode = function (o){
  var level, input, output, prog1, ref, ref$, code, out;
  level = o.level;
  input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
  if (prog1 &amp;&amp; ('ret' in this || level &amp;&amp; !this['void'])) {
    output.add((ref$ = Literal('..'), ref$.cascadee = true, ref$));
  }
  if ('ret' in this) {
    output = output.makeReturn(this.ret);
  }
  if (ref) {
    prog1 || (output = Assign(Var(ref), output));
  } else {
    ref = o.scope.temporary('x');
  }
  if (input instanceof Cascade) {
    input.ref = ref;
  } else {
    input &amp;&amp; (input = Assign(Var(ref), input));
  }
  o.level &amp;&amp; (o.level = LEVEL_PAREN);
  code = [input.compile(o)];
  out = Block(output).compile((o.ref = new String(ref), o));
  if (prog1 === 'cascade' &amp;&amp; !o.ref.erred) {
    this.carp("unreferred cascadee");
  }
  if (!level) {
    return sn.apply(null, [null].concat(slice$.call(code), [input.terminator, "\n", out]));
  }
  code.push(", ", out);
  if (level &gt; LEVEL_PAREN) {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.getJump" id="apidoc.element.livescript.ast.Cascade.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.getJump = function (it){
  return this.output.getJump(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isArray" id="apidoc.element.livescript.ast.Cascade.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable" id="apidoc.element.livescript.ast.Cascade.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex" id="apidoc.element.livescript.ast.Cascade.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isString" id="apidoc.element.livescript.ast.Cascade.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn" id="apidoc.element.livescript.ast.Cascade.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.makeReturn
        <span class="apidocSignatureSpan">(ret)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.makeReturn = function (ret){
  this.ret = ret;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.show" id="apidoc.element.livescript.ast.Cascade.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Cascade.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Cascade.prototype.show = function (){
  return this.prog1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case" id="apidoc.element.livescript.ast.Case">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Case
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.compileCase" id="apidoc.element.livescript.ast.Case.prototype.compileCase">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.compileCase
        <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Case.prototype.compileCase = function (o, tab, nobr, bool, type, target){
  var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
  tests = [];
  for (i$ = 0, len$ = (ref$ = this.tests).length; i$ &lt; len$; ++i$) {
    test = ref$[i$];
    test = test.expandSlice(o).unwrap();
    if (test instanceof Arr &amp;&amp; type !== 'match') {
      for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ &lt; len1$; ++j$) {
        t = ref1$[j$];
        tests.push(t);
      }
    } else {
      tests.push(test);
    }
  }
  tests.length || tests.push(Literal('void'));
  if (type === 'match') {
    for (i$ = 0, len$ = tests.length; i$ &lt; len$; ++i$) {
      i = i$;
      test = tests[i$];
      tar = Chain(target).add(Index(Literal(i), '.', true));
      tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
    }
  }
  if (bool) {
    binary = type === 'match' ? '&amp;&amp;' : '||';
    t = tests[0];
    i = 0;
    while (that = tests[++i]) {
      t = Binary(binary, t, that);
    }
    tests = [(this.t = t, this.aSource = 't', this.aTargets = ['body'], this).anaphorize().invert()];
  }
  code = [];
  for (i$ = 0, len$ = tests.length; i$ &lt; len$; ++i$) {
    t = tests[i$];
    code.push(tab, sn(t, "case ", t.compile(o, LEVEL_PAREN), ":\n"));
  }
  lines = this.body.lines;
  last = lines[lines.length - 1];
  if (ft = (last != null ? last.value : void 8) === 'fallthrough') {
    lines[lines.length - 1] = JS('// fallthrough');
  }
  o.indent = tab += TAB;
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(bodyCode, '\n');
  }
  if (!(nobr || ft || last instanceof Jump)) {
    code.push(tab + 'break;\n');
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.isCallable" id="apidoc.element.livescript.ast.Case.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Case.prototype.isCallable = function (){
  return this.body.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.makeReturn" id="apidoc.element.livescript.ast.Case.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Case.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Case.prototype.makeReturn = function (){
  var ref$, ref1$;
  if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== 'fallthrough') {
    (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain" id="apidoc.element.livescript.ast.Chain">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &amp;&amp; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.add" id="apidoc.element.livescript.ast.Chain.prototype.add">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.add = function (it){
  var last, ref$, index, ref1$, bi, logics, call, f;
  if (this.tails.length) {
    last = (ref$ = this.tails)[ref$.length - 1];
    if (last instanceof Call &amp;&amp; ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 &amp;&amp; it.args.length === 1) {
      index = last.partialized[0].head.value;
      delete last.partialized;
      last.args[index] = it.args[0];
      return this;
    }
  }
  if (this.head instanceof Existence) {
    ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
    it.soak = true;
  }
  this.tails.push(it);
  bi = this.head instanceof Parens &amp;&amp; this.head.it instanceof Binary &amp;&amp; !this.head.it.partial
    ? this.head.it
    : this.head instanceof Binary &amp;&amp; !this.head.partial ? this.head : void 8;
  if (this.head instanceof Super) {
    if (!this.head.called &amp;&amp; it instanceof Call &amp;&amp; !it.method) {
      it.method = '.call';
      it.args.unshift(Literal('this'));
      this.head.called = true;
    } else if (!this.tails[1] &amp;&amp; ((ref1$ = it.key) != null ? ref1$.name : void 8) === 'prototype') {
      this.head.sproto = true;
    }
  } else if (it instanceof Call &amp;&amp; this.tails.length === 1 &amp;&amp; bi &amp;&amp; in$(bi.op, logics = ['&amp;&amp;', '||', 'xor'])) {
    call = it;
    f = function(x, key){
      var y;
      y = x[key];
      if (y instanceof Binary &amp;&amp; in$(y.op, logics)) {
        f(y, 'first');
        return f(y, 'second');
      } else {
        return x[key] = Chain(y).autoCompare(call.args);
      }
    };
    f(bi, 'first');
    f(bi, 'second');
    return bi;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.assigns" id="apidoc.element.livescript.ast.Chain.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.assigns = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare" id="apidoc.element.livescript.ast.Chain.prototype.autoCompare">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.autoCompare
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.autoCompare = function (target){
  var test;
  test = this.head;
  switch (false) {
  case !(test instanceof Literal):
    return Binary('===', test, target[0]);
  case !(test instanceof Unary &amp;&amp; test.it instanceof Literal):
    return Binary('===', test, target[0]);
  case !(test instanceof Arr || test instanceof Obj):
    return Binary('====', test, target[0]);
  case !(test instanceof Var &amp;&amp; test.value === '_'):
    return Literal('true');
  default:
    return this.add(Call(target)) || [];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference" id="apidoc.element.livescript.ast.Chain.prototype.cacheReference">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.cacheReference
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.cacheReference = function (o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.unwrap().cache(o, true);
  }
  if (this.tails.length &lt; 2 &amp;&amp; !this.head.isComplex() &amp;&amp; !(name != null &amp;&amp; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
    base = Chain(Assign(Var(ref), base));
    bref = (ref$ = Var(ref), ref$.temp = true, ref$);
  }
  if (!name) {
    return [base, bref];
  }
  if (name.isComplex()) {
    ref = o.scope.temporary('key');
    name = Index(Assign(Var(ref), name.key));
    nref = Index((ref$ = Var(ref), ref$.temp = true, ref$));
  }
  return [base.add(name), Chain(bref || base.head, [nref || name])];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.compileNode" id="apidoc.element.livescript.ast.Chain.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.compileNode = function (o){
  var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
  if (this.flip) {
    util('flip');
    util('curry');
  }
  head = this.head, tails = this.tails;
  head.front = this.front;
  head.newed = this.newed;
  if (!tails.length) {
    return head.compile(o);
  }
  if (that = this.unfoldAssign(o)) {
    return that.compile(o);
  }
  for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
    t = tails[i$];
    if (t.partialized) {
      hasPartial = true;
      break;
    }
  }
  if (hasPartial) {
    util('slice');
    pre = [];
    rest = [];
    for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
      t = tails[i$];
      broken = broken || t.partialized != null;
      if (broken) {
        rest.push(t);
      } else {
        pre.push(t);
      }
    }
    if (rest != null) {
      partial = rest[0], post = slice$.call(rest, 1);
    }
    this.tails = pre;
    context = pre.length
      ? Chain(head, slice$.call(pre, 0, -1))
      : Literal('this');
    return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial
.partialized)])])), post).compile(o);
  }
  if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
    this.carp('invalid callee');
  }
  this.expandSlice(o);
  this.expandVivify();
  this.expandBind(o);
  this.expandSplat(o);
  this.expandStar(o);
  if (this.splattedNewArgs) {
    idt = o.indent + TAB;
    func = Chain(this.head, tails.slice(0, -1));
    return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor
, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
  }
  if (!this.tails.length) {
    return this.head.compile(o);
  }
  base = [this.head.compile(o, LEVEL_CALL)];
  news = [];
  rest = [];
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    t = ref$[i$];
    if (t['new']) {
      news.push('new ');
    }
    rest.push(t.compile(o));
  }
  if ('.' === rest.join("").charAt(0) &amp;&amp; SIMPLENUM.test(base[0].toString())) {
    base.push(' ');
  }
  return sn.apply(null, [null].concat(slice$.call(news), slice$.call(base), slice$.call(rest)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandBind" id="apidoc.element.livescript.ast.Chain.prototype.expandBind">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandBind
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.expandBind = function (o){
  var tails, i, that, obj, key, call;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.symbol !== '.~') {
      continue;
    }
    that.symbol = '';
    obj = Chain(this.head, tails.splice(0, i)).unwrap();
    key = tails.shift().key;
    call = Call.make(Util('bind'), [obj, (key.reserved = true, key)]);
    this.head = this.newed ? Parens(call, true) : call;
    i = -1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice" id="apidoc.element.livescript.ast.Chain.prototype.expandSlice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandSlice
        <span class="apidocSignatureSpan">(o, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.expandSlice = function (o, assign){
  var tails, i, tail, ref$, x;
  tails = this.tails;
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &amp;&amp; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp('calling a slice');
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat" id="apidoc.element.livescript.ast.Chain.prototype.expandSplat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandSplat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.expandSplat = function (o){
  var tails, i, call, args, ctx, ref$;
  tails = this.tails;
  i = -1;
  while (call = tails[++i]) {
    if (!(args = call.args)) {
      continue;
    }
    ctx = call.method === '.call' &amp;&amp; (args = args.concat()).shift();
    if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
      continue;
    }
    if (call['new']) {
      this.splattedNewArgs = args;
    } else {
      if (!ctx &amp;&amp; tails[i - 1] instanceof Index) {
        ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
        i = 0;
      }
      call.method = '.apply';
      call.args = [ctx || Literal('null'), JS(args)];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandStar" id="apidoc.element.livescript.ast.Chain.prototype.expandStar">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandStar
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.expandStar = function (o){
  var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.args || that.stars || that.key instanceof Key) {
      continue;
    }
    stars = that.stars = [];
    that.eachChild(seek);
    if (!stars.length) {
      continue;
    }
    ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
    value = Chain(ref, [Index(Key('length'))]).compile(o);
    for (i$ = 0, len$ = stars.length; i$ &lt; len$; ++i$) {
      star = stars[i$];
      star.value = value;
      star.isAssignable = YES;
    }
    this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
    if (temps) {
      o.scope.free(temps[0]);
    }
    i = -1;
  }
  function seek(it){
    if (it.value === '*') {
      stars.push(it);
    } else if (!(it instanceof Index)) {
      it.eachChild(seek);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify" id="apidoc.element.livescript.ast.Chain.prototype.expandVivify">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.expandVivify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.expandVivify = function (){
  var tails, i, that, ref$, ref1$;
  tails = this.tails;
  i = 0;
  while (i &lt; tails.length) {
    if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
      this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), '=', '||');
      i = 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.flipIt" id="apidoc.element.livescript.ast.Chain.prototype.flipIt">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.flipIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.flipIt = function (){
  this.flip = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getCall" id="apidoc.element.livescript.ast.Chain.prototype.getCall">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.getCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.getCall = function (){
  var tail, ref$;
  return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call &amp;&amp; tail;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getJump" id="apidoc.element.livescript.ast.Chain.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.getJump = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isArray" id="apidoc.element.livescript.ast.Chain.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isArray = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.isArray();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable" id="apidoc.element.livescript.ast.Chain.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isAssignable = function (){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.isAssignable();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isCallable" id="apidoc.element.livescript.ast.Chain.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isCallable = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return !((ref$ = that.key) != null &amp;&amp; ref$.items);
  } else {
    return this.head.isCallable();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isComplex" id="apidoc.element.livescript.ast.Chain.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isComplex = function (){
  return this.tails.length || this.head.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isRegex" id="apidoc.element.livescript.ast.Chain.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isRegex = function (){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess" id="apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isSimpleAccess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isSimpleAccess = function (){
  return this.tails.length === 1 &amp;&amp; !this.head.isComplex() &amp;&amp; !this.tails[0].isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isStatement" id="apidoc.element.livescript.ast.Chain.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isStatement
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isStatement = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isString" id="apidoc.element.livescript.ast.Chain.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn" id="apidoc.element.livescript.ast.Chain.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.makeReturn = function (){
  var ref$;
  if (this.tails.length) {
    return superclass.prototype.makeReturn.apply(this, arguments);
  } else {
    return (ref$ = this.head).makeReturn.apply(ref$, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Chain.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unfoldAssign
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.unfoldAssign = function (o){
  var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
  if (that = this.head.unfoldAssign(o)) {
    (ref$ = that.right.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    i = i$;
    index = ref$[i$];
    if (op = index.assign) {
      index.assign = '';
      left = Chain(this.head, this.tails.splice(0, i)).expandSlice(o).unwrap();
      if (left instanceof Arr) {
        lefts = left.items;
        rites = (this.head = Arr()).items;
        for (j$ = 0, len1$ = lefts.length; j$ &lt; len1$; ++j$) {
          i = j$;
          node = lefts[j$];
          ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
        }
      } else {
        ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
      }
      if (op === '=') {
        op = ':=';
      }
      return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Chain.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.unfoldSoak = function (o){
  var that, ref$, i$, len$, i, node, ref1$, bust, test;
  if (that = this.head.unfoldSoak(o)) {
    (ref$ = that.then.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    i = i$;
    node = ref$[i$];
    if (ref1$ = node.soak, delete node.soak, ref1$) {
      bust = Chain(this.head, this.tails.splice(0, i));
      if (node.assign &amp;&amp; !bust.isAssignable()) {
        node.carp('invalid accessign');
      }
      if (i &amp;&amp; (node.assign || node instanceof Call)) {
        ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
        if (bust instanceof Chain) {
          (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
          bust = bust.head;
        }
        this.head = bust;
      } else {
        ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
      }
      test = node instanceof Call
        ? JS("typeof " + test.compile(o, LEVEL_OP) + " == 'function'")
        : Existence(test);
      return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$['void'] = this['void'], ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unwrap" id="apidoc.element.livescript.ast.Chain.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.unwrap = function (){
  if (this.tails.length) {
    return this;
  } else {
    return this.head;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.varName" id="apidoc.element.livescript.ast.Chain.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Chain.prototype.varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Chain.prototype.varName = function (){
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class" id="apidoc.element.livescript.ast.Class">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Class
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.compile" id="apidoc.element.livescript.ast.Class.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype.compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Class.prototype.compile = function (o, level){
  var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj
, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
  fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
  CopyL(this, fun);
  boundFuncs = [];
  curriedBoundFuncs = [];
  decl = title != null ? title.varName() : void 8;
  name = decl || this.name;
  if (ID.test(name || '')) {
    fun.cname = name;
  } else {
    name = 'constructor';
  }
  proto = Var('prototype');
  vname = fun.proto = Var(fun.bound = name);
  ctorName = 'constructor$$';
  importProtoObj = function(node, i){
    var j, prop, key, i$, ref$, len$, v;
    j = 0;
    for (; j &lt; node.items.length; j++) {
      prop = node.items[j];
      key = prop.key;
      if ((key instanceof Key &amp;&amp; key.name === ctorName) || (key instanceof Literal &amp;&amp; key.value === "'" + ctorName + "'")) {
        if (ctor) {
          node.carp('redundant constructor');
        }
        ctor = prop.val;
        node.items.splice(j--, 1);
        ctorPlace = i;
      }
      if (!(prop.val instanceof Fun || prop.accessor)) {
        continue;
      }
      if (key.isComplex()) {
        key = Var(o.scope.temporary('key'));
        prop.key = Assign(key, prop.key);
      }
      if (prop.val.bound) {
        if (prop.val.curried) {
          curriedBoundFuncs.push(prop.key);
        } else {
          boundFuncs.push(prop.key);
        }
        prop.val.bound = false;
        prop.val.classBound = true;
      }
      for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ &lt; len$; ++i$) {
        v = ref$[i$];
        v.meth = key;
      }
    }
    if (node.items.length) {
      return ref$ = Import(Chain(vname).add(Index(Key('prototype'))), node), ref$.proto = true, ref$;
    } else {
      return Literal('void');
    }
  };
  for (i$ = 0, len$ = lines.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = lines[i$];
    if (node instanceof Obj) {
      lines[i] = importProtoObj(node, i);
    } else if (node instanceof Fun &amp;&amp; !node.statement) {
      ctor &amp;&amp; node.carp('redundant constructor');
      ctor = node;
    } else if (node instanceof Assign &amp;&amp; node.left instanceof Chain &amp;&amp; node.left.head.value === 'this' &amp;&amp; node.right instanceof
Fun) {
      node.right.stat = node.left.tails[0].key;
    } else {
      node.traverseChildren(fn$);
    }
  }
  ctor || (ctor = lines[lines.length] = this.sup
    ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal('arguments'))]))))
    : Fun());
  if (!(ctor instanceof Fun)) {
    lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
    lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat('arguments', true)]))))));
  }
  ctor.name = name;
  ctor.ctor = true;
  ctor.statement = true;
  for (i$ = 0, len$ = boundFuncs.length; i$ &lt; len$; ++i$) {
    f = boundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal
("'" + f.name + "'"), Var('prototype')]))));
  }
  for (i$ = 0, len$ = curriedBoundFuncs.length; i$ &lt; len$; ++i$) {
    f = curriedBoundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(Key("_" + f.name))), Chain(Var(util('curry'))).add(Call([Chain
(Var('prototype')).add(Index(f)), Var('true')]))), Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call
([Literal('this'), Literal("'_" + f.name + "'")]))));
  }
  lines.push(vname);
  args = [];
  if (that = this.sup) {
    args.push(that);
    imports = Chain(Import(Literal('this'), Var('superclass')));
    fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key('displayName'))), Literal("'" + name + "'")), Literal
(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var('superclass'));
  }
  if (that = this.mixins) {
    res$ = [];
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      args[args.length] = that[i$];
      res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
    }
    import ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.ripName" id="apidoc.element.livescript.ast.Class.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Class.prototype.ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Class.prototype.ripName = function (it){
  this.name = it.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.CopyL" id="apidoc.element.livescript.ast.CopyL">
        function <span class="apidocSignatureSpan">livescript.</span>ast.CopyL
        <span class="apidocSignatureSpan">(a, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.CopyL = function (a, node){
  if (node &amp;&amp; typeof node === "object") {
    node.first_line = a.first_line;
    node.first_column = a.first_column;
    node.last_line = a.last_line;
    node.last_column = a.last_column;
    node.line = a.line;
    node.column = a.column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Decl" id="apidoc.element.livescript.ast.Decl">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Decl
        <span class="apidocSignatureSpan">(type, nodes, lno)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Decl = function (type, nodes, lno){
  if (!nodes[0]) {
    throw SyntaxError("empty " + type + " on line " + lno);
  }
  return DECLS[type](nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence" id="apidoc.element.livescript.ast.Existence">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Existence
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.compileNode" id="apidoc.element.livescript.ast.Existence.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Existence.prototype.compileNode = function (o){
  var node, ref$, code, op, eq;
  node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
  code = [node.compile(o, LEVEL_OP + PREC['=='])];
  if (node instanceof Var &amp;&amp; !o.scope.check(code.join(""), true)) {
    ref$ = this.negated
      ? ['||', '=']
      : ['&amp;&amp;', '!'], op = ref$[0], eq = ref$[1];
    code = ["typeof "].concat(slice$.call(code), [" " + eq + "= 'undefined' " + op + " "], slice$.call(code), [" " + eq + "== null
"]);
  } else {
    code.push(" " + (op = this.negated ? '==' : '!=') + " null");
  }
  if (o.level &lt; LEVEL_OP + PREC[op]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn(this, "(", code, ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.invert" id="apidoc.element.livescript.ast.Existence.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Existence.prototype.invert = function (){
  this.negated = !this.negated;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.show" id="apidoc.element.livescript.ast.Existence.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Existence.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Existence.prototype.show = function (){
  return this.negated &amp;&amp; '!';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For" id="apidoc.element.livescript.ast.For">
        function <span class="apidocSignatureSpan">livescript.</span>ast.For
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &amp;&amp; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &lt; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &amp;&amp; !this.object) {
    this.carp('`for own` requires `of`');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.addBody" id="apidoc.element.livescript.ast.For.prototype.addBody">
        function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.For.prototype.addBody = function (body){
  var hasYield, ref$, x$, that, this$ = this;
  hasYield = !!body.traverseChildren(function(child){
    if (child instanceof Yield) {
      return true;
    }
  });
  if (this['let']) {
    if (ref$ = this.ref, delete this.ref, ref$) {
      this.item = Literal('..');
    }
    body = Block(Call['let']((x$ = [], (that = this.index) &amp;&amp; x$.push(Assign(Var(that), Literal('index$$'))), (that = this.item) &amp;&amp;
x$.push(Assign(that, Literal('item$$'))), x$), body, hasYield));
  }
  superclass.prototype.addBody.call(this, body);
  if (this.guard &amp;&amp; this['let'] &amp;&amp; (this.index || this.item)) {
    this.body.lines[0]['if'].traverseChildren(function(it){
      if (it instanceof Var) {
        if (this$.index &amp;&amp; it.value === this$.index) {
          it.value = 'index$$';
        }
        if (this$.item &amp;&amp; it.value === this$.item.value) {
          it.value = 'item$$';
        }
      }
    });
  }
  if (this['let']) {
    if (hasYield) {
      this.body = Block(Yield('yieldfrom', body));
    }
    delete this.index;
    delete this.item;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.compileNode" id="apidoc.element.livescript.ast.For.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.For.prototype.compileNode = function (o){
  var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
  o.loop = true;
  temps = this.temps = [];
  if (this.object &amp;&amp; this.index) {
    o.scope.declare(idx = this.index);
  } else {
    temps.push(idx = o.scope.temporary('i'));
  }
  if (!this.body) {
    this.addBody(Block(Var(idx)));
  }
  if (!this.object) {
    ref$ = (this.step || Literal(1)).compileLoopReference(o, 'step'), pvar = ref$[0], step = ref$[1];
    pvar === step || temps.push(pvar);
  }
  if (this.from) {
    if (this.ref) {
      this.item = Var(idx);
    }
    ref$ = this.to.compileLoopReference(o, 'to'), tvar = ref$[0], tail = ref$[1];
    fvar = this.from.compile(o, LEVEL_LIST);
    vars = idx + " = " + fvar;
    if (tail !== tvar) {
      vars += ", " + tail;
      temps.push(tvar);
    }
    if (!this.step &amp;&amp; +fvar &gt; +tvar) {
      pvar = step = -1;
    }
    eq = this.op === 'til' ? '' : '=';
    cond = +pvar
      ? idx + " " + '&lt;&gt;'.charAt(pvar &lt; 0) + eq + " " + tvar
      : pvar + " &lt; 0 ? " + idx + " &gt;" + eq + " " + tvar + " : " + idx + " &lt;" + eq + " " + tvar;
  } else {
    if (this.ref) {
      this.item = Var(o.scope.temporary('x'));
    }
    if (this.item || this.object &amp;&amp; this.own || this['let']) {
      ref$ = this.source.compileLoopReference(o, 'ref', !this.object, true), svar = ref$[0], srcPart = ref$[1];
      svar === srcPart || temps.push(svar);
    } else {
      svar = srcPart = this.source.compile(o, LEVEL_PAREN);
    }
    if (!this.object) {
      if (0 &gt; pvar &amp;&amp; ~~pvar === +pvar) {
        vars = idx + " = " + srcPart + ".length - 1";
        cond = idx + " &gt;= 0";
      } else {
        temps.push(lvar = o.scope.temporary('len'));
        vars = idx + " = 0, " + lvar + " = " + srcPart + ".length";
        cond = idx + " &lt; " + lvar;
      }
    }
  }
  this['else'] &amp;&amp; (this.yet = o.scope.temporary('yet'));
  head = [sn(this, 'for (')];
  if (this.object) {
    head.push(idx, " in ");
  }
  if (that = this.yet) {
    head.push(that, " = true, ");
  }
  if (this.object) {
    head.push(srcPart);
  } else {
    step === pvar || (vars += ', ' + step);
    head.push(vars, "; ", cond, "; " + (1 == Math.abs(pvar)
      ? (pvar &lt; 0 ? '--' : '++') + idx
      : idx + (pvar &lt; 0
        ? ' -= ' + pvar.toString().slice(1)
        : ' += ' + pvar)));
  }
  this.own &amp;&amp; head.push(sn(this, ") if ("), o.scope.assign('own$', '{}.hasOwnProperty'), ".call(", svar, ", ", idx, ")");
  head.push(sn(this, ') {'));
  if (this['let']) {
    this.body.traverseChildren(function(it){
      switch (it.value) {
      case 'index$$':
        it.value = idx;
        break;
      case 'item$$':
        it.value = svar + "[" + idx + "]";
      }
    });
  }
  o.indent += TAB;
  if (this.index &amp;&amp; !this.object) {
    head.push('\n' + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), ';');
  }
  if (this.item &amp;&amp; !this.item.isEmpty() &amp;&amp; !this.from) {
    head.push('\n' + o.indent, Assign(this.item, JS(svar + "[" + idx + "]")).compile(o, LEVEL_TOP), ';');
  }
  if (this.ref) {
    o.ref = this.item.value;
  }
  body = this.compileBody(o);
  if ((this.item || (this.index &amp;&amp; !this.object)) &amp;&amp; '}' === body.toString().charAt(0)) {
    head.push('\n' + this.tab);
  }
  return sn.apply(null, [null].concat(slice$.call(head), [body]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.show" id="apidoc.element.livescript.ast.For.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.For.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.For.prototype.show = function (){
  return ((this.kind || []).concat(this.index)).join(' ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun" id="apidoc.element.livescript.ast.Fun">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &amp;&amp; 'this$';
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileNode" id="apidoc.element.livescript.ast.Fun.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.compileNode = function (o){
  var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this;
  pscope = o.scope;
  sscope = pscope.shared || pscope;
  scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper &amp;&amp; sscope);
  scope.fun = this;
  if (that = this.proto) {
    scope.assign('prototype', that.compile(o) + ".prototype");
  }
  if (that = this.cname) {
    scope.assign('constructor', that);
  }
  if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
    o.indent = this.tab = '';
  }
  o.indent += TAB;
  body = this.body, name = this.name, tab = this.tab;
  code = ['function'];
  if (this.generator) {
    this.ctor &amp;&amp; this.carp("a constructor can't be a generator");
    o.inGenerator = true;
    code.push('*');
  } else if (!this.wrapper) {
    o.inGenerator = false;
  }
  if (this.bound === 'this$') {
    if (this.ctor) {
      scope.assign('this$', 'this instanceof ctor$ ? this : new ctor$');
      body.lines.push(Return(Literal('this$')));
    } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
      this.bound = that;
    } else {
      sscope.assign('this$', 'this');
    }
  }
  if (this.statement) {
    name || this.carp('nameless function declaration');
    pscope === o.block.scope || this.carp('misplaced function declaration');
    this.accessor &amp;&amp; this.carp('named accessor');
    pscope.add(name, 'function', this);
  }
  if (this.statement || name &amp;&amp; this.labeled) {
    code.push(' ', scope.add(name, 'function', this));
  }
  this.hushed || this.ctor || this.newed || body.makeReturn();
  code.push("(", this.compileParams(o, scope), ")");
  code = [sn.apply(null, [this].concat(slice$.call(code)))];
  code.push("{");
  if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
    code.push("\n", bodyCode, "\n" + tab);
  }
  code.push('}');
  curryCodeCheck = function(){
    if (this$.curried &amp;&amp; this$.hasSplats) {
      this$.carp('cannot curry a function with a variable number of arguments');
    }
    if (this$.curried &amp;&amp; this$.params.length &gt; 1 &amp;&amp; !this$.classBound) {
      if (this$.bound) {
        return [util('curry'), "(("].concat(slice$.call(code), ["), true)"]);
      } else {
        return [util('curry'), "("].concat(slice$.call(code), [")"]);
      }
    } else {
      return code;
    }
  };
  if (inLoop) {
    return pscope.assign(pscope.temporary('fn'), sn.apply(null, [null].concat(slice$.call(curryCodeCheck()))));
  }
  if (this.returns) {
    code.push("\n" + tab + "return ", name, ";");
  } else if (this.bound &amp;&amp; this.ctor) {
    code.push(' function ctor$(){} ctor$.prototype = prototype;');
  }
  code = curryCodeCheck();
  if (this.front &amp;&amp; !this.statement) {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileParams" id="apidoc.element.livescript.ast.Fun.prototype.compileParams">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.compileParams
        <span class="apidocSignatureSpan">(o, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.compileParams = function (o, scope){
  var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
  params = this.params, length = params.length, body = this.body;
  for (i$ = params.length - 1; i$ &gt;= 0; --i$) {
    p = params[i$];
    if (!(p.isEmpty() || p.filler)) {
      break;
    }
    --params.length;
  }
  for (i$ = 0, len$ = params.length; i$ &lt; len$; ++i$) {
    i = i$;
    p = params[i$];
    if (p.left instanceof Splat) {
      p.carp('invalid splat');
    }
    if (p instanceof Splat) {
      this.hasSplats = true;
      splace = i;
    } else if (p.op === '=') {
      params[i] = Binary(p.logic || '?', p.left, p.right);
    }
  }
  if (splace != null) {
    rest = params.splice(splace, 9e9);
  } else if (this.accessor) {
    if (that = params[1]) {
      that.carp('excess accessor parameter');
    }
  } else if (!(length || this.wrapper)) {
    if (body.traverseChildren(function(it){
      return it.value === 'it' || null;
    })) {
      params[0] = Var('it');
    }
  }
  names = [];
  assigns = [];
  for (i$ = 0, len$ = params.length; i$ &lt; len$; ++i$) {
    p = params[i$];
    vr = p;
    if (df = vr.getDefault()) {
      vr = vr.first;
    }
    if (vr.isEmpty()) {
      vr = Var(scope.temporary('arg'));
    } else if (vr.value === '..') {
      vr = Var(o.ref = scope.temporary());
    } else if (!(vr instanceof Var)) {
      unaries = [];
      while (vr instanceof Unary) {
        hasUnary = true;
        unaries.push(vr);
        vr = vr.it;
      }
      v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary('arg'));
      assigns.push(Assign(vr, (fn$())));
      vr = v;
    } else if (df) {
      assigns.push(Assign(vr, p.second, '=', p.op, true));
    }
    names.push(scope.add(vr.value, 'arg', p), ', ');
  }
  if (rest) {
    while (splace--) {
      rest.unshift(Arr());
    }
    assigns.push(Assign(Arr(rest), Literal('arguments')));
  }
  if (assigns.length) {
    (ref$ = this.body).prepend.apply(ref$, assigns);
  }
  names.pop();
  return sn.apply(null, [null].concat(slice$.call(names)));
  function fn$(){
    switch (false) {
    case !df:
      return Binary(p.op, v, p.second);
    case !hasUnary:
      return fold(function(x, y){
        y.it = x;
        return y;
      }, v, unaries.reverse());
    default:
      return v;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.isStatement" id="apidoc.element.livescript.ast.Fun.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.isStatement = function (){
  return !!this.statement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn" id="apidoc.element.livescript.ast.Fun.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.makeReturn = function (){
  if (this.statement) {
    return this.returns = true, this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.named" id="apidoc.element.livescript.ast.Fun.prototype.named">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.named
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.named = function (it){
  return this.name = it, this.statement = true, this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.ripName" id="apidoc.element.livescript.ast.Fun.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.ripName = function (it){
  this.name || (this.name = it.varName());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.show" id="apidoc.element.livescript.ast.Fun.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.show = function (){
  var that;
  return [this.name] + [(that = this.bound) ? "~" + that : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren" id="apidoc.element.livescript.ast.Fun.prototype.traverseChildren">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Fun.prototype.traverseChildren
        <span class="apidocSignatureSpan">(arg$, xscope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Fun.prototype.traverseChildren = function (arg$, xscope){
  if (xscope) {
    return superclass.prototype.traverseChildren.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If" id="apidoc.element.livescript.ast.If">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$['if'] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileExpression" id="apidoc.element.livescript.ast.If.prototype.compileExpression">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileExpression
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.compileExpression = function (o){
  var thn, els, code, pad;
  thn = this.then, els = this['else'] || Literal('void');
  this['void'] &amp;&amp; (thn['void'] = els['void'] = true);
  if (!this['else'] &amp;&amp; (this.cond || this['void'])) {
    return Parens(Binary('&amp;&amp;', this['if'], thn)).compile(o);
  }
  code = [sn(this, this['if'].compile(o, LEVEL_COND))];
  pad = els.isComplex() ? '\n' + (o.indent += TAB) : ' ';
  code.push(pad + "", sn(thn, "? "), thn.compile(o, LEVEL_LIST), pad + "", sn(els, ": "), els.compile(o, LEVEL_LIST));
  if (o.level &lt; LEVEL_COND) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, "(", code, ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileNode" id="apidoc.element.livescript.ast.If.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.compileNode = function (o){
  if (this.un) {
    this['if'] = this['if'].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.compileStatement(o);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileStatement" id="apidoc.element.livescript.ast.If.prototype.compileStatement">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.compileStatement
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.compileStatement = function (o){
  var code, els;
  code = [sn(this, "if (", this['if'].compile(o, LEVEL_PAREN), ") ")];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
  if (!(els = this['else'])) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  return sn.apply(null, [null].concat(
    slice$.call(code), [
      sn(els, ' else '), els instanceof constructor
        ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
        : this.compileBlock(o, els)
    ]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.getJump" id="apidoc.element.livescript.ast.If.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.getJump = function (it){
  var ref$;
  return this.then.getJump(it) || ((ref$ = this['else']) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isArray" id="apidoc.element.livescript.ast.If.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isCallable" id="apidoc.element.livescript.ast.If.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isRegex" id="apidoc.element.livescript.ast.If.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isString" id="apidoc.element.livescript.ast.If.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.makeReturn" id="apidoc.element.livescript.ast.If.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.makeReturn = function (){
  var ref$;
  this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
  if (this['else'] != null) {
    this['else'] = (ref$ = this['else']).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.show" id="apidoc.element.livescript.ast.If.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.If.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.If.prototype.show = function (){
  return this.un &amp;&amp; '!';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import" id="apidoc.element.livescript.ast.Import">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &amp;&amp; 'All';
  if (!all &amp;&amp; left instanceof Obj &amp;&amp; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileAssign" id="apidoc.element.livescript.ast.Import.prototype.compileAssign">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.compileAssign
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.compileAssign = function (o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
    return this.left.compile(o);
  }
  top = !o.level;
  if (this.proto || (items.length &lt; 2 &amp;&amp; (top || this['void'] || items[0] instanceof Splat))) {
    reft = this.left;
    if (reft.isComplex()) {
      reft = Parens(reft);
    }
  } else {
    ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
  }
  ref$ = top
    ? [';', '\n' + this.tab]
    : [',', ' '], delim = ref$[0], space = ref$[1];
  delim += space;
  code = this.temps
    ? [left.compile(o, LEVEL_PAREN), delim]
    : [];
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = items[i$];
    i &amp;&amp; code.push(com ? space : delim);
    if (com = node.comment) {
      code.push(node.compile(o));
      continue;
    }
    if (node instanceof Splat) {
      code.push(Import(reft, node.it).compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (dyna = node instanceof Parens) {
      ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
    } else if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        if (key instanceof Key) {
          key = JS("'" + key.name + "'");
        }
        code.push("Object.defineProperty(", reft.compile(o, LEVEL_LIST), ", ", key.compile(o, LEVEL_LIST), ", ", node.compileDescriptor
(o), ")");
        continue;
      }
    } else {
      key = val = node;
    }
    dyna || (key = key.maybeKey());
    logic &amp;&amp; (val = (logic.first = val, logic));
    code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
  }
  if (top) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  this['void'] || node instanceof Splat || code.push(com ? ' ' : ', ', reft.compile(o, LEVEL_PAREN));
  if (o.level &lt; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileNode" id="apidoc.element.livescript.ast.Import.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.compileNode = function (o){
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.compileAssign(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util("import" + (this.all || '')), [this.left, right])).compileNode(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isArray" id="apidoc.element.livescript.ast.Import.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isCallable" id="apidoc.element.livescript.ast.Import.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.show" id="apidoc.element.livescript.ast.Import.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.show = function (){
  return this.all;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Import.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Import.prototype.unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Import.prototype.unfoldSoak = function (o){
  var left, value, ref$, temps;
  left = this.left;
  if (left instanceof Existence &amp;&amp; !left.negated) {
    if ((left = left.it) instanceof Var) {
      value = (this.left = left).value;
      if (!o.scope.check(value, true)) {
        left = JS("typeof " + value + " != 'undefined' &amp;&amp; " + value);
      }
    } else {
      ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
    }
    return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
  }
  return If.unfoldSoak(o, this, 'left') || (this['void'] || !o.level) &amp;&amp; If.unfoldSoak(o, this, 'right');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In" id="apidoc.element.livescript.ast.In">
        function <span class="apidocSignatureSpan">livescript.</span>ast.In
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.compileNode" id="apidoc.element.livescript.ast.In.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.In.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.In.prototype.compileNode = function (o){
  var array, items, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
  items = (array = this.array.expandSlice(o).unwrap()).items;
  if (!(array instanceof Arr) || items.length &lt; 2) {
    return sn(this, this.negated ? '!' : '', util('in'), "(", this.item.compile(o, LEVEL_LIST), ", ", array.compile(o, LEVEL_LIST
), ")");
  }
  code = [];
  ref$ = this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
  ref$ = this.negated
    ? [' !== ', ' &amp;&amp; ']
    : [' === ', ' || '], cmp = ref$[0], cnj = ref$[1];
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    test = items[i$];
    if (code.length &gt; 0) {
      code.push(cnj);
    }
    if (test instanceof Splat) {
      code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
      if (!(i || sub === ref)) {
        code = ["(" + sub + ", "].concat(slice$.call(code), [")"]);
      }
    } else {
      code.push(i || sub === ref
        ? ref
        : "(" + sub + ")", cmp, test.compile(o, LEVEL_OP + PREC['==']));
    }
  }
  sub === ref || o.scope.free(ref);
  if (o.level &lt; LEVEL_OP + PREC['||']) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index" id="apidoc.element.livescript.ast.Index">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = '.');
  if (init &amp;&amp; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case '[]':
    this$.vivify = Arr;
    break;
  case '{}':
    this$.vivify = Obj;
    break;
  default:
    if ('=' === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.compile" id="apidoc.element.livescript.ast.Index.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Index.prototype.compile = function (o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
    return sn(this, "[", code, "]");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.isComplex" id="apidoc.element.livescript.ast.Index.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Index.prototype.isComplex = function (){
  return this.key.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.show" id="apidoc.element.livescript.ast.Index.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Index.prototype.show = function (){
  return [this.soak ? '?' : void 8] + this.symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.varName" id="apidoc.element.livescript.ast.Index.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Index.prototype.varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Index.prototype.varName = function (){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS" id="apidoc.element.livescript.ast.JS">
        function <span class="apidocSignatureSpan">livescript.</span>ast.JS
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.compile" id="apidoc.element.livescript.ast.JS.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.compile
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.JS.prototype.compile = function (it){
  return sn(this, snSafe(this.literal
    ? entab(this.code, it.indent)
    : this.code));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.isCallable" id="apidoc.element.livescript.ast.JS.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.JS.prototype.isCallable = function (){
  return !this.comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.show" id="apidoc.element.livescript.ast.JS.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.JS.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.JS.prototype.show = function (){
  if (this.comment) {
    return this.code;
  } else {
    return "`" + this.code + "`";
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump" id="apidoc.element.livescript.ast.Jump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.compileNode" id="apidoc.element.livescript.ast.Jump.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Jump.prototype.compileNode = function (o){
  var that, ref$;
  if (that = this.label) {
    in$(that, (ref$ = o.labels) != null
      ? ref$
      : o.labels = []) || this.carp("unknown label \"" + that + "\"");
  } else {
    o[this.verb] || this.carp("stray " + this.verb);
  }
  return sn(this, this.show() + ';');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.getJump" id="apidoc.element.livescript.ast.Jump.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Jump.prototype.getJump = function (ctx){
  var that, ref$;
  ctx || (ctx = {});
  if (!ctx[this.verb]) {
    return this;
  }
  if (that = this.label) {
    return !in$(that, (ref$ = ctx.labels) != null
      ? ref$
      : ctx.labels = []) &amp;&amp; this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn" id="apidoc.element.livescript.ast.Jump.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.show" id="apidoc.element.livescript.ast.Jump.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Jump.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Jump.prototype.show = function (){
  var that;
  return (this.verb || '') + ((that = this.label) ? ' ' + that : '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key" id="apidoc.element.livescript.ast.Key">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = '' + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.assigns" id="apidoc.element.livescript.ast.Key.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Key.prototype.assigns = function (it){
  return it === this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.compile" id="apidoc.element.livescript.ast.Key.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Key.prototype.compile = function (){
  return sn(this, this.show());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.isComplex" id="apidoc.element.livescript.ast.Key.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.show" id="apidoc.element.livescript.ast.Key.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Key.prototype.show = function (){
  if (this.reserved) {
    return "'" + this.name + "'";
  } else {
    return this.name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.varName" id="apidoc.element.livescript.ast.Key.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Key.prototype.varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Key.prototype.varName = function (){
  var name;
  name = this.name;
  if (this.reserved || (name === 'arguments' || name === 'eval')) {
    return "$" + name;
  } else {
    return name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.L" id="apidoc.element.livescript.ast.L">
        function <span class="apidocSignatureSpan">livescript.</span>ast.L
        <span class="apidocSignatureSpan">(a, b, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.L = function (a, b, node){
  if (node &amp;&amp; typeof node === "object") {
    node.first_line = a.first_line + 1;
    node.first_column = a.first_column;
    node.last_line = b.last_line + 1;
    node.last_column = b.last_column;
    node.line = a.first_line + 1;
    node.column = a.first_column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label" id="apidoc.element.livescript.ast.Label">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || '_';
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &amp;&amp; it || it.calling &amp;&amp; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.compileNode" id="apidoc.element.livescript.ast.Label.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.compileNode = function (o){
  var label, it, labels;
  label = this.label, it = this.it;
  labels = o.labels = slice$.call(o.labels || []);
  if (in$(label, labels)) {
    this.carp("duplicate label \"" + label + "\"");
  }
  labels.push(label);
  it.isStatement() || (it = Block(it));
  return sn(null, sn(this, label, ": "), it instanceof Block
    ? (o.indent += TAB, this.compileBlock(o, it))
    : it.compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.getJump" id="apidoc.element.livescript.ast.Label.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.getJump = function (ctx){
  var ref$;
  ctx || (ctx = {});
  ((ref$ = ctx.labels) != null
    ? ref$
    : ctx.labels = []).push(this.label);
  return this.it.getJump((ctx['break'] = true, ctx));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isArray" id="apidoc.element.livescript.ast.Label.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isCallable" id="apidoc.element.livescript.ast.Label.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.makeReturn" id="apidoc.element.livescript.ast.Label.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.makeReturn = function (){
  var ref$;
  this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.show" id="apidoc.element.livescript.ast.Label.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Label.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Label.prototype.show = function (){
  return this.label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal" id="apidoc.element.livescript.ast.Literal">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + "", true);
  }
  if (value === 'super') {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.compile" id="apidoc.element.livescript.ast.Literal.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.compile = function (o, level){
  var val, ref$;
  level == null &amp;&amp; (level = o.level);
  switch (val = this.value + "") {
  case 'this':
    return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
  case 'void':
    if (!level) {
      return sn(this, '');
    }
    val += ' 8';
    // fallthrough
  case 'null':
    if (level === LEVEL_CALL) {
      this.carp('invalid use of ' + this.value);
    }
    break;
  case 'on':
  case 'yes':
    val = 'true';
    break;
  case 'off':
  case 'no':
    val = 'false';
    break;
  case '*':
    this.carp('stray star');
    break;
  case '..':
    if (!(val = o.ref)) {
      this.carp('stray reference');
    }
    this.cascadee || (val.erred = true);
    break;
  case 'debugger':
    if (level) {
      return sn(this, "(function(){ debugger; }())");
    }
  }
  return sn(this, snSafe(val));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isCallable" id="apidoc.element.livescript.ast.Literal.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isCallable = function (){
  var ref$;
  return (ref$ = this.value) === 'this' || ref$ === 'eval' || ref$ === '..';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isComplex" id="apidoc.element.livescript.ast.Literal.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isComplex = function (){
  return this.isRegex() || this.value === 'debugger';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty" id="apidoc.element.livescript.ast.Literal.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isEmpty = function (){
  var ref$;
  return (ref$ = this.value) === 'void' || ref$ === 'null';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isRegex" id="apidoc.element.livescript.ast.Literal.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isRegex = function (){
  return (this.value + "").charAt() === '/';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isString" id="apidoc.element.livescript.ast.Literal.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isString = function (){
  return 0 &lt;= '\'"'.indexOf((this.value + "").charAt());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isWhat" id="apidoc.element.livescript.ast.Literal.prototype.isWhat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.isWhat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.isWhat = function (){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.isCallable():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
  default:

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn" id="apidoc.element.livescript.ast.Literal.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.makeReturn = function (it){
  if (!it &amp;&amp; this.value === 'debugger') {
    return this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey" id="apidoc.element.livescript.ast.Literal.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.maybeKey = function (){
  if (ID.test(this.value)) {
    return Key(this.value);
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.varName" id="apidoc.element.livescript.ast.Literal.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Literal.prototype.varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Literal.prototype.varName = function (){
  if (/^\w+$/.test(this.value)) {
    return '$' + this.value;
  } else {
    return '';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj" id="apidoc.element.livescript.ast.Obj">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Obj
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.compileNode" id="apidoc.element.livescript.ast.Obj.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Obj.prototype.compileNode = function (o){
  var items, code, idt, dic, i$, len$, i, node, logic, rest, ref$, multi, key, val;
  items = this.items;
  if (!items.length) {
    return sn(this, this.front ? '({})' : '{}');
  }
  code = [];
  idt = '\n' + (o.indent += TAB);
  dic = {};
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      code.push(idt, node.compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Splat || (node.key || node) instanceof Parens) {
      rest = items.slice(i);
      break;
    }
    if (logic) {
      if (node instanceof Prop) {
        node.val = (logic.first = node.val, logic);
      } else {
        node = Prop(node, (logic.first = node, logic));
      }
    }
    if (this.deepEq &amp;&amp; node instanceof Prop) {
      if (node.val instanceof Var &amp;&amp; node.val.value === '_') {
        node.val = Obj([Prop(Key('__placeholder__'), Literal(true))]);
      } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
        node.val.deepEq = true;
      }
    }
    if (multi) {
      code.push(',');
    } else {
      multi = true;
    }
    code.push(idt);
    if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        code.push(node.compileAccessor(o, key = key.compile(o)));
      } else {
        val.ripName(key);
        code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
      }
    } else {
      code.push(key = node.compile(o), ": ", key);
    }
    ID.test(key) || (key = Function("return " + key)());
    if (!(dic[key + "."] ^= 1)) {
      node.carp("duplicate property \"" + key + "\"");
    }
  }
  if (code.join("")) {
    code.push('\n' + this.tab);
  }
  code = sn.apply(null, [null, sn(this, "{")].concat(slice$.call(code), [sn(this, "}")]));
  rest &amp;&amp; (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
  if (this.front &amp;&amp; '{' === code.toString().charAt()) {
    return sn(null, "(", code, ")");
  } else {
    return code;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.toSlice" id="apidoc.element.livescript.ast.Obj.prototype.toSlice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Obj.prototype.toSlice
        <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Obj.prototype.toSlice = function (o, base, symbol, assign){
  var items, ref$, ref, temps, i$, len$, i, node, name, chain, logic, key, val;
  items = this.items;
  if (items.length &gt; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      continue;
    }
    if (node instanceof Prop || node instanceof Splat) {
      node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
    } else {
      if (logic = node.getDefault()) {
        node = node.first;
      }
      if (node instanceof Parens) {
        ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
        if (assign) {
          ref$ = [node, key], key = ref$[0], node = ref$[1];
        }
        key = Parens(key);
      } else {
        key = node;
      }
      val = chain = Chain(base, [Index(node.maybeKey(), symbol)]);
      if (logic) {
        val = (logic.first = val, logic);
      }
      items[i] = Prop(key, val);
    }
    base = ref;
  }
  chain || this.carp('empty slice');
  if (temps) {
    (chain.head = Var(temps[0])).temp = true;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens" id="apidoc.element.livescript.ast.Parens">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.compile" id="apidoc.element.livescript.ast.Parens.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.compile = function (o, level){
  var it;
  level == null &amp;&amp; (level = o.level);
  it = this.it;
  it.cond || (it.cond = this.cond), it['void'] || (it['void'] = this['void']);
  if (this.calling &amp;&amp; (!level || this['void'])) {
    it.head.hushed = true;
  }
  if (!(this.keep || this.newed || level &gt;= LEVEL_OP + PREC[it.op])) {
    return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
  }
  if (it.isStatement()) {
    return it.compileClosure(o);
  } else {
    return sn(null, sn(this.lb, "("), it.compile(o, LEVEL_PAREN), sn(this.rb, ")"));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isComplex" id="apidoc.element.livescript.ast.Parens.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isComplex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.isComplex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isRegex" id="apidoc.element.livescript.ast.Parens.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isString" id="apidoc.element.livescript.ast.Parens.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.isString = function (){
  return this.string || this.it.isString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.show" id="apidoc.element.livescript.ast.Parens.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.show = function (){
  return this.string &amp;&amp; '""';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.unparen" id="apidoc.element.livescript.ast.Parens.prototype.unparen">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Parens.prototype.unparen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Parens.prototype.unparen = function (){
  if (this.keep) {
    return this;
  } else {
    return this.it.unparen();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop" id="apidoc.element.livescript.ast.Prop">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === '...') {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
    }
    this$['accessor'] = 'accessor';
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.assigns" id="apidoc.element.livescript.ast.Prop.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Prop.prototype.assigns = function (it){
  var ref$;
  return typeof (ref$ = this.val).assigns == 'function' ? ref$.assigns(it) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor" id="apidoc.element.livescript.ast.Prop.prototype.compileAccessor">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.compileAccessor
        <span class="apidocSignatureSpan">(o, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Prop.prototype.compileAccessor = function (o, key){
  var funs, code, i$, len$, fun;
  funs = this.val;
  if (funs[1] &amp;&amp; funs[0].params.length + funs[1].params.length !== 1) {
    funs[0].carp('invalid accessor parameter');
  }
  code = [];
  for (i$ = 0, len$ = funs.length; i$ &lt; len$; ++i$) {
    fun = funs[i$];
    fun.accessor = true;
    code.push(fun.x, "et ", key, fun.compile(o, LEVEL_LIST).toString().slice(8), ',\n' + o.indent);
  }
  code.pop();
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor" id="apidoc.element.livescript.ast.Prop.prototype.compileDescriptor">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.compileDescriptor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Prop.prototype.compileDescriptor = function (o){
  var obj, i$, ref$, len$, fun;
  obj = Obj();
  for (i$ = 0, len$ = (ref$ = this.val).length; i$ &lt; len$; ++i$) {
    fun = ref$[i$];
    obj.items.push(Prop(Key(fun.x + 'et'), fun));
  }
  obj.items.push(Prop(Key('configurable'), Literal(true)));
  obj.items.push(Prop(Key('enumerable'), Literal(true)));
  return obj.compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.show" id="apidoc.element.livescript.ast.Prop.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Prop.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Prop.prototype.show = function (){
  return this.accessor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require" id="apidoc.element.livescript.ast.Require">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Require
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require.prototype.compile" id="apidoc.element.livescript.ast.Require.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Require.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Require.prototype.compile = function (o){
  var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
  getValue = function(item, throwError){
    switch (false) {
    case !(item instanceof Key):
      return item.name;
    case !(item instanceof Var):
      return item.value;
    case !(item instanceof Literal):
      return item.value;
    default:
      if (throwError) {
        return this$.carp('invalid require! argument');
      } else {
        return item;
      }
    }
  };
  processItem = function(item){
    var ref$, asg, value, asgValue, toAsg, main;
    ref$ = (function(){
      switch (false) {
      case !(item instanceof Prop):
        return [item.val, item.key];
      default:
        return [item, item];
      }
    }()), asg = ref$[0], value = ref$[1];
    asgValue = getValue(asg);
    toAsg = toString$.call(asgValue).slice(8, -1) === 'String' ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
    value = stripString(getValue(value, true));
    main = Chain(CopyL(this, Var('require'))).add(Call([Literal("'" + value + "'")]));
    return sn(item, Assign(toAsg, main).compile(o));
  };
  if (this.body.items != null) {
    code = [];
    for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ &lt; len$; ++i$) {
      item = ref$[i$];
      code.push(processItem(item), ";\n" + o.indent);
    }
    code.pop();
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, processItem(this.body));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return" id="apidoc.element.livescript.ast.Return">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &amp;&amp; it.value !== 'void') {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.compileNode" id="apidoc.element.livescript.ast.Return.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Return.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Return.prototype.compileNode = function (o){
  var that;
  return sn.apply(null, [this, "return"].concat(
    (that = this.it)
      ? [' ', that.compile(o, LEVEL_PAREN)]
      : [], [";"]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice" id="apidoc.element.livescript.ast.Slice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Slice
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &amp;&amp; (this$.from = Literal(0));
  if (this$.to &amp;&amp; this$.type === 'to') {
    this$.to = Binary('+', this$.to, Literal('1'));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.compileNode" id="apidoc.element.livescript.ast.Slice.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Slice.prototype.compileNode = function (o){
  var args;
  if (this.to &amp;&amp; this.type === 'to') {
    this.to = Binary('||', this.to, Literal('9e9'));
  }
  args = [this.target, this.from];
  if (this.to) {
    args.push(this.to);
  }
  return Chain(Var(util('slice'))).add(Index(Key('call'), '.', true)).add(Call(args)).compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.show" id="apidoc.element.livescript.ast.Slice.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Slice.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Slice.prototype.show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat" id="apidoc.element.livescript.ast.Splat">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Splat
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.assigns" id="apidoc.element.livescript.ast.Splat.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Splat.prototype.assigns = function (it){
  return this.it.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.compile" id="apidoc.element.livescript.ast.Splat.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Splat.prototype.compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Splat.prototype.compile = function (){
  return this.carp('invalid splat');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice" id="apidoc.element.livescript.ast.StepSlice">
        function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode" id="apidoc.element.livescript.ast.StepSlice.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.StepSlice.prototype.compileNode = function (o){
  var ref$, sub, ref, temps, code;
  this.index = o.scope.temporary('x');
  ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
  this.guard = Binary('&lt;', Literal(this.index), Chain(ref).add(Index(Key('length'))));
  this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
  if (this.makeReturnArg != null) {
    this.makeReturn(this.makeReturnArg);
  }
  code = [];
  if (temps) {
    code.push(sub.compile(o), ';' + '\n' + o.indent);
  }
  code.push(superclass.prototype.compileNode.apply(this, arguments));
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn" id="apidoc.element.livescript.ast.StepSlice.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.StepSlice.prototype.makeReturn
        <span class="apidocSignatureSpan">(makeReturnArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.StepSlice.prototype.makeReturn = function (makeReturnArg){
  this.makeReturnArg = makeReturnArg;
  return superclass.prototype.makeReturn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super" id="apidoc.element.livescript.ast.Super">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.compile" id="apidoc.element.livescript.ast.Super.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Super.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Super.prototype.compile = function (o){
  var scope, that, result, ref$;
  scope = o.scope;
  if (!this.sproto) {
    for (; that = !scope.get('superclass') &amp;&amp; scope.fun; scope = scope.parent) {
      result = that;
      if (that = result.meth) {
        return sn(this, 'superclass.prototype', Index(that).compile(o));
      }
      if (that = result.stat) {
        return sn(this, 'superclass', Index(that).compile(o));
      }
      if (that = scope.fun.inClass) {
        return sn(this, that, ".superclass.prototype.", scope.fun.name);
      } else if (that = scope.fun.inClassStatic) {
        return sn(this, that, ".superclass.", scope.fun.name);
      }
    }
    if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
      return sn(this, that, ".superclass");
    }
  }
  return sn(this, 'superclass');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch" id="apidoc.element.livescript.ast.Switch">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this['default'] = $default;
  if (type === 'match') {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &gt; 1) {
        throw "can't have more than one topic in switch statement";
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &amp;&amp; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &amp;&amp; last.tests[0] instanceof Var &amp;&amp; last
.tests[0].value === '_') {
    this.cases.pop();
    this['default'] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.compileNode" id="apidoc.element.livescript.ast.Switch.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Switch.prototype.compileNode = function (o){
  var tab, ref$, targetNode, target, topic, t, code, stop, i$, len$, i, c, that;
  tab = this.tab;
  if (this.target) {
    ref$ = Chain(this.target).cacheReference(o), targetNode = ref$[0], target = ref$[1];
  }
  topic = this.type === 'match'
    ? (t = target
      ? [targetNode]
      : [], Block(t.concat([Literal('false')])).compile(o, LEVEL_PAREN))
    : !!this.topic &amp;&amp; this.anaphorize().compile(o, LEVEL_PAREN);
  code = [sn(this, "switch (", snSafe(topic), ") {\n")];
  stop = this['default'] || this.cases.length - 1;
  o['break'] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    i = i$;
    c = ref$[i$];
    code.push(c.compileCase(o, tab, i === stop, this.type === 'match' || !topic, this.type, target));
  }
  if (this['default']) {
    o.indent = tab + TAB;
    if (that = this['default'].compile(o, LEVEL_TOP)) {
      code.push(tab + "default:\n", that, "\n");
    }
  }
  return sn.apply(null, [null].concat(slice$.call(code), [tab + '}']));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.getJump" id="apidoc.element.livescript.ast.Switch.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Switch.prototype.getJump = function (ctx){
  var i$, ref$, len$, c, that;
  ctx || (ctx = {});
  ctx['break'] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    c = ref$[i$];
    if (that = c.body.getJump(ctx)) {
      return that;
    }
  }
  return (ref$ = this['default']) != null ? ref$.getJump(ctx) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.isCallable" id="apidoc.element.livescript.ast.Switch.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Switch.prototype.isCallable = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    c = ref$[i$];
    if (!c.isCallable()) {
      return false;
    }
  }
  if (this['default']) {
    return this['default'].isCallable();
  } else {
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn" id="apidoc.element.livescript.ast.Switch.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Switch.prototype.makeReturn = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    c = ref$[i$];
    c.makeReturn.apply(c, arguments);
  }
  if ((ref$ = this['default']) != null) {
    ref$.makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.show" id="apidoc.element.livescript.ast.Switch.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Switch.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Switch.prototype.show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw" id="apidoc.element.livescript.ast.Throw">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.compileNode" id="apidoc.element.livescript.ast.Throw.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Throw.prototype.compileNode = function (o){
  var ref$;
  return sn(this, "throw ", ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || 'null', ";");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.getJump" id="apidoc.element.livescript.ast.Throw.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Throw.prototype.getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try" id="apidoc.element.livescript.ast.Try">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var('e'), Var('e$')));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.compileNode" id="apidoc.element.livescript.ast.Try.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Try.prototype.compileNode = function (o){
  var code, that;
  o.indent += TAB;
  code = [sn(this, 'try '), this.compileBlock(o, this.attempt)];
  if (that = this.recovery || !this.ensure &amp;&amp; JS('')) {
    code.push(sn(that, ' catch (e$) '), this.compileBlock(o, that));
  }
  if (that = this.ensure) {
    code.push(sn(that, ' finally '), this.compileBlock(o, that));
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.getJump" id="apidoc.element.livescript.ast.Try.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Try.prototype.getJump = function (it){
  var ref$;
  return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.isCallable" id="apidoc.element.livescript.ast.Try.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Try.prototype.isCallable = function (){
  var ref$;
  return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) &amp;&amp; this.attempt.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.makeReturn" id="apidoc.element.livescript.ast.Try.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Try.prototype.makeReturn = function (){
  var ref$;
  this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
  if (this.recovery != null) {
    this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.show" id="apidoc.element.livescript.ast.Try.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Try.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Try.prototype.show = function (){
  return this.thrown;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary" id="apidoc.element.livescript.ast.Unary">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &amp;&amp; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case '!':
      if (flag) {
        break;
      }
      if (it instanceof Fun &amp;&amp; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case '++':
    case '--':
      if (flag) {
        this$.post = true;
      }
      break;
    case 'new':
      if (it instanceof Existence &amp;&amp; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || '').length; i$ &lt; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &amp;&amp; !node['new']) {
          if (node.method === '.call') {
            node.args.shift();
          }
          node['new'] = 'new';
          node.method = '';
          return it;
        }
      }
      break;
    case '~':
      if (it instanceof Fun &amp;&amp; it.statement &amp;&amp; !it.bound) {
        return it.bound = 'this$', it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc" id="apidoc.element.livescript.ast.Unary.prototype.compileAsFunc">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileAsFunc
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.compileAsFunc = function (o){
  if (this.op === '!') {
    return sn(this, util('not'));
  } else {
    return sn(this, "(", Fun([], Block(Unary(this.op, Chain(Var('it'))))).compile(o), ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileNode" id="apidoc.element.livescript.ast.Unary.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.compileNode = function (o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case '!':
    it.cond = true;
    break;
  case 'new':
    it.isCallable() || it.carp('invalid constructor');
    break;
  case 'do':
    if (o.level === LEVEL_TOP &amp;&amp; it instanceof Fun &amp;&amp; it.isStatement()) {
      return sn(this, it.compile(o), " ", Unary('do', Var(it.name)).compile(o));
    }
    x = Parens(it instanceof Existence &amp;&amp; !it.negated
      ? Chain(it).add(Call())
      : Call.make(it));
    return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
  case 'delete':
    if (it instanceof Var || !it.isAssignable()) {
      this.carp('invalid delete');
    }
    if (o.level &amp;&amp; !this['void']) {
      return this.compilePluck(o);
    }
    break;
  case '++':
  case '--':
    it.isAssignable() || this.carp('invalid ' + crement(op));
    if (that = it instanceof Var &amp;&amp; o.scope.checkReadOnly(it.value)) {
      this.carp(crement(op) + " of " + that + " \"" + it.value + "\"", ReferenceError);
    }
    if (this.post) {
      it.front = this.front;
    }
    break;
  case '^^':
    return sn(this, util('clone'), "(", it.compile(o, LEVEL_LIST), ")");
  case 'jsdelete':
    return sn(this, "delete ", it.compile(o, LEVEL_LIST));
  case 'classof':
    return sn(this, util('toString'), ".call(", it.compile(o, LEVEL_LIST), ").slice(8, -1)");
  }
  code = [it.compile(o, LEVEL_OP + PREC.unary)];
  if (this.post) {
    code.push(op);
  } else {
    if ((op === 'new' || op === 'typeof' || op === 'delete') || (op === '+' || op === '-') &amp;&amp; op === code.join("").charAt()) {
      op += ' ';
    }
    code.unshift(op);
  }
  if (o.level &lt; LEVEL_CALL) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck" id="apidoc.element.livescript.ast.Unary.prototype.compilePluck">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compilePluck
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.compilePluck = function (o){
  var ref$, get, del, code, ref;
  ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
  code = [ref = o.scope.temporary(), " = ", get.compile(o, LEVEL_LIST), ", delete ", del.compile(o, LEVEL_LIST), ", ", o.scope.free
(ref)];
  if (o.level &lt; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread" id="apidoc.element.livescript.ast.Unary.prototype.compileSpread">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.compileSpread
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.compileSpread = function (o){
  var it, ops;
  it = this.it;
  ops = [this];
  for (; it instanceof constructor; it = it.it) {
    ops.push(it);
  }
  if (!(it instanceof Splat &amp;&amp; (it = it.it.expandSlice(o).unwrap()) instanceof List)) {
    return '';
  }
  return this.compileSpreadOver(o, it, function(node){
    var i$, ref$, op;
    for (i$ = (ref$ = ops).length - 1; i$ &gt;= 0; --i$) {
      op = ref$[i$];
      node = constructor(op.op, node, op.post);
    }
    return node;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors" id="apidoc.element.livescript.ast.Unary.prototype.getAccessors">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.getAccessors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.getAccessors = function (){
  var items;
  if (this.op !== '~') {
    return;
  }
  if (this.it instanceof Fun) {
    return [this.it];
  }
  if (this.it instanceof Arr) {
    items = this.it.items;
    if (!items[2] &amp;&amp; items[0] instanceof Fun &amp;&amp; items[1] instanceof Fun) {
      return items;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.invert" id="apidoc.element.livescript.ast.Unary.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.invert = function (){
  var ref$;
  if (this.op === '!' &amp;&amp; ((ref$ = this.it.op) === '!' || ref$ === '&lt;' || ref$ === '&gt;' || ref$ === '&lt;=' || ref$ === '&gt;=' || ref$ === '
of' || ref$ === 'instanceof')) {
    return this.it;
  }
  return constructor('!', this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isArray" id="apidoc.element.livescript.ast.Unary.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.isArray = function (){
  return this.it instanceof Arr &amp;&amp; this.it.items.length || this.it instanceof Chain &amp;&amp; this.it.isArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isCallable" id="apidoc.element.livescript.ast.Unary.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.isCallable = function (){
  var ref$;
  return ((ref$ = this.op) === 'do' || ref$ === 'new' || ref$ === 'delete') || this.it == null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isString" id="apidoc.element.livescript.ast.Unary.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.isString = function (){
  var ref$;
  return (ref$ = this.op) === 'typeof' || ref$ === 'classof';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.show" id="apidoc.element.livescript.ast.Unary.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.show = function (){
  return [this.post ? '@' : void 8] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Unary.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Unary.prototype.unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Unary.prototype.unfoldSoak = function (o){
  var ref$;
  return ((ref$ = this.op) === '++' || ref$ === '--' || ref$ === 'delete') &amp;&amp; this.it != null &amp;&amp; If.unfoldSoak(o, this, 'it');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util" id="apidoc.element.livescript.ast.Util">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Util
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.compile" id="apidoc.element.livescript.ast.Util.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Util.prototype.compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Util.prototype.compile = function (){
  return sn(this, util(this.verb));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var" id="apidoc.element.livescript.ast.Var">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.assigns" id="apidoc.element.livescript.ast.Var.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Var.prototype.assigns = function (it){
  return it === this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.compile" id="apidoc.element.livescript.ast.Var.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Var.prototype.compile = function (o){
  return sn(this, this.temp
    ? o.scope.free(this.value)
    : this.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.maybeKey" id="apidoc.element.livescript.ast.Var.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Var.prototype.maybeKey = function (){
  var ref$;
  return ref$ = Key(this.value), ref$.line = this.line, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.varName" id="apidoc.element.livescript.ast.Var.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Var.prototype.varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Var.prototype.varName = function (){
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars" id="apidoc.element.livescript.ast.Vars">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Vars
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.compile" id="apidoc.element.livescript.ast.Vars.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Vars.prototype.compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Vars.prototype.compile = function (o, level){
  var i$, ref$, len$, v, value;
  for (i$ = 0, len$ = (ref$ = this.vars).length; i$ &lt; len$; ++i$) {
    v = ref$[i$], value = v.value;
    if (!(v instanceof Var)) {
      v.carp('invalid variable declaration');
    }
    if (o.scope.check(value)) {
      v.carp("redeclaration of \"" + value + "\"");
    }
    o.scope.declare(value, v);
  }
  return sn(this, Literal('void').compile(o, level));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While" id="apidoc.element.livescript.ast.While">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &amp;&amp; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== '' + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addBody" id="apidoc.element.livescript.ast.While.prototype.addBody">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.addBody = function (body){
  var top;
  this.body = body;
  if (this.guard) {
    this.body = Block(If(this.guard, this.body));
  }
  top = this.body.lines[0];
  if ((top != null ? top.verb : void 8) === 'continue' &amp;&amp; !top.label) {
    this.body.lines.length = 0;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addGuard" id="apidoc.element.livescript.ast.While.prototype.addGuard">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addGuard
        <span class="apidocSignatureSpan">(guard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.addGuard = function (guard){
  this.guard = guard;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addObjComp" id="apidoc.element.livescript.ast.While.prototype.addObjComp">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.addObjComp
        <span class="apidocSignatureSpan">(objComp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.addObjComp = function (objComp){
  this.objComp = objComp != null ? objComp : true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileBody" id="apidoc.element.livescript.ast.While.prototype.compileBody">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.compileBody
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.compileBody = function (o){
  var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ =
this;
  o['break'] = o['continue'] = true;
  lines = this.body.lines, yet = this.yet, tab = this.tab;
  code = [];
  ret = [];
  mid = [];
  empty = this.objComp ? '{}' : '[]';
  getResultName = function(){
    return _resultName != null
      ? _resultName
      : _resultName = o.scope.temporary(this$.objComp ? 'resultObj' : 'results');
  };
  last = lines != null ? lines[lines.length - 1] : void 8;
  if (!(this.isComprehension || this.inComprehension) || (last != null &amp;&amp; last.isComprehension)) {
    hasLoop = false;
    if (last != null) {
      last.traverseChildren(function(it){
        var ref$;
        if (it instanceof Block &amp;&amp; (ref$ = it.lines)[ref$.length - 1] instanceof While) {
          hasLoop = true;
        }
      });
    }
    if (this.returns &amp;&amp; !this.resVar) {
      this.resVar = res = o.scope.assign(getResultName(), empty);
    }
    if (this.resVar &amp;&amp; (last instanceof While || hasLoop)) {
      temp = o.scope.temporary('lresult');
      lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
        ? Obj()
        : Arr(), '='));
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(temp);
      }
      mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key('push'), '.', true)).add(Call([Chain(Var(temp))])).compile(o), ";\n" +
this.tab);
    } else {
      this.hasReturned = true;
      if (this.resVar) {
        this.body.makeReturn(this.resVar);
      }
    }
  }
  if (this.returns) {
    if ((!last instanceof While &amp;&amp; !this.hasReturned) || this.isComprehension || this.inComprehension) {
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
      }
    }
    ret.push("\n" + this.tab + "return ", res || empty, ";");
    if ((ref$ = this['else']) != null) {
      ref$.makeReturn();
    }
  }
  yet &amp;&amp; lines.unshift(JS(yet + " = false;"));
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push("\n", bodyCode, "\n" + tab);
  }
  code.push.apply(code, mid);
  code.push('}');
  if (this.post) {
    code.push(sn(this, " while ("), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, ");"));
  }
  if (yet) {
    code.push(sn(this, " if ("), yet, sn(this, ") "), this.compileBlock(o, Block(this['else'])));
    o.scope.free(yet);
  }
  return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileNode" id="apidoc.element.livescript.ast.While.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.compileNode = function (o){
  var test, ref$, head, that;
  o.loop = true;
  this.test &amp;&amp; (this.un
    ? this.test = this.test.invert()
    : this.anaphorize());
  if (this.post) {
    return sn(null, sn(this, 'do {'), this.compileBody((o.indent += TAB, o)));
  }
  test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
  if (!(this.update || this['else'])) {
    head = !snEmpty(test)
      ? [sn(this, "while ("), test]
      : [sn(this, 'for (;;')];
  } else {
    head = [sn(this, 'for (')];
    if (this['else']) {
      head.push(this.yet = o.scope.temporary('yet'), " = true");
    }
    head.push(sn(this, ";"), test.toString() &amp;&amp; ' ', test, sn(this, ";"));
    if (that = this.update) {
      head.push(' ', that.compile(o, LEVEL_PAREN));
    }
  }
  return sn.apply(null, [null].concat(slice$.call(head), [sn(this, ') {'), this.compileBody((o.indent += TAB, o))]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.getJump" id="apidoc.element.livescript.ast.While.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.getJump = function (ctx){
  var i$, ref$, ref1$, len$, node;
  ctx || (ctx = {});
  ctx['continue'] = true;
  ctx['break'] = true;
  for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.getJump(ctx)) {
      return node;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeComprehension" id="apidoc.element.livescript.ast.While.prototype.makeComprehension">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.makeComprehension
        <span class="apidocSignatureSpan">(toAdd, loops)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.makeComprehension = function (toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().addBody(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeReturn" id="apidoc.element.livescript.ast.While.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.makeReturn = function (it){
  var last, ref$, ref1$, ref2$;
  if (this.hasReturned) {
    return this;
  }
  if (it) {
    if (this.objComp) {
      this.body = Block(this.body.makeReturn(it, true));
    } else {
      if (!(this.body || this.index)) {
        this.addBody(Block(Var(this.index = 'ridx$')));
      }
      last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
      if ((this.isComprehension || this.inComprehension) &amp;&amp; !(last != null &amp;&amp; last.isComprehension)) {
        (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
        if ((ref1$ = this['else']) != null) {
          ref1$.makeReturn.apply(ref1$, arguments);
        }
        this.hasReturned = true;
      } else {
        this.resVar = it;
        if ((ref2$ = this['else']) != null) {
          ref2$.makeReturn.apply(ref2$, arguments);
        }
      }
    }
  } else {
    this.getJump() || (this.returns = true);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.show" id="apidoc.element.livescript.ast.While.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.While.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.While.prototype.show = function (){
  return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield" id="apidoc.element.livescript.ast.Yield">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Yield
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.compileNode" id="apidoc.element.livescript.ast.Yield.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Yield.prototype.compileNode = function (o){
  var code;
  code = [];
  if (this.op === 'yieldfrom') {
    code.push('yield*');
  } else {
    code.push('yield');
  }
  if (this.it) {
    code.push(" " + this.it.compile(o, LEVEL_OP + PREC.unary));
  }
  return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.isCallable" id="apidoc.element.livescript.ast.Yield.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Yield.prototype.isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.show" id="apidoc.element.livescript.ast.Yield.prototype.show">
        function <span class="apidocSignatureSpan">livescript.</span>ast.Yield.prototype.show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.Yield.prototype.show = function (){
  if (this.op === 'yieldfrom') {
    return 'from';
  } else {
    return '';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.fromJSON" id="apidoc.element.livescript.ast.fromJSON">
        function <span class="apidocSignatureSpan">livescript.</span>ast.fromJSON
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &amp;&amp; typeof it === 'object')) {
    return it;
  }
  if (that = it.type) {
    node = clone$(exports[that].prototype);
    for (key in it) {
      val = it[key];
      node[key] = fromJSON(val);
    }
    return node;
  }
  if (it.length != null) {
    for (i$ = 0, len$ = it.length; i$ &lt; len$; ++i$) {
      v = it[i$];
      results$.push(fromJSON(v));
    }
    return results$;
  } else {
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.parse" id="apidoc.element.livescript.ast.parse">
        function <span class="apidocSignatureSpan">livescript.</span>ast.parse
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast.parse = function (json){
  return exports.fromJSON(JSON.parse(json));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.command" id="apidoc.element.livescript.command">
        function <span class="apidocSignatureSpan">livescript.</span>command
        <span class="apidocSignatureSpan">(args, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">command = function (args, arg$){
  var ref$, say, sayWithTimestamp, warn, die, p, pp, ppp, fileExists, dasherizeVars, startsWith, o, positional, e, validMapValues
, toInsert, that, filename, jsonCallback;
  ref$ = arg$ != null
    ? arg$
    : {}, say = ref$.say, sayWithTimestamp = ref$.sayWithTimestamp, warn = ref$.warn, die = ref$.die;
  say == null &amp;&amp; (say = console.log);
  sayWithTimestamp == null &amp;&amp; (sayWithTimestamp = util.log);
  warn == null &amp;&amp; (warn = console.error);
  die == null &amp;&amp; (die = function(message){
    console.error(message);
    process.exit(1);
  });
  p = function(){
    var args, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ &lt; to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    each(console.dir, args);
  };
  pp = function(x, showHidden, depth){
    say(util.inspect(x, showHidden, depth, !process.env.NODE_DISABLE_COLORS));
  };
  ppp = function(it){
    pp(it, true, null);
  };
  fileExists = function(path){
    try {
      fs.statSync(path);
      return true;
    } catch (e$) {}
  };
  dasherizeVars = function(str){
    if (/^[a-z]/.exec(str)) {
      return dasherize(str);
    } else {
      return str;
    }
  };
  startsWith = function(str){
    var this$ = this;
    return function(it){
      return it.indexOf(str) === 0;
    };
  };
  try {
    o = parseOptions(args);
    positional = o._;
  } catch (e$) {
    e = e$;
    die(e.message);
  }
  switch (false) {
  case !o.nodejs:
    forkNode();
    break;
  case !o.version:
    say("LiveScript version " + version);
    break;
  case !o.help:
    say(generateHelp({
      interpolate: {
        version: version
      }
    }));
    break;
  default:
    validMapValues = ['none', 'linked', 'linked-src', 'embedded', 'debug'];
    if (!in$(o.map, validMapValues)) {
      die("Option --map must be either: " + validMapValues.join(', '));
    }
    o.run = !(o.compile || (o.compile = o.output));
    if (args === process.argv) {
      process.argv[0] = process.argv[1];
      toInsert = o.stdin
        ? positional
        : o.run
          ? positional.splice(1, 9e9)
          : [];
      (ref$ = process.argv).splice.apply(ref$, [2, 9e9].concat(slice$.call(toInsert)));
    }
    if (that = o.require) {
      filename = module.filename;
      module.filename = '.';
      each(function(it){
        return global[nameFromPath(it)] = require(it);
      })(
      that);
      module.filename = filename;
    }
    switch (false) {
    case !o.eval:
      jsonCallback = function(input){
        if (o.prelude) {
          import$(global, prelude);
        }
        o.runContext = JSON.parse(input.toString());
        compileScript('', o.eval);
      };
      if (positional.length &amp;&amp; (o.json || /\.json$/.test(positional[0]))) {
        o.json = true;
        fshoot('readFile', positional[0], jsonCallback);
      } else if (o.json) {
        getStdin(jsonCallback);
      } else {
        compileScript('', o.eval);
      }
      break;
    case !o.stdin:
      compileStdin();
      break;
    case !positional.length:
      compileScripts();
      break;
    case !require('tty').isatty(0):
      say("LiveScript " + version + " - use 'lsc --help' for more information");
      repl();
      break;
    default:
      compileStdin();
    }
  }
  function fshoot(name, arg, callback){
    fs[name](arg, function(e, result){
      if (e) {
        die(e.stack || e);
      }
      callback(result);
    });
  }
  function compileScripts(){
    positional.forEach(function(it){
      walk(it, path.normalize(it), true);
    });
    function walk(source, base, top){
      function work(){
        fshoot('readFile', source, function(it){
          compileScript(source, it + "", base);
        });
      }
      fs.stat(source, function(e, stats){
        if (e) {
          if (!top || /(?:\.ls|\/)$/.test(source)) {
            die("Can't find: " + source);
          }
          walk(source + ".ls", base);
          return;
        }
        if (stats.isDirectory()) {
          if (!o.run) {
            fshoot('readdir', source, function(it) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.compile" id="apidoc.element.livescript.compile">
        function <span class="apidocSignatureSpan">livescript.</span>compile
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (code, options){
  var result, ast, output, filename, outputFilename, ref$, mapPath, e, that;
  options == null &amp;&amp; (options = {});
  options.header == null &amp;&amp; (options.header = true);
  try {
    if (options.json) {
      result = Function(exports.compile(code, {
        bare: true,
        run: true,
        print: true
      }))();
      return JSON.stringify(result, null, 2) + "\n";
    } else {
      ast = parser.parse(lexer.lex(code));
      if (options.run &amp;&amp; options.print) {
        ast.makeReturn();
      }
      output = ast.compileRoot(options);
      if (options.header) {
        output = new SourceNode(null, null, null, ["// Generated by LiveScript " + exports.VERSION + "\n", output]);
      }
      if (options.map &amp;&amp; options.map !== 'none') {
        filename = options.filename, outputFilename = options.outputFilename;
        if (!filename) {
          filename = "unnamed-" + Math.floor(Math.random() * 4294967296).toString(16) + ".ls";
        }
        output.setFile(filename);
        result = output.toStringWithSourceMap();
        if (options.map === 'embedded') {
          result.map.setSourceContent(filename, code);
        }
        if ((ref$ = options.map) === 'linked' || ref$ === 'debug') {
          mapPath = outputFilename + ".map";
          result.code += "\n//# sourceMappingURL=" + mapPath + "\n";
        } else {
          result.code += "\n//# sourceMappingURL=data:application/json;base64," + new Buffer(result.map.toString()).toString('base64
') + "\n";
        }
        return result;
      } else {
        return output.toString();
      }
    }
  } catch (e$) {
    e = e$;
    if (that = options.filename) {
      e.message += "\nat " + that;
    }
    throw e;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.emit" id="apidoc.element.livescript.emit">
        function <span class="apidocSignatureSpan">livescript.</span>emit
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError &amp;&amp; events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  if (domain &amp;&amp; this !== process) {
    domain.enter();
    needDomainExit = true;
  }

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i &lt; len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  if (needDomainExit)
    domain.exit();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), "\n"];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.<span class="apidocCodeKeywordSpan">emit</span>(post, o.indent) : post]));
};
Block.prototype.compileExpressions = function(o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.eventNames" id="apidoc.element.livescript.eventNames">
        function <span class="apidocSignatureSpan">livescript.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  return this._eventsCount &gt; 0 ? Reflect.ownKeys(this._events) : [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.getMaxListeners" id="apidoc.element.livescript.getMaxListeners">
        function <span class="apidocSignatureSpan">livescript.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMaxListeners() {
  return $getMaxListeners(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.go" id="apidoc.element.livescript.go">
        function <span class="apidocSignatureSpan">livescript.</span>go
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">go = function (){
  var type, sink, i$, ref$, len$, script, that;
  type = /^(?:text\/|application\/)?ls$/i;
  sink = function(error){
    error &amp;&amp; setTimeout(function(){
      throw error;
    });
  };
  for (i$ = 0, len$ = (ref$ = document.getElementsByTagName('script')).length; i$ &lt; len$; ++i$) {
    script = ref$[i$];
    if (type.test(script.type)) {
      if (that = script.src) {
        LiveScript.load(that, sink);
      } else {
        LiveScript.stab(script.innerHTML, sink, script.id);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lex" id="apidoc.element.livescript.lex">
        function <span class="apidocSignatureSpan">livescript.</span>lex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lex = function (it){
  return lexer.lex(it, {
    raw: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    stack.length = stack.length - 2 * n;
    vstack.length = vstack.length - n;
    lstack.length = lstack.length - n;
}
_token_stack:
    var lex = function () {
        var token;
        token = lexer.<span class="apidocCodeKeywordSpan">lex</span>() || EOF;
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    };
var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
while (true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.listenerCount" id="apidoc.element.livescript.listenerCount">
        function <span class="apidocSignatureSpan">livescript.</span>listenerCount
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenerCount(type) {
  const events = this._events;

  if (events) {
    const evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.listeners" id="apidoc.element.livescript.listeners">
        function <span class="apidocSignatureSpan">livescript.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener];
    else
      ret = arrayClone(evlistener, evlistener.length);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      : t.output.code).trimRight());
  } else {
    writeJS(filename, t.output, t.input, base, json);
  }
} catch (e$) {
  e = e$;
  if (e != null) {
    if (LiveScript.<span class="apidocCodeKeywordSpan">listeners</span>('failure').length) {
      LiveScript.emit('failure', e, t);
    } else {
      if (filename) {
        warn("Failed at: " + filename);
      }
      if (!(e instanceof SyntaxError || /^Parse error /.test(e.message))) {
        e = e.stack || e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.load" id="apidoc.element.livescript.load">
        function <span class="apidocSignatureSpan">livescript.</span>load
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (url, callback){
  var xhr;
  xhr = new XMLHttpRequest;
  xhr.open('GET', url, true);
  if ('overrideMimeType' in xhr) {
    xhr.overrideMimeType('text/plain');
  }
  xhr.onreadystatechange = function(){
    var ref$;
    if (xhr.readyState === 4) {
      if ((ref$ = xhr.status) === 200 || ref$ === 0) {
        LiveScript.stab(xhr.responseText, callback, url);
      } else {
        if (typeof callback == 'function') {
          callback(Error(url + ": " + xhr.status + " " + xhr.statusText));
        }
      }
    }
  };
  xhr.send(null);
  return xhr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.node" id="apidoc.element.livescript.node">
        function <span class="apidocSignatureSpan">livescript.</span>node
        <span class="apidocSignatureSpan">(LiveScript)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">node = function (LiveScript){
  var fs, path, events;
  fs = require('fs');
  path = require('path');
  events = require('events');
  LiveScript.run = function(code, options, arg$){
    var filename, ref$, js, context, main, dirname, e;
    if (options != null) {
      filename = options.filename;
    }
    ref$ = arg$ != null
      ? arg$
      : {}, js = ref$.js, context = ref$.context;
    main = require.main;
    if (filename) {
      dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));
    } else {
      dirname = filename = '.';
    }
    main.paths = main.constructor._nodeModulePaths(dirname);
    main.filename = filename;
    if (!js) {
      code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
    }
    if (context) {
      global.__runContext = context;
      code = "return (function() {\n" + code + "\n}).call(global.__runContext);";
    }
    try {
      return main._compile(code, filename);
    } catch (e$) {
      e = e$;
      throw hackTrace(e, code, filename);
    }
  };
  importAll$(LiveScript, events.EventEmitter.prototype);
  require.extensions['.ls'] = function(module, filename){
    var file, js, e;
    file = fs.readFileSync(filename, 'utf8');
    js = '.json.ls' === filename.substr(-8)
      ? 'module.exports = ' + LiveScript.compile(file, {
        filename: filename,
        json: true
      })
      : LiveScript.compile(file, {
        filename: filename,
        bare: true,
        map: "embedded"
      }).code;
    try {
      return module._compile(js, filename);
    } catch (e$) {
      e = e$;
      throw hackTrace(e, js, filename);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.on" id="apidoc.element.livescript.on">
        function <span class="apidocSignatureSpan">livescript.</span>on
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  LiveScript.emit('success', t);
}
function getStdin(cb){
  var x$, code;
  x$ = process.openStdin();
  code = '';
  x$.<span class="apidocCodeKeywordSpan">on</span>('data', function(it){
    code += it;
  });
  x$.on('end', function(){
    cb(code);
  });
  x$.on('data', function(){
    var ref$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.once" id="apidoc.element.livescript.once">
        function <span class="apidocSignatureSpan">livescript.</span>once
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.prependListener" id="apidoc.element.livescript.prependListener">
        function <span class="apidocSignatureSpan">livescript.</span>prependListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.prependOnceListener" id="apidoc.element.livescript.prependOnceListener">
        function <span class="apidocSignatureSpan">livescript.</span>prependOnceListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependOnceListener(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.removeAllListeners" id="apidoc.element.livescript.removeAllListeners">
        function <span class="apidocSignatureSpan">livescript.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(type) {
  var listeners, events;

  events = this._events;
  if (!events)
    return this;

  // not listening for removeListener, no need to emit
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i = 0, key; i &lt; keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.removeListener" id="apidoc.element.livescript.removeListener">
        function <span class="apidocSignatureSpan">livescript.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = this._events;
  if (!events)
    return this;

  list = events[type];
  if (!list)
    return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events[type];
      if (events.removeListener)
        this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length; i-- &gt; 0;) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position &lt; 0)
      return this;

    if (list.length === 1) {
      list[0] = undefined;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }

    if (events.removeListener)
      this.emit('removeListener', type, originalListener || listener);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.run" id="apidoc.element.livescript.run">
        function <span class="apidocSignatureSpan">livescript.</span>run
        <span class="apidocSignatureSpan">(code, options, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (code, options, arg$){
  var filename, ref$, js, context, main, dirname, e;
  if (options != null) {
    filename = options.filename;
  }
  ref$ = arg$ != null
    ? arg$
    : {}, js = ref$.js, context = ref$.context;
  main = require.main;
  if (filename) {
    dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));
  } else {
    dirname = filename = '.';
  }
  main.paths = main.constructor._nodeModulePaths(dirname);
  main.filename = filename;
  if (!js) {
    code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
  }
  if (context) {
    global.__runContext = context;
    code = "return (function() {\n" + code + "\n}).call(global.__runContext);";
  }
  try {
    return main._compile(code, filename);
  } catch (e$) {
    e = e$;
    throw hackTrace(e, code, filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
json = o.json || /\.json\.ls$/.test(filename);
run = o.run || o.eval;
if (run) {
  LiveScript.emit('compile', t);
  print = json || o.print;
  t.output = LiveScript.compile(t.input, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$.run = run, ref$.print = print
, ref$));
  LiveScript.emit('run', t);
  t.result = LiveScript.<span class="apidocCodeKeywordSpan">run</span>(o.map === 'none'
    ? t.output
    : t.output.code, options, {
    js: true,
    context: o.runContext
  });
  switch (false) {
  case !json:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.setMaxListeners" id="apidoc.element.livescript.setMaxListeners">
        function <span class="apidocSignatureSpan">livescript.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners(n) {
  if (typeof n !== 'number' || n &lt; 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.stab" id="apidoc.element.livescript.stab">
        function <span class="apidocSignatureSpan">livescript.</span>stab
        <span class="apidocSignatureSpan">(code, callback, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stab = function (code, callback, filename){
  var e;
  try {
    LiveScript.run(code, {
      filename: filename,
      map: 'embedded'
    });
  } catch (e$) {
    e = e$;
  }
  if (typeof callback == 'function') {
    callback(e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.tokens" id="apidoc.element.livescript.tokens">
        function <span class="apidocSignatureSpan">livescript.</span>tokens
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokens = function (code, options){
  return clone$(exports).tokenize(code || '', options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
t = {
  input: input,
  options: options
};
try {
  if (o.lex || o.tokens || o.ast) {
    LiveScript.emit('lex', t);
    t.tokens = LiveScript.<span class="apidocCodeKeywordSpan">tokens</span>(t.input, {
      raw: o.lex
    });
    if (o.lex || o.tokens) {
      printTokens(t.tokens);
      throw null;
    }
    LiveScript.emit('parse', t);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.tokens.rewrite" id="apidoc.element.livescript.tokens.rewrite">
        function <span class="apidocSignatureSpan">livescript.</span>tokens.rewrite
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokens.rewrite = function (it){
  var ref$;
  it || (it = this.tokens);
  firstPass(it);
  addImplicitIndentation(it);
  rewriteBlockless(it);
  addImplicitParentheses(it);
  addImplicitBraces(it);
  expandLiterals(it);
  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
    it.shift();
  }
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.addListener" id="apidoc.module.livescript.addListener">module livescript.addListener</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.addListener.addListener" id="apidoc.element.livescript.addListener.addListener">
        function <span class="apidocSignatureSpan">livescript.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast" id="apidoc.module.livescript.ast">module livescript.ast</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.ast" id="apidoc.element.livescript.ast.ast">
        function <span class="apidocSignatureSpan">livescript.</span>ast
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ast = function (it){
  return parser.parse(typeof it === 'string' ? lexer.lex(it) : it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    raw: o.lex
  });
  if (o.lex || o.tokens) {
    printTokens(t.tokens);
    throw null;
  }
  LiveScript.emit('parse', t);
  t.ast = LiveScript.<span class="apidocCodeKeywordSpan">ast</span>(t.tokens);
  say(o.json
    ? t.ast.stringify(2)
    : ''.trim.call(t.ast));
  throw null;
}
json = o.json || /\.json\.ls$/.test(filename);
run = o.run || o.eval;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr" id="apidoc.element.livescript.ast.Arr">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.<span class="apidocCodeKeywordSpan">Arr</span>($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign" id="apidoc.element.livescript.ast.Assign">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || '=';
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += '';
  this$[rite instanceof Node ? 'right' : 'unaries'] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Assign</span>($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$
0-1],yy.Box($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary" id="apidoc.element.livescript.ast.Binary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === 'String') {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== '=':
        return '?';
      default:
        return '=';
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if ('=' === op.charAt(op.length - 1) &amp;&amp; ((ref$ = op.charAt(op.length - 2)) !== '=' &amp;&amp; ref$ !== '&lt;' &amp;&amp; ref$ !== '&gt;' &amp;&amp; ref$ !== '!')) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case 'in':
      return new In(first, second);
    case 'with':
      return new Import(Unary('^^', first), second, false);
    case '&lt;&lt;&lt;':
    case '&lt;&lt;&lt;&lt;':
      return Import(first, second, op === '&lt;&lt;&lt;&lt;');
    case '&lt;|':
      return Block(first).pipe(second, op);
    case '|&gt;':
      return Block(second).pipe(first, '&lt;|');
    case '.':
    case '.~':
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Binary</span>($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block" id="apidoc.element.livescript.ast.Block">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Block
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if ('length' in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Block</span>());
break;
case 62:
this.$ = yy.L(_$[$0], _$[$0],yy.Block($$[$0]));
break;
case 63: case 172:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Box" id="apidoc.element.livescript.ast.Box">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Box
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Box = function (v){
  if (typeof v === "object") {
    return v;
  } else {
    return new v.constructor(v);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan
">Box</span>($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call" id="apidoc.element.livescript.ast.Call">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Call
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &amp;&amp; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = '.call';
      args[0] = Literal('this');
      args[1] = Splat(Literal('arguments'));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &lt; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === '_') {
        args[i] = Chain(Literal('void'));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.<span class="apidocCodeKeywordSpan">Call</span>($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call['let']($$[$0-3], $$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade" id="apidoc.element.livescript.ast.Cascade">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 40:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], yy.Slice({
type: $$[$0-1],
target: $$[$0-4]
      }))));
break;
case 41:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], yy.<span class="apidocCodeKeywordSpan">Cascade</span>($$[$0-1], $$[$
0], 'with'))));
break;
case 42:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({
kind: $$[$0-2],
source: $$[$0-1],
body: $$[$0],
ref: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case" id="apidoc.element.livescript.ast.Case">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Case
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 201:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-4], $$[$0-5] === 'until', $$[$0-2]).addGuard($$[$0]));
break;
case 203:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].concat($$[$0]));
break;
case 206:
this.$ = yy.L(_$[$0-2], _$[$0],[yy.L(_$[$0-2],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">Case</span>($$[$0-1], $$[$0]))]);
break;
case 207:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat(yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))));
break;
case 212:
return this.$
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain" id="apidoc.element.livescript.ast.Chain">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &amp;&amp; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Chain</span>(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class" id="apidoc.element.livescript.ast.Class">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Class
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 139:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.Try($$[$0-5], $$[$0-3], yy.L(_$[$0-4],_$[$0-3], $$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 140:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 141:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Class</span>({
        title: $$[$0-3].unwrap(),
        sup: $$[$0-2],
        mixins: $$[$0-1],
        body: $$[$0]
      }));
break;
case 142:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.CopyL" id="apidoc.element.livescript.ast.CopyL">
        function <span class="apidocSignatureSpan">livescript.ast.</span>CopyL
        <span class="apidocSignatureSpan">(a, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CopyL = function (a, node){
  if (node &amp;&amp; typeof node === "object") {
    node.first_line = a.first_line;
    node.first_column = a.first_column;
    node.last_line = a.last_line;
    node.last_column = a.last_column;
    node.line = a.line;
    node.column = a.column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Decl" id="apidoc.element.livescript.ast.Decl">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Decl
        <span class="apidocSignatureSpan">(type, nodes, lno)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decl = function (type, nodes, lno){
  if (!nodes[0]) {
    throw SyntaxError("empty " + type + " on line " + lno);
  }
  return DECLS[type](nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.<span class="apidocCodeKeywordSpan">Decl</span>($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== 'arguments' &amp;&amp; $$[$0] !== &amp;#
x27;eval')), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence" id="apidoc.element.livescript.ast.Existence">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Existence</span>($$[$0-1].unwrap
()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call['let']($$[$0-3], $$[$0]))));
break;
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For" id="apidoc.element.livescript.ast.For">
        function <span class="apidocSignatureSpan">livescript.ast.</span>For
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &amp;&amp; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &lt; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &amp;&amp; !this.object) {
    this.carp('`for own` requires `of`');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 28:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var('flip$'))).add(yy.L(_$[$0-3],_$[$0-3],yy
.Call([$$[$0-3]])))).flipIt().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 29:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">For</span>({
        from: $$[$0-3],
        op: $$[$0-2],
        to: $$[$0-1],
        inComprehension: true
      }))));
break;
case 30:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun" id="apidoc.element.livescript.ast.Fun">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &amp;&amp; 'this$';
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 113:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]));
break;
case 114:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Existence($$[$0-1].unwrap(), true));
break;
case 115:
this.$ = yy.L(_$[$0-5], _$[$0],yy.<span class="apidocCodeKeywordSpan">Fun</span>($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test
($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
break;
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If" id="apidoc.element.livescript.ast.If">
        function <span class="apidocSignatureSpan">livescript.ast.</span>If
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$['if'] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
case 118:
this.$ = (yy.L(_$[$0-3],_$[$0-2], yy.<span class="apidocCodeKeywordSpan">If</span>($$[$0-2], $$[$0-1], $$[$0-3] === 'unless
')).addElse($$[$0]));
break;
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === 'unless')));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import" id="apidoc.element.livescript.ast.Import">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Import
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &amp;&amp; 'All';
  if (!all &amp;&amp; left instanceof Obj &amp;&amp; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
case 73:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Import</span>(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^'
;, $$[$0-2], {
  prec: 'yy.UNARY'
})), $$[$0], false));
break;
case 74:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^', $$[$0-2], {
  prec: 'yy.UNARY'
})), $$[$0].unwrap(), false));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In" id="apidoc.element.livescript.ast.In">
        function <span class="apidocSignatureSpan">livescript.ast.</span>In
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index" id="apidoc.element.livescript.ast.Index">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Index
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = '.');
  if (init &amp;&amp; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case '[]':
    this$.vivify = Arr;
    break;
  case '{}':
    this$.vivify = Obj;
    break;
  default:
    if ('=' === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Index</span>($$[$0], $$[$
0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS" id="apidoc.element.livescript.ast.JS">
        function <span class="apidocSignatureSpan">livescript.ast.</span>JS
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 66:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], 'cascade'));
break;
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">JS</span>($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS("Error('unimplemented')"))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump" id="apidoc.element.livescript.ast.Jump">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
case 125:
this.$ = yy.L(_$[$0], _$[$0],yy.Jump[$$[$0]]());
break;
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Jump</span>($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.Switch($$[$0-2], $$[$0-1], $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key" id="apidoc.element.livescript.ast.Key">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Key
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = '' + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
case 49:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Key</span>($$[$0]));
break;
case 50:
this.$ = yy.L(_$[$0], _$[$0],yy.Literal($$[$0]));
break;
case 51: case 164:
this.$ = yy.L(_$[$0], _$[$0],[]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.L" id="apidoc.element.livescript.ast.L">
        function <span class="apidocSignatureSpan">livescript.ast.</span>L
        <span class="apidocSignatureSpan">(a, b, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">L = function (a, b, node){
  if (node &amp;&amp; typeof node === "object") {
    node.first_line = a.first_line + 1;
    node.first_column = a.first_column;
    node.last_line = b.last_line + 1;
    node.last_column = b.last_column;
    node.line = a.first_line + 1;
    node.column = a.first_column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.<span class="apidocCodeKeywordSpan">L</span>(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label" id="apidoc.element.livescript.ast.Label">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Label
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || '_';
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &amp;&amp; it || it.calling &amp;&amp; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        body: $$[$0]
      }));
break;
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Label</span>($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== 'arguments' &amp;&amp; $$[$0] !== &amp;#
x27;eval')), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal" id="apidoc.element.livescript.ast.Literal">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + "", true);
  }
  if (value === 'super') {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Literal</span>($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj" id="apidoc.element.livescript.ast.Obj">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ref: true
      }).addBody($$[$0]))));
break;
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.<span class="apidocCodeKeywordSpan">Obj</span>($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).named($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens" id="apidoc.element.livescript.ast.Parens">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 161:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], true)), yy.L(_$[$0-1],_$[$0-1],yy.Literal($$[$0-1] === &amp;#
x27;+'))));
break;
case 168:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-2]);
break;
case 169:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Parens</span>($$[$0-1].chomp().unwrap(), false, $$[$0-2] === &amp;#
x27;"', yy.L(_$[$0-2],_$[$0-2],{}), yy.L(_$[$0],_$[$0],{})));
break;
case 173: case 209: case 211:
this.$ = yy.L(_$[$0], _$[$0],null);
break;
case 174: case 208: case 210:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop" id="apidoc.element.livescript.ast.Prop">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === '...') {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
    }
    this$['accessor'] = 'accessor';
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Prop</span>(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== '
;arguments' &amp;&amp; $$[$0] !== 'eval')), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
case 152:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Literal($$[$0-2])), [yy.L(_$[$0-1],_$[$0], yy.
Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require" id="apidoc.element.livescript.ast.Require">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Require
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS("Error('unimplemented')"))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Require</span>($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return" id="apidoc.element.livescript.ast.Return">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &amp;&amp; it.value !== 'void') {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice" id="apidoc.element.livescript.ast.Slice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &amp;&amp; (this$.from = Literal(0));
  if (this$.to &amp;&amp; this$.type === 'to') {
    this$.to = Binary('+', this$.to, Literal('1'));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        target: $$[$0-7],
        from: yy.Literal(0),
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
case 37:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], yy.<span class="apidocCodeKeywordSpan">Slice</span>({
        type: $$[$0-2],
        target: $$[$0-6],
        from: $$[$0-3],
        to: $$[$0-1]
      }))));
break;
case 38:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat" id="apidoc.element.livescript.ast.Splat">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 54: case 167:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat($$[$0]));
break;
case 55:
this.$ = yy.L(_$[$0-5], _$[$0-2],$$[$0-5].concat($$[$0-2]));
break;
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Splat</span>($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.Block());
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice" id="apidoc.element.livescript.ast.StepSlice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        op: $$[$0-4],
        to: $$[$0-3],
        step: $$[$0-1],
        inComprehension: true
      }))));
break;
case 35:
this.$ = yy.L(_$[$0-8], _$[$0],yy.Chain(yy.L(_$[$0-8],_$[$0], new yy.<span class="apidocCodeKeywordSpan">StepSlice</span>({
        op: $$[$0-4],
        target: $$[$0-8],
        from: $$[$0-5],
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super" id="apidoc.element.livescript.ast.Super">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch" id="apidoc.element.livescript.ast.Switch">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this['default'] = $default;
  if (type === 'match') {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &gt; 1) {
        throw "can't have more than one topic in switch statement";
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &amp;&amp; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &amp;&amp; last.tests[0] instanceof Var &amp;&amp; last
.tests[0].value === '_') {
    this.cases.pop();
    this['default'] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.Jump($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Switch</span>($$[$0-2], $$[$0-1], $$[$0]));
break;
case 129: case 130:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]));
break;
case 131:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw" id="apidoc.element.livescript.ast.Throw">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Throw</span>(yy.L(_$[$0],_$[$0],yy.JS("Error('unimplemented
')"))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try" id="apidoc.element.livescript.ast.Try">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Try
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var('e'), Var('e$')));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 132: case 133:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]));
break;
case 134:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, [], $$[$0]));
break;
case 135:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Try</span>($$[$0]));
break;
case 136:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 137:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.Try($$[$0-4], void 8, yy.L(_$[$0-3],_$[$0-3],$$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary" id="apidoc.element.livescript.ast.Unary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &amp;&amp; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case '!':
      if (flag) {
        break;
      }
      if (it instanceof Fun &amp;&amp; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case '++':
    case '--':
      if (flag) {
        this$.post = true;
      }
      break;
    case 'new':
      if (it instanceof Existence &amp;&amp; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || '').length; i$ &lt; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &amp;&amp; !node['new']) {
          if (node.method === '.call') {
            node.args.shift();
          }
          node['new'] = 'new';
          node.method = '';
          return it;
        }
      }
      break;
    case '~':
      if (it instanceof Fun &amp;&amp; it.statement &amp;&amp; !it.bound) {
        return it.bound = 'this$', it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 21:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-5],yy.Binary($$[$0-5], void 8, $$[$0-3]))));
break;
case 23:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-4]))));
break;
case 24: case 25:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Unary</span>($$[$0-1]))));
break;
case 26:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util" id="apidoc.element.livescript.ast.Util">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Util
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var" id="apidoc.element.livescript.ast.Var">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Var
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Var</span>($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars" id="apidoc.element.livescript.ast.Vars">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While" id="apidoc.element.livescript.ast.While">
        function <span class="apidocSignatureSpan">livescript.ast.</span>While
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &amp;&amp; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== '' + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === 'unless')));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.<span class="apidocCodeKeywordSpan">While</span>($$[$0], $$[$0-1] === 'until', true
).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', true).addGuard($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield" id="apidoc.element.livescript.ast.Yield">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 98:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Unary($$[$0-5], yy.Splat(yy.Arr($$[$0-2]))));
break;
case 99:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2])));
break;
case 100:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Yield</span>($$[$0]));
break;
case 101:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Yield($$[$0-1], $$[$0]));
break;
case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 158:
this.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.fromJSON" id="apidoc.element.livescript.ast.fromJSON">
        function <span class="apidocSignatureSpan">livescript.ast.</span>fromJSON
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &amp;&amp; typeof it === 'object')) {
    return it;
  }
  if (that = it.type) {
    node = clone$(exports[that].prototype);
    for (key in it) {
      val = it[key];
      node[key] = fromJSON(val);
    }
    return node;
  }
  if (it.length != null) {
    for (i$ = 0, len$ = it.length; i$ &lt; len$; ++i$) {
      v = it[i$];
      results$.push(fromJSON(v));
    }
    return results$;
  } else {
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.<span class="apidocCodeKeywordSpan">fromJSON</span>(JSON.parse(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &amp;&amp; typeof it === 'object')) {
    return it;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.parse" id="apidoc.element.livescript.ast.parse">
        function <span class="apidocSignatureSpan">livescript.ast.</span>parse
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (json){
  return exports.fromJSON(JSON.parse(json));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.fromJSON(JSON.<span class="apidocCodeKeywordSpan">parse</span>(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &amp;&amp; typeof it === 'object')) {
    return it;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr" id="apidoc.module.livescript.ast.Arr">module livescript.ast.Arr</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.Arr" id="apidoc.element.livescript.ast.Arr.Arr">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Arr
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.<span class="apidocCodeKeywordSpan">Arr</span>($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.compile" id="apidoc.element.livescript.ast.Arr.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>compile
        <span class="apidocSignatureSpan">(o, items, deepEq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
  case 0:
    return '';
  case 1:
    return items[0].compile(o, LEVEL_LIST);
  }
  indent = o.indent, level = o.level;
  o.indent = indent + TAB;
  o.level = LEVEL_LIST;
  code = [items[i = 0].compile(o)];
  while (that = items[++i]) {
    code.push(', ');
    target = that;
    if (deepEq) {
      if (target instanceof Var &amp;&amp; target.value === '_') {
        target = Obj([Prop(Key('__placeholder__'), Literal(true))]);
      } else if (target instanceof Obj || target instanceof Arr) {
        target.deepEq = true;
      }
    }
    code.push(target.compile(o));
  }
  if (~code.join("").indexOf('\n')) {
    code = ["\n" + o.indent].concat(slice$.call(code), ["\n" + indent]);
  }
  o.indent = indent;
  o.level = level;
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.maybe" id="apidoc.element.livescript.ast.Arr.maybe">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>maybe
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybe = function (nodes){
  if (nodes.length === 1 &amp;&amp; !(nodes[0] instanceof Splat)) {
    return nodes[0];
  }
  return constructor(nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.<span class="apidocCodeKeywordSpan">maybe</span>($$[$0-2]), yy
.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
case 80:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import($$[$0-2], $$[$0], $$[$0-1] === '&lt;&lt;&lt;&lt;'));
break;
case 81:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Import($$[$0-5], yy.Arr.maybe($$[$0-2]), $$[$0-4] === '&lt;&lt;&lt;&lt;'));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass" id="apidoc.element.livescript.ast.Arr.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(){
  List.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.wrap" id="apidoc.element.livescript.ast.Arr.wrap">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.</span>wrap
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrap = function (it){
  return constructor([Splat((it.isArray = YES, it))]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (i + 1 === (len = nodes.length)) {
  if (skip) {
    break;
  }
  if (destructureArgs) {
    val = argsSlice(Literal(i), Chain(Var('arguments')).add(Index(Key('length'))));
  } else {
    val = Arr.<span class="apidocCodeKeywordSpan">wrap</span>(JS(util('slice') + '.call(' + rite + (i ? "
;, " + i + ")" : ')')));
  }
} else {
  val = ivar = rite + ".length - " + (len - i - 1);
  if (skip &amp;&amp; i + 2 === len) {
    continue;
  }
  start = i + 1;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype" id="apidoc.module.livescript.ast.Arr.prototype">module livescript.ast.Arr.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.asObj" id="apidoc.element.livescript.ast.Arr.prototype.asObj">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>asObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObj = function (){
  var i, item;
  return Obj((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
      i = i$;
      item = ref$[i$];
      results$.push(Prop(Literal(i), item));
    }
    return results$;
  }.call(this)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prototype = extend$((import$(Import, superclass).displayName = 'Import', Import), superclass).prototype, constructor
 = Import;
function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &amp;&amp; 'All';
  if (!all &amp;&amp; left instanceof Obj &amp;&amp; right.items) {
    return Obj(left.items.concat(right.<span class="apidocCodeKeywordSpan">asObj</span>().items));
  }
  return this$;
} function ctor$(){} ctor$.prototype = prototype;
Import.prototype.children = ['left', 'right'];
Import.prototype.show = function(){
  return this.all;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.compile" id="apidoc.element.livescript.ast.Arr.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var items, code;
  items = this.items;
  if (!items.length) {
    return sn(this, '[]');
  }
  if (!snEmpty(code = Splat.compileArray(o, items))) {
    return this.newed
      ? sn(this, "(", code, ")")
      : sn(this, code);
  }
  return sn(null, sn(this, "["), List.compile(o, items, this.deepEq), sn(this, "]"));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.constructor" id="apidoc.element.livescript.ast.Arr.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>constructor
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Arr(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.isArray" id="apidoc.element.livescript.ast.Arr.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.toSlice" id="apidoc.element.livescript.ast.Arr.prototype.toSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>toSlice
        <span class="apidocSignatureSpan">(o, base, symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSlice = function (o, base, symbol){
  var items, ref$, ref, i$, len$, i, item, splat, chain;
  items = this.items;
  if (items.length &gt; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    item = items[i$];
    if (splat = item instanceof Splat) {
      item = item.it;
    }
    if (item.isEmpty()) {
      continue;
    }
    chain = Chain(base, [Index(item, symbol)]);
    items[i] = splat ? Splat(chain) : chain;
    base = ref;
  }
  chain || this.carp('empty slice');
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &amp;&amp; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp('calling a slice');
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.<span class="apidocCodeKeywordSpan">toSlice</span>(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
};
return Chain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype.asObj" id="apidoc.module.livescript.ast.Arr.prototype.asObj">module livescript.ast.Arr.prototype.asObj</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.asObj.asObj" id="apidoc.element.livescript.ast.Arr.prototype.asObj.asObj">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>asObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObj = function (){
  var i, item;
  return Obj((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
      i = i$;
      item = ref$[i$];
      results$.push(Prop(Literal(i), item));
    }
    return results$;
  }.call(this)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prototype = extend$((import$(Import, superclass).displayName = 'Import', Import), superclass).prototype, constructor
 = Import;
function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &amp;&amp; 'All';
  if (!all &amp;&amp; left instanceof Obj &amp;&amp; right.items) {
    return Obj(left.items.concat(right.<span class="apidocCodeKeywordSpan">asObj</span>().items));
  }
  return this$;
} function ctor$(){} ctor$.prototype = prototype;
Import.prototype.children = ['left', 'right'];
Import.prototype.show = function(){
  return this.all;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype.compile" id="apidoc.module.livescript.ast.Arr.prototype.compile">module livescript.ast.Arr.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.compile.compile" id="apidoc.element.livescript.ast.Arr.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var items, code;
  items = this.items;
  if (!items.length) {
    return sn(this, '[]');
  }
  if (!snEmpty(code = Splat.compileArray(o, items))) {
    return this.newed
      ? sn(this, "(", code, ")")
      : sn(this, code);
  }
  return sn(null, sn(this, "["), List.compile(o, items, this.deepEq), sn(this, "]"));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype.isArray" id="apidoc.module.livescript.ast.Arr.prototype.isArray">module livescript.ast.Arr.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Arr.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.prototype.toSlice" id="apidoc.module.livescript.ast.Arr.prototype.toSlice">module livescript.ast.Arr.prototype.toSlice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.prototype.toSlice.toSlice" id="apidoc.element.livescript.ast.Arr.prototype.toSlice.toSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.prototype.</span>toSlice
        <span class="apidocSignatureSpan">(o, base, symbol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSlice = function (o, base, symbol){
  var items, ref$, ref, i$, len$, i, item, splat, chain;
  items = this.items;
  if (items.length &gt; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    item = items[i$];
    if (splat = item instanceof Splat) {
      item = item.it;
    }
    if (item.isEmpty()) {
      continue;
    }
    chain = Chain(base, [Index(item, symbol)]);
    items[i] = splat ? Splat(chain) : chain;
    base = ref;
  }
  chain || this.carp('empty slice');
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &amp;&amp; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp('calling a slice');
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.<span class="apidocCodeKeywordSpan">toSlice</span>(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
};
return Chain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Arr.superclass.prototype" id="apidoc.module.livescript.ast.Arr.superclass.prototype">module livescript.ast.Arr.superclass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.assigns" id="apidoc.element.livescript.ast.Arr.superclass.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.assigns(it)) {
      return true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.constructor" id="apidoc.element.livescript.ast.Arr.superclass.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(){
  List.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.isEmpty" id="apidoc.element.livescript.ast.Arr.superclass.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (){
  return !this.items.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + "").charAt() === '/';
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return 'empty';
  case !this.isCallable():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.named" id="apidoc.element.livescript.ast.Arr.superclass.prototype.named">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>named
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">named = function (name){
  this.name = name;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Obj($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).<span class="apidocCodeKeywordSpan">named</span>($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Arr.superclass.prototype.show" id="apidoc.element.livescript.ast.Arr.superclass.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Arr.superclass.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign" id="apidoc.module.livescript.ast.Assign">module livescript.ast.Assign</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.Assign" id="apidoc.element.livescript.ast.Assign.Assign">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Assign
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || '=';
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += '';
  this$[rite instanceof Node ? 'right' : 'unaries'] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Assign</span>($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$
0-1],yy.Box($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass" id="apidoc.element.livescript.ast.Assign.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype" id="apidoc.module.livescript.ast.Assign.prototype">module livescript.ast.Assign.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.assigns" id="apidoc.element.livescript.ast.Assign.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return this.left.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional" id="apidoc.element.livescript.ast.Assign.prototype.compileConditional">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileConditional
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileConditional = function (o, left){
  var lefts, morph;
  if (left instanceof Var &amp;&amp; in$(this.logic, ['?']) &amp;&amp; this.op === '=') {
    o.scope.declare(left.value, left);
  }
  lefts = Chain(left).cacheReference(o);
  o.level += LEVEL_OP &lt; o.level;
  morph = Binary(this.logic, lefts[0], (this.logic = false, this.left = lefts[1], this));
  return sn(this, (morph['void'] = this['void'], morph).compileNode(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  left = left.first;
}
if (left.items) {
  return this.compileDestructuring(o, left);
}
left.isAssignable() || left.carp('invalid assign');
if (this.logic) {
  return this.<span class="apidocCodeKeywordSpan">compileConditional</span>(o, left);
}
op = this.op, right = this.right;
if (op === '&lt;?=' || op === '&gt;?=') {
  return this.compileMinMax(o, left, right);
}
if ((op === '**=' || op === '^=' || op === '%%=' || op === '++=' || op === '|&gt;=&amp;#
x27;) || op === '*=' &amp;&amp; right.isString() || (op === '-=' || op === '/=') &amp;&amp; right
.isMatcher()) {
  ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring" id="apidoc.element.livescript.ast.Assign.prototype.compileDestructuring">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileDestructuring
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDestructuring = function (o, left){
  var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
  items = left.items, len = items.length;
  ret = o.level &amp;&amp; !this['void'];
  rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
  if (that = left.name) {
    cache = sn(this, that, " = ", rite);
    o.scope.declare(rite = that, left);
  } else if ((ret || len &gt; 1) &amp;&amp; (!ID.test(rite.toString()) || left.assigns(rite.toString()))) {
    cache = sn(this, rref = o.scope.temporary(), " = ", rite);
    rite = rref;
  }
  if (rite.toString() === 'arguments' &amp;&amp; !ret) {
    destructureArgs = true;
    if (!(left instanceof Arr)) {
      this.carp('arguments can only destructure to array');
    }
  }
  list = this["rend" + left.constructor.displayName](o, items, rite, destructureArgs);
  if (rref) {
    o.scope.free(rref);
  }
  if (cache) {
    list.unshift(cache);
  }
  if (ret || !list.length) {
    list.push(rite);
  }
  code = [];
  sep = destructureArgs ? '; ' : ', ';
  for (i$ = 0, len$ = list.length; i$ &lt; len$; ++i$) {
    item = list[i$];
    code.push(item, sep);
  }
  code.pop();
  if (list.length &lt; 2 || o.level &lt; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
}
if (left.getDefault()) {
  this.right = Binary(left.op, this.right, left.second);
  left = left.first;
}
if (left.items) {
  return this.<span class="apidocCodeKeywordSpan">compileDestructuring</span>(o, left);
}
left.isAssignable() || left.carp('invalid assign');
if (this.logic) {
  return this.compileConditional(o, left);
}
op = this.op, right = this.right;
if (op === '&lt;?=' || op === '&gt;?=') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax" id="apidoc.element.livescript.ast.Assign.prototype.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileMinMax
        <span class="apidocSignatureSpan">(o, left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMinMax = function (o, left, right){
  var lefts, rites, test, put, ref$;
  lefts = Chain(left).cacheReference(o);
  rites = right.cache(o, true);
  test = Binary(this.op.replace('?', ''), lefts[0], rites[0]);
  put = Assign(lefts[1], rites[1], ':=');
  if (this['void'] || !o.level) {
    return Parens(Binary('||', test, put)).compile(o);
  }
  ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
  return sn(this, If(test, left).addElse(put).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case '**':
case '^':
  return this.compilePow(o);
case '&lt;?':
case '&gt;?':
  return this.<span class="apidocCodeKeywordSpan">compileMinMax</span>(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
  return this.compileConcat(o);
case '%%':
  return this.compileMod(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileNode" id="apidoc.element.livescript.ast.Assign.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &amp;&amp; this.op === '=') {
    return this.compileSplice(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
    left instanceof List || this.left.carp('invalid splat');
    return this.compileSpread(o, left);
  }
  if (!this.right) {
    left.isAssignable() || left.carp('invalid unary assign');
    ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
    for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ &lt; len$; ++i$) {
      op = ref$[i$];
      this.right = Unary(op, this.right);
    }
  }
  if (left.isEmpty()) {
    return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
  }
  if (left.getDefault()) {
    this.right = Binary(left.op, this.right, left.second);
    left = left.first;
  }
  if (left.items) {
    return this.compileDestructuring(o, left);
  }
  left.isAssignable() || left.carp('invalid assign');
  if (this.logic) {
    return this.compileConditional(o, left);
  }
  op = this.op, right = this.right;
  if (op === '&lt;?=' || op === '&gt;?=') {
    return this.compileMinMax(o, left, right);
  }
  if ((op === '**=' || op === '^=' || op === '%%=' || op === '++=' || op === '|&gt;=') || op === '*=' &amp;&amp; right.isString() || (op === '-=' ||
op === '/=') &amp;&amp; right.isMatcher()) {
    ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
    right = Binary(op.slice(0, -1), reft, right);
    op = ':=';
  }
  if (op === '.&amp;.=' || op === '.|.=' || op === '.^.=' || op === '.&lt;&lt;.=' || op === '.&gt;&gt;.=' || op === '.&gt;&gt;&gt;.=') {
    op = op.slice(1, -2) + '=';
  }
  (right = right.unparen()).ripName(left = left.unwrap());
  sign = sn(this.opLoc, " ", op.replace(':', ''), " ");
  name = (left.front = true, left).compile(o, LEVEL_LIST);
  if (lvar = left instanceof Var) {
    if (op === '=') {
      o.scope.declare(name.toString(), left, this['const'] || !this.defParam &amp;&amp; o['const'] &amp;&amp; '$' !== name.toString().slice(-1));
    } else if (that = o.scope.checkReadOnly(name.toString())) {
      left.carp("assignment to " + that + " \"" + name + "\"", ReferenceError);
    }
  }
  if (left instanceof Chain &amp;&amp; right instanceof Fun) {
    protoSplit = name.toString().split('.prototype.');
    dotSplit = name.toString().split('.');
    if (protoSplit.length &gt; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &gt; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');
    }
  }
  code = !o.level &amp;&amp; right instanceof While &amp;&amp; !right['else'] &amp;&amp; (lvar || left instanceof Chain &amp;&amp; left.isSimpleAccess())
    ? (empty = right.objComp ? '{}' : '[]', [res = o.scope.temporary('res'), " = " + empty + ";\n" + this.tab, right.makeReturn(
res).compile(o), "\n" + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &gt; LEVEL_LIST) {
    code = ["("].concat(slice$.call(code), [")"]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice" id="apidoc.element.livescript.ast.Assign.prototype.compileSplice">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSplice
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSplice = function (o){
  var ref$, fromExpNode, fromExp, rightNode, right, toExp;
  ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
  ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
  toExp = Binary('-', this.left.to, fromExp);
  return sn(this, Block([Chain(Var(util('splice'))).add(Index(Key('apply'), '.', true)).add(Call([this.left.target, Chain(Arr([fromExpNode
, toExp])).add(Index(Key('concat'), '.', true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Assign.prototype.unfoldAssign = function(){
  return this.access &amp;&amp; this;
};
Assign.prototype.compileNode = function(o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &amp;&amp; this.op === '=') {
    return this.<span class="apidocCodeKeywordSpan">compileSplice</span>(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread" id="apidoc.element.livescript.ast.Assign.prototype.compileSpread">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSpread
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpread = function (o, left){
  var that, ref$, rite, rref, this$ = this;
  ref$ = (that = this.unaries)
    ? [that, that]
    : left.items.length &lt;= 1
      ? [ref$ = this.right, ref$]
      : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
  return this.compileSpreadOver(o, left, function(it){
    var result;
    result = constructor(it, rite, this$.op, this$.logic);
    rite = rref;
    return result;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }[it] + 'crement';
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.<span class="apidocCodeKeywordSpan">compileSpread</span>(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case '!':
    it.cond = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.constructor" id="apidoc.element.livescript.ast.Assign.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>constructor
        <span class="apidocSignatureSpan">(left, rite, op, logic, defParam)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assign(left, rite, op, logic, defParam){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.op = op || '=';
  this$.logic = logic || this$.op.logic;
  this$.defParam = defParam;
  this$.opLoc = this$.op;
  this$.op += '';
  this$[rite instanceof Node ? 'right' : 'unaries'] = rite;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isArray" id="apidoc.element.livescript.ast.Assign.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  switch (this.op) {
  case '=':
  case ':=':
    return this.right &amp;&amp; this.right.isArray();
  case '/=':
    return this.right &amp;&amp; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isCallable" id="apidoc.element.livescript.ast.Assign.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isRegex" id="apidoc.element.livescript.ast.Assign.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isString" id="apidoc.element.livescript.ast.Assign.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  switch (this.op) {
  case '=':
  case ':=':
  case '+=':
  case '*=':
    return this.right &amp;&amp; this.right.isString();
  case '-=':
    return this.right &amp;&amp; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendArr" id="apidoc.element.livescript.ast.Assign.prototype.rendArr">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendArr
        <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rendArr = function (o, nodes, rite, destructureArgs){
  var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
  function argsSlice(begin, end){
    return new For({
      ref: true,
      from: begin,
      op: 'til',
      to: end
    }).makeComprehension(Chain(Var('arguments')).add(Index(Literal('..'))), []);
  }
  ret = [];
  for (i$ = 0, len$ = nodes.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = nodes[i$];
    if (node.isEmpty()) {
      continue;
    }
    if (node instanceof Splat) {
      len &amp;&amp; node.carp('multiple splat in an assignment');
      skip = (node = node.it).isEmpty();
      if (i + 1 === (len = nodes.length)) {
        if (skip) {
          break;
        }
        if (destructureArgs) {
          val = argsSlice(Literal(i), Chain(Var('arguments')).add(Index(Key('length'))));
        } else {
          val = Arr.wrap(JS(util('slice') + '.call(' + rite + (i ? ", " + i + ")" : ')')));
        }
      } else {
        val = ivar = rite + ".length - " + (len - i - 1);
        if (skip &amp;&amp; i + 2 === len) {
          continue;
        }
        start = i + 1;
        (this.temps || (this.temps = [])).push(ivar = o.scope.temporary('i'));
        val = (fn$());
      }
    } else {
      (inc = ivar) &amp;&amp; start &lt; i &amp;&amp; (inc += " + " + (i - start));
      val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
    }
    if (node instanceof Assign) {
      node = Binary(node.op, node.left, node.right, node.logic || true);
    }
    if (destructureArgs) {
      if (!(node instanceof Var) &amp;&amp; val instanceof For) {
        (this.temps || (this.temps = [])).push(tmp = o.scope.temporary('ref'));
        vtmp = Var(tmp);
        ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
      } else {
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
      }
    } else {
      ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
    }
  }
  return ret;
  function fn$(){
    switch (false) {
    case !skip:
      return Arr.wrap(JS(i + " &lt; (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"));
    case !destructureArgs:
      return argsSlice(JS(i + " &lt; (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"), Var(ivar));
    default:
      return Arr.wrap(JS(i + " &lt; (" + ivar + " = " + val + ")\ ? " + util('slice') + ".call(" + rite + ", " + i + ", " + ivar + ")\ : (" + ivar + " = " + i + ", [])"));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendObj" id="apidoc.element.livescript.ast.Assign.prototype.rendObj">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendObj
        <span class="apidocSignatureSpan">(o, nodes, rite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rendObj = function (o, nodes, rite){
  var i$, len$, node, splat, logic, ref$, key, val, rcache, results$ = [];
  for (i$ = 0, len$ = nodes.length; i$ &lt; len$; ++i$) {
    node = nodes[i$];
    if (splat = node instanceof Splat) {
      node = node.it;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Parens) {
      ref$ = Chain(node.it).cacheReference(o), node = ref$[0], key = ref$[1];
    } else if (node instanceof Prop) {
      node = (key = node.key, node).val;
    } else {
      key = node;
    }
    if (node instanceof Key) {
      node = CopyL(node, Var(node.name));
    }
    if (logic) {
      node = (logic.first = node, logic);
    }
    val = Chain(rcache || (rcache = Var(rite)), [Index(key.maybeKey())]);
    if (splat) {
      val = Import(Obj(), val);
    }
    results$.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
  }
  return results$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.show" id="apidoc.element.livescript.ast.Assign.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [void 8].concat(this.unaries).reverse().join(' ') + [this.logic] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Assign.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldAssign = function (){
  return this.access &amp;&amp; this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Assign.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var that, ref$, ref1$, rite, temps;
  if (this.left instanceof Existence) {
    if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
      rite = this.right;
      rite = Assign(this.right = Var(that), rite);
    } else {
      ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
    }
    return ref$ = If(Existence(rite), this), ref$.temps = temps, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
  }
  return If.unfoldSoak(o, this, 'left');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.assigns" id="apidoc.module.livescript.ast.Assign.prototype.assigns">module livescript.ast.Assign.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Assign.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return this.left.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileConditional" id="apidoc.module.livescript.ast.Assign.prototype.compileConditional">module livescript.ast.Assign.prototype.compileConditional</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileConditional.compileConditional" id="apidoc.element.livescript.ast.Assign.prototype.compileConditional.compileConditional">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileConditional
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileConditional = function (o, left){
  var lefts, morph;
  if (left instanceof Var &amp;&amp; in$(this.logic, ['?']) &amp;&amp; this.op === '=') {
    o.scope.declare(left.value, left);
  }
  lefts = Chain(left).cacheReference(o);
  o.level += LEVEL_OP &lt; o.level;
  morph = Binary(this.logic, lefts[0], (this.logic = false, this.left = lefts[1], this));
  return sn(this, (morph['void'] = this['void'], morph).compileNode(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  left = left.first;
}
if (left.items) {
  return this.compileDestructuring(o, left);
}
left.isAssignable() || left.carp('invalid assign');
if (this.logic) {
  return this.<span class="apidocCodeKeywordSpan">compileConditional</span>(o, left);
}
op = this.op, right = this.right;
if (op === '&lt;?=' || op === '&gt;?=') {
  return this.compileMinMax(o, left, right);
}
if ((op === '**=' || op === '^=' || op === '%%=' || op === '++=' || op === '|&gt;=&amp;#
x27;) || op === '*=' &amp;&amp; right.isString() || (op === '-=' || op === '/=') &amp;&amp; right
.isMatcher()) {
  ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileDestructuring" id="apidoc.module.livescript.ast.Assign.prototype.compileDestructuring">module livescript.ast.Assign.prototype.compileDestructuring</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileDestructuring.compileDestructuring" id="apidoc.element.livescript.ast.Assign.prototype.compileDestructuring.compileDestructuring">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileDestructuring
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDestructuring = function (o, left){
  var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
  items = left.items, len = items.length;
  ret = o.level &amp;&amp; !this['void'];
  rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
  if (that = left.name) {
    cache = sn(this, that, " = ", rite);
    o.scope.declare(rite = that, left);
  } else if ((ret || len &gt; 1) &amp;&amp; (!ID.test(rite.toString()) || left.assigns(rite.toString()))) {
    cache = sn(this, rref = o.scope.temporary(), " = ", rite);
    rite = rref;
  }
  if (rite.toString() === 'arguments' &amp;&amp; !ret) {
    destructureArgs = true;
    if (!(left instanceof Arr)) {
      this.carp('arguments can only destructure to array');
    }
  }
  list = this["rend" + left.constructor.displayName](o, items, rite, destructureArgs);
  if (rref) {
    o.scope.free(rref);
  }
  if (cache) {
    list.unshift(cache);
  }
  if (ret || !list.length) {
    list.push(rite);
  }
  code = [];
  sep = destructureArgs ? '; ' : ', ';
  for (i$ = 0, len$ = list.length; i$ &lt; len$; ++i$) {
    item = list[i$];
    code.push(item, sep);
  }
  code.pop();
  if (list.length &lt; 2 || o.level &lt; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
}
if (left.getDefault()) {
  this.right = Binary(left.op, this.right, left.second);
  left = left.first;
}
if (left.items) {
  return this.<span class="apidocCodeKeywordSpan">compileDestructuring</span>(o, left);
}
left.isAssignable() || left.carp('invalid assign');
if (this.logic) {
  return this.compileConditional(o, left);
}
op = this.op, right = this.right;
if (op === '&lt;?=' || op === '&gt;?=') {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileMinMax" id="apidoc.module.livescript.ast.Assign.prototype.compileMinMax">module livescript.ast.Assign.prototype.compileMinMax</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileMinMax.compileMinMax" id="apidoc.element.livescript.ast.Assign.prototype.compileMinMax.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileMinMax
        <span class="apidocSignatureSpan">(o, left, right)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMinMax = function (o, left, right){
  var lefts, rites, test, put, ref$;
  lefts = Chain(left).cacheReference(o);
  rites = right.cache(o, true);
  test = Binary(this.op.replace('?', ''), lefts[0], rites[0]);
  put = Assign(lefts[1], rites[1], ':=');
  if (this['void'] || !o.level) {
    return Parens(Binary('||', test, put)).compile(o);
  }
  ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
  return sn(this, If(test, left).addElse(put).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case '**':
case '^':
  return this.compilePow(o);
case '&lt;?':
case '&gt;?':
  return this.<span class="apidocCodeKeywordSpan">compileMinMax</span>(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
  return this.compileConcat(o);
case '%%':
  return this.compileMod(o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileNode" id="apidoc.module.livescript.ast.Assign.prototype.compileNode">module livescript.ast.Assign.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Assign.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &amp;&amp; this.op === '=') {
    return this.compileSplice(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
    left instanceof List || this.left.carp('invalid splat');
    return this.compileSpread(o, left);
  }
  if (!this.right) {
    left.isAssignable() || left.carp('invalid unary assign');
    ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
    for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ &lt; len$; ++i$) {
      op = ref$[i$];
      this.right = Unary(op, this.right);
    }
  }
  if (left.isEmpty()) {
    return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
  }
  if (left.getDefault()) {
    this.right = Binary(left.op, this.right, left.second);
    left = left.first;
  }
  if (left.items) {
    return this.compileDestructuring(o, left);
  }
  left.isAssignable() || left.carp('invalid assign');
  if (this.logic) {
    return this.compileConditional(o, left);
  }
  op = this.op, right = this.right;
  if (op === '&lt;?=' || op === '&gt;?=') {
    return this.compileMinMax(o, left, right);
  }
  if ((op === '**=' || op === '^=' || op === '%%=' || op === '++=' || op === '|&gt;=') || op === '*=' &amp;&amp; right.isString() || (op === '-=' ||
op === '/=') &amp;&amp; right.isMatcher()) {
    ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
    right = Binary(op.slice(0, -1), reft, right);
    op = ':=';
  }
  if (op === '.&amp;.=' || op === '.|.=' || op === '.^.=' || op === '.&lt;&lt;.=' || op === '.&gt;&gt;.=' || op === '.&gt;&gt;&gt;.=') {
    op = op.slice(1, -2) + '=';
  }
  (right = right.unparen()).ripName(left = left.unwrap());
  sign = sn(this.opLoc, " ", op.replace(':', ''), " ");
  name = (left.front = true, left).compile(o, LEVEL_LIST);
  if (lvar = left instanceof Var) {
    if (op === '=') {
      o.scope.declare(name.toString(), left, this['const'] || !this.defParam &amp;&amp; o['const'] &amp;&amp; '$' !== name.toString().slice(-1));
    } else if (that = o.scope.checkReadOnly(name.toString())) {
      left.carp("assignment to " + that + " \"" + name + "\"", ReferenceError);
    }
  }
  if (left instanceof Chain &amp;&amp; right instanceof Fun) {
    protoSplit = name.toString().split('.prototype.');
    dotSplit = name.toString().split('.');
    if (protoSplit.length &gt; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &gt; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');
    }
  }
  code = !o.level &amp;&amp; right instanceof While &amp;&amp; !right['else'] &amp;&amp; (lvar || left instanceof Chain &amp;&amp; left.isSimpleAccess())
    ? (empty = right.objComp ? '{}' : '[]', [res = o.scope.temporary('res'), " = " + empty + ";\n" + this.tab, right.makeReturn(
res).compile(o), "\n" + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &gt; LEVEL_LIST) {
    code = ["("].concat(slice$.call(code), [")"]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileSplice" id="apidoc.module.livescript.ast.Assign.prototype.compileSplice">module livescript.ast.Assign.prototype.compileSplice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSplice.compileSplice" id="apidoc.element.livescript.ast.Assign.prototype.compileSplice.compileSplice">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSplice
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSplice = function (o){
  var ref$, fromExpNode, fromExp, rightNode, right, toExp;
  ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
  ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
  toExp = Binary('-', this.left.to, fromExp);
  return sn(this, Block([Chain(Var(util('splice'))).add(Index(Key('apply'), '.', true)).add(Call([this.left.target, Chain(Arr([fromExpNode
, toExp])).add(Index(Key('concat'), '.', true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Assign.prototype.unfoldAssign = function(){
  return this.access &amp;&amp; this;
};
Assign.prototype.compileNode = function(o){
  var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
  if (this.left instanceof Slice &amp;&amp; this.op === '=') {
    return this.<span class="apidocCodeKeywordSpan">compileSplice</span>(o);
  }
  left = this.left;
  if (sp = this.left instanceof Splat) {
    left = left.it;
  }
  left = left.expandSlice(o, true).unwrap();
  if (sp) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.compileSpread" id="apidoc.module.livescript.ast.Assign.prototype.compileSpread">module livescript.ast.Assign.prototype.compileSpread</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.compileSpread.compileSpread" id="apidoc.element.livescript.ast.Assign.prototype.compileSpread.compileSpread">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>compileSpread
        <span class="apidocSignatureSpan">(o, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpread = function (o, left){
  var that, ref$, rite, rref, this$ = this;
  ref$ = (that = this.unaries)
    ? [that, that]
    : left.items.length &lt;= 1
      ? [ref$ = this.right, ref$]
      : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
  return this.compileSpreadOver(o, left, function(it){
    var result;
    result = constructor(it, rite, this$.op, this$.logic);
    rite = rref;
    return result;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }[it] + 'crement';
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.<span class="apidocCodeKeywordSpan">compileSpread</span>(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case '!':
    it.cond = true;
    break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.isArray" id="apidoc.module.livescript.ast.Assign.prototype.isArray">module livescript.ast.Assign.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Assign.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  switch (this.op) {
  case '=':
  case ':=':
    return this.right &amp;&amp; this.right.isArray();
  case '/=':
    return this.right &amp;&amp; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.isCallable" id="apidoc.module.livescript.ast.Assign.prototype.isCallable">module livescript.ast.Assign.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Assign.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.isRegex" id="apidoc.module.livescript.ast.Assign.prototype.isRegex">module livescript.ast.Assign.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Assign.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.isString" id="apidoc.module.livescript.ast.Assign.prototype.isString">module livescript.ast.Assign.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.isString.isString" id="apidoc.element.livescript.ast.Assign.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  switch (this.op) {
  case '=':
  case ':=':
  case '+=':
  case '*=':
    return this.right &amp;&amp; this.right.isString();
  case '-=':
    return this.right &amp;&amp; this.right.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.rendArr" id="apidoc.module.livescript.ast.Assign.prototype.rendArr">module livescript.ast.Assign.prototype.rendArr</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendArr.rendArr" id="apidoc.element.livescript.ast.Assign.prototype.rendArr.rendArr">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendArr
        <span class="apidocSignatureSpan">(o, nodes, rite, destructureArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rendArr = function (o, nodes, rite, destructureArgs){
  var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
  function argsSlice(begin, end){
    return new For({
      ref: true,
      from: begin,
      op: 'til',
      to: end
    }).makeComprehension(Chain(Var('arguments')).add(Index(Literal('..'))), []);
  }
  ret = [];
  for (i$ = 0, len$ = nodes.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = nodes[i$];
    if (node.isEmpty()) {
      continue;
    }
    if (node instanceof Splat) {
      len &amp;&amp; node.carp('multiple splat in an assignment');
      skip = (node = node.it).isEmpty();
      if (i + 1 === (len = nodes.length)) {
        if (skip) {
          break;
        }
        if (destructureArgs) {
          val = argsSlice(Literal(i), Chain(Var('arguments')).add(Index(Key('length'))));
        } else {
          val = Arr.wrap(JS(util('slice') + '.call(' + rite + (i ? ", " + i + ")" : ')')));
        }
      } else {
        val = ivar = rite + ".length - " + (len - i - 1);
        if (skip &amp;&amp; i + 2 === len) {
          continue;
        }
        start = i + 1;
        (this.temps || (this.temps = [])).push(ivar = o.scope.temporary('i'));
        val = (fn$());
      }
    } else {
      (inc = ivar) &amp;&amp; start &lt; i &amp;&amp; (inc += " + " + (i - start));
      val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
    }
    if (node instanceof Assign) {
      node = Binary(node.op, node.left, node.right, node.logic || true);
    }
    if (destructureArgs) {
      if (!(node instanceof Var) &amp;&amp; val instanceof For) {
        (this.temps || (this.temps = [])).push(tmp = o.scope.temporary('ref'));
        vtmp = Var(tmp);
        ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
      } else {
        ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
      }
    } else {
      ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
    }
  }
  return ret;
  function fn$(){
    switch (false) {
    case !skip:
      return Arr.wrap(JS(i + " &lt; (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"));
    case !destructureArgs:
      return argsSlice(JS(i + " &lt; (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"), Var(ivar));
    default:
      return Arr.wrap(JS(i + " &lt; (" + ivar + " = " + val + ")\ ? " + util('slice') + ".call(" + rite + ", " + i + ", " + ivar + ")\ : (" + ivar + " = " + i + ", [])"));
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.rendObj" id="apidoc.module.livescript.ast.Assign.prototype.rendObj">module livescript.ast.Assign.prototype.rendObj</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.rendObj.rendObj" id="apidoc.element.livescript.ast.Assign.prototype.rendObj.rendObj">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>rendObj
        <span class="apidocSignatureSpan">(o, nodes, rite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rendObj = function (o, nodes, rite){
  var i$, len$, node, splat, logic, ref$, key, val, rcache, results$ = [];
  for (i$ = 0, len$ = nodes.length; i$ &lt; len$; ++i$) {
    node = nodes[i$];
    if (splat = node instanceof Splat) {
      node = node.it;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Parens) {
      ref$ = Chain(node.it).cacheReference(o), node = ref$[0], key = ref$[1];
    } else if (node instanceof Prop) {
      node = (key = node.key, node).val;
    } else {
      key = node;
    }
    if (node instanceof Key) {
      node = CopyL(node, Var(node.name));
    }
    if (logic) {
      node = (logic.first = node, logic);
    }
    val = Chain(rcache || (rcache = Var(rite)), [Index(key.maybeKey())]);
    if (splat) {
      val = Import(Obj(), val);
    }
    results$.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
  }
  return results$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.show" id="apidoc.module.livescript.ast.Assign.prototype.show">module livescript.ast.Assign.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.show.show" id="apidoc.element.livescript.ast.Assign.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [void 8].concat(this.unaries).reverse().join(' ') + [this.logic] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.unfoldAssign" id="apidoc.module.livescript.ast.Assign.prototype.unfoldAssign">module livescript.ast.Assign.prototype.unfoldAssign</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldAssign.unfoldAssign" id="apidoc.element.livescript.ast.Assign.prototype.unfoldAssign.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldAssign = function (){
  return this.access &amp;&amp; this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.prototype.unfoldSoak" id="apidoc.module.livescript.ast.Assign.prototype.unfoldSoak">module livescript.ast.Assign.prototype.unfoldSoak</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.prototype.unfoldSoak.unfoldSoak" id="apidoc.element.livescript.ast.Assign.prototype.unfoldSoak.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var that, ref$, ref1$, rite, temps;
  if (this.left instanceof Existence) {
    if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
      rite = this.right;
      rite = Assign(this.right = Var(that), rite);
    } else {
      ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
    }
    return ref$ = If(Existence(rite), this), ref$.temps = temps, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
  }
  return If.unfoldSoak(o, this, 'left');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Assign.superclass.prototype" id="apidoc.module.livescript.ast.Assign.superclass.prototype">module livescript.ast.Assign.superclass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.addElse" id="apidoc.element.livescript.ast.Assign.superclass.prototype.addElse">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>addElse
        <span class="apidocSignatureSpan">($else)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addElse = function ($else){
  this['else'] = $else;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compileExistence = function(o){
  var x;
  if (this['void'] || !o.level) {
    x = Binary('&amp;&amp;', Existence(this.first, true), this.second);
    return (x['void'] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).<span class="apidocCodeKeywordSpan">addElse</span>(this.second).compileExpression(o));
};
Binary.prototype.compileAnyInstanceOf = function(o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary('instanceof', sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    item = items[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.anaphorize" id="apidoc.element.livescript.ast.Assign.superclass.prototype.anaphorize">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>anaphorize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anaphorize = function (){
  var base, name, ref$;
  this.children = this.aTargets;
  if (this.eachChild(hasThat)) {
    if ((base = this)[name = this.aSource] instanceof Existence) {
      base = base[name];
      name = 'it';
    }
    if (base[name].value !== 'that') {
      base[name] = Assign(Var('that'), base[name]);
    }
  }
  function hasThat(it){
    var that;
    return it.value === 'that' || ((that = it.aSource)
      ? (that = it[that]) ? hasThat(that) : void 8
      : it.eachChild(hasThat));
  }
  delete this.children;
  return ref$ = this[this.aSource], ref$.cond = true, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this;
};
While.prototype.compileNode = function(o){
  var test, ref$, head, that;
  o.loop = true;
  this.test &amp;&amp; (this.un
    ? this.test = this.test.invert()
    : this.<span class="apidocCodeKeywordSpan">anaphorize</span>());
  if (this.post) {
    return sn(null, sn(this, 'do {'), this.compileBody((o.indent += TAB, o)));
  }
  test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
  if (!(this.update || this['else'])) {
    head = !snEmpty(test)
      ? [sn(this, "while ("), test]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.assigns" id="apidoc.element.livescript.ast.Assign.superclass.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>assigns
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.cache" id="apidoc.element.livescript.ast.Assign.superclass.prototype.cache">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>cache
        <span class="apidocSignatureSpan">(o, once, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cache = function (o, once, level){
  var ref$, sub, ref;
  if (!this.isComplex()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
    }
    return [sub, ref.value];
  }
  if (once) {
    return [sub, (ref.temp = true, ref)];
  } else {
    return [sub, ref, [ref.value]];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.unwrap().<span class="apidocCodeKeywordSpan">cache</span>(o, true);
  }
  if (this.tails.length &lt; 2 &amp;&amp; !this.head.isComplex() &amp;&amp; !(name != null &amp;&amp; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.carp" id="apidoc.element.livescript.ast.Assign.superclass.prototype.carp">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>carp
        <span class="apidocSignatureSpan">(msg, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">carp = function (msg, type){
  type == null &amp;&amp; (type = SyntaxError);
  throw type(msg + " on line " + (this.line || this.traverseChildren(function(it){
    return it.line;
  })));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.getJump()) {
    that.<span class="apidocCodeKeywordSpan">carp</span>('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
  this.traverseChildren(function(it){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compile" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compile
        <span class="apidocSignatureSpan">(options, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.unfoldSoak(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
      o.scope.free(tmp);
    }
  }
  return code;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileBlock" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileBlock">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileBlock
        <span class="apidocSignatureSpan">(o, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileBlock = function (o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    code.push.apply(code, mid);
    code.push('}');
    if (this.post) {
      code.push(sn(this, " while ("), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, ");"));
    }
    if (yet) {
      code.push(sn(this, " if ("), yet, sn(this, ") "), this.<span class="apidocCodeKeywordSpan">compileBlock
</span>(o, Block(this['else'])));
      o.scope.free(yet);
    }
    return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));
  };
  return While;
}(Node));
exports.For = For = (function(superclass){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileClosure" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileClosure">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileClosure
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileClosure = function (o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.getJump()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
  this.traverseChildren(function(it){
    switch (it.value) {
    case 'this':
      hasThis = true;
      break;
    case 'arguments':
      hasArgs = it.value = 'args$';
    }
  });
  if (hasThis) {
    call.args.push(Literal('this'));
    call.method = '.call';
  }
  if (hasArgs) {
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.<span class="apidocCodeKeywordSpan">compileClosure</span>(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileLoopReference" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileLoopReference">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileLoopReference
        <span class="apidocSignatureSpan">(o, name, ret, safeAccess)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileLoopReference = function (o, name, ret, safeAccess){
  var ref$, code, asn, tmp;
  if (this instanceof Var &amp;&amp; o.scope.check(this.value) || this instanceof Unary &amp;&amp; ((ref$ = this.op) === '+' || ref$ === '-') &amp;&amp; (-
1 / 0 &lt; (ref$ = +this.it.value) &amp;&amp; ref$ &lt; 1 / 0) || this instanceof Literal &amp;&amp; !this.isComplex()) {
    code = this.compile(o, LEVEL_PAREN);
    if (safeAccess &amp;&amp; !(this instanceof Var)) {
      code = "(" + code + ")";
    }
    return [code, code];
  }
  asn = Assign(Var(tmp = o.scope.temporary(name)), this);
  ret || (asn['void'] = true);
  return [tmp, asn.compile(o, ret ? LEVEL_CALL : LEVEL_PAREN)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  temps.push(idx = o.scope.temporary('i'));
}
if (!this.body) {
  this.addBody(Block(Var(idx)));
}
if (!this.object) {
  ref$ = (this.step || Literal(1)).<span class="apidocCodeKeywordSpan">compileLoopReference</span>(o, 'step'), pvar =
ref$[0], step = ref$[1];
  pvar === step || temps.push(pvar);
}
if (this.from) {
  if (this.ref) {
    this.item = Var(idx);
  }
  ref$ = this.to.compileLoopReference(o, 'to'), tvar = ref$[0], tail = ref$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.compileSpreadOver" id="apidoc.element.livescript.ast.Assign.superclass.prototype.compileSpreadOver">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>compileSpreadOver
        <span class="apidocSignatureSpan">(o, list, transform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpreadOver = function (o, list, transform){
  var ob, them, i$, len$, i, node, sp, lat, ref$;
  ob = list instanceof Obj;
  them = list.items;
  for (i$ = 0, len$ = them.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = them[i$];
    if (sp = node instanceof Splat) {
      node = node.it;
    }
    if (ob &amp;&amp; !sp) {
      node = node.val;
    }
    node = transform(node);
    if (sp) {
      node = lat = Splat(node);
    }
    if (ob &amp;&amp; !sp) {
      them[i].val = node;
    } else {
      them[i] = node;
    }
  }
  if (!lat &amp;&amp; (this['void'] || !o.level)) {
    list = (ref$ = Block(ob ? (function(){
      var i$, x$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = them).length; i$ &lt; len$; ++i$) {
        x$ = ref$[i$];
        results$.push(x$.val);
      }
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ops = [this];
for (; it instanceof constructor; it = it.it) {
  ops.push(it);
}
if (!(it instanceof Splat &amp;&amp; (it = it.it.expandSlice(o).unwrap()) instanceof List)) {
  return '';
}
return this.<span class="apidocCodeKeywordSpan">compileSpreadOver</span>(o, it, function(node){
  var i$, ref$, op;
  for (i$ = (ref$ = ops).length - 1; i$ &gt;= 0; --i$) {
    op = ref$[i$];
    node = constructor(op.op, node, op.post);
  }
  return node;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.delegate" id="apidoc.element.livescript.ast.Assign.superclass.prototype.delegate">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>delegate
        <span class="apidocSignatureSpan">(names, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delegate = function (names, fn){
  var i$, len$;
  for (i$ = 0, len$ = names.length; i$ &lt; len$; ++i$) {
    (fn$.call(this, names[i$]));
  }
  function fn$(name){
    this[name] = function(it){
      return fn.call(this, name, it);
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return pos;
};
Block.prototype.isComplex = function(){
  var ref$;
  return this.lines.length &gt; 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
};
prototype.<span class="apidocCodeKeywordSpan">delegate</span>(['isCallable', 'isArray', 'isString', &amp;#
x27;isRegex'], function(it){
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.lines)[ref1$.length - 1]) != null ? ref$[it]() : void 8;
});
Block.prototype.getJump = function(it){
  var i$, ref$, len$, node, that;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.eachChild" id="apidoc.element.livescript.ast.Assign.superclass.prototype.eachChild">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>eachChild
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachChild = function (fn){
  var i$, ref$, len$, name, child, j$, len1$, i, node, that;
  for (i$ = 0, len$ = (ref$ = this.children).length; i$ &lt; len$; ++i$) {
    name = ref$[i$];
    if (child = this[name]) {
      if ('length' in child) {
        for (j$ = 0, len1$ = child.length; j$ &lt; len1$; ++j$) {
          i = j$;
          node = child[j$];
          if (that = fn(node, name, i)) {
            return that;
          }
        }
      } else {
        if ((that = fn(child, name)) != null) {
          return that;
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
      }
    }
  }
},
traverseChildren: function(fn, xscope){
  var this$ = this;
  return this.<span class="apidocCodeKeywordSpan">eachChild</span>(function(node, name, index){
    var ref$;
    return (ref$ = fn(node, this$, name, index)) != null
      ? ref$
      : node.traverseChildren(fn, xscope);
  });
},
anaphorize: function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.expandSlice" id="apidoc.element.livescript.ast.Assign.superclass.prototype.expandSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>expandSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? Chain(head, slice$.call(pre, 0, -1))
    : Literal('this');
  return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.<span class="apidocCodeKeywordSpan">expandSlice</span>(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getAccessors" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getAccessors">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getAccessors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function Prop(key, val){
var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
this$.key = key;
this$.val = val;
if (key.value === '...') {
  return Splat(this$.val);
}
if (that = val.<span class="apidocCodeKeywordSpan">getAccessors</span>()) {
  this$.val = that;
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    fun = that[i$];
    fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
  }
  this$['accessor'] = 'accessor';
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getCall" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getCall">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fun.name = node.label;
  fun.labeled = true;
  node = node.it;
}
if (!fun.hushed &amp;&amp; (fun.hushed = node.op === '!')) {
  node = node.it;
}
if ((ref$ = node.<span class="apidocCodeKeywordSpan">getCall</span>()) != null) {
  ref$.partialized = null;
}
args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
index = 0;
for (i$ = 0, len$ = args.length; i$ &lt; len$; ++i$) {
  a = args[i$];
  if (a.placeholder) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getDefault" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getDefault">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
} else {
  if (logic = node.<span class="apidocCodeKeywordSpan">getDefault</span>()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
      ref$ = [node, key], key = ref$[0], node = ref$[1];
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.getJump" id="apidoc.element.livescript.ast.Assign.superclass.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invert" id="apidoc.element.livescript.ast.Assign.superclass.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  return Unary('!', this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary('!', this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this['else'] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.invertCheck" id="apidoc.element.livescript.ast.Assign.superclass.prototype.invertCheck">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>invertCheck
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invertCheck = function (it){
  if (it.inverted) {
    return this.invert();
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compilePartial = function(o){
  var vit, x, y;
  vit = Var('it');
  switch (false) {
  case !(this.first == null &amp;&amp; this.second == null):
    x = Var('x$');
    y = Var('y$');
    return sn(this, Fun([x, y], Block(Binary(this.op, x, y).<span class="apidocCodeKeywordSpan">invertCheck</span>(this)), false
, true).compile(o));
  case this.first == null:
    return sn(this, "(", Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), "
;)");
  default:
    return sn(this, "(", Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), "
;)");
  }
};
Binary.prototype.compileRegexEquals = function(o, arg$){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isArray" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isAssignable" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isCallable" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isComplex" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isEmpty" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + "").charAt() === '/';
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return 'empty';
  case !this.isCallable():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isMatcher" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isMatcher">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isMatcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isMatcher = function (){
  return this.isString() || this.isRegex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.partial || ((ref$ = this.op) === '&amp;&amp;' || ref$ === '||' || ref$ === '?' ||
ref$ === '&lt;&lt;' || ref$ === '&gt;&gt;') &amp;&amp; this.first.isCallable() &amp;&amp; this.second
.isCallable();
};
Binary.prototype.isArray = function(){
  switch (this.op) {
  case '*':
    return this.first.isArray();
  case '/':
    return this.second.<span class="apidocCodeKeywordSpan">isMatcher</span>();
  }
};
Binary.prototype.isString = function(){
  switch (this.op) {
  case '+':
  case '*':
    return this.first.isString() || this.second.isString();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isRegex" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isStatement" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.isString" id="apidoc.element.livescript.ast.Assign.superclass.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.makeReturn" id="apidoc.element.livescript.ast.Assign.superclass.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(ref, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (ref, obj){
  var items, kv, i, v;
  if (obj) {
    items = this instanceof Arr
      ? (this.items[0] == null || this.items[1] == null &amp;&amp; this.carp('must specify both key and value for object comprehension'),
this.items)
      : (kv = 'keyValue$', (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &lt; len$; ++i$) {
          i = i$;
          v = ref$[i$];
          results$.push(Chain(v).add(Index(Literal(i))));
        }
        return results$;
      }.call(this)));
    return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);
  } else if (ref) {
    return Call.make(JS(ref + '.push'), [this]);
  } else {
    return Return(this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.maybeKey" id="apidoc.element.livescript.ast.Assign.superclass.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.ripName" id="apidoc.element.livescript.ast.Assign.superclass.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>ripName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), ": ", key);
}
ID.test(key) || (key = Function("return " + key)());
if (!(dic[key + "."] ^= 1)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.show" id="apidoc.element.livescript.ast.Assign.superclass.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function String() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.stringify" id="apidoc.element.livescript.ast.Assign.superclass.prototype.stringify">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>stringify
        <span class="apidocSignatureSpan">(space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringify = function (space){
  return JSON.stringify(this, null, space);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    genForNode(child);
  }
  debugIndent = debugIndent.slice(0, debugIndent.length - debugIndentStr.length);
  if (valid) {
    return stack.pop();
  }
} else {
  debugOutput += debugIndent + "" + JSON.<span class="apidocCodeKeywordSpan">stringify</span>(node) + "\n";
  code += node;
  cur = stack[stack.length - 1];
  if (cur) {
    gen.addMapping({
      source: cur.source,
      original: {
        line: cur.line,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toJSON" id="apidoc.element.livescript.ast.Assign.superclass.prototype.toJSON">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
  return import$({
    type: this.constructor.displayName
  }, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.toString" id="apidoc.element.livescript.ast.Assign.superclass.prototype.toString">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>toString
        <span class="apidocSignatureSpan">(idt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.show()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return !node;
}
};
snSafe = function(code){
if (code instanceof SourceNode) {
  return code;
} else {
  return code.<span class="apidocCodeKeywordSpan">toString</span>();
}
};
snRemoveLeft = function(node, count){
var i$, to$, i, child;
for (i$ = 0, to$ = node.children.length; i$ &lt; to$; ++i$) {
  i = i$;
  child = node.children[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.traverseChildren" id="apidoc.element.livescript.ast.Assign.superclass.prototype.traverseChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>traverseChildren
        <span class="apidocSignatureSpan">(fn, xscope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseChildren = function (fn, xscope){
  var this$ = this;
  return this.eachChild(function(node, name, index){
    var ref$;
    return (ref$ = fn(node, this$, name, index)) != null
      ? ref$
      : node.traverseChildren(fn, xscope);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.carp('inconvertible statement');
}
fun = Fun([], Block(this));
call = Call();
if (o.inGenerator) {
  fun.generator = true;
}
this.<span class="apidocCodeKeywordSpan">traverseChildren</span>(function(it){
  switch (it.value) {
  case 'this':
    hasThis = true;
    break;
  case 'arguments':
    hasArgs = it.value = 'args$';
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unparen" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unparen">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unparen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Block.prototype.children = ['lines'];
Block.prototype.toJSON = function(){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
};
Block.prototype.add = function(it){
  var that, ref$;
  it = it.<span class="apidocCodeKeywordSpan">unparen</span>();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.unwrap" id="apidoc.element.livescript.ast.Assign.superclass.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &lt; 2 &amp;&amp; !this.head.isComplex() &amp;&amp; !(name != null &amp;&amp; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Assign.superclass.prototype.varName" id="apidoc.element.livescript.ast.Assign.superclass.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Assign.superclass.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function String() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary" id="apidoc.module.livescript.ast.Binary">module livescript.ast.Binary</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.Binary" id="apidoc.element.livescript.ast.Binary.Binary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Binary
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === 'String') {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== '=':
        return '?';
      default:
        return '=';
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if ('=' === op.charAt(op.length - 1) &amp;&amp; ((ref$ = op.charAt(op.length - 2)) !== '=' &amp;&amp; ref$ !== '&lt;' &amp;&amp; ref$ !== '&gt;' &amp;&amp; ref$ !== '!')) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case 'in':
      return new In(first, second);
    case 'with':
      return new Import(Unary('^^', first), second, false);
    case '&lt;&lt;&lt;':
    case '&lt;&lt;&lt;&lt;':
      return Import(first, second, op === '&lt;&lt;&lt;&lt;');
    case '&lt;|':
      return Block(first).pipe(second, op);
    case '|&gt;':
      return Block(second).pipe(first, '&lt;|');
    case '.':
    case '.~':
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],
yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Binary</span>($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.superclass" id="apidoc.element.livescript.ast.Binary.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype" id="apidoc.module.livescript.ast.Binary.prototype">module livescript.ast.Binary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf" id="apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileAnyInstanceOf
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAnyInstanceOf = function (o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary('instanceof', sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    item = items[i$];
    test = Binary('||', test, Binary('instanceof', ref, item));
  }
  return sn(this, Parens(test).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.second.cond = true;
  }
  break;
case 'instanceof':
  rite = this.second.expandSlice(o).unwrap(), items = rite.items;
  if (rite instanceof Arr) {
    if (items[1]) {
      return this.<span class="apidocCodeKeywordSpan">compileAnyInstanceOf</span>(o, items);
    }
    this.second = items[0] || rite;
  }
  this.second.isCallable() || this.second.carp('invalid instanceof operand');
  break;
case '====':
case '!===':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileChain" id="apidoc.element.livescript.ast.Binary.prototype.compileChain">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileChain
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileChain = function (o){
  var code, level, ref$, sub;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
  ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
  code.push(" ", this.op, " ", sub.compile(o, level), " &amp;&amp; ", this.second.compile(o, LEVEL_OP));
  if (o.level &lt;= LEVEL_OP) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;
;&amp; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != 'undefined' &amp;&amp; console !== null) {
        console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + &amp;#
x22; == " + this.second.value);
      }
    }
  }
  if (COMPARER.test(this.op) &amp;&amp; COMPARER.test(this.second.op)) {
    return this.<span class="apidocCodeKeywordSpan">compileChain</span>(o);
  }
}
this.first.front = this.front;
code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.mapOp(this.op), " ", this.second.
compile(o, level)];
if (o.level &lt;= level) {
  return sn.apply(null, [this].concat(slice$.call(code)));
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose" id="apidoc.element.livescript.ast.Binary.prototype.compileCompose">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileCompose
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileCompose = function (o){
  var op, functions, x;
  op = this.op;
  functions = [this.first];
  x = this.second;
  while (x instanceof Binary &amp;&amp; x.op === op &amp;&amp; !x.partial) {
    functions.push(x.first);
    x = x.second;
  }
  functions.push(x);
  if (op === '&lt;&lt;') {
    functions.reverse();
  }
  return sn(this, Chain(Var(util('compose'))).add(Call(functions)).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '^':
  return this.compilePow(o);
case '&lt;?':
case '&gt;?':
  return this.compileMinMax(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.<span class="apidocCodeKeywordSpan">compileCompose</span>(o);
case '++':
  return this.compileConcat(o);
case '%%':
  return this.compileMod(o);
case 'xor':
  return this.compileXor(o);
case '&amp;&amp;':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat" id="apidoc.element.livescript.ast.Binary.prototype.compileConcat">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileConcat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileConcat = function (o){
  var f;
  f = function(x){
    switch (false) {
    case !(x instanceof Binary &amp;&amp; x.op === '++'):
      return f(x.first).concat(f(x.second));
    default:
      return [x];
    }
  };
  return sn(null, Chain(this.first).add(CopyL(this, Index(Key('concat'), '.', true))).add(Call(f(this.second))).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '&lt;?':
case '&gt;?':
  return this.compileMinMax(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
  return this.<span class="apidocCodeKeywordSpan">compileConcat</span>(o);
case '%%':
  return this.compileMod(o);
case 'xor':
  return this.compileXor(o);
case '&amp;&amp;':
case '||':
  if (top = this['void'] || !o.level) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq" id="apidoc.element.livescript.ast.Binary.prototype.compileDeepEq">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileDeepEq
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDeepEq = function (o){
  var ref$, negate, i$, len$, x, r;
  if ((ref$ = this.op) === '&gt;==' || ref$ === '&gt;&gt;=') {
    ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
    this.op = this.op === '&gt;==' ? '&lt;==' : '&lt;&lt;=';
  }
  if (this.op === '!==') {
    this.op = '===';
    negate = true;
  }
  for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ &lt; len$; ++i$) {
    x = ref$[i$];
    if (x instanceof Obj || x instanceof Arr) {
      x.deepEq = true;
    }
  }
  r = Chain(Var(util('deepEq'))).add(Call([this.first, this.second, Literal("'" + this.op + "'")]));
  return sn(this, (negate ? Unary('!', r) : r).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '!===':
  this.op = this.op.slice(0, 3);
  // fallthrough
case '&lt;==':
case '&gt;==':
case '&lt;&lt;=':
case '&gt;&gt;=':
  return this.<span class="apidocCodeKeywordSpan">compileDeepEq</span>(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.xorChildren(function(it){
      return it.isRegex();
    })) {
      return this.compileRegexEquals(o, that);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence" id="apidoc.element.livescript.ast.Binary.prototype.compileExistence">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileExistence
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExistence = function (o){
  var x;
  if (this['void'] || !o.level) {
    x = Binary('&amp;&amp;', Existence(this.first, true), this.second);
    return (x['void'] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Binary.prototype.compileNode = function(o){
var top, rite, items, that, ref$, code, level, this$ = this;
if (this.partial) {
  return this.compilePartial(o);
}
switch (this.op) {
case '?':
  return this.<span class="apidocCodeKeywordSpan">compileExistence</span>(o);
case '*':
  if (this.second.isString()) {
    return this.compileJoin(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin" id="apidoc.element.livescript.ast.Binary.prototype.compileJoin">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileJoin
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileJoin = function (it){
  return this.compileMethod(it, 'Array', 'join');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.compilePartial(o);
}
switch (this.op) {
case '?':
  return this.compileExistence(o);
case '*':
  if (this.second.isString()) {
    return this.<span class="apidocCodeKeywordSpan">compileJoin</span>(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
  break;
case '-':
  if (this.second.isMatcher()) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod" id="apidoc.element.livescript.ast.Binary.prototype.compileMethod">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMethod
        <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMethod = function (o, klass, method, arg){
  var args;
  args = [this.second].concat(arg || []);
  if (this.first["is" + klass]()) {
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + '.call'), args).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + '.call'), args).compile(o));
  }
};
Binary.prototype.compileJoin = function(it){
  return this.<span class="apidocCodeKeywordSpan">compileMethod</span>(it, 'Array', 'join');
};
Binary.prototype.compileRemove = function(it){
  return this.compileMethod(it, 'String', 'replace', JS("''"));
};
Binary.prototype.compileSplit = function(it){
  return this.compileMethod(it, 'String', 'split');
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax" id="apidoc.element.livescript.ast.Binary.prototype.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMinMax
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMinMax = function (o){
  var lefts, rites, x;
  lefts = this.first.cache(o, true);
  rites = this.second.cache(o, true);
  x = Binary(this.op.charAt(), lefts[0], rites[0]);
  return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case '**':
case '^':
  return this.compilePow(o);
case '&lt;?':
case '&gt;?':
  return this.<span class="apidocCodeKeywordSpan">compileMinMax</span>(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
  return this.compileConcat(o);
case '%%':
  return this.compileMod(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMod" id="apidoc.element.livescript.ast.Binary.prototype.compileMod">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMod
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMod = function (o){
  var ref, code;
  ref = o.scope.temporary();
  code = [sn(this, "((("), this.first.compile(o), sn(this, ") % ("), sn(this, ref, " = "), this.second.compile(o), sn(this, ") + ",
ref, ") % ", ref, ")")];
  o.scope.free(ref);
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.compileMinMax(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
  return this.compileConcat(o);
case '%%':
  return this.<span class="apidocCodeKeywordSpan">compileMod</span>(o);
case 'xor':
  return this.compileXor(o);
case '&amp;&amp;':
case '||':
  if (top = this['void'] || !o.level) {
    this.second['void'] = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileNode" id="apidoc.element.livescript.ast.Binary.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.compilePartial(o);
  }
  switch (this.op) {
  case '?':
    return this.compileExistence(o);
  case '*':
    if (this.second.isString()) {
      return this.compileJoin(o);
    }
    if (this.first.isString() || this.first.isArray()) {
      return this.compileRepeat(o);
    }
    break;
  case '-':
    if (this.second.isMatcher()) {
      return this.compileRemove(o);
    }
    break;
  case '/':
    if (this.second.isMatcher()) {
      return this.compileSplit(o);
    }
    break;
  case '**':
  case '^':
    return this.compilePow(o);
  case '&lt;?':
  case '&gt;?':
    return this.compileMinMax(o);
  case '&lt;&lt;':
  case '&gt;&gt;':
    return this.compileCompose(o);
  case '++':
    return this.compileConcat(o);
  case '%%':
    return this.compileMod(o);
  case 'xor':
    return this.compileXor(o);
  case '&amp;&amp;':
  case '||':
    if (top = this['void'] || !o.level) {
      this.second['void'] = true;
    }
    if (top || this.cond) {
      this.first.cond = true;
      this.second.cond = true;
    }
    break;
  case 'instanceof':
    rite = this.second.expandSlice(o).unwrap(), items = rite.items;
    if (rite instanceof Arr) {
      if (items[1]) {
        return this.compileAnyInstanceOf(o, items);
      }
      this.second = items[0] || rite;
    }
    this.second.isCallable() || this.second.carp('invalid instanceof operand');
    break;
  case '====':
  case '!===':
    this.op = this.op.slice(0, 3);
    // fallthrough
  case '&lt;==':
  case '&gt;==':
  case '&lt;&lt;=':
  case '&gt;&gt;=':
    return this.compileDeepEq(o);
  default:
    if (COMPARER.test(this.op)) {
      if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.xorChildren(function(it){
        return it.isRegex();
      })) {
        return this.compileRegexEquals(o, that);
      }
      if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;&amp; this.first.isWhat() !== this
.second.isWhat()) {
        if (typeof console != 'undefined' &amp;&amp; console !== null) {
          console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + " == " +
this.second.value);
        }
      }
    }
    if (COMPARER.test(this.op) &amp;&amp; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.mapOp(this.op), " ", this.second.compile(o, level)];
  if (o.level &lt;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial" id="apidoc.element.livescript.ast.Binary.prototype.compilePartial">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePartial
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePartial = function (o){
  var vit, x, y;
  vit = Var('it');
  switch (false) {
  case !(this.first == null &amp;&amp; this.second == null):
    x = Var('x$');
    y = Var('y$');
    return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));
  case this.first == null:
    return sn(this, "(", Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), ")");
  default:
    return sn(this, "(", Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
};
Binary.prototype.compileNode = function(o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.<span class="apidocCodeKeywordSpan">compilePartial</span>(o);
  }
  switch (this.op) {
  case '?':
    return this.compileExistence(o);
  case '*':
    if (this.second.isString()) {
      return this.compileJoin(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePow" id="apidoc.element.livescript.ast.Binary.prototype.compilePow">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePow
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePow = function (o){
  return sn(null, Call.make(CopyL(this, JS('Math.pow')), [this.first, this.second]).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '/':
  if (this.second.isMatcher()) {
    return this.compileSplit(o);
  }
  break;
case '**':
case '^':
  return this.<span class="apidocCodeKeywordSpan">compilePow</span>(o);
case '&lt;?':
case '&gt;?':
  return this.compileMinMax(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals" id="apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRegexEquals
        <span class="apidocSignatureSpan">(o, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRegexEquals = function (o, arg$){
  var regex, target, method;
  regex = arg$[0], target = arg$[1];
  if (this.op === '===') {
    method = this.wasInverted ? 'test' : 'exec';
    return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
  } else {
    return sn(this, Unary('!', Chain(regex).add(Index(Key('test'))).add(Call([target]))).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '&gt;&gt;=':
  return this.compileDeepEq(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.xorChildren(function(it){
      return it.isRegex();
    })) {
      return this.<span class="apidocCodeKeywordSpan">compileRegexEquals</span>(o, that);
    }
    if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;
;&amp; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != 'undefined' &amp;&amp; console !== null) {
        console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + &amp;#
x22; == " + this.second.value);
      }
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove" id="apidoc.element.livescript.ast.Binary.prototype.compileRemove">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRemove
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRemove = function (it){
  return this.compileMethod(it, 'String', 'replace', JS("''"));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
  break;
case '-':
  if (this.second.isMatcher()) {
    return this.<span class="apidocCodeKeywordSpan">compileRemove</span>(o);
  }
  break;
case '/':
  if (this.second.isMatcher()) {
    return this.compileSplit(o);
  }
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat" id="apidoc.element.livescript.ast.Binary.prototype.compileRepeat">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRepeat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRepeat = function (o){
  var x, n, items, arr, arrCode, refs, i$, len$, i, item, ref$, q;
  x = this.first, n = this.second;
  items = (x = x.expandSlice(o).unwrap()).items;
  arr = x.isArray() &amp;&amp; 'Array';
  if (items &amp;&amp; !snEmpty(arrCode = Splat.compileArray(o, items))) {
    x = JS(arrCode);
    items = null;
  }
  if (arr &amp;&amp; !items || !(n instanceof Literal &amp;&amp; n.value &lt; 0x20)) {
    return sn(this, Call.make(Util('repeat' + (arr || 'String')), [x, n]).compile(o));
  }
  n = +n.value;
  if (1 &lt;= n &amp;&amp; n &lt; 2) {
    return sn(this, x.compile(o));
  }
  if (items) {
    if (n &lt; 1) {
      return sn(this, Block(items).add(JS('[]')).compile(o));
    }
    refs = [];
    for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
      i = i$;
      item = items[i$];
      ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
    }
    items.push((ref$ = JS(), ref$.compile = function(){
      return sn.apply(null, [this].concat(slice$.call((repeatArray$([", ", List.compile(o, refs)], n - 1)).slice(1))));
    }, ref$));
    return sn(this, x.compile(o));
  } else if (x instanceof Literal) {
    return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + "", n) + q);
  } else {
    if (n &lt; 1) {
      return sn(this, Block(x.it).add(JS("''")).compile(o));
    }
    x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(" + " + refs[1], n - 1);
    if (o.level &lt; LEVEL_OP + PREC['+']) {
      return sn(this, x);
    } else {
      return sn(this, "(", x, ")");
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '?':
  return this.compileExistence(o);
case '*':
  if (this.second.isString()) {
    return this.compileJoin(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.<span class="apidocCodeKeywordSpan">compileRepeat</span>(o);
  }
  break;
case '-':
  if (this.second.isMatcher()) {
    return this.compileRemove(o);
  }
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit" id="apidoc.element.livescript.ast.Binary.prototype.compileSplit">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileSplit
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSplit = function (it){
  return this.compileMethod(it, 'String', 'split');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '-':
  if (this.second.isMatcher()) {
    return this.compileRemove(o);
  }
  break;
case '/':
  if (this.second.isMatcher()) {
    return this.<span class="apidocCodeKeywordSpan">compileSplit</span>(o);
  }
  break;
case '**':
case '^':
  return this.compilePow(o);
case '&lt;?':
case '&gt;?':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileXor" id="apidoc.element.livescript.ast.Binary.prototype.compileXor">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileXor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileXor = function (o){
  var left, right;
  left = Chain(this.first).cacheReference(o);
  right = Chain(this.second).cacheReference(o);
  return sn(this, Binary('&amp;&amp;', Binary('!==', Unary('!', left[0]), Unary('!', right[0])), Parens(Binary('||', left[1], right[1]))).
compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
  return this.compileConcat(o);
case '%%':
  return this.compileMod(o);
case 'xor':
  return this.<span class="apidocCodeKeywordSpan">compileXor</span>(o);
case '&amp;&amp;':
case '||':
  if (top = this['void'] || !o.level) {
    this.second['void'] = true;
  }
  if (top || this.cond) {
    this.first.cond = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.constructor" id="apidoc.element.livescript.ast.Binary.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>constructor
        <span class="apidocSignatureSpan">(op, first, second, destructuring)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(op, first, second, destructuring){
  var logic, that, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  if (destructuring) {
    logic = op.logic;
    if (toString$.call(destructuring).slice(8, -1) === 'String') {
      logic = destructuring;
    }
    op = (function(){
      switch (false) {
      case !(that = logic):
        return that;
      case op !== '=':
        return '?';
      default:
        return '=';
      }
    }());
  }
  this$.partial = first == null || second == null;
  if (!this$.partial) {
    if ('=' === op.charAt(op.length - 1) &amp;&amp; ((ref$ = op.charAt(op.length - 2)) !== '=' &amp;&amp; ref$ !== '&lt;' &amp;&amp; ref$ !== '&gt;' &amp;&amp; ref$ !== '!')) {
      return Assign(first.unwrap(), second, op);
    }
    switch (op) {
    case 'in':
      return new In(first, second);
    case 'with':
      return new Import(Unary('^^', first), second, false);
    case '&lt;&lt;&lt;':
    case '&lt;&lt;&lt;&lt;':
      return Import(first, second, op === '&lt;&lt;&lt;&lt;');
    case '&lt;|':
      return Block(first).pipe(second, op);
    case '|&gt;':
      return Block(second).pipe(first, '&lt;|');
    case '.':
    case '.~':
      return Chain(first).add(Index(second, op));
    }
  }
  this$.op = op;
  this$.first = first;
  this$.second = second;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.getDefault" id="apidoc.element.livescript.ast.Binary.prototype.getDefault">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>getDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefault = function (){
  switch (this.op) {
  case '?':
  case '||':
  case '&amp;&amp;':
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
} else {
  if (logic = node.<span class="apidocCodeKeywordSpan">getDefault</span>()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
      ref$ = [node, key], key = ref$[0], node = ref$[1];
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invert" id="apidoc.element.livescript.ast.Binary.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  var that;
  if (that = !COMPARER.test(this.second.op) &amp;&amp; INVERSIONS[this.op]) {
    this.op = that;
    this.wasInverted = true;
    return this;
  }
  return Unary('!', Parens(this), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary('!', this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this['else'] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invertIt" id="apidoc.element.livescript.ast.Binary.prototype.invertIt">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invertIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invertIt = function (){
  this.inverted = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
case 17:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],'!' === $$[$0-1].charAt(0)
        ? yy.Binary($$[$0-1].slice(1)).<span class="apidocCodeKeywordSpan">invertIt</span>()
        : yy.Binary($$[$0-1]))));
break;
case 18:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],'!' === $$[$0-2].charAt(0)
        ? yy.Binary($$[$0-2].slice(1), void 8, $$[$0-1]).invertIt()
        : yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isArray" id="apidoc.element.livescript.ast.Binary.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  switch (this.op) {
  case '*':
    return this.first.isArray();
  case '/':
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isCallable" id="apidoc.element.livescript.ast.Binary.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return this.partial || ((ref$ = this.op) === '&amp;&amp;' || ref$ === '||' || ref$ === '?' || ref$ === '&lt;&lt;' || ref$ === '&gt;&gt;') &amp;&amp; this.
first.isCallable() &amp;&amp; this.second.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isString" id="apidoc.element.livescript.ast.Binary.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  switch (this.op) {
  case '+':
  case '*':
    return this.first.isString() || this.second.isString();
  case '-':
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.mapOp" id="apidoc.element.livescript.ast.Binary.prototype.mapOp">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>mapOp
        <span class="apidocSignatureSpan">(op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapOp = function (op){
  var that;
  switch (false) {
  case !(that = op.match(/\.([&amp;\|\^]|&lt;&lt;|&gt;&gt;&gt;?)\./)):
    return that[1];
  case op !== 'of':
    return 'in';
  default:
    return op;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
    if (COMPARER.test(this.op) &amp;&amp; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.<span class="apidocCodeKeywordSpan">mapOp
</span>(this.op), " ", this.second.compile(o, level)];
  if (o.level &lt;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
};
Binary.prototype.mapOp = function(op){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.show" id="apidoc.element.livescript.ast.Binary.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren" id="apidoc.element.livescript.ast.Binary.prototype.xorChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>xorChildren
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xorChildren = function (test){
  var ref$, ref1$, first;
  if (!(!(ref$ = first = test(this.first)) !== !(ref1$ = test(this.second)) &amp;&amp; (ref$ || ref1$))) {
    return false;
  }
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '&lt;==':
case '&gt;==':
case '&lt;&lt;=':
case '&gt;&gt;=':
  return this.compileDeepEq(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.<span class="apidocCodeKeywordSpan
">xorChildren</span>(function(it){
      return it.isRegex();
    })) {
      return this.compileRegexEquals(o, that);
    }
    if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;
;&amp; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != 'undefined' &amp;&amp; console !== null) {
        console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + &amp;#
x22; == " + this.second.value);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileAnyInstanceOf" id="apidoc.module.livescript.ast.Binary.prototype.compileAnyInstanceOf">module livescript.ast.Binary.prototype.compileAnyInstanceOf</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf.compileAnyInstanceOf" id="apidoc.element.livescript.ast.Binary.prototype.compileAnyInstanceOf.compileAnyInstanceOf">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileAnyInstanceOf
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAnyInstanceOf = function (o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary('instanceof', sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    item = items[i$];
    test = Binary('||', test, Binary('instanceof', ref, item));
  }
  return sn(this, Parens(test).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.second.cond = true;
  }
  break;
case 'instanceof':
  rite = this.second.expandSlice(o).unwrap(), items = rite.items;
  if (rite instanceof Arr) {
    if (items[1]) {
      return this.<span class="apidocCodeKeywordSpan">compileAnyInstanceOf</span>(o, items);
    }
    this.second = items[0] || rite;
  }
  this.second.isCallable() || this.second.carp('invalid instanceof operand');
  break;
case '====':
case '!===':
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileChain" id="apidoc.module.livescript.ast.Binary.prototype.compileChain">module livescript.ast.Binary.prototype.compileChain</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileChain.compileChain" id="apidoc.element.livescript.ast.Binary.prototype.compileChain.compileChain">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileChain
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileChain = function (o){
  var code, level, ref$, sub;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
  ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
  code.push(" ", this.op, " ", sub.compile(o, level), " &amp;&amp; ", this.second.compile(o, LEVEL_OP));
  if (o.level &lt;= LEVEL_OP) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;
;&amp; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != 'undefined' &amp;&amp; console !== null) {
        console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + &amp;#
x22; == " + this.second.value);
      }
    }
  }
  if (COMPARER.test(this.op) &amp;&amp; COMPARER.test(this.second.op)) {
    return this.<span class="apidocCodeKeywordSpan">compileChain</span>(o);
  }
}
this.first.front = this.front;
code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.mapOp(this.op), " ", this.second.
compile(o, level)];
if (o.level &lt;= level) {
  return sn.apply(null, [this].concat(slice$.call(code)));
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileCompose" id="apidoc.module.livescript.ast.Binary.prototype.compileCompose">module livescript.ast.Binary.prototype.compileCompose</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileCompose.compileCompose" id="apidoc.element.livescript.ast.Binary.prototype.compileCompose.compileCompose">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileCompose
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileCompose = function (o){
  var op, functions, x;
  op = this.op;
  functions = [this.first];
  x = this.second;
  while (x instanceof Binary &amp;&amp; x.op === op &amp;&amp; !x.partial) {
    functions.push(x.first);
    x = x.second;
  }
  functions.push(x);
  if (op === '&lt;&lt;') {
    functions.reverse();
  }
  return sn(this, Chain(Var(util('compose'))).add(Call(functions)).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '^':
  return this.compilePow(o);
case '&lt;?':
case '&gt;?':
  return this.compileMinMax(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.<span class="apidocCodeKeywordSpan">compileCompose</span>(o);
case '++':
  return this.compileConcat(o);
case '%%':
  return this.compileMod(o);
case 'xor':
  return this.compileXor(o);
case '&amp;&amp;':
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileConcat" id="apidoc.module.livescript.ast.Binary.prototype.compileConcat">module livescript.ast.Binary.prototype.compileConcat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileConcat.compileConcat" id="apidoc.element.livescript.ast.Binary.prototype.compileConcat.compileConcat">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileConcat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileConcat = function (o){
  var f;
  f = function(x){
    switch (false) {
    case !(x instanceof Binary &amp;&amp; x.op === '++'):
      return f(x.first).concat(f(x.second));
    default:
      return [x];
    }
  };
  return sn(null, Chain(this.first).add(CopyL(this, Index(Key('concat'), '.', true))).add(Call(f(this.second))).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '&lt;?':
case '&gt;?':
  return this.compileMinMax(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
  return this.<span class="apidocCodeKeywordSpan">compileConcat</span>(o);
case '%%':
  return this.compileMod(o);
case 'xor':
  return this.compileXor(o);
case '&amp;&amp;':
case '||':
  if (top = this['void'] || !o.level) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileDeepEq" id="apidoc.module.livescript.ast.Binary.prototype.compileDeepEq">module livescript.ast.Binary.prototype.compileDeepEq</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileDeepEq.compileDeepEq" id="apidoc.element.livescript.ast.Binary.prototype.compileDeepEq.compileDeepEq">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileDeepEq
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDeepEq = function (o){
  var ref$, negate, i$, len$, x, r;
  if ((ref$ = this.op) === '&gt;==' || ref$ === '&gt;&gt;=') {
    ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
    this.op = this.op === '&gt;==' ? '&lt;==' : '&lt;&lt;=';
  }
  if (this.op === '!==') {
    this.op = '===';
    negate = true;
  }
  for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ &lt; len$; ++i$) {
    x = ref$[i$];
    if (x instanceof Obj || x instanceof Arr) {
      x.deepEq = true;
    }
  }
  r = Chain(Var(util('deepEq'))).add(Call([this.first, this.second, Literal("'" + this.op + "'")]));
  return sn(this, (negate ? Unary('!', r) : r).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '!===':
  this.op = this.op.slice(0, 3);
  // fallthrough
case '&lt;==':
case '&gt;==':
case '&lt;&lt;=':
case '&gt;&gt;=':
  return this.<span class="apidocCodeKeywordSpan">compileDeepEq</span>(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.xorChildren(function(it){
      return it.isRegex();
    })) {
      return this.compileRegexEquals(o, that);
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileExistence" id="apidoc.module.livescript.ast.Binary.prototype.compileExistence">module livescript.ast.Binary.prototype.compileExistence</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileExistence.compileExistence" id="apidoc.element.livescript.ast.Binary.prototype.compileExistence.compileExistence">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileExistence
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExistence = function (o){
  var x;
  if (this['void'] || !o.level) {
    x = Binary('&amp;&amp;', Existence(this.first, true), this.second);
    return (x['void'] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  Binary.prototype.compileNode = function(o){
var top, rite, items, that, ref$, code, level, this$ = this;
if (this.partial) {
  return this.compilePartial(o);
}
switch (this.op) {
case '?':
  return this.<span class="apidocCodeKeywordSpan">compileExistence</span>(o);
case '*':
  if (this.second.isString()) {
    return this.compileJoin(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileJoin" id="apidoc.module.livescript.ast.Binary.prototype.compileJoin">module livescript.ast.Binary.prototype.compileJoin</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileJoin.compileJoin" id="apidoc.element.livescript.ast.Binary.prototype.compileJoin.compileJoin">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileJoin
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileJoin = function (it){
  return this.compileMethod(it, 'Array', 'join');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.compilePartial(o);
}
switch (this.op) {
case '?':
  return this.compileExistence(o);
case '*':
  if (this.second.isString()) {
    return this.<span class="apidocCodeKeywordSpan">compileJoin</span>(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
  break;
case '-':
  if (this.second.isMatcher()) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMethod" id="apidoc.module.livescript.ast.Binary.prototype.compileMethod">module livescript.ast.Binary.prototype.compileMethod</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMethod.compileMethod" id="apidoc.element.livescript.ast.Binary.prototype.compileMethod.compileMethod">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMethod
        <span class="apidocSignatureSpan">(o, klass, method, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMethod = function (o, klass, method, arg){
  var args;
  args = [this.second].concat(arg || []);
  if (this.first["is" + klass]()) {
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + '.call'), args).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
  } else {
    args.unshift(this.first);
    return sn(this, Call.make(JS(util(method) + '.call'), args).compile(o));
  }
};
Binary.prototype.compileJoin = function(it){
  return this.<span class="apidocCodeKeywordSpan">compileMethod</span>(it, 'Array', 'join');
};
Binary.prototype.compileRemove = function(it){
  return this.compileMethod(it, 'String', 'replace', JS("''"));
};
Binary.prototype.compileSplit = function(it){
  return this.compileMethod(it, 'String', 'split');
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMinMax" id="apidoc.module.livescript.ast.Binary.prototype.compileMinMax">module livescript.ast.Binary.prototype.compileMinMax</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMinMax.compileMinMax" id="apidoc.element.livescript.ast.Binary.prototype.compileMinMax.compileMinMax">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMinMax
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMinMax = function (o){
  var lefts, rites, x;
  lefts = this.first.cache(o, true);
  rites = this.second.cache(o, true);
  x = Binary(this.op.charAt(), lefts[0], rites[0]);
  return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case '**':
case '^':
  return this.compilePow(o);
case '&lt;?':
case '&gt;?':
  return this.<span class="apidocCodeKeywordSpan">compileMinMax</span>(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
  return this.compileConcat(o);
case '%%':
  return this.compileMod(o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileMod" id="apidoc.module.livescript.ast.Binary.prototype.compileMod">module livescript.ast.Binary.prototype.compileMod</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileMod.compileMod" id="apidoc.element.livescript.ast.Binary.prototype.compileMod.compileMod">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileMod
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileMod = function (o){
  var ref, code;
  ref = o.scope.temporary();
  code = [sn(this, "((("), this.first.compile(o), sn(this, ") % ("), sn(this, ref, " = "), this.second.compile(o), sn(this, ") + ",
ref, ") % ", ref, ")")];
  o.scope.free(ref);
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.compileMinMax(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
  return this.compileConcat(o);
case '%%':
  return this.<span class="apidocCodeKeywordSpan">compileMod</span>(o);
case 'xor':
  return this.compileXor(o);
case '&amp;&amp;':
case '||':
  if (top = this['void'] || !o.level) {
    this.second['void'] = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileNode" id="apidoc.module.livescript.ast.Binary.prototype.compileNode">module livescript.ast.Binary.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Binary.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.compilePartial(o);
  }
  switch (this.op) {
  case '?':
    return this.compileExistence(o);
  case '*':
    if (this.second.isString()) {
      return this.compileJoin(o);
    }
    if (this.first.isString() || this.first.isArray()) {
      return this.compileRepeat(o);
    }
    break;
  case '-':
    if (this.second.isMatcher()) {
      return this.compileRemove(o);
    }
    break;
  case '/':
    if (this.second.isMatcher()) {
      return this.compileSplit(o);
    }
    break;
  case '**':
  case '^':
    return this.compilePow(o);
  case '&lt;?':
  case '&gt;?':
    return this.compileMinMax(o);
  case '&lt;&lt;':
  case '&gt;&gt;':
    return this.compileCompose(o);
  case '++':
    return this.compileConcat(o);
  case '%%':
    return this.compileMod(o);
  case 'xor':
    return this.compileXor(o);
  case '&amp;&amp;':
  case '||':
    if (top = this['void'] || !o.level) {
      this.second['void'] = true;
    }
    if (top || this.cond) {
      this.first.cond = true;
      this.second.cond = true;
    }
    break;
  case 'instanceof':
    rite = this.second.expandSlice(o).unwrap(), items = rite.items;
    if (rite instanceof Arr) {
      if (items[1]) {
        return this.compileAnyInstanceOf(o, items);
      }
      this.second = items[0] || rite;
    }
    this.second.isCallable() || this.second.carp('invalid instanceof operand');
    break;
  case '====':
  case '!===':
    this.op = this.op.slice(0, 3);
    // fallthrough
  case '&lt;==':
  case '&gt;==':
  case '&lt;&lt;=':
  case '&gt;&gt;=':
    return this.compileDeepEq(o);
  default:
    if (COMPARER.test(this.op)) {
      if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.xorChildren(function(it){
        return it.isRegex();
      })) {
        return this.compileRegexEquals(o, that);
      }
      if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;&amp; this.first.isWhat() !== this
.second.isWhat()) {
        if (typeof console != 'undefined' &amp;&amp; console !== null) {
          console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + " == " +
this.second.value);
        }
      }
    }
    if (COMPARER.test(this.op) &amp;&amp; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.mapOp(this.op), " ", this.second.compile(o, level)];
  if (o.level &lt;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compilePartial" id="apidoc.module.livescript.ast.Binary.prototype.compilePartial">module livescript.ast.Binary.prototype.compilePartial</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePartial.compilePartial" id="apidoc.element.livescript.ast.Binary.prototype.compilePartial.compilePartial">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePartial
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePartial = function (o){
  var vit, x, y;
  vit = Var('it');
  switch (false) {
  case !(this.first == null &amp;&amp; this.second == null):
    x = Var('x$');
    y = Var('y$');
    return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));
  case this.first == null:
    return sn(this, "(", Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), ")");
  default:
    return sn(this, "(", Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
};
Binary.prototype.compileNode = function(o){
  var top, rite, items, that, ref$, code, level, this$ = this;
  if (this.partial) {
    return this.<span class="apidocCodeKeywordSpan">compilePartial</span>(o);
  }
  switch (this.op) {
  case '?':
    return this.compileExistence(o);
  case '*':
    if (this.second.isString()) {
      return this.compileJoin(o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compilePow" id="apidoc.module.livescript.ast.Binary.prototype.compilePow">module livescript.ast.Binary.prototype.compilePow</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compilePow.compilePow" id="apidoc.element.livescript.ast.Binary.prototype.compilePow.compilePow">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compilePow
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePow = function (o){
  return sn(null, Call.make(CopyL(this, JS('Math.pow')), [this.first, this.second]).compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '/':
  if (this.second.isMatcher()) {
    return this.compileSplit(o);
  }
  break;
case '**':
case '^':
  return this.<span class="apidocCodeKeywordSpan">compilePow</span>(o);
case '&lt;?':
case '&gt;?':
  return this.compileMinMax(o);
case '&lt;&lt;':
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRegexEquals" id="apidoc.module.livescript.ast.Binary.prototype.compileRegexEquals">module livescript.ast.Binary.prototype.compileRegexEquals</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals.compileRegexEquals" id="apidoc.element.livescript.ast.Binary.prototype.compileRegexEquals.compileRegexEquals">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRegexEquals
        <span class="apidocSignatureSpan">(o, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRegexEquals = function (o, arg$){
  var regex, target, method;
  regex = arg$[0], target = arg$[1];
  if (this.op === '===') {
    method = this.wasInverted ? 'test' : 'exec';
    return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
  } else {
    return sn(this, Unary('!', Chain(regex).add(Index(Key('test'))).add(Call([target]))).compile(o));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '&gt;&gt;=':
  return this.compileDeepEq(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.xorChildren(function(it){
      return it.isRegex();
    })) {
      return this.<span class="apidocCodeKeywordSpan">compileRegexEquals</span>(o, that);
    }
    if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;
;&amp; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != 'undefined' &amp;&amp; console !== null) {
        console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + &amp;#
x22; == " + this.second.value);
      }
    }
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRemove" id="apidoc.module.livescript.ast.Binary.prototype.compileRemove">module livescript.ast.Binary.prototype.compileRemove</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRemove.compileRemove" id="apidoc.element.livescript.ast.Binary.prototype.compileRemove.compileRemove">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRemove
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRemove = function (it){
  return this.compileMethod(it, 'String', 'replace', JS("''"));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.compileRepeat(o);
  }
  break;
case '-':
  if (this.second.isMatcher()) {
    return this.<span class="apidocCodeKeywordSpan">compileRemove</span>(o);
  }
  break;
case '/':
  if (this.second.isMatcher()) {
    return this.compileSplit(o);
  }
  break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileRepeat" id="apidoc.module.livescript.ast.Binary.prototype.compileRepeat">module livescript.ast.Binary.prototype.compileRepeat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileRepeat.compileRepeat" id="apidoc.element.livescript.ast.Binary.prototype.compileRepeat.compileRepeat">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileRepeat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRepeat = function (o){
  var x, n, items, arr, arrCode, refs, i$, len$, i, item, ref$, q;
  x = this.first, n = this.second;
  items = (x = x.expandSlice(o).unwrap()).items;
  arr = x.isArray() &amp;&amp; 'Array';
  if (items &amp;&amp; !snEmpty(arrCode = Splat.compileArray(o, items))) {
    x = JS(arrCode);
    items = null;
  }
  if (arr &amp;&amp; !items || !(n instanceof Literal &amp;&amp; n.value &lt; 0x20)) {
    return sn(this, Call.make(Util('repeat' + (arr || 'String')), [x, n]).compile(o));
  }
  n = +n.value;
  if (1 &lt;= n &amp;&amp; n &lt; 2) {
    return sn(this, x.compile(o));
  }
  if (items) {
    if (n &lt; 1) {
      return sn(this, Block(items).add(JS('[]')).compile(o));
    }
    refs = [];
    for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
      i = i$;
      item = items[i$];
      ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
    }
    items.push((ref$ = JS(), ref$.compile = function(){
      return sn.apply(null, [this].concat(slice$.call((repeatArray$([", ", List.compile(o, refs)], n - 1)).slice(1))));
    }, ref$));
    return sn(this, x.compile(o));
  } else if (x instanceof Literal) {
    return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + "", n) + q);
  } else {
    if (n &lt; 1) {
      return sn(this, Block(x.it).add(JS("''")).compile(o));
    }
    x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(" + " + refs[1], n - 1);
    if (o.level &lt; LEVEL_OP + PREC['+']) {
      return sn(this, x);
    } else {
      return sn(this, "(", x, ")");
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '?':
  return this.compileExistence(o);
case '*':
  if (this.second.isString()) {
    return this.compileJoin(o);
  }
  if (this.first.isString() || this.first.isArray()) {
    return this.<span class="apidocCodeKeywordSpan">compileRepeat</span>(o);
  }
  break;
case '-':
  if (this.second.isMatcher()) {
    return this.compileRemove(o);
  }
  break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileSplit" id="apidoc.module.livescript.ast.Binary.prototype.compileSplit">module livescript.ast.Binary.prototype.compileSplit</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileSplit.compileSplit" id="apidoc.element.livescript.ast.Binary.prototype.compileSplit.compileSplit">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileSplit
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSplit = function (it){
  return this.compileMethod(it, 'String', 'split');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '-':
  if (this.second.isMatcher()) {
    return this.compileRemove(o);
  }
  break;
case '/':
  if (this.second.isMatcher()) {
    return this.<span class="apidocCodeKeywordSpan">compileSplit</span>(o);
  }
  break;
case '**':
case '^':
  return this.compilePow(o);
case '&lt;?':
case '&gt;?':
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.compileXor" id="apidoc.module.livescript.ast.Binary.prototype.compileXor">module livescript.ast.Binary.prototype.compileXor</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.compileXor.compileXor" id="apidoc.element.livescript.ast.Binary.prototype.compileXor.compileXor">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>compileXor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileXor = function (o){
  var left, right;
  left = Chain(this.first).cacheReference(o);
  right = Chain(this.second).cacheReference(o);
  return sn(this, Binary('&amp;&amp;', Binary('!==', Unary('!', left[0]), Unary('!', right[0])), Parens(Binary('||', left[1], right[1]))).
compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '&gt;&gt;':
  return this.compileCompose(o);
case '++':
  return this.compileConcat(o);
case '%%':
  return this.compileMod(o);
case 'xor':
  return this.<span class="apidocCodeKeywordSpan">compileXor</span>(o);
case '&amp;&amp;':
case '||':
  if (top = this['void'] || !o.level) {
    this.second['void'] = true;
  }
  if (top || this.cond) {
    this.first.cond = true;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.getDefault" id="apidoc.module.livescript.ast.Binary.prototype.getDefault">module livescript.ast.Binary.prototype.getDefault</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.getDefault.getDefault" id="apidoc.element.livescript.ast.Binary.prototype.getDefault.getDefault">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>getDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefault = function (){
  switch (this.op) {
  case '?':
  case '||':
  case '&amp;&amp;':
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
} else {
  if (logic = node.<span class="apidocCodeKeywordSpan">getDefault</span>()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
      ref$ = [node, key], key = ref$[0], node = ref$[1];
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.invert" id="apidoc.module.livescript.ast.Binary.prototype.invert">module livescript.ast.Binary.prototype.invert</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invert.invert" id="apidoc.element.livescript.ast.Binary.prototype.invert.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  var that;
  if (that = !COMPARER.test(this.second.op) &amp;&amp; INVERSIONS[this.op]) {
    this.op = that;
    this.wasInverted = true;
    return this;
  }
  return Unary('!', Parens(this), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary('!', this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this['else'] = $else;
  return this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.invertIt" id="apidoc.module.livescript.ast.Binary.prototype.invertIt">module livescript.ast.Binary.prototype.invertIt</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.invertIt.invertIt" id="apidoc.element.livescript.ast.Binary.prototype.invertIt.invertIt">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>invertIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invertIt = function (){
  this.inverted = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
case 16:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
break;
case 17:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],'!' === $$[$0-1].charAt(0)
        ? yy.Binary($$[$0-1].slice(1)).<span class="apidocCodeKeywordSpan">invertIt</span>()
        : yy.Binary($$[$0-1]))));
break;
case 18:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],'!' === $$[$0-2].charAt(0)
        ? yy.Binary($$[$0-2].slice(1), void 8, $$[$0-1]).invertIt()
        : yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.isArray" id="apidoc.module.livescript.ast.Binary.prototype.isArray">module livescript.ast.Binary.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Binary.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  switch (this.op) {
  case '*':
    return this.first.isArray();
  case '/':
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.isCallable" id="apidoc.module.livescript.ast.Binary.prototype.isCallable">module livescript.ast.Binary.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Binary.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return this.partial || ((ref$ = this.op) === '&amp;&amp;' || ref$ === '||' || ref$ === '?' || ref$ === '&lt;&lt;' || ref$ === '&gt;&gt;') &amp;&amp; this.
first.isCallable() &amp;&amp; this.second.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.isString" id="apidoc.module.livescript.ast.Binary.prototype.isString">module livescript.ast.Binary.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.isString.isString" id="apidoc.element.livescript.ast.Binary.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  switch (this.op) {
  case '+':
  case '*':
    return this.first.isString() || this.second.isString();
  case '-':
    return this.second.isMatcher();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.mapOp" id="apidoc.module.livescript.ast.Binary.prototype.mapOp">module livescript.ast.Binary.prototype.mapOp</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.mapOp.mapOp" id="apidoc.element.livescript.ast.Binary.prototype.mapOp.mapOp">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>mapOp
        <span class="apidocSignatureSpan">(op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapOp = function (op){
  var that;
  switch (false) {
  case !(that = op.match(/\.([&amp;\|\^]|&lt;&lt;|&gt;&gt;&gt;?)\./)):
    return that[1];
  case op !== 'of':
    return 'in';
  default:
    return op;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
    if (COMPARER.test(this.op) &amp;&amp; COMPARER.test(this.second.op)) {
      return this.compileChain(o);
    }
  }
  this.first.front = this.front;
  code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.<span class="apidocCodeKeywordSpan">mapOp
</span>(this.op), " ", this.second.compile(o, level)];
  if (o.level &lt;= level) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
};
Binary.prototype.mapOp = function(op){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.show" id="apidoc.module.livescript.ast.Binary.prototype.show">module livescript.ast.Binary.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.show.show" id="apidoc.element.livescript.ast.Binary.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Binary.prototype.xorChildren" id="apidoc.module.livescript.ast.Binary.prototype.xorChildren">module livescript.ast.Binary.prototype.xorChildren</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Binary.prototype.xorChildren.xorChildren" id="apidoc.element.livescript.ast.Binary.prototype.xorChildren.xorChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Binary.prototype.</span>xorChildren
        <span class="apidocSignatureSpan">(test)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xorChildren = function (test){
  var ref$, ref1$, first;
  if (!(!(ref$ = first = test(this.first)) !== !(ref1$ = test(this.second)) &amp;&amp; (ref$ || ref1$))) {
    return false;
  }
  return first
    ? [this.first, this.second]
    : [this.second, this.first];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '&lt;==':
case '&gt;==':
case '&lt;&lt;=':
case '&gt;&gt;=':
  return this.compileDeepEq(o);
default:
  if (COMPARER.test(this.op)) {
    if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.<span class="apidocCodeKeywordSpan
">xorChildren</span>(function(it){
      return it.isRegex();
    })) {
      return this.compileRegexEquals(o, that);
    }
    if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;
;&amp; this.first.isWhat() !== this.second.isWhat()) {
      if (typeof console != 'undefined' &amp;&amp; console !== null) {
        console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + &amp;#
x22; == " + this.second.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block" id="apidoc.module.livescript.ast.Block">module livescript.ast.Block</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.Block" id="apidoc.element.livescript.ast.Block.Block">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Block
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if ('length' in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Block</span>());
break;
case 62:
this.$ = yy.L(_$[$0], _$[$0],yy.Block($$[$0]));
break;
case 63: case 172:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.superclass" id="apidoc.element.livescript.ast.Block.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Block.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype" id="apidoc.module.livescript.ast.Block.prototype">module livescript.ast.Block.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.add" id="apidoc.element.livescript.ast.Block.prototype.add">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (it){
  var that, ref$;
  it = it.unparen();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
  default:
    this.lines.push(it);
    if (that = (ref$ = it.back, delete it.back, ref$)) {
      this.back = that;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  items = this instanceof Arr
    ? (this.items[0] == null || this.items[1] == null &amp;&amp; this.carp('must specify both key and value for object comprehension
'), this.items)
    : (kv = 'keyValue$', (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &lt; len$; ++i$) {
        i = i$;
        v = ref$[i$];
        results$.push(Chain(v).<span class="apidocCodeKeywordSpan">add</span>(Index(Literal(i))));
      }
      return results$;
    }.call(this)));
  return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);
} else if (ref) {
  return Call.make(JS(ref + '.push'), [this]);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.chomp" id="apidoc.element.livescript.ast.Block.prototype.chomp">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>chomp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chomp = function (){
  var lines, i, that;
  lines = this.lines;
  i = lines.length;
  while (that = lines[--i]) {
    if (!that.comment) {
      break;
    }
  }
  lines.length = i + 1;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (that = node.getJump(it)) {
      return that;
    }
  }
};
Block.prototype.makeReturn = function(){
  var that, ref$, key$, ref1$;
  this.<span class="apidocCodeKeywordSpan">chomp</span>();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &amp;&amp; !that.it) {
      --this.lines.length;
    }
  }
  return this;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compile" id="apidoc.element.livescript.ast.Block.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &amp;&amp; (level = o.level);
  if (level) {
    return this.compileExpressions(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
    if (snEmpty(code = (node.front = true, node).compile(o, level))) {
      continue;
    }
    codes.push(tab);
    codes.push(code);
    node.isStatement() || codes.push(node.terminator);
    codes.push('\n');
  }
  codes.pop();
  return sn.apply(null, [null].concat(slice$.call(codes)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions" id="apidoc.element.livescript.ast.Block.prototype.compileExpressions">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileExpressions
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExpressions = function (o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
      lines.splice(i--, 1);
    }
  }
  if (!lines.length) {
    lines.push(Literal('void'));
  }
  lines[0].front = this.front;
  lines[lines.length - 1]['void'] = this['void'];
  if (!lines[1]) {
    return lines[0].compile(o, level);
  }
  code = [];
  last = lines.pop();
  for (i$ = 0, len$ = lines.length; i$ &lt; len$; ++i$) {
    node = lines[i$];
    code.push((node['void'] = true, node).compile(o, LEVEL_PAREN), ', ');
  }
  code.push(last.compile(o, LEVEL_PAREN));
  if (level &lt; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return this;
};
Block.prototype.compile = function(o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &amp;&amp; (level = o.level);
  if (level) {
    return this.<span class="apidocCodeKeywordSpan">compileExpressions</span>(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileRoot" id="apidoc.element.livescript.ast.Block.prototype.compileRoot">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileRoot
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRoot = function (options){
  var o, that, ref$, bare, prefix, ref1$, code, result;
  o = (import$({
    level: LEVEL_TOP,
    scope: this.scope = Scope.root = new Scope
  }, options));
  if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
    this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
  }
  delete o.filename;
  o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? '' : TAB;
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations" id="apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileWithDeclarations
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileWithDeclarations = function (o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
  if (i = this.neck()) {
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), "\n"];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.emit(post, o.indent) : post]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.<span class="apidocCodeKeywordSpan">compileWithDeclarations</span>(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.constructor" id="apidoc.element.livescript.ast.Block.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>constructor
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Block(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  body || (body = []);
  if ('length' in body) {
    this$.lines = body;
  } else {
    this$.lines = [];
    this$.add(body);
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.getJump" id="apidoc.element.livescript.ast.Block.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var i$, ref$, len$, node, that;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (that = node.getJump(it)) {
      return that;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isArray" id="apidoc.element.livescript.ast.Block.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isCallable" id="apidoc.element.livescript.ast.Block.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isComplex" id="apidoc.element.livescript.ast.Block.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  var ref$;
  return this.lines.length &gt; 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isRegex" id="apidoc.element.livescript.ast.Block.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isString" id="apidoc.element.livescript.ast.Block.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.makeReturn" id="apidoc.element.livescript.ast.Block.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var that, ref$, key$, ref1$;
  this.chomp();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &amp;&amp; !that.it) {
      --this.lines.length;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.neck" id="apidoc.element.livescript.ast.Block.prototype.neck">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>neck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neck = function (){
  var pos, i$, ref$, len$, x;
  pos = 0;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    x = ref$[i$];
    if (!(x.comment || x instanceof Literal)) {
      break;
    }
    ++pos;
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.back = that;
    }
  }
  return this;
};
Block.prototype.prepend = function(){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.<span class="apidocCodeKeywordSpan">neck</span>(), 0].concat(slice$.call(arguments
)));
  return this;
};
Block.prototype.pipe = function(target, type){
  var args;
  args = type === '|&gt;' ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== 'Array') {
    args = [args];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.pipe" id="apidoc.element.livescript.ast.Block.prototype.pipe">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>pipe
        <span class="apidocSignatureSpan">(target, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (target, type){
  var args;
  args = type === '|&gt;' ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== 'Array') {
    args = [args];
  }
  switch (type) {
  case '|&gt;':
    this.lines.push(Call.make(target, args, {
      pipe: true
    }));
    break;
  case '&lt;|':
    this.lines.push(Call.make(this.lines.pop(), args));
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new In(first, second);
  case 'with':
    return new Import(Unary('^^', first), second, false);
  case '&lt;&lt;&lt;':
  case '&lt;&lt;&lt;&lt;':
    return Import(first, second, op === '&lt;&lt;&lt;&lt;');
  case '&lt;|':
    return Block(first).<span class="apidocCodeKeywordSpan">pipe</span>(second, op);
  case '|&gt;':
    return Block(second).pipe(first, '&lt;|');
  case '.':
  case '.~':
    return Chain(first).add(Index(second, op));
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.prepend" id="apidoc.element.livescript.ast.Block.prototype.prepend">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>prepend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(slice$.call(arguments)));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    args[args.length] = that[i$];
    res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
  }
  imports = res$;
  body.prepend.apply(body, imports);
}
if (fun.cname &amp;&amp; !this.sup) {
  body.<span class="apidocCodeKeywordSpan">prepend</span>(Literal(name + ".displayName = '" + name + "'&amp;#
x22;));
}
clas = Parens(Call.make(fun, args), true);
if (decl &amp;&amp; title.isComplex()) {
  clas = Assign(vname, clas);
}
if (title) {
  clas = Assign(title, clas);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.toJSON" id="apidoc.element.livescript.ast.Block.prototype.toJSON">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.unwrap" id="apidoc.element.livescript.ast.Block.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (){
  if (this.lines.length === 1) {
    return this.lines[0];
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &lt; 2 &amp;&amp; !this.head.isComplex() &amp;&amp; !(name != null &amp;&amp; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.add" id="apidoc.module.livescript.ast.Block.prototype.add">module livescript.ast.Block.prototype.add</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.add.add" id="apidoc.element.livescript.ast.Block.prototype.add.add">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (it){
  var that, ref$;
  it = it.unparen();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
  default:
    this.lines.push(it);
    if (that = (ref$ = it.back, delete it.back, ref$)) {
      this.back = that;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  items = this instanceof Arr
    ? (this.items[0] == null || this.items[1] == null &amp;&amp; this.carp('must specify both key and value for object comprehension
'), this.items)
    : (kv = 'keyValue$', (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &lt; len$; ++i$) {
        i = i$;
        v = ref$[i$];
        results$.push(Chain(v).<span class="apidocCodeKeywordSpan">add</span>(Index(Literal(i))));
      }
      return results$;
    }.call(this)));
  return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);
} else if (ref) {
  return Call.make(JS(ref + '.push'), [this]);
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.chomp" id="apidoc.module.livescript.ast.Block.prototype.chomp">module livescript.ast.Block.prototype.chomp</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.chomp.chomp" id="apidoc.element.livescript.ast.Block.prototype.chomp.chomp">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>chomp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chomp = function (){
  var lines, i, that;
  lines = this.lines;
  i = lines.length;
  while (that = lines[--i]) {
    if (!that.comment) {
      break;
    }
  }
  lines.length = i + 1;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (that = node.getJump(it)) {
      return that;
    }
  }
};
Block.prototype.makeReturn = function(){
  var that, ref$, key$, ref1$;
  this.<span class="apidocCodeKeywordSpan">chomp</span>();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &amp;&amp; !that.it) {
      --this.lines.length;
    }
  }
  return this;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.compile" id="apidoc.module.livescript.ast.Block.prototype.compile">module livescript.ast.Block.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compile.compile" id="apidoc.element.livescript.ast.Block.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &amp;&amp; (level = o.level);
  if (level) {
    return this.compileExpressions(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
    if (snEmpty(code = (node.front = true, node).compile(o, level))) {
      continue;
    }
    codes.push(tab);
    codes.push(code);
    node.isStatement() || codes.push(node.terminator);
    codes.push('\n');
  }
  codes.pop();
  return sn.apply(null, [null].concat(slice$.call(codes)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.compileExpressions" id="apidoc.module.livescript.ast.Block.prototype.compileExpressions">module livescript.ast.Block.prototype.compileExpressions</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileExpressions.compileExpressions" id="apidoc.element.livescript.ast.Block.prototype.compileExpressions.compileExpressions">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileExpressions
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExpressions = function (o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
      lines.splice(i--, 1);
    }
  }
  if (!lines.length) {
    lines.push(Literal('void'));
  }
  lines[0].front = this.front;
  lines[lines.length - 1]['void'] = this['void'];
  if (!lines[1]) {
    return lines[0].compile(o, level);
  }
  code = [];
  last = lines.pop();
  for (i$ = 0, len$ = lines.length; i$ &lt; len$; ++i$) {
    node = lines[i$];
    code.push((node['void'] = true, node).compile(o, LEVEL_PAREN), ', ');
  }
  code.push(last.compile(o, LEVEL_PAREN));
  if (level &lt; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return this;
};
Block.prototype.compile = function(o, level){
  var tab, codes, i$, ref$, len$, node, code;
  level == null &amp;&amp; (level = o.level);
  if (level) {
    return this.<span class="apidocCodeKeywordSpan">compileExpressions</span>(o, level);
  }
  o.block = this;
  tab = o.indent;
  codes = [];
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    node = node.unfoldSoak(o) || node;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.compileRoot" id="apidoc.module.livescript.ast.Block.prototype.compileRoot">module livescript.ast.Block.prototype.compileRoot</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileRoot.compileRoot" id="apidoc.element.livescript.ast.Block.prototype.compileRoot.compileRoot">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileRoot
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileRoot = function (options){
  var o, that, ref$, bare, prefix, ref1$, code, result;
  o = (import$({
    level: LEVEL_TOP,
    scope: this.scope = Scope.root = new Scope
  }, options));
  if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
    this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
  }
  delete o.filename;
  o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? '' : TAB;
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.compileWithDeclarations" id="apidoc.module.livescript.ast.Block.prototype.compileWithDeclarations">module livescript.ast.Block.prototype.compileWithDeclarations</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations.compileWithDeclarations" id="apidoc.element.livescript.ast.Block.prototype.compileWithDeclarations.compileWithDeclarations">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>compileWithDeclarations
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileWithDeclarations = function (o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
  if (i = this.neck()) {
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), "\n"];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.emit(post, o.indent) : post]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.makeReturn();
    }
  }
  code = [this.<span class="apidocCodeKeywordSpan">compileWithDeclarations</span>(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
  var pre, i, rest, post, that;
  o.level = LEVEL_TOP;
  pre = [];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.getJump" id="apidoc.module.livescript.ast.Block.prototype.getJump">module livescript.ast.Block.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Block.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var i$, ref$, len$, node, that;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (that = node.getJump(it)) {
      return that;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.isArray" id="apidoc.module.livescript.ast.Block.prototype.isArray">module livescript.ast.Block.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Block.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.isCallable" id="apidoc.module.livescript.ast.Block.prototype.isCallable">module livescript.ast.Block.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Block.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.isComplex" id="apidoc.module.livescript.ast.Block.prototype.isComplex">module livescript.ast.Block.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Block.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  var ref$;
  return this.lines.length &gt; 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.isRegex" id="apidoc.module.livescript.ast.Block.prototype.isRegex">module livescript.ast.Block.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Block.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.isString" id="apidoc.module.livescript.ast.Block.prototype.isString">module livescript.ast.Block.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.isString.isString" id="apidoc.element.livescript.ast.Block.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.makeReturn" id="apidoc.module.livescript.ast.Block.prototype.makeReturn">module livescript.ast.Block.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Block.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var that, ref$, key$, ref1$;
  this.chomp();
  if (that = (ref1$ = ref$ = this.lines)[key$ = ref1$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref
$, arguments) : void 8) {
    if (that instanceof Return &amp;&amp; !that.it) {
      --this.lines.length;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.neck" id="apidoc.module.livescript.ast.Block.prototype.neck">module livescript.ast.Block.prototype.neck</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.neck.neck" id="apidoc.element.livescript.ast.Block.prototype.neck.neck">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>neck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neck = function (){
  var pos, i$, ref$, len$, x;
  pos = 0;
  for (i$ = 0, len$ = (ref$ = this.lines).length; i$ &lt; len$; ++i$) {
    x = ref$[i$];
    if (!(x.comment || x instanceof Literal)) {
      break;
    }
    ++pos;
  }
  return pos;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.back = that;
    }
  }
  return this;
};
Block.prototype.prepend = function(){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.<span class="apidocCodeKeywordSpan">neck</span>(), 0].concat(slice$.call(arguments
)));
  return this;
};
Block.prototype.pipe = function(target, type){
  var args;
  args = type === '|&gt;' ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== 'Array') {
    args = [args];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.pipe" id="apidoc.module.livescript.ast.Block.prototype.pipe">module livescript.ast.Block.prototype.pipe</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.pipe.pipe" id="apidoc.element.livescript.ast.Block.prototype.pipe.pipe">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>pipe
        <span class="apidocSignatureSpan">(target, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipe = function (target, type){
  var args;
  args = type === '|&gt;' ? this.lines.pop() : target;
  if (toString$.call(args).slice(8, -1) !== 'Array') {
    args = [args];
  }
  switch (type) {
  case '|&gt;':
    this.lines.push(Call.make(target, args, {
      pipe: true
    }));
    break;
  case '&lt;|':
    this.lines.push(Call.make(this.lines.pop(), args));
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new In(first, second);
  case 'with':
    return new Import(Unary('^^', first), second, false);
  case '&lt;&lt;&lt;':
  case '&lt;&lt;&lt;&lt;':
    return Import(first, second, op === '&lt;&lt;&lt;&lt;');
  case '&lt;|':
    return Block(first).<span class="apidocCodeKeywordSpan">pipe</span>(second, op);
  case '|&gt;':
    return Block(second).pipe(first, '&lt;|');
  case '.':
  case '.~':
    return Chain(first).add(Index(second, op));
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.prepend" id="apidoc.module.livescript.ast.Block.prototype.prepend">module livescript.ast.Block.prototype.prepend</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.prepend.prepend" id="apidoc.element.livescript.ast.Block.prototype.prepend.prepend">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>prepend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (){
  var ref$;
  (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(slice$.call(arguments)));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    args[args.length] = that[i$];
    res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
  }
  imports = res$;
  body.prepend.apply(body, imports);
}
if (fun.cname &amp;&amp; !this.sup) {
  body.<span class="apidocCodeKeywordSpan">prepend</span>(Literal(name + ".displayName = '" + name + "'&amp;#
x22;));
}
clas = Parens(Call.make(fun, args), true);
if (decl &amp;&amp; title.isComplex()) {
  clas = Assign(vname, clas);
}
if (title) {
  clas = Assign(title, clas);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.toJSON" id="apidoc.module.livescript.ast.Block.prototype.toJSON">module livescript.ast.Block.prototype.toJSON</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.toJSON.toJSON" id="apidoc.element.livescript.ast.Block.prototype.toJSON.toJSON">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Block.prototype.unwrap" id="apidoc.module.livescript.ast.Block.prototype.unwrap">module livescript.ast.Block.prototype.unwrap</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Block.prototype.unwrap.unwrap" id="apidoc.element.livescript.ast.Block.prototype.unwrap.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Block.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (){
  if (this.lines.length === 1) {
    return this.lines[0];
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &lt; 2 &amp;&amp; !this.head.isComplex() &amp;&amp; !(name != null &amp;&amp; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Box" id="apidoc.module.livescript.ast.Box">module livescript.ast.Box</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Box.Box" id="apidoc.element.livescript.ast.Box.Box">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Box
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Box = function (v){
  if (typeof v === "object") {
    return v;
  } else {
    return new v.constructor(v);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 75:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
break;
case 76:
this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
break;
case 77:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan
">Box</span>($$[$0-1]))));
break;
case 78:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
break;
case 79:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Call" id="apidoc.module.livescript.ast.Call">module livescript.ast.Call</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Call.Call" id="apidoc.element.livescript.ast.Call.Call">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Call
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &amp;&amp; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = '.call';
      args[0] = Literal('this');
      args[1] = Splat(Literal('arguments'));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &lt; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === '_') {
        args[i] = Chain(Literal('void'));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.<span class="apidocCodeKeywordSpan">Call</span>($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call['let']($$[$0-3], $$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.back" id="apidoc.element.livescript.ast.Call.back">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>back
        <span class="apidocSignatureSpan">(params, node, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">back = function (params, node, bound, curried, hushed, generator){
  var fun, ref$, args, index, i$, len$, a;
  fun = Fun(params, void 8, bound, curried, hushed, generator);
  if (node instanceof Label) {
    fun.name = node.label;
    fun.labeled = true;
    node = node.it;
  }
  if (!fun.hushed &amp;&amp; (fun.hushed = node.op === '!')) {
    node = node.it;
  }
  if ((ref$ = node.getCall()) != null) {
    ref$.partialized = null;
  }
  args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
  index = 0;
  for (i$ = 0, len$ = args.length; i$ &lt; len$; ++i$) {
    a = args[i$];
    if (a.placeholder) {
      break;
    }
    ++index;
  }
  return node.back = (args[index] = fun).body, node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 63: case 172:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
break;
case 66:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], 'cascade'));
break;
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.<span class="apidocCodeKeywordSpan">back</span>($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.
test($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS("Error('unimplemented')"))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.block" id="apidoc.element.livescript.ast.Call.block">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>block
        <span class="apidocSignatureSpan">(fun, args, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function (fun, args, method){
  var ref$, ref1$;
  return ref$ = Parens(Chain(fun, [(ref1$ = Call(args), ref1$.method = method, ref1$)]), true), ref$.calling = true, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      res$.push(a.left);
    } else {
      res$.push(Var(a.varName() || a.carp('invalid "let" argument')));
    }
  }
  params = res$;
  gotThis || args.unshift(Literal('this'));
  return this.<span class="apidocCodeKeywordSpan">block</span>(Fun(params, body, null, null, null, generator), args, '.call
');
};
return Call;
}(Node));
List = (function(superclass){
var prototype = extend$((import$(List, superclass).displayName = 'List', List), superclass).prototype, constructor = List
;
List.prototype.children = ['items'];
List.prototype.show = function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.let" id="apidoc.element.livescript.ast.Call.let">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>let
        <span class="apidocSignatureSpan">(args, body, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">let = function (args, body, generator){
  var params, res$, i$, len$, i, a, that, gotThis;
  generator == null &amp;&amp; (generator = false);
  res$ = [];
  for (i$ = 0, len$ = args.length; i$ &lt; len$; ++i$) {
    i = i$;
    a = args[i$];
    if (that = a.op === '=' &amp;&amp; !a.logic &amp;&amp; a.right) {
      args[i] = that;
      if (i === 0 &amp;&amp; (gotThis = a.left.value === 'this')) {
        continue;
      }
      res$.push(a.left);
    } else {
      res$.push(Var(a.varName() || a.carp('invalid "let" argument')));
    }
  }
  params = res$;
  gotThis || args.unshift(Literal('this'));
  return this.block(Fun(params, body, null, null, null, generator), args, '.call');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.make" id="apidoc.element.livescript.ast.Call.make">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>make
        <span class="apidocSignatureSpan">(callee, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">make = function (callee, args, opts){
  var call;
  call = Call(args);
  if (opts) {
    import$(call, opts);
  }
  return Chain(callee).add(call);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          v = ref$[i$];
          results$.push(Chain(v).add(Index(Literal(i))));
        }
        return results$;
      }.call(this)));
    return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);
  } else if (ref) {
    return Call.<span class="apidocCodeKeywordSpan">make</span>(JS(ref + '.push'), [this]);
  } else {
    return Return(this);
  }
},
show: String,
toString: function(idt){
  var tree, that;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.superclass" id="apidoc.element.livescript.ast.Call.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Call.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Call.prototype" id="apidoc.module.livescript.ast.Call.prototype">module livescript.ast.Call.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.compile" id="apidoc.element.livescript.ast.Call.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var code, i$, ref$, len$, i, a;
  code = [sn(this, this.method || '', '(') + (this.pipe ? "\n" + o.indent : '')];
  for (i$ = 0, len$ = (ref$ = this.args).length; i$ &lt; len$; ++i$) {
    i = i$;
    a = ref$[i$];
    code.push(i ? ', ' : '', a.compile(o, LEVEL_LIST));
  }
  code.push(sn(this, ')'));
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.constructor" id="apidoc.element.livescript.ast.Call.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>constructor
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Call(args){
  var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
  args || (args = []);
  if (args.length === 1 &amp;&amp; (splat = args[0]) instanceof Splat) {
    if (splat.filler) {
      this$.method = '.call';
      args[0] = Literal('this');
      args[1] = Splat(Literal('arguments'));
    } else if (splat.it instanceof Arr) {
      args = splat.it.items;
    }
  } else {
    for (i$ = 0, len$ = args.length; i$ &lt; len$; ++i$) {
      i = i$;
      a = args[i$];
      if (a.value === '_') {
        args[i] = Chain(Literal('void'));
        args[i].placeholder = true;
        ((ref$ = this$.partialized) != null
          ? ref$
          : this$.partialized = []).push(Chain(Literal(i)));
      }
    }
  }
  this$.args = args;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.show" id="apidoc.element.livescript.ast.Call.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this['new']] + [this.method] + [this.soak ? '?' : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Call.prototype.compile" id="apidoc.module.livescript.ast.Call.prototype.compile">module livescript.ast.Call.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.compile.compile" id="apidoc.element.livescript.ast.Call.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var code, i$, ref$, len$, i, a;
  code = [sn(this, this.method || '', '(') + (this.pipe ? "\n" + o.indent : '')];
  for (i$ = 0, len$ = (ref$ = this.args).length; i$ &lt; len$; ++i$) {
    i = i$;
    a = ref$[i$];
    code.push(i ? ', ' : '', a.compile(o, LEVEL_LIST));
  }
  code.push(sn(this, ')'));
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Call.prototype.show" id="apidoc.module.livescript.ast.Call.prototype.show">module livescript.ast.Call.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Call.prototype.show.show" id="apidoc.element.livescript.ast.Call.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Call.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this['new']] + [this.method] + [this.soak ? '?' : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade" id="apidoc.module.livescript.ast.Cascade">module livescript.ast.Cascade</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.Cascade" id="apidoc.element.livescript.ast.Cascade.Cascade">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Cascade
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 40:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], yy.Slice({
type: $$[$0-1],
target: $$[$0-4]
      }))));
break;
case 41:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], yy.<span class="apidocCodeKeywordSpan">Cascade</span>($$[$0-1], $$[$
0], 'with'))));
break;
case 42:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({
kind: $$[$0-2],
source: $$[$0-1],
body: $$[$0],
ref: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.superclass" id="apidoc.element.livescript.ast.Cascade.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype" id="apidoc.module.livescript.ast.Cascade.prototype">module livescript.ast.Cascade.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode" id="apidoc.element.livescript.ast.Cascade.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var level, input, output, prog1, ref, ref$, code, out;
  level = o.level;
  input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
  if (prog1 &amp;&amp; ('ret' in this || level &amp;&amp; !this['void'])) {
    output.add((ref$ = Literal('..'), ref$.cascadee = true, ref$));
  }
  if ('ret' in this) {
    output = output.makeReturn(this.ret);
  }
  if (ref) {
    prog1 || (output = Assign(Var(ref), output));
  } else {
    ref = o.scope.temporary('x');
  }
  if (input instanceof Cascade) {
    input.ref = ref;
  } else {
    input &amp;&amp; (input = Assign(Var(ref), input));
  }
  o.level &amp;&amp; (o.level = LEVEL_PAREN);
  code = [input.compile(o)];
  out = Block(output).compile((o.ref = new String(ref), o));
  if (prog1 === 'cascade' &amp;&amp; !o.ref.erred) {
    this.carp("unreferred cascadee");
  }
  if (!level) {
    return sn.apply(null, [null].concat(slice$.call(code), [input.terminator, "\n", out]));
  }
  code.push(", ", out);
  if (level &gt; LEVEL_PAREN) {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.constructor" id="apidoc.element.livescript.ast.Cascade.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>constructor
        <span class="apidocSignatureSpan">(input, output, prog1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cascade(input, output, prog1){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.input = input;
  this$.output = output;
  this$.prog1 = prog1;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.getJump" id="apidoc.element.livescript.ast.Cascade.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  return this.output.getJump(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isArray" id="apidoc.element.livescript.ast.Cascade.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable" id="apidoc.element.livescript.ast.Cascade.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex" id="apidoc.element.livescript.ast.Cascade.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isString" id="apidoc.element.livescript.ast.Cascade.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn" id="apidoc.element.livescript.ast.Cascade.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(ret)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (ret){
  this.ret = ret;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.show" id="apidoc.element.livescript.ast.Cascade.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.prog1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.compileNode" id="apidoc.module.livescript.ast.Cascade.prototype.compileNode">module livescript.ast.Cascade.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Cascade.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var level, input, output, prog1, ref, ref$, code, out;
  level = o.level;
  input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
  if (prog1 &amp;&amp; ('ret' in this || level &amp;&amp; !this['void'])) {
    output.add((ref$ = Literal('..'), ref$.cascadee = true, ref$));
  }
  if ('ret' in this) {
    output = output.makeReturn(this.ret);
  }
  if (ref) {
    prog1 || (output = Assign(Var(ref), output));
  } else {
    ref = o.scope.temporary('x');
  }
  if (input instanceof Cascade) {
    input.ref = ref;
  } else {
    input &amp;&amp; (input = Assign(Var(ref), input));
  }
  o.level &amp;&amp; (o.level = LEVEL_PAREN);
  code = [input.compile(o)];
  out = Block(output).compile((o.ref = new String(ref), o));
  if (prog1 === 'cascade' &amp;&amp; !o.ref.erred) {
    this.carp("unreferred cascadee");
  }
  if (!level) {
    return sn.apply(null, [null].concat(slice$.call(code), [input.terminator, "\n", out]));
  }
  code.push(", ", out);
  if (level &gt; LEVEL_PAREN) {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.getJump" id="apidoc.module.livescript.ast.Cascade.prototype.getJump">module livescript.ast.Cascade.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Cascade.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  return this.output.getJump(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.isArray" id="apidoc.module.livescript.ast.Cascade.prototype.isArray">module livescript.ast.Cascade.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Cascade.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.isCallable" id="apidoc.module.livescript.ast.Cascade.prototype.isCallable">module livescript.ast.Cascade.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Cascade.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.isRegex" id="apidoc.module.livescript.ast.Cascade.prototype.isRegex">module livescript.ast.Cascade.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Cascade.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.isString" id="apidoc.module.livescript.ast.Cascade.prototype.isString">module livescript.ast.Cascade.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.isString.isString" id="apidoc.element.livescript.ast.Cascade.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.makeReturn" id="apidoc.module.livescript.ast.Cascade.prototype.makeReturn">module livescript.ast.Cascade.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Cascade.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(ret)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (ret){
  this.ret = ret;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Cascade.prototype.show" id="apidoc.module.livescript.ast.Cascade.prototype.show">module livescript.ast.Cascade.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Cascade.prototype.show.show" id="apidoc.element.livescript.ast.Cascade.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Cascade.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.prog1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case" id="apidoc.module.livescript.ast.Case">module livescript.ast.Case</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.Case" id="apidoc.element.livescript.ast.Case.Case">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Case
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 201:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-4], $$[$0-5] === 'until', $$[$0-2]).addGuard($$[$0]));
break;
case 203:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].concat($$[$0]));
break;
case 206:
this.$ = yy.L(_$[$0-2], _$[$0],[yy.L(_$[$0-2],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">Case</span>($$[$0-1], $$[$0]))]);
break;
case 207:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat(yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))));
break;
case 212:
return this.$
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.superclass" id="apidoc.element.livescript.ast.Case.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Case.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case.prototype" id="apidoc.module.livescript.ast.Case.prototype">module livescript.ast.Case.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.compileCase" id="apidoc.element.livescript.ast.Case.prototype.compileCase">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>compileCase
        <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileCase = function (o, tab, nobr, bool, type, target){
  var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
  tests = [];
  for (i$ = 0, len$ = (ref$ = this.tests).length; i$ &lt; len$; ++i$) {
    test = ref$[i$];
    test = test.expandSlice(o).unwrap();
    if (test instanceof Arr &amp;&amp; type !== 'match') {
      for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ &lt; len1$; ++j$) {
        t = ref1$[j$];
        tests.push(t);
      }
    } else {
      tests.push(test);
    }
  }
  tests.length || tests.push(Literal('void'));
  if (type === 'match') {
    for (i$ = 0, len$ = tests.length; i$ &lt; len$; ++i$) {
      i = i$;
      test = tests[i$];
      tar = Chain(target).add(Index(Literal(i), '.', true));
      tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
    }
  }
  if (bool) {
    binary = type === 'match' ? '&amp;&amp;' : '||';
    t = tests[0];
    i = 0;
    while (that = tests[++i]) {
      t = Binary(binary, t, that);
    }
    tests = [(this.t = t, this.aSource = 't', this.aTargets = ['body'], this).anaphorize().invert()];
  }
  code = [];
  for (i$ = 0, len$ = tests.length; i$ &lt; len$; ++i$) {
    t = tests[i$];
    code.push(tab, sn(t, "case ", t.compile(o, LEVEL_PAREN), ":\n"));
  }
  lines = this.body.lines;
  last = lines[lines.length - 1];
  if (ft = (last != null ? last.value : void 8) === 'fallthrough') {
    lines[lines.length - 1] = JS('// fallthrough');
  }
  o.indent = tab += TAB;
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(bodyCode, '\n');
  }
  if (!(nobr || ft || last instanceof Jump)) {
    code.push(tab + 'break;\n');
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  : !!this.topic &amp;&amp; this.anaphorize().compile(o, LEVEL_PAREN);
code = [sn(this, "switch (", snSafe(topic), ") {\n")];
stop = this['default'] || this.cases.length - 1;
o['break'] = true;
for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
  i = i$;
  c = ref$[i$];
  code.push(c.<span class="apidocCodeKeywordSpan">compileCase</span>(o, tab, i === stop, this.type === 'match' || !topic
, this.type, target));
}
if (this['default']) {
  o.indent = tab + TAB;
  if (that = this['default'].compile(o, LEVEL_TOP)) {
    code.push(tab + "default:\n", that, "\n");
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.constructor" id="apidoc.element.livescript.ast.Case.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>constructor
        <span class="apidocSignatureSpan">(tests, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Case(tests, body){
  this.tests = tests;
  this.body = body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.isCallable" id="apidoc.element.livescript.ast.Case.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  return this.body.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.makeReturn" id="apidoc.element.livescript.ast.Case.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$, ref1$;
  if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== 'fallthrough') {
    (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case.prototype.compileCase" id="apidoc.module.livescript.ast.Case.prototype.compileCase">module livescript.ast.Case.prototype.compileCase</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.compileCase.compileCase" id="apidoc.element.livescript.ast.Case.prototype.compileCase.compileCase">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>compileCase
        <span class="apidocSignatureSpan">(o, tab, nobr, bool, type, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileCase = function (o, tab, nobr, bool, type, target){
  var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
  tests = [];
  for (i$ = 0, len$ = (ref$ = this.tests).length; i$ &lt; len$; ++i$) {
    test = ref$[i$];
    test = test.expandSlice(o).unwrap();
    if (test instanceof Arr &amp;&amp; type !== 'match') {
      for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ &lt; len1$; ++j$) {
        t = ref1$[j$];
        tests.push(t);
      }
    } else {
      tests.push(test);
    }
  }
  tests.length || tests.push(Literal('void'));
  if (type === 'match') {
    for (i$ = 0, len$ = tests.length; i$ &lt; len$; ++i$) {
      i = i$;
      test = tests[i$];
      tar = Chain(target).add(Index(Literal(i), '.', true));
      tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
    }
  }
  if (bool) {
    binary = type === 'match' ? '&amp;&amp;' : '||';
    t = tests[0];
    i = 0;
    while (that = tests[++i]) {
      t = Binary(binary, t, that);
    }
    tests = [(this.t = t, this.aSource = 't', this.aTargets = ['body'], this).anaphorize().invert()];
  }
  code = [];
  for (i$ = 0, len$ = tests.length; i$ &lt; len$; ++i$) {
    t = tests[i$];
    code.push(tab, sn(t, "case ", t.compile(o, LEVEL_PAREN), ":\n"));
  }
  lines = this.body.lines;
  last = lines[lines.length - 1];
  if (ft = (last != null ? last.value : void 8) === 'fallthrough') {
    lines[lines.length - 1] = JS('// fallthrough');
  }
  o.indent = tab += TAB;
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push(bodyCode, '\n');
  }
  if (!(nobr || ft || last instanceof Jump)) {
    code.push(tab + 'break;\n');
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  : !!this.topic &amp;&amp; this.anaphorize().compile(o, LEVEL_PAREN);
code = [sn(this, "switch (", snSafe(topic), ") {\n")];
stop = this['default'] || this.cases.length - 1;
o['break'] = true;
for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
  i = i$;
  c = ref$[i$];
  code.push(c.<span class="apidocCodeKeywordSpan">compileCase</span>(o, tab, i === stop, this.type === 'match' || !topic
, this.type, target));
}
if (this['default']) {
  o.indent = tab + TAB;
  if (that = this['default'].compile(o, LEVEL_TOP)) {
    code.push(tab + "default:\n", that, "\n");
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case.prototype.isCallable" id="apidoc.module.livescript.ast.Case.prototype.isCallable">module livescript.ast.Case.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Case.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  return this.body.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Case.prototype.makeReturn" id="apidoc.module.livescript.ast.Case.prototype.makeReturn">module livescript.ast.Case.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Case.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Case.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Case.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$, ref1$;
  if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== 'fallthrough') {
    (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain" id="apidoc.module.livescript.ast.Chain">module livescript.ast.Chain</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.Chain" id="apidoc.element.livescript.ast.Chain.Chain">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Chain
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &amp;&amp; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Chain</span>(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.superclass" id="apidoc.element.livescript.ast.Chain.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype" id="apidoc.module.livescript.ast.Chain.prototype">module livescript.ast.Chain.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.add" id="apidoc.element.livescript.ast.Chain.prototype.add">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (it){
  var last, ref$, index, ref1$, bi, logics, call, f;
  if (this.tails.length) {
    last = (ref$ = this.tails)[ref$.length - 1];
    if (last instanceof Call &amp;&amp; ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 &amp;&amp; it.args.length === 1) {
      index = last.partialized[0].head.value;
      delete last.partialized;
      last.args[index] = it.args[0];
      return this;
    }
  }
  if (this.head instanceof Existence) {
    ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
    it.soak = true;
  }
  this.tails.push(it);
  bi = this.head instanceof Parens &amp;&amp; this.head.it instanceof Binary &amp;&amp; !this.head.it.partial
    ? this.head.it
    : this.head instanceof Binary &amp;&amp; !this.head.partial ? this.head : void 8;
  if (this.head instanceof Super) {
    if (!this.head.called &amp;&amp; it instanceof Call &amp;&amp; !it.method) {
      it.method = '.call';
      it.args.unshift(Literal('this'));
      this.head.called = true;
    } else if (!this.tails[1] &amp;&amp; ((ref1$ = it.key) != null ? ref1$.name : void 8) === 'prototype') {
      this.head.sproto = true;
    }
  } else if (it instanceof Call &amp;&amp; this.tails.length === 1 &amp;&amp; bi &amp;&amp; in$(bi.op, logics = ['&amp;&amp;', '||', 'xor'])) {
    call = it;
    f = function(x, key){
      var y;
      y = x[key];
      if (y instanceof Binary &amp;&amp; in$(y.op, logics)) {
        f(y, 'first');
        return f(y, 'second');
      } else {
        return x[key] = Chain(y).autoCompare(call.args);
      }
    };
    f(bi, 'first');
    f(bi, 'second');
    return bi;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  items = this instanceof Arr
    ? (this.items[0] == null || this.items[1] == null &amp;&amp; this.carp('must specify both key and value for object comprehension
'), this.items)
    : (kv = 'keyValue$', (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &lt; len$; ++i$) {
        i = i$;
        v = ref$[i$];
        results$.push(Chain(v).<span class="apidocCodeKeywordSpan">add</span>(Index(Literal(i))));
      }
      return results$;
    }.call(this)));
  return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);
} else if (ref) {
  return Call.make(JS(ref + '.push'), [this]);
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.assigns" id="apidoc.element.livescript.ast.Chain.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare" id="apidoc.element.livescript.ast.Chain.prototype.autoCompare">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>autoCompare
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoCompare = function (target){
  var test;
  test = this.head;
  switch (false) {
  case !(test instanceof Literal):
    return Binary('===', test, target[0]);
  case !(test instanceof Unary &amp;&amp; test.it instanceof Literal):
    return Binary('===', test, target[0]);
  case !(test instanceof Arr || test instanceof Obj):
    return Binary('====', test, target[0]);
  case !(test instanceof Var &amp;&amp; test.value === '_'):
    return Literal('true');
  default:
    return this.add(Call(target)) || [];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  f = function(x, key){
    var y;
    y = x[key];
    if (y instanceof Binary &amp;&amp; in$(y.op, logics)) {
      f(y, 'first');
      return f(y, 'second');
    } else {
      return x[key] = Chain(y).<span class="apidocCodeKeywordSpan">autoCompare</span>(call.args);
    }
  };
  f(bi, 'first');
  f(bi, 'second');
  return bi;
}
return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference" id="apidoc.element.livescript.ast.Chain.prototype.cacheReference">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>cacheReference
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cacheReference = function (o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.unwrap().cache(o, true);
  }
  if (this.tails.length &lt; 2 &amp;&amp; !this.head.isComplex() &amp;&amp; !(name != null &amp;&amp; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
    base = Chain(Assign(Var(ref), base));
    bref = (ref$ = Var(ref), ref$.temp = true, ref$);
  }
  if (!name) {
    return [base, bref];
  }
  if (name.isComplex()) {
    ref = o.scope.temporary('key');
    name = Index(Assign(Var(ref), name.key));
    nref = Index((ref$ = Var(ref), ref$.temp = true, ref$));
  }
  return [base.add(name), Chain(bref || base.head, [nref || name])];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = ref$[i$];
if (ref1$ = node.soak, delete node.soak, ref1$) {
  bust = Chain(this.head, this.tails.splice(0, i));
  if (node.assign &amp;&amp; !bust.isAssignable()) {
    node.carp('invalid accessign');
  }
  if (i &amp;&amp; (node.assign || node instanceof Call)) {
    ref1$ = bust.<span class="apidocCodeKeywordSpan">cacheReference</span>(o), test = ref1$[0], bust = ref1$[1];
    if (bust instanceof Chain) {
      (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
      bust = bust.head;
    }
    this.head = bust;
  } else {
    ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.compileNode" id="apidoc.element.livescript.ast.Chain.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
  if (this.flip) {
    util('flip');
    util('curry');
  }
  head = this.head, tails = this.tails;
  head.front = this.front;
  head.newed = this.newed;
  if (!tails.length) {
    return head.compile(o);
  }
  if (that = this.unfoldAssign(o)) {
    return that.compile(o);
  }
  for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
    t = tails[i$];
    if (t.partialized) {
      hasPartial = true;
      break;
    }
  }
  if (hasPartial) {
    util('slice');
    pre = [];
    rest = [];
    for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
      t = tails[i$];
      broken = broken || t.partialized != null;
      if (broken) {
        rest.push(t);
      } else {
        pre.push(t);
      }
    }
    if (rest != null) {
      partial = rest[0], post = slice$.call(rest, 1);
    }
    this.tails = pre;
    context = pre.length
      ? Chain(head, slice$.call(pre, 0, -1))
      : Literal('this');
    return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial
.partialized)])])), post).compile(o);
  }
  if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
    this.carp('invalid callee');
  }
  this.expandSlice(o);
  this.expandVivify();
  this.expandBind(o);
  this.expandSplat(o);
  this.expandStar(o);
  if (this.splattedNewArgs) {
    idt = o.indent + TAB;
    func = Chain(this.head, tails.slice(0, -1));
    return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor
, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
  }
  if (!this.tails.length) {
    return this.head.compile(o);
  }
  base = [this.head.compile(o, LEVEL_CALL)];
  news = [];
  rest = [];
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    t = ref$[i$];
    if (t['new']) {
      news.push('new ');
    }
    rest.push(t.compile(o));
  }
  if ('.' === rest.join("").charAt(0) &amp;&amp; SIMPLENUM.test(base[0].toString())) {
    base.push(' ');
  }
  return sn.apply(null, [null].concat(slice$.call(news), slice$.call(base), slice$.call(rest)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.constructor" id="apidoc.element.livescript.ast.Chain.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>constructor
        <span class="apidocSignatureSpan">(head, tails)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Chain(head, tails){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (!tails &amp;&amp; head instanceof Chain) {
    return head;
  }
  this$.head = head;
  this$.tails = tails || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandBind" id="apidoc.element.livescript.ast.Chain.prototype.expandBind">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandBind
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandBind = function (o){
  var tails, i, that, obj, key, call;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.symbol !== '.~') {
      continue;
    }
    that.symbol = '';
    obj = Chain(this.head, tails.splice(0, i)).unwrap();
    key = tails.shift().key;
    call = Call.make(Util('bind'), [obj, (key.reserved = true, key)]);
    this.head = this.newed ? Parens(call, true) : call;
    i = -1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.expandSlice(o);
this.expandVivify();
this.<span class="apidocCodeKeywordSpan">expandBind</span>(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "
;var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice" id="apidoc.element.livescript.ast.Chain.prototype.expandSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSlice
        <span class="apidocSignatureSpan">(o, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandSlice = function (o, assign){
  var tails, i, tail, ref$, x;
  tails = this.tails;
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &amp;&amp; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp('calling a slice');
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? Chain(head, slice$.call(pre, 0, -1))
    : Literal('this');
  return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.<span class="apidocCodeKeywordSpan">expandSlice</span>(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat" id="apidoc.element.livescript.ast.Chain.prototype.expandSplat">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSplat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandSplat = function (o){
  var tails, i, call, args, ctx, ref$;
  tails = this.tails;
  i = -1;
  while (call = tails[++i]) {
    if (!(args = call.args)) {
      continue;
    }
    ctx = call.method === '.call' &amp;&amp; (args = args.concat()).shift();
    if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
      continue;
    }
    if (call['new']) {
      this.splattedNewArgs = args;
    } else {
      if (!ctx &amp;&amp; tails[i - 1] instanceof Index) {
        ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
        i = 0;
      }
      call.method = '.apply';
      call.args = [ctx || Literal('null'), JS(args)];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.expandSlice(o);
this.expandVivify();
this.expandBind(o);
this.<span class="apidocCodeKeywordSpan">expandSplat</span>(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "
;var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
}
if (!this.tails.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandStar" id="apidoc.element.livescript.ast.Chain.prototype.expandStar">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandStar
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandStar = function (o){
  var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.args || that.stars || that.key instanceof Key) {
      continue;
    }
    stars = that.stars = [];
    that.eachChild(seek);
    if (!stars.length) {
      continue;
    }
    ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
    value = Chain(ref, [Index(Key('length'))]).compile(o);
    for (i$ = 0, len$ = stars.length; i$ &lt; len$; ++i$) {
      star = stars[i$];
      star.value = value;
      star.isAssignable = YES;
    }
    this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
    if (temps) {
      o.scope.free(temps[0]);
    }
    i = -1;
  }
  function seek(it){
    if (it.value === '*') {
      stars.push(it);
    } else if (!(it instanceof Index)) {
      it.eachChild(seek);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.expandSlice(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.<span class="apidocCodeKeywordSpan">expandStar</span>(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "
;var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
}
if (!this.tails.length) {
  return this.head.compile(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify" id="apidoc.element.livescript.ast.Chain.prototype.expandVivify">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandVivify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandVivify = function (){
  var tails, i, that, ref$, ref1$;
  tails = this.tails;
  i = 0;
  while (i &lt; tails.length) {
    if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
      this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), '=', '||');
      i = 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    : Literal('this');
  return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.expandSlice(o);
this.<span class="apidocCodeKeywordSpan">expandVivify</span>();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "
;var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.flipIt" id="apidoc.element.livescript.ast.Chain.prototype.flipIt">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>flipIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flipIt = function (){
  this.flip = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 26:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 28:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var('flip$'))).add(yy.L(_$[$0-3],_$[$0-3],yy
.Call([$$[$0-3]])))).<span class="apidocCodeKeywordSpan">flipIt</span>().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 29:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.For({
from: $$[$0-3],
op: $$[$0-2],
to: $$[$0-1],
inComprehension: true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getCall" id="apidoc.element.livescript.ast.Chain.prototype.getCall">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCall = function (){
  var tail, ref$;
  return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call &amp;&amp; tail;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fun.name = node.label;
  fun.labeled = true;
  node = node.it;
}
if (!fun.hushed &amp;&amp; (fun.hushed = node.op === '!')) {
  node = node.it;
}
if ((ref$ = node.<span class="apidocCodeKeywordSpan">getCall</span>()) != null) {
  ref$.partialized = null;
}
args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
index = 0;
for (i$ = 0, len$ = args.length; i$ &lt; len$; ++i$) {
  a = args[i$];
  if (a.placeholder) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getJump" id="apidoc.element.livescript.ast.Chain.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isArray" id="apidoc.element.livescript.ast.Chain.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.isArray();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable" id="apidoc.element.livescript.ast.Chain.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAssignable = function (){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.isAssignable();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isCallable" id="apidoc.element.livescript.ast.Chain.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return !((ref$ = that.key) != null &amp;&amp; ref$.items);
  } else {
    return this.head.isCallable();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isComplex" id="apidoc.element.livescript.ast.Chain.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.tails.length || this.head.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isRegex" id="apidoc.element.livescript.ast.Chain.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess" id="apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isSimpleAccess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSimpleAccess = function (){
  return this.tails.length === 1 &amp;&amp; !this.head.isComplex() &amp;&amp; !this.tails[0].isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    dotSplit = name.toString().split('.');
    if (protoSplit.length &gt; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &gt; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');
    }
  }
  code = !o.level &amp;&amp; right instanceof While &amp;&amp; !right['else'] &amp;&amp; (lvar || left instanceof
 Chain &amp;&amp; left.<span class="apidocCodeKeywordSpan">isSimpleAccess</span>())
    ? (empty = right.objComp ? '{}' : '[]', [res = o.scope.temporary('res'), " = " + empty
 + ";\n" + this.tab, right.makeReturn(res).compile(o), "\n" + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &gt; LEVEL_LIST) {
    code = ["("].concat(slice$.call(code), [")"]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isStatement" id="apidoc.element.livescript.ast.Chain.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isStatement
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStatement = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isString" id="apidoc.element.livescript.ast.Chain.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn" id="apidoc.element.livescript.ast.Chain.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  if (this.tails.length) {
    return superclass.prototype.makeReturn.apply(this, arguments);
  } else {
    return (ref$ = this.head).makeReturn.apply(ref$, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign" id="apidoc.element.livescript.ast.Chain.prototype.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldAssign = function (o){
  var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
  if (that = this.head.unfoldAssign(o)) {
    (ref$ = that.right.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    i = i$;
    index = ref$[i$];
    if (op = index.assign) {
      index.assign = '';
      left = Chain(this.head, this.tails.splice(0, i)).expandSlice(o).unwrap();
      if (left instanceof Arr) {
        lefts = left.items;
        rites = (this.head = Arr()).items;
        for (j$ = 0, len1$ = lefts.length; j$ &lt; len1$; ++j$) {
          i = j$;
          node = lefts[j$];
          ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
        }
      } else {
        ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
      }
      if (op === '=') {
        op = ':=';
      }
      return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Chain.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var that, ref$, i$, len$, i, node, ref1$, bust, test;
  if (that = this.head.unfoldSoak(o)) {
    (ref$ = that.then.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    i = i$;
    node = ref$[i$];
    if (ref1$ = node.soak, delete node.soak, ref1$) {
      bust = Chain(this.head, this.tails.splice(0, i));
      if (node.assign &amp;&amp; !bust.isAssignable()) {
        node.carp('invalid accessign');
      }
      if (i &amp;&amp; (node.assign || node instanceof Call)) {
        ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
        if (bust instanceof Chain) {
          (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
          bust = bust.head;
        }
        this.head = bust;
      } else {
        ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
      }
      test = node instanceof Call
        ? JS("typeof " + test.compile(o, LEVEL_OP) + " == 'function'")
        : Existence(test);
      return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$['void'] = this['void'], ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unwrap" id="apidoc.element.livescript.ast.Chain.prototype.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (){
  if (this.tails.length) {
    return this;
  } else {
    return this.head;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &lt; 2 &amp;&amp; !this.head.isComplex() &amp;&amp; !(name != null &amp;&amp; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.varName" id="apidoc.element.livescript.ast.Chain.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.add" id="apidoc.module.livescript.ast.Chain.prototype.add">module livescript.ast.Chain.prototype.add</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.add.add" id="apidoc.element.livescript.ast.Chain.prototype.add.add">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>add
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (it){
  var last, ref$, index, ref1$, bi, logics, call, f;
  if (this.tails.length) {
    last = (ref$ = this.tails)[ref$.length - 1];
    if (last instanceof Call &amp;&amp; ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 &amp;&amp; it.args.length === 1) {
      index = last.partialized[0].head.value;
      delete last.partialized;
      last.args[index] = it.args[0];
      return this;
    }
  }
  if (this.head instanceof Existence) {
    ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
    it.soak = true;
  }
  this.tails.push(it);
  bi = this.head instanceof Parens &amp;&amp; this.head.it instanceof Binary &amp;&amp; !this.head.it.partial
    ? this.head.it
    : this.head instanceof Binary &amp;&amp; !this.head.partial ? this.head : void 8;
  if (this.head instanceof Super) {
    if (!this.head.called &amp;&amp; it instanceof Call &amp;&amp; !it.method) {
      it.method = '.call';
      it.args.unshift(Literal('this'));
      this.head.called = true;
    } else if (!this.tails[1] &amp;&amp; ((ref1$ = it.key) != null ? ref1$.name : void 8) === 'prototype') {
      this.head.sproto = true;
    }
  } else if (it instanceof Call &amp;&amp; this.tails.length === 1 &amp;&amp; bi &amp;&amp; in$(bi.op, logics = ['&amp;&amp;', '||', 'xor'])) {
    call = it;
    f = function(x, key){
      var y;
      y = x[key];
      if (y instanceof Binary &amp;&amp; in$(y.op, logics)) {
        f(y, 'first');
        return f(y, 'second');
      } else {
        return x[key] = Chain(y).autoCompare(call.args);
      }
    };
    f(bi, 'first');
    f(bi, 'second');
    return bi;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  items = this instanceof Arr
    ? (this.items[0] == null || this.items[1] == null &amp;&amp; this.carp('must specify both key and value for object comprehension
'), this.items)
    : (kv = 'keyValue$', (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ &lt; len$; ++i$) {
        i = i$;
        v = ref$[i$];
        results$.push(Chain(v).<span class="apidocCodeKeywordSpan">add</span>(Index(Literal(i))));
      }
      return results$;
    }.call(this)));
  return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);
} else if (ref) {
  return Call.make(JS(ref + '.push'), [this]);
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.assigns" id="apidoc.module.livescript.ast.Chain.prototype.assigns">module livescript.ast.Chain.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Chain.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.autoCompare" id="apidoc.module.livescript.ast.Chain.prototype.autoCompare">module livescript.ast.Chain.prototype.autoCompare</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.autoCompare.autoCompare" id="apidoc.element.livescript.ast.Chain.prototype.autoCompare.autoCompare">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>autoCompare
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoCompare = function (target){
  var test;
  test = this.head;
  switch (false) {
  case !(test instanceof Literal):
    return Binary('===', test, target[0]);
  case !(test instanceof Unary &amp;&amp; test.it instanceof Literal):
    return Binary('===', test, target[0]);
  case !(test instanceof Arr || test instanceof Obj):
    return Binary('====', test, target[0]);
  case !(test instanceof Var &amp;&amp; test.value === '_'):
    return Literal('true');
  default:
    return this.add(Call(target)) || [];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  f = function(x, key){
    var y;
    y = x[key];
    if (y instanceof Binary &amp;&amp; in$(y.op, logics)) {
      f(y, 'first');
      return f(y, 'second');
    } else {
      return x[key] = Chain(y).<span class="apidocCodeKeywordSpan">autoCompare</span>(call.args);
    }
  };
  f(bi, 'first');
  f(bi, 'second');
  return bi;
}
return this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.cacheReference" id="apidoc.module.livescript.ast.Chain.prototype.cacheReference">module livescript.ast.Chain.prototype.cacheReference</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.cacheReference.cacheReference" id="apidoc.element.livescript.ast.Chain.prototype.cacheReference.cacheReference">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>cacheReference
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cacheReference = function (o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.unwrap().cache(o, true);
  }
  if (this.tails.length &lt; 2 &amp;&amp; !this.head.isComplex() &amp;&amp; !(name != null &amp;&amp; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
    base = Chain(Assign(Var(ref), base));
    bref = (ref$ = Var(ref), ref$.temp = true, ref$);
  }
  if (!name) {
    return [base, bref];
  }
  if (name.isComplex()) {
    ref = o.scope.temporary('key');
    name = Index(Assign(Var(ref), name.key));
    nref = Index((ref$ = Var(ref), ref$.temp = true, ref$));
  }
  return [base.add(name), Chain(bref || base.head, [nref || name])];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
node = ref$[i$];
if (ref1$ = node.soak, delete node.soak, ref1$) {
  bust = Chain(this.head, this.tails.splice(0, i));
  if (node.assign &amp;&amp; !bust.isAssignable()) {
    node.carp('invalid accessign');
  }
  if (i &amp;&amp; (node.assign || node instanceof Call)) {
    ref1$ = bust.<span class="apidocCodeKeywordSpan">cacheReference</span>(o), test = ref1$[0], bust = ref1$[1];
    if (bust instanceof Chain) {
      (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
      bust = bust.head;
    }
    this.head = bust;
  } else {
    ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.compileNode" id="apidoc.module.livescript.ast.Chain.prototype.compileNode">module livescript.ast.Chain.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Chain.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
  if (this.flip) {
    util('flip');
    util('curry');
  }
  head = this.head, tails = this.tails;
  head.front = this.front;
  head.newed = this.newed;
  if (!tails.length) {
    return head.compile(o);
  }
  if (that = this.unfoldAssign(o)) {
    return that.compile(o);
  }
  for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
    t = tails[i$];
    if (t.partialized) {
      hasPartial = true;
      break;
    }
  }
  if (hasPartial) {
    util('slice');
    pre = [];
    rest = [];
    for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
      t = tails[i$];
      broken = broken || t.partialized != null;
      if (broken) {
        rest.push(t);
      } else {
        pre.push(t);
      }
    }
    if (rest != null) {
      partial = rest[0], post = slice$.call(rest, 1);
    }
    this.tails = pre;
    context = pre.length
      ? Chain(head, slice$.call(pre, 0, -1))
      : Literal('this');
    return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial
.partialized)])])), post).compile(o);
  }
  if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
    this.carp('invalid callee');
  }
  this.expandSlice(o);
  this.expandVivify();
  this.expandBind(o);
  this.expandSplat(o);
  this.expandStar(o);
  if (this.splattedNewArgs) {
    idt = o.indent + TAB;
    func = Chain(this.head, tails.slice(0, -1));
    return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor
, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
  }
  if (!this.tails.length) {
    return this.head.compile(o);
  }
  base = [this.head.compile(o, LEVEL_CALL)];
  news = [];
  rest = [];
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    t = ref$[i$];
    if (t['new']) {
      news.push('new ');
    }
    rest.push(t.compile(o));
  }
  if ('.' === rest.join("").charAt(0) &amp;&amp; SIMPLENUM.test(base[0].toString())) {
    base.push(' ');
  }
  return sn.apply(null, [null].concat(slice$.call(news), slice$.call(base), slice$.call(rest)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.expandBind" id="apidoc.module.livescript.ast.Chain.prototype.expandBind">module livescript.ast.Chain.prototype.expandBind</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandBind.expandBind" id="apidoc.element.livescript.ast.Chain.prototype.expandBind.expandBind">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandBind
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandBind = function (o){
  var tails, i, that, obj, key, call;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.symbol !== '.~') {
      continue;
    }
    that.symbol = '';
    obj = Chain(this.head, tails.splice(0, i)).unwrap();
    key = tails.shift().key;
    call = Call.make(Util('bind'), [obj, (key.reserved = true, key)]);
    this.head = this.newed ? Parens(call, true) : call;
    i = -1;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.expandSlice(o);
this.expandVivify();
this.<span class="apidocCodeKeywordSpan">expandBind</span>(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "
;var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.expandSlice" id="apidoc.module.livescript.ast.Chain.prototype.expandSlice">module livescript.ast.Chain.prototype.expandSlice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSlice.expandSlice" id="apidoc.element.livescript.ast.Chain.prototype.expandSlice.expandSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSlice
        <span class="apidocSignatureSpan">(o, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandSlice = function (o, assign){
  var tails, i, tail, ref$, x;
  tails = this.tails;
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &amp;&amp; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp('calling a slice');
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? Chain(head, slice$.call(pre, 0, -1))
    : Literal('this');
  return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.<span class="apidocCodeKeywordSpan">expandSlice</span>(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.expandSplat" id="apidoc.module.livescript.ast.Chain.prototype.expandSplat">module livescript.ast.Chain.prototype.expandSplat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandSplat.expandSplat" id="apidoc.element.livescript.ast.Chain.prototype.expandSplat.expandSplat">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandSplat
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandSplat = function (o){
  var tails, i, call, args, ctx, ref$;
  tails = this.tails;
  i = -1;
  while (call = tails[++i]) {
    if (!(args = call.args)) {
      continue;
    }
    ctx = call.method === '.call' &amp;&amp; (args = args.concat()).shift();
    if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
      continue;
    }
    if (call['new']) {
      this.splattedNewArgs = args;
    } else {
      if (!ctx &amp;&amp; tails[i - 1] instanceof Index) {
        ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
        i = 0;
      }
      call.method = '.apply';
      call.args = [ctx || Literal('null'), JS(args)];
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.expandSlice(o);
this.expandVivify();
this.expandBind(o);
this.<span class="apidocCodeKeywordSpan">expandSplat</span>(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "
;var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
}
if (!this.tails.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.expandStar" id="apidoc.module.livescript.ast.Chain.prototype.expandStar">module livescript.ast.Chain.prototype.expandStar</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandStar.expandStar" id="apidoc.element.livescript.ast.Chain.prototype.expandStar.expandStar">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandStar
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandStar = function (o){
  var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
  tails = this.tails;
  i = -1;
  while (that = tails[++i]) {
    if (that.args || that.stars || that.key instanceof Key) {
      continue;
    }
    stars = that.stars = [];
    that.eachChild(seek);
    if (!stars.length) {
      continue;
    }
    ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
    value = Chain(ref, [Index(Key('length'))]).compile(o);
    for (i$ = 0, len$ = stars.length; i$ &lt; len$; ++i$) {
      star = stars[i$];
      star.value = value;
      star.isAssignable = YES;
    }
    this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
    if (temps) {
      o.scope.free(temps[0]);
    }
    i = -1;
  }
  function seek(it){
    if (it.value === '*') {
      stars.push(it);
    } else if (!(it instanceof Index)) {
      it.eachChild(seek);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.expandSlice(o);
this.expandVivify();
this.expandBind(o);
this.expandSplat(o);
this.<span class="apidocCodeKeywordSpan">expandStar</span>(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "
;var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
}
if (!this.tails.length) {
  return this.head.compile(o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.expandVivify" id="apidoc.module.livescript.ast.Chain.prototype.expandVivify">module livescript.ast.Chain.prototype.expandVivify</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.expandVivify.expandVivify" id="apidoc.element.livescript.ast.Chain.prototype.expandVivify.expandVivify">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>expandVivify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandVivify = function (){
  var tails, i, that, ref$, ref1$;
  tails = this.tails;
  i = 0;
  while (i &lt; tails.length) {
    if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
      this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), '=', '||');
      i = 0;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    : Literal('this');
  return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial
.args), Arr(partial.partialized)])])), post).compile(o);
}
if (tails[0] instanceof Call &amp;&amp; !head.isCallable()) {
  this.carp('invalid callee');
}
this.expandSlice(o);
this.<span class="apidocCodeKeywordSpan">expandVivify</span>();
this.expandBind(o);
this.expandSplat(o);
this.expandStar(o);
if (this.splattedNewArgs) {
  idt = o.indent + TAB;
  func = Chain(this.head, tails.slice(0, -1));
  return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "
;var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.flipIt" id="apidoc.module.livescript.ast.Chain.prototype.flipIt">module livescript.ast.Chain.prototype.flipIt</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.flipIt.flipIt" id="apidoc.element.livescript.ast.Chain.prototype.flipIt.flipIt">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>flipIt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flipIt = function (){
  this.flip = true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 26:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 28:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var('flip$'))).add(yy.L(_$[$0-3],_$[$0-3],yy
.Call([$$[$0-3]])))).<span class="apidocCodeKeywordSpan">flipIt</span>().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 29:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.For({
from: $$[$0-3],
op: $$[$0-2],
to: $$[$0-1],
inComprehension: true
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.getCall" id="apidoc.module.livescript.ast.Chain.prototype.getCall">module livescript.ast.Chain.prototype.getCall</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getCall.getCall" id="apidoc.element.livescript.ast.Chain.prototype.getCall.getCall">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getCall
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCall = function (){
  var tail, ref$;
  return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call &amp;&amp; tail;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  fun.name = node.label;
  fun.labeled = true;
  node = node.it;
}
if (!fun.hushed &amp;&amp; (fun.hushed = node.op === '!')) {
  node = node.it;
}
if ((ref$ = node.<span class="apidocCodeKeywordSpan">getCall</span>()) != null) {
  ref$.partialized = null;
}
args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
index = 0;
for (i$ = 0, len$ = args.length; i$ &lt; len$; ++i$) {
  a = args[i$];
  if (a.placeholder) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.getJump" id="apidoc.module.livescript.ast.Chain.prototype.getJump">module livescript.ast.Chain.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Chain.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isArray" id="apidoc.module.livescript.ast.Chain.prototype.isArray">module livescript.ast.Chain.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Chain.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.isArray();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isAssignable" id="apidoc.module.livescript.ast.Chain.prototype.isAssignable">module livescript.ast.Chain.prototype.isAssignable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isAssignable.isAssignable" id="apidoc.element.livescript.ast.Chain.prototype.isAssignable.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAssignable = function (){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.isAssignable();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isCallable" id="apidoc.module.livescript.ast.Chain.prototype.isCallable">module livescript.ast.Chain.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Chain.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return !((ref$ = that.key) != null &amp;&amp; ref$.items);
  } else {
    return this.head.isCallable();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isComplex" id="apidoc.module.livescript.ast.Chain.prototype.isComplex">module livescript.ast.Chain.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Chain.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.tails.length || this.head.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isRegex" id="apidoc.module.livescript.ast.Chain.prototype.isRegex">module livescript.ast.Chain.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Chain.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isSimpleAccess" id="apidoc.module.livescript.ast.Chain.prototype.isSimpleAccess">module livescript.ast.Chain.prototype.isSimpleAccess</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess.isSimpleAccess" id="apidoc.element.livescript.ast.Chain.prototype.isSimpleAccess.isSimpleAccess">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isSimpleAccess
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSimpleAccess = function (){
  return this.tails.length === 1 &amp;&amp; !this.head.isComplex() &amp;&amp; !this.tails[0].isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    dotSplit = name.toString().split('.');
    if (protoSplit.length &gt; 1) {
      right.inClass = protoSplit[0];
    } else if (dotSplit.length &gt; 1) {
      right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');
    }
  }
  code = !o.level &amp;&amp; right instanceof While &amp;&amp; !right['else'] &amp;&amp; (lvar || left instanceof
 Chain &amp;&amp; left.<span class="apidocCodeKeywordSpan">isSimpleAccess</span>())
    ? (empty = right.objComp ? '{}' : '[]', [res = o.scope.temporary('res'), " = " + empty
 + ";\n" + this.tab, right.makeReturn(res).compile(o), "\n" + this.tab, name, sign, o.scope.free(res)])
    : [name, sign, right.compile(o, LEVEL_LIST)];
  if (o.level &gt; LEVEL_LIST) {
    code = ["("].concat(slice$.call(code), [")"]);
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isStatement" id="apidoc.module.livescript.ast.Chain.prototype.isStatement">module livescript.ast.Chain.prototype.isStatement</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isStatement.isStatement" id="apidoc.element.livescript.ast.Chain.prototype.isStatement.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isStatement
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStatement = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.isString" id="apidoc.module.livescript.ast.Chain.prototype.isString">module livescript.ast.Chain.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.isString.isString" id="apidoc.element.livescript.ast.Chain.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.makeReturn" id="apidoc.module.livescript.ast.Chain.prototype.makeReturn">module livescript.ast.Chain.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Chain.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  if (this.tails.length) {
    return superclass.prototype.makeReturn.apply(this, arguments);
  } else {
    return (ref$ = this.head).makeReturn.apply(ref$, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.unfoldAssign" id="apidoc.module.livescript.ast.Chain.prototype.unfoldAssign">module livescript.ast.Chain.prototype.unfoldAssign</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldAssign.unfoldAssign" id="apidoc.element.livescript.ast.Chain.prototype.unfoldAssign.unfoldAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldAssign
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldAssign = function (o){
  var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
  if (that = this.head.unfoldAssign(o)) {
    (ref$ = that.right.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    i = i$;
    index = ref$[i$];
    if (op = index.assign) {
      index.assign = '';
      left = Chain(this.head, this.tails.splice(0, i)).expandSlice(o).unwrap();
      if (left instanceof Arr) {
        lefts = left.items;
        rites = (this.head = Arr()).items;
        for (j$ = 0, len1$ = lefts.length; j$ &lt; len1$; ++j$) {
          i = j$;
          node = lefts[j$];
          ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
        }
      } else {
        ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
      }
      if (op === '=') {
        op = ':=';
      }
      return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
head = this.head, tails = this.tails;
head.front = this.front;
head.newed = this.newed;
if (!tails.length) {
  return head.compile(o);
}
if (that = this.<span class="apidocCodeKeywordSpan">unfoldAssign</span>(o)) {
  return that.compile(o);
}
for (i$ = 0, len$ = tails.length; i$ &lt; len$; ++i$) {
  t = tails[i$];
  if (t.partialized) {
    hasPartial = true;
    break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.unfoldSoak" id="apidoc.module.livescript.ast.Chain.prototype.unfoldSoak">module livescript.ast.Chain.prototype.unfoldSoak</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unfoldSoak.unfoldSoak" id="apidoc.element.livescript.ast.Chain.prototype.unfoldSoak.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var that, ref$, i$, len$, i, node, ref1$, bust, test;
  if (that = this.head.unfoldSoak(o)) {
    (ref$ = that.then.tails).push.apply(ref$, this.tails);
    return that;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    i = i$;
    node = ref$[i$];
    if (ref1$ = node.soak, delete node.soak, ref1$) {
      bust = Chain(this.head, this.tails.splice(0, i));
      if (node.assign &amp;&amp; !bust.isAssignable()) {
        node.carp('invalid accessign');
      }
      if (i &amp;&amp; (node.assign || node instanceof Call)) {
        ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
        if (bust instanceof Chain) {
          (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
          bust = bust.head;
        }
        this.head = bust;
      } else {
        ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
      }
      test = node instanceof Call
        ? JS("typeof " + test.compile(o, LEVEL_OP) + " == 'function'")
        : Existence(test);
      return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$['void'] = this['void'], ref1$;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.unwrap" id="apidoc.module.livescript.ast.Chain.prototype.unwrap">module livescript.ast.Chain.prototype.unwrap</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.unwrap.unwrap" id="apidoc.element.livescript.ast.Chain.prototype.unwrap.unwrap">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>unwrap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (){
  if (this.tails.length) {
    return this;
  } else {
    return this.head;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
};
Chain.prototype.cacheReference = function(o){
  var name, ref$, base, ref, bref, nref;
  name = (ref$ = this.tails)[ref$.length - 1];
  if (!this.isAssignable()) {
    return this.<span class="apidocCodeKeywordSpan">unwrap</span>().cache(o, true);
  }
  if (this.tails.length &lt; 2 &amp;&amp; !this.head.isComplex() &amp;&amp; !(name != null &amp;&amp; name.isComplex())) {
    return [this, this];
  }
  base = Chain(this.head, this.tails.slice(0, -1));
  if (base.isComplex()) {
    ref = o.scope.temporary();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Chain.prototype.varName" id="apidoc.module.livescript.ast.Chain.prototype.varName">module livescript.ast.Chain.prototype.varName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Chain.prototype.varName.varName" id="apidoc.element.livescript.ast.Chain.prototype.varName.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Chain.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var ref$, ref1$;
  return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Class" id="apidoc.module.livescript.ast.Class">module livescript.ast.Class</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Class.Class" id="apidoc.element.livescript.ast.Class.Class">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Class
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 139:
this.$ = yy.L(_$[$0-6], _$[$0],new yy.Try($$[$0-5], $$[$0-3], yy.L(_$[$0-4],_$[$0-3], $$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 140:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 141:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Class</span>({
        title: $$[$0-3].unwrap(),
        sup: $$[$0-2],
        mixins: $$[$0-1],
        body: $$[$0]
      }));
break;
case 142:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.superclass" id="apidoc.element.livescript.ast.Class.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Class.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Class.prototype" id="apidoc.module.livescript.ast.Class.prototype">module livescript.ast.Class.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.compile" id="apidoc.element.livescript.ast.Class.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj
, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
  fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
  CopyL(this, fun);
  boundFuncs = [];
  curriedBoundFuncs = [];
  decl = title != null ? title.varName() : void 8;
  name = decl || this.name;
  if (ID.test(name || '')) {
    fun.cname = name;
  } else {
    name = 'constructor';
  }
  proto = Var('prototype');
  vname = fun.proto = Var(fun.bound = name);
  ctorName = 'constructor$$';
  importProtoObj = function(node, i){
    var j, prop, key, i$, ref$, len$, v;
    j = 0;
    for (; j &lt; node.items.length; j++) {
      prop = node.items[j];
      key = prop.key;
      if ((key instanceof Key &amp;&amp; key.name === ctorName) || (key instanceof Literal &amp;&amp; key.value === "'" + ctorName + "'")) {
        if (ctor) {
          node.carp('redundant constructor');
        }
        ctor = prop.val;
        node.items.splice(j--, 1);
        ctorPlace = i;
      }
      if (!(prop.val instanceof Fun || prop.accessor)) {
        continue;
      }
      if (key.isComplex()) {
        key = Var(o.scope.temporary('key'));
        prop.key = Assign(key, prop.key);
      }
      if (prop.val.bound) {
        if (prop.val.curried) {
          curriedBoundFuncs.push(prop.key);
        } else {
          boundFuncs.push(prop.key);
        }
        prop.val.bound = false;
        prop.val.classBound = true;
      }
      for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ &lt; len$; ++i$) {
        v = ref$[i$];
        v.meth = key;
      }
    }
    if (node.items.length) {
      return ref$ = Import(Chain(vname).add(Index(Key('prototype'))), node), ref$.proto = true, ref$;
    } else {
      return Literal('void');
    }
  };
  for (i$ = 0, len$ = lines.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = lines[i$];
    if (node instanceof Obj) {
      lines[i] = importProtoObj(node, i);
    } else if (node instanceof Fun &amp;&amp; !node.statement) {
      ctor &amp;&amp; node.carp('redundant constructor');
      ctor = node;
    } else if (node instanceof Assign &amp;&amp; node.left instanceof Chain &amp;&amp; node.left.head.value === 'this' &amp;&amp; node.right instanceof
Fun) {
      node.right.stat = node.left.tails[0].key;
    } else {
      node.traverseChildren(fn$);
    }
  }
  ctor || (ctor = lines[lines.length] = this.sup
    ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal('arguments'))]))))
    : Fun());
  if (!(ctor instanceof Fun)) {
    lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
    lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat('arguments', true)]))))));
  }
  ctor.name = name;
  ctor.ctor = true;
  ctor.statement = true;
  for (i$ = 0, len$ = boundFuncs.length; i$ &lt; len$; ++i$) {
    f = boundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal
("'" + f.name + "'"), Var('prototype')]))));
  }
  for (i$ = 0, len$ = curriedBoundFuncs.length; i$ &lt; len$; ++i$) {
    f = curriedBoundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(Key("_" + f.name))), Chain(Var(util('curry'))).add(Call([Chain
(Var('prototype')).add(Index(f)), Var('true')]))), Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call
([Literal('this'), Literal("'_" + f.name + "'")]))));
  }
  lines.push(vname);
  args = [];
  if (that = this.sup) {
    args.push(that);
    imports = Chain(Import(Literal('this'), Var('superclass')));
    fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key('displayName'))), Literal("'" + name + "'")), Literal
(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var('superclass'));
  }
  if (that = this.mixins) {
    res$ = [];
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      args[args.length] = that[i$];
      res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
    }
    import ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.constructor" id="apidoc.element.livescript.ast.Class.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>constructor
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(arg$){
  var body;
  this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
  this.fun = Fun([], body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.isCallable" id="apidoc.element.livescript.ast.Class.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.ripName" id="apidoc.element.livescript.ast.Class.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripName = function (it){
  this.name = it.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), ": ", key);
}
ID.test(key) || (key = Function("return " + key)());
if (!(dic[key + "."] ^= 1)) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Class.prototype.compile" id="apidoc.module.livescript.ast.Class.prototype.compile">module livescript.ast.Class.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.compile.compile" id="apidoc.element.livescript.ast.Class.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj
, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
  fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
  CopyL(this, fun);
  boundFuncs = [];
  curriedBoundFuncs = [];
  decl = title != null ? title.varName() : void 8;
  name = decl || this.name;
  if (ID.test(name || '')) {
    fun.cname = name;
  } else {
    name = 'constructor';
  }
  proto = Var('prototype');
  vname = fun.proto = Var(fun.bound = name);
  ctorName = 'constructor$$';
  importProtoObj = function(node, i){
    var j, prop, key, i$, ref$, len$, v;
    j = 0;
    for (; j &lt; node.items.length; j++) {
      prop = node.items[j];
      key = prop.key;
      if ((key instanceof Key &amp;&amp; key.name === ctorName) || (key instanceof Literal &amp;&amp; key.value === "'" + ctorName + "'")) {
        if (ctor) {
          node.carp('redundant constructor');
        }
        ctor = prop.val;
        node.items.splice(j--, 1);
        ctorPlace = i;
      }
      if (!(prop.val instanceof Fun || prop.accessor)) {
        continue;
      }
      if (key.isComplex()) {
        key = Var(o.scope.temporary('key'));
        prop.key = Assign(key, prop.key);
      }
      if (prop.val.bound) {
        if (prop.val.curried) {
          curriedBoundFuncs.push(prop.key);
        } else {
          boundFuncs.push(prop.key);
        }
        prop.val.bound = false;
        prop.val.classBound = true;
      }
      for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ &lt; len$; ++i$) {
        v = ref$[i$];
        v.meth = key;
      }
    }
    if (node.items.length) {
      return ref$ = Import(Chain(vname).add(Index(Key('prototype'))), node), ref$.proto = true, ref$;
    } else {
      return Literal('void');
    }
  };
  for (i$ = 0, len$ = lines.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = lines[i$];
    if (node instanceof Obj) {
      lines[i] = importProtoObj(node, i);
    } else if (node instanceof Fun &amp;&amp; !node.statement) {
      ctor &amp;&amp; node.carp('redundant constructor');
      ctor = node;
    } else if (node instanceof Assign &amp;&amp; node.left instanceof Chain &amp;&amp; node.left.head.value === 'this' &amp;&amp; node.right instanceof
Fun) {
      node.right.stat = node.left.tails[0].key;
    } else {
      node.traverseChildren(fn$);
    }
  }
  ctor || (ctor = lines[lines.length] = this.sup
    ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal('arguments'))]))))
    : Fun());
  if (!(ctor instanceof Fun)) {
    lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
    lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat('arguments', true)]))))));
  }
  ctor.name = name;
  ctor.ctor = true;
  ctor.statement = true;
  for (i$ = 0, len$ = boundFuncs.length; i$ &lt; len$; ++i$) {
    f = boundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal
("'" + f.name + "'"), Var('prototype')]))));
  }
  for (i$ = 0, len$ = curriedBoundFuncs.length; i$ &lt; len$; ++i$) {
    f = curriedBoundFuncs[i$];
    ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(Key("_" + f.name))), Chain(Var(util('curry'))).add(Call([Chain
(Var('prototype')).add(Index(f)), Var('true')]))), Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call
([Literal('this'), Literal("'_" + f.name + "'")]))));
  }
  lines.push(vname);
  args = [];
  if (that = this.sup) {
    args.push(that);
    imports = Chain(Import(Literal('this'), Var('superclass')));
    fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key('displayName'))), Literal("'" + name + "'")), Literal
(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var('superclass'));
  }
  if (that = this.mixins) {
    res$ = [];
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      args[args.length] = that[i$];
      res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
    }
    import ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Class.prototype.ripName" id="apidoc.module.livescript.ast.Class.prototype.ripName">module livescript.ast.Class.prototype.ripName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Class.prototype.ripName.ripName" id="apidoc.element.livescript.ast.Class.prototype.ripName.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Class.prototype.</span>ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripName = function (it){
  this.name = it.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), ": ", key);
}
ID.test(key) || (key = Function("return " + key)());
if (!(dic[key + "."] ^= 1)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.CopyL" id="apidoc.module.livescript.ast.CopyL">module livescript.ast.CopyL</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.CopyL.CopyL" id="apidoc.element.livescript.ast.CopyL.CopyL">
        function <span class="apidocSignatureSpan">livescript.ast.</span>CopyL
        <span class="apidocSignatureSpan">(a, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CopyL = function (a, node){
  if (node &amp;&amp; typeof node === "object") {
    node.first_line = a.first_line;
    node.first_column = a.first_column;
    node.last_line = a.last_line;
    node.last_column = a.last_column;
    node.line = a.line;
    node.column = a.column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Decl" id="apidoc.module.livescript.ast.Decl">module livescript.ast.Decl</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Decl.Decl" id="apidoc.element.livescript.ast.Decl.Decl">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Decl
        <span class="apidocSignatureSpan">(type, nodes, lno)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Decl = function (type, nodes, lno){
  if (!nodes[0]) {
    throw SyntaxError("empty " + type + " on line " + lno);
  }
  return DECLS[type](nodes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.<span class="apidocCodeKeywordSpan">Decl</span>($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== 'arguments' &amp;&amp; $$[$0] !== &amp;#
x27;eval')), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence" id="apidoc.module.livescript.ast.Existence">module livescript.ast.Existence</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.Existence" id="apidoc.element.livescript.ast.Existence.Existence">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Existence
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Existence</span>($$[$0-1].unwrap
()))));
break;
case 10:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call['let']($$[$0-3], $$[$0]))));
break;
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.superclass" id="apidoc.element.livescript.ast.Existence.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence.prototype" id="apidoc.module.livescript.ast.Existence.prototype">module livescript.ast.Existence.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.compileNode" id="apidoc.element.livescript.ast.Existence.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var node, ref$, code, op, eq;
  node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
  code = [node.compile(o, LEVEL_OP + PREC['=='])];
  if (node instanceof Var &amp;&amp; !o.scope.check(code.join(""), true)) {
    ref$ = this.negated
      ? ['||', '=']
      : ['&amp;&amp;', '!'], op = ref$[0], eq = ref$[1];
    code = ["typeof "].concat(slice$.call(code), [" " + eq + "= 'undefined' " + op + " "], slice$.call(code), [" " + eq + "== null
"]);
  } else {
    code.push(" " + (op = this.negated ? '==' : '!=') + " null");
  }
  if (o.level &lt; LEVEL_OP + PREC[op]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn(this, "(", code, ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.constructor" id="apidoc.element.livescript.ast.Existence.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it, negated)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Existence(it, negated){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.negated = negated;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.invert" id="apidoc.element.livescript.ast.Existence.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  this.negated = !this.negated;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary('!', this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this['else'] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.show" id="apidoc.element.livescript.ast.Existence.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.negated &amp;&amp; '!';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence.prototype.compileNode" id="apidoc.module.livescript.ast.Existence.prototype.compileNode">module livescript.ast.Existence.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Existence.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var node, ref$, code, op, eq;
  node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
  code = [node.compile(o, LEVEL_OP + PREC['=='])];
  if (node instanceof Var &amp;&amp; !o.scope.check(code.join(""), true)) {
    ref$ = this.negated
      ? ['||', '=']
      : ['&amp;&amp;', '!'], op = ref$[0], eq = ref$[1];
    code = ["typeof "].concat(slice$.call(code), [" " + eq + "= 'undefined' " + op + " "], slice$.call(code), [" " + eq + "== null
"]);
  } else {
    code.push(" " + (op = this.negated ? '==' : '!=') + " null");
  }
  if (o.level &lt; LEVEL_OP + PREC[op]) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn(this, "(", code, ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence.prototype.invert" id="apidoc.module.livescript.ast.Existence.prototype.invert">module livescript.ast.Existence.prototype.invert</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.invert.invert" id="apidoc.element.livescript.ast.Existence.prototype.invert.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  this.negated = !this.negated;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary('!', this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this['else'] = $else;
  return this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Existence.prototype.show" id="apidoc.module.livescript.ast.Existence.prototype.show">module livescript.ast.Existence.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Existence.prototype.show.show" id="apidoc.element.livescript.ast.Existence.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Existence.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.negated &amp;&amp; '!';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For" id="apidoc.module.livescript.ast.For">module livescript.ast.For</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.For" id="apidoc.element.livescript.ast.For.For">
        function <span class="apidocSignatureSpan">livescript.ast.</span>For
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &amp;&amp; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &lt; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &amp;&amp; !this.object) {
    this.carp('`for own` requires `of`');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
case 28:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var('flip$'))).add(yy.L(_$[$0-3],_$[$0-3],yy
.Call([$$[$0-3]])))).flipIt().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
break;
case 29:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.<span class="apidocCodeKeywordSpan">For</span>({
        from: $$[$0-3],
        op: $$[$0-2],
        to: $$[$0-1],
        inComprehension: true
      }))));
break;
case 30:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.superclass" id="apidoc.element.livescript.ast.For.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.For.</span>superclass
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &amp;&amp; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== '' + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For.prototype" id="apidoc.module.livescript.ast.For.prototype">module livescript.ast.For.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.addBody" id="apidoc.element.livescript.ast.For.prototype.addBody">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBody = function (body){
  var hasYield, ref$, x$, that, this$ = this;
  hasYield = !!body.traverseChildren(function(child){
    if (child instanceof Yield) {
      return true;
    }
  });
  if (this['let']) {
    if (ref$ = this.ref, delete this.ref, ref$) {
      this.item = Literal('..');
    }
    body = Block(Call['let']((x$ = [], (that = this.index) &amp;&amp; x$.push(Assign(Var(that), Literal('index$$'))), (that = this.item) &amp;&amp;
x$.push(Assign(that, Literal('item$$'))), x$), body, hasYield));
  }
  superclass.prototype.addBody.call(this, body);
  if (this.guard &amp;&amp; this['let'] &amp;&amp; (this.index || this.item)) {
    this.body.lines[0]['if'].traverseChildren(function(it){
      if (it instanceof Var) {
        if (this$.index &amp;&amp; it.value === this$.index) {
          it.value = 'index$$';
        }
        if (this$.item &amp;&amp; it.value === this$.item.value) {
          it.value = 'item$$';
        }
      }
    });
  }
  if (this['let']) {
    if (hasYield) {
      this.body = Block(Yield('yieldfrom', body));
    }
    delete this.index;
    delete this.item;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
While.prototype.show = function(){
  return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
};
prototype.isStatement = prototype.isArray = YES;
While.prototype.makeComprehension = function(toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().<span class="apidocCodeKeywordSpan">addBody</span>(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
};
While.prototype.getJump = function(ctx){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.compileNode" id="apidoc.element.livescript.ast.For.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
  o.loop = true;
  temps = this.temps = [];
  if (this.object &amp;&amp; this.index) {
    o.scope.declare(idx = this.index);
  } else {
    temps.push(idx = o.scope.temporary('i'));
  }
  if (!this.body) {
    this.addBody(Block(Var(idx)));
  }
  if (!this.object) {
    ref$ = (this.step || Literal(1)).compileLoopReference(o, 'step'), pvar = ref$[0], step = ref$[1];
    pvar === step || temps.push(pvar);
  }
  if (this.from) {
    if (this.ref) {
      this.item = Var(idx);
    }
    ref$ = this.to.compileLoopReference(o, 'to'), tvar = ref$[0], tail = ref$[1];
    fvar = this.from.compile(o, LEVEL_LIST);
    vars = idx + " = " + fvar;
    if (tail !== tvar) {
      vars += ", " + tail;
      temps.push(tvar);
    }
    if (!this.step &amp;&amp; +fvar &gt; +tvar) {
      pvar = step = -1;
    }
    eq = this.op === 'til' ? '' : '=';
    cond = +pvar
      ? idx + " " + '&lt;&gt;'.charAt(pvar &lt; 0) + eq + " " + tvar
      : pvar + " &lt; 0 ? " + idx + " &gt;" + eq + " " + tvar + " : " + idx + " &lt;" + eq + " " + tvar;
  } else {
    if (this.ref) {
      this.item = Var(o.scope.temporary('x'));
    }
    if (this.item || this.object &amp;&amp; this.own || this['let']) {
      ref$ = this.source.compileLoopReference(o, 'ref', !this.object, true), svar = ref$[0], srcPart = ref$[1];
      svar === srcPart || temps.push(svar);
    } else {
      svar = srcPart = this.source.compile(o, LEVEL_PAREN);
    }
    if (!this.object) {
      if (0 &gt; pvar &amp;&amp; ~~pvar === +pvar) {
        vars = idx + " = " + srcPart + ".length - 1";
        cond = idx + " &gt;= 0";
      } else {
        temps.push(lvar = o.scope.temporary('len'));
        vars = idx + " = 0, " + lvar + " = " + srcPart + ".length";
        cond = idx + " &lt; " + lvar;
      }
    }
  }
  this['else'] &amp;&amp; (this.yet = o.scope.temporary('yet'));
  head = [sn(this, 'for (')];
  if (this.object) {
    head.push(idx, " in ");
  }
  if (that = this.yet) {
    head.push(that, " = true, ");
  }
  if (this.object) {
    head.push(srcPart);
  } else {
    step === pvar || (vars += ', ' + step);
    head.push(vars, "; ", cond, "; " + (1 == Math.abs(pvar)
      ? (pvar &lt; 0 ? '--' : '++') + idx
      : idx + (pvar &lt; 0
        ? ' -= ' + pvar.toString().slice(1)
        : ' += ' + pvar)));
  }
  this.own &amp;&amp; head.push(sn(this, ") if ("), o.scope.assign('own$', '{}.hasOwnProperty'), ".call(", svar, ", ", idx, ")");
  head.push(sn(this, ') {'));
  if (this['let']) {
    this.body.traverseChildren(function(it){
      switch (it.value) {
      case 'index$$':
        it.value = idx;
        break;
      case 'item$$':
        it.value = svar + "[" + idx + "]";
      }
    });
  }
  o.indent += TAB;
  if (this.index &amp;&amp; !this.object) {
    head.push('\n' + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), ';');
  }
  if (this.item &amp;&amp; !this.item.isEmpty() &amp;&amp; !this.from) {
    head.push('\n' + o.indent, Assign(this.item, JS(svar + "[" + idx + "]")).compile(o, LEVEL_TOP), ';');
  }
  if (this.ref) {
    o.ref = this.item.value;
  }
  body = this.compileBody(o);
  if ((this.item || (this.index &amp;&amp; !this.object)) &amp;&amp; '}' === body.toString().charAt(0)) {
    head.push('\n' + this.tab);
  }
  return sn.apply(null, [null].concat(slice$.call(head), [body]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.constructor" id="apidoc.element.livescript.ast.For.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &amp;&amp; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &lt; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &amp;&amp; !this.object) {
    this.carp('`for own` requires `of`');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.show" id="apidoc.element.livescript.ast.For.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return ((this.kind || []).concat(this.index)).join(' ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For.prototype.addBody" id="apidoc.module.livescript.ast.For.prototype.addBody">module livescript.ast.For.prototype.addBody</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.addBody.addBody" id="apidoc.element.livescript.ast.For.prototype.addBody.addBody">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBody = function (body){
  var hasYield, ref$, x$, that, this$ = this;
  hasYield = !!body.traverseChildren(function(child){
    if (child instanceof Yield) {
      return true;
    }
  });
  if (this['let']) {
    if (ref$ = this.ref, delete this.ref, ref$) {
      this.item = Literal('..');
    }
    body = Block(Call['let']((x$ = [], (that = this.index) &amp;&amp; x$.push(Assign(Var(that), Literal('index$$'))), (that = this.item) &amp;&amp;
x$.push(Assign(that, Literal('item$$'))), x$), body, hasYield));
  }
  superclass.prototype.addBody.call(this, body);
  if (this.guard &amp;&amp; this['let'] &amp;&amp; (this.index || this.item)) {
    this.body.lines[0]['if'].traverseChildren(function(it){
      if (it instanceof Var) {
        if (this$.index &amp;&amp; it.value === this$.index) {
          it.value = 'index$$';
        }
        if (this$.item &amp;&amp; it.value === this$.item.value) {
          it.value = 'item$$';
        }
      }
    });
  }
  if (this['let']) {
    if (hasYield) {
      this.body = Block(Yield('yieldfrom', body));
    }
    delete this.index;
    delete this.item;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
While.prototype.show = function(){
  return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
};
prototype.isStatement = prototype.isArray = YES;
While.prototype.makeComprehension = function(toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().<span class="apidocCodeKeywordSpan">addBody</span>(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
};
While.prototype.getJump = function(ctx){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For.prototype.compileNode" id="apidoc.module.livescript.ast.For.prototype.compileNode">module livescript.ast.For.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.For.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
  o.loop = true;
  temps = this.temps = [];
  if (this.object &amp;&amp; this.index) {
    o.scope.declare(idx = this.index);
  } else {
    temps.push(idx = o.scope.temporary('i'));
  }
  if (!this.body) {
    this.addBody(Block(Var(idx)));
  }
  if (!this.object) {
    ref$ = (this.step || Literal(1)).compileLoopReference(o, 'step'), pvar = ref$[0], step = ref$[1];
    pvar === step || temps.push(pvar);
  }
  if (this.from) {
    if (this.ref) {
      this.item = Var(idx);
    }
    ref$ = this.to.compileLoopReference(o, 'to'), tvar = ref$[0], tail = ref$[1];
    fvar = this.from.compile(o, LEVEL_LIST);
    vars = idx + " = " + fvar;
    if (tail !== tvar) {
      vars += ", " + tail;
      temps.push(tvar);
    }
    if (!this.step &amp;&amp; +fvar &gt; +tvar) {
      pvar = step = -1;
    }
    eq = this.op === 'til' ? '' : '=';
    cond = +pvar
      ? idx + " " + '&lt;&gt;'.charAt(pvar &lt; 0) + eq + " " + tvar
      : pvar + " &lt; 0 ? " + idx + " &gt;" + eq + " " + tvar + " : " + idx + " &lt;" + eq + " " + tvar;
  } else {
    if (this.ref) {
      this.item = Var(o.scope.temporary('x'));
    }
    if (this.item || this.object &amp;&amp; this.own || this['let']) {
      ref$ = this.source.compileLoopReference(o, 'ref', !this.object, true), svar = ref$[0], srcPart = ref$[1];
      svar === srcPart || temps.push(svar);
    } else {
      svar = srcPart = this.source.compile(o, LEVEL_PAREN);
    }
    if (!this.object) {
      if (0 &gt; pvar &amp;&amp; ~~pvar === +pvar) {
        vars = idx + " = " + srcPart + ".length - 1";
        cond = idx + " &gt;= 0";
      } else {
        temps.push(lvar = o.scope.temporary('len'));
        vars = idx + " = 0, " + lvar + " = " + srcPart + ".length";
        cond = idx + " &lt; " + lvar;
      }
    }
  }
  this['else'] &amp;&amp; (this.yet = o.scope.temporary('yet'));
  head = [sn(this, 'for (')];
  if (this.object) {
    head.push(idx, " in ");
  }
  if (that = this.yet) {
    head.push(that, " = true, ");
  }
  if (this.object) {
    head.push(srcPart);
  } else {
    step === pvar || (vars += ', ' + step);
    head.push(vars, "; ", cond, "; " + (1 == Math.abs(pvar)
      ? (pvar &lt; 0 ? '--' : '++') + idx
      : idx + (pvar &lt; 0
        ? ' -= ' + pvar.toString().slice(1)
        : ' += ' + pvar)));
  }
  this.own &amp;&amp; head.push(sn(this, ") if ("), o.scope.assign('own$', '{}.hasOwnProperty'), ".call(", svar, ", ", idx, ")");
  head.push(sn(this, ') {'));
  if (this['let']) {
    this.body.traverseChildren(function(it){
      switch (it.value) {
      case 'index$$':
        it.value = idx;
        break;
      case 'item$$':
        it.value = svar + "[" + idx + "]";
      }
    });
  }
  o.indent += TAB;
  if (this.index &amp;&amp; !this.object) {
    head.push('\n' + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), ';');
  }
  if (this.item &amp;&amp; !this.item.isEmpty() &amp;&amp; !this.from) {
    head.push('\n' + o.indent, Assign(this.item, JS(svar + "[" + idx + "]")).compile(o, LEVEL_TOP), ';');
  }
  if (this.ref) {
    o.ref = this.item.value;
  }
  body = this.compileBody(o);
  if ((this.item || (this.index &amp;&amp; !this.object)) &amp;&amp; '}' === body.toString().charAt(0)) {
    head.push('\n' + this.tab);
  }
  return sn.apply(null, [null].concat(slice$.call(head), [body]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.For.prototype.show" id="apidoc.module.livescript.ast.For.prototype.show">module livescript.ast.For.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.For.prototype.show.show" id="apidoc.element.livescript.ast.For.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.For.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return ((this.kind || []).concat(this.index)).join(' ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun" id="apidoc.module.livescript.ast.Fun">module livescript.ast.Fun</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.Fun" id="apidoc.element.livescript.ast.Fun.Fun">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Fun
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &amp;&amp; 'this$';
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 113:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]));
break;
case 114:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Existence($$[$0-1].unwrap(), true));
break;
case 115:
this.$ = yy.L(_$[$0-5], _$[$0],yy.<span class="apidocCodeKeywordSpan">Fun</span>($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test
($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
break;
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.superclass" id="apidoc.element.livescript.ast.Fun.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype" id="apidoc.module.livescript.ast.Fun.prototype">module livescript.ast.Fun.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileNode" id="apidoc.element.livescript.ast.Fun.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this;
  pscope = o.scope;
  sscope = pscope.shared || pscope;
  scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper &amp;&amp; sscope);
  scope.fun = this;
  if (that = this.proto) {
    scope.assign('prototype', that.compile(o) + ".prototype");
  }
  if (that = this.cname) {
    scope.assign('constructor', that);
  }
  if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
    o.indent = this.tab = '';
  }
  o.indent += TAB;
  body = this.body, name = this.name, tab = this.tab;
  code = ['function'];
  if (this.generator) {
    this.ctor &amp;&amp; this.carp("a constructor can't be a generator");
    o.inGenerator = true;
    code.push('*');
  } else if (!this.wrapper) {
    o.inGenerator = false;
  }
  if (this.bound === 'this$') {
    if (this.ctor) {
      scope.assign('this$', 'this instanceof ctor$ ? this : new ctor$');
      body.lines.push(Return(Literal('this$')));
    } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
      this.bound = that;
    } else {
      sscope.assign('this$', 'this');
    }
  }
  if (this.statement) {
    name || this.carp('nameless function declaration');
    pscope === o.block.scope || this.carp('misplaced function declaration');
    this.accessor &amp;&amp; this.carp('named accessor');
    pscope.add(name, 'function', this);
  }
  if (this.statement || name &amp;&amp; this.labeled) {
    code.push(' ', scope.add(name, 'function', this));
  }
  this.hushed || this.ctor || this.newed || body.makeReturn();
  code.push("(", this.compileParams(o, scope), ")");
  code = [sn.apply(null, [this].concat(slice$.call(code)))];
  code.push("{");
  if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
    code.push("\n", bodyCode, "\n" + tab);
  }
  code.push('}');
  curryCodeCheck = function(){
    if (this$.curried &amp;&amp; this$.hasSplats) {
      this$.carp('cannot curry a function with a variable number of arguments');
    }
    if (this$.curried &amp;&amp; this$.params.length &gt; 1 &amp;&amp; !this$.classBound) {
      if (this$.bound) {
        return [util('curry'), "(("].concat(slice$.call(code), ["), true)"]);
      } else {
        return [util('curry'), "("].concat(slice$.call(code), [")"]);
      }
    } else {
      return code;
    }
  };
  if (inLoop) {
    return pscope.assign(pscope.temporary('fn'), sn.apply(null, [null].concat(slice$.call(curryCodeCheck()))));
  }
  if (this.returns) {
    code.push("\n" + tab + "return ", name, ";");
  } else if (this.bound &amp;&amp; this.ctor) {
    code.push(' function ctor$(){} ctor$.prototype = prototype;');
  }
  code = curryCodeCheck();
  if (this.front &amp;&amp; !this.statement) {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileParams" id="apidoc.element.livescript.ast.Fun.prototype.compileParams">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileParams
        <span class="apidocSignatureSpan">(o, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileParams = function (o, scope){
  var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
  params = this.params, length = params.length, body = this.body;
  for (i$ = params.length - 1; i$ &gt;= 0; --i$) {
    p = params[i$];
    if (!(p.isEmpty() || p.filler)) {
      break;
    }
    --params.length;
  }
  for (i$ = 0, len$ = params.length; i$ &lt; len$; ++i$) {
    i = i$;
    p = params[i$];
    if (p.left instanceof Splat) {
      p.carp('invalid splat');
    }
    if (p instanceof Splat) {
      this.hasSplats = true;
      splace = i;
    } else if (p.op === '=') {
      params[i] = Binary(p.logic || '?', p.left, p.right);
    }
  }
  if (splace != null) {
    rest = params.splice(splace, 9e9);
  } else if (this.accessor) {
    if (that = params[1]) {
      that.carp('excess accessor parameter');
    }
  } else if (!(length || this.wrapper)) {
    if (body.traverseChildren(function(it){
      return it.value === 'it' || null;
    })) {
      params[0] = Var('it');
    }
  }
  names = [];
  assigns = [];
  for (i$ = 0, len$ = params.length; i$ &lt; len$; ++i$) {
    p = params[i$];
    vr = p;
    if (df = vr.getDefault()) {
      vr = vr.first;
    }
    if (vr.isEmpty()) {
      vr = Var(scope.temporary('arg'));
    } else if (vr.value === '..') {
      vr = Var(o.ref = scope.temporary());
    } else if (!(vr instanceof Var)) {
      unaries = [];
      while (vr instanceof Unary) {
        hasUnary = true;
        unaries.push(vr);
        vr = vr.it;
      }
      v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary('arg'));
      assigns.push(Assign(vr, (fn$())));
      vr = v;
    } else if (df) {
      assigns.push(Assign(vr, p.second, '=', p.op, true));
    }
    names.push(scope.add(vr.value, 'arg', p), ', ');
  }
  if (rest) {
    while (splace--) {
      rest.unshift(Arr());
    }
    assigns.push(Assign(Arr(rest), Literal('arguments')));
  }
  if (assigns.length) {
    (ref$ = this.body).prepend.apply(ref$, assigns);
  }
  names.pop();
  return sn.apply(null, [null].concat(slice$.call(names)));
  function fn$(){
    switch (false) {
    case !df:
      return Binary(p.op, v, p.second);
    case !hasUnary:
      return fold(function(x, y){
        y.it = x;
        return y;
      }, v, unaries.reverse());
    default:
      return v;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.accessor &amp;&amp; this.carp('named accessor');
  pscope.add(name, 'function', this);
}
if (this.statement || name &amp;&amp; this.labeled) {
  code.push(' ', scope.add(name, 'function', this));
}
this.hushed || this.ctor || this.newed || body.makeReturn();
code.push("(", this.<span class="apidocCodeKeywordSpan">compileParams</span>(o, scope), ")");
code = [sn.apply(null, [this].concat(slice$.call(code)))];
code.push("{");
if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
  code.push("\n", bodyCode, "\n" + tab);
}
code.push('}');
curryCodeCheck = function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.constructor" id="apidoc.element.livescript.ast.Fun.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>constructor
        <span class="apidocSignatureSpan">(params, body, bound, curried, hushed, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fun(params, body, bound, curried, hushed, generator){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.params = params || [];
  this$.body = body || Block();
  this$.bound = bound &amp;&amp; 'this$';
  this$.curried = curried || false;
  this$.hushed = hushed != null ? hushed : false;
  this$.generator = generator != null ? generator : false;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.isCallable" id="apidoc.element.livescript.ast.Fun.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.isStatement" id="apidoc.element.livescript.ast.Fun.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStatement = function (){
  return !!this.statement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn" id="apidoc.element.livescript.ast.Fun.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  if (this.statement) {
    return this.returns = true, this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.named" id="apidoc.element.livescript.ast.Fun.prototype.named">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>named
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">named = function (it){
  return this.name = it, this.statement = true, this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Obj($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).<span class="apidocCodeKeywordSpan">named</span>($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.ripName" id="apidoc.element.livescript.ast.Fun.prototype.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripName = function (it){
  this.name || (this.name = it.varName());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), ": ", key);
}
ID.test(key) || (key = Function("return " + key)());
if (!(dic[key + "."] ^= 1)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.show" id="apidoc.element.livescript.ast.Fun.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return [this.name] + [(that = this.bound) ? "~" + that : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren" id="apidoc.element.livescript.ast.Fun.prototype.traverseChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>traverseChildren
        <span class="apidocSignatureSpan">(arg$, xscope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseChildren = function (arg$, xscope){
  if (xscope) {
    return superclass.prototype.traverseChildren.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.carp('inconvertible statement');
}
fun = Fun([], Block(this));
call = Call();
if (o.inGenerator) {
  fun.generator = true;
}
this.<span class="apidocCodeKeywordSpan">traverseChildren</span>(function(it){
  switch (it.value) {
  case 'this':
    hasThis = true;
    break;
  case 'arguments':
    hasArgs = it.value = 'args$';
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.compileNode" id="apidoc.module.livescript.ast.Fun.prototype.compileNode">module livescript.ast.Fun.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Fun.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this;
  pscope = o.scope;
  sscope = pscope.shared || pscope;
  scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper &amp;&amp; sscope);
  scope.fun = this;
  if (that = this.proto) {
    scope.assign('prototype', that.compile(o) + ".prototype");
  }
  if (that = this.cname) {
    scope.assign('constructor', that);
  }
  if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
    o.indent = this.tab = '';
  }
  o.indent += TAB;
  body = this.body, name = this.name, tab = this.tab;
  code = ['function'];
  if (this.generator) {
    this.ctor &amp;&amp; this.carp("a constructor can't be a generator");
    o.inGenerator = true;
    code.push('*');
  } else if (!this.wrapper) {
    o.inGenerator = false;
  }
  if (this.bound === 'this$') {
    if (this.ctor) {
      scope.assign('this$', 'this instanceof ctor$ ? this : new ctor$');
      body.lines.push(Return(Literal('this$')));
    } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
      this.bound = that;
    } else {
      sscope.assign('this$', 'this');
    }
  }
  if (this.statement) {
    name || this.carp('nameless function declaration');
    pscope === o.block.scope || this.carp('misplaced function declaration');
    this.accessor &amp;&amp; this.carp('named accessor');
    pscope.add(name, 'function', this);
  }
  if (this.statement || name &amp;&amp; this.labeled) {
    code.push(' ', scope.add(name, 'function', this));
  }
  this.hushed || this.ctor || this.newed || body.makeReturn();
  code.push("(", this.compileParams(o, scope), ")");
  code = [sn.apply(null, [this].concat(slice$.call(code)))];
  code.push("{");
  if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
    code.push("\n", bodyCode, "\n" + tab);
  }
  code.push('}');
  curryCodeCheck = function(){
    if (this$.curried &amp;&amp; this$.hasSplats) {
      this$.carp('cannot curry a function with a variable number of arguments');
    }
    if (this$.curried &amp;&amp; this$.params.length &gt; 1 &amp;&amp; !this$.classBound) {
      if (this$.bound) {
        return [util('curry'), "(("].concat(slice$.call(code), ["), true)"]);
      } else {
        return [util('curry'), "("].concat(slice$.call(code), [")"]);
      }
    } else {
      return code;
    }
  };
  if (inLoop) {
    return pscope.assign(pscope.temporary('fn'), sn.apply(null, [null].concat(slice$.call(curryCodeCheck()))));
  }
  if (this.returns) {
    code.push("\n" + tab + "return ", name, ";");
  } else if (this.bound &amp;&amp; this.ctor) {
    code.push(' function ctor$(){} ctor$.prototype = prototype;');
  }
  code = curryCodeCheck();
  if (this.front &amp;&amp; !this.statement) {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  } else {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.compileParams" id="apidoc.module.livescript.ast.Fun.prototype.compileParams">module livescript.ast.Fun.prototype.compileParams</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.compileParams.compileParams" id="apidoc.element.livescript.ast.Fun.prototype.compileParams.compileParams">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>compileParams
        <span class="apidocSignatureSpan">(o, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileParams = function (o, scope){
  var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
  params = this.params, length = params.length, body = this.body;
  for (i$ = params.length - 1; i$ &gt;= 0; --i$) {
    p = params[i$];
    if (!(p.isEmpty() || p.filler)) {
      break;
    }
    --params.length;
  }
  for (i$ = 0, len$ = params.length; i$ &lt; len$; ++i$) {
    i = i$;
    p = params[i$];
    if (p.left instanceof Splat) {
      p.carp('invalid splat');
    }
    if (p instanceof Splat) {
      this.hasSplats = true;
      splace = i;
    } else if (p.op === '=') {
      params[i] = Binary(p.logic || '?', p.left, p.right);
    }
  }
  if (splace != null) {
    rest = params.splice(splace, 9e9);
  } else if (this.accessor) {
    if (that = params[1]) {
      that.carp('excess accessor parameter');
    }
  } else if (!(length || this.wrapper)) {
    if (body.traverseChildren(function(it){
      return it.value === 'it' || null;
    })) {
      params[0] = Var('it');
    }
  }
  names = [];
  assigns = [];
  for (i$ = 0, len$ = params.length; i$ &lt; len$; ++i$) {
    p = params[i$];
    vr = p;
    if (df = vr.getDefault()) {
      vr = vr.first;
    }
    if (vr.isEmpty()) {
      vr = Var(scope.temporary('arg'));
    } else if (vr.value === '..') {
      vr = Var(o.ref = scope.temporary());
    } else if (!(vr instanceof Var)) {
      unaries = [];
      while (vr instanceof Unary) {
        hasUnary = true;
        unaries.push(vr);
        vr = vr.it;
      }
      v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary('arg'));
      assigns.push(Assign(vr, (fn$())));
      vr = v;
    } else if (df) {
      assigns.push(Assign(vr, p.second, '=', p.op, true));
    }
    names.push(scope.add(vr.value, 'arg', p), ', ');
  }
  if (rest) {
    while (splace--) {
      rest.unshift(Arr());
    }
    assigns.push(Assign(Arr(rest), Literal('arguments')));
  }
  if (assigns.length) {
    (ref$ = this.body).prepend.apply(ref$, assigns);
  }
  names.pop();
  return sn.apply(null, [null].concat(slice$.call(names)));
  function fn$(){
    switch (false) {
    case !df:
      return Binary(p.op, v, p.second);
    case !hasUnary:
      return fold(function(x, y){
        y.it = x;
        return y;
      }, v, unaries.reverse());
    default:
      return v;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.accessor &amp;&amp; this.carp('named accessor');
  pscope.add(name, 'function', this);
}
if (this.statement || name &amp;&amp; this.labeled) {
  code.push(' ', scope.add(name, 'function', this));
}
this.hushed || this.ctor || this.newed || body.makeReturn();
code.push("(", this.<span class="apidocCodeKeywordSpan">compileParams</span>(o, scope), ")");
code = [sn.apply(null, [this].concat(slice$.call(code)))];
code.push("{");
if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
  code.push("\n", bodyCode, "\n" + tab);
}
code.push('}');
curryCodeCheck = function(){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.isStatement" id="apidoc.module.livescript.ast.Fun.prototype.isStatement">module livescript.ast.Fun.prototype.isStatement</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.isStatement.isStatement" id="apidoc.element.livescript.ast.Fun.prototype.isStatement.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStatement = function (){
  return !!this.statement;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.makeReturn" id="apidoc.module.livescript.ast.Fun.prototype.makeReturn">module livescript.ast.Fun.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Fun.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  if (this.statement) {
    return this.returns = true, this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.named" id="apidoc.module.livescript.ast.Fun.prototype.named">module livescript.ast.Fun.prototype.named</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.named.named" id="apidoc.element.livescript.ast.Fun.prototype.named.named">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>named
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">named = function (it){
  return this.name = it, this.statement = true, this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Obj($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).<span class="apidocCodeKeywordSpan">named</span>($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.ripName" id="apidoc.module.livescript.ast.Fun.prototype.ripName">module livescript.ast.Fun.prototype.ripName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.ripName.ripName" id="apidoc.element.livescript.ast.Fun.prototype.ripName.ripName">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>ripName
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripName = function (it){
  this.name || (this.name = it.varName());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.compileAccessor(o, key = key.compile(o)));
  } else {
    val.<span class="apidocCodeKeywordSpan">ripName</span>(key);
    code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), ": ", key);
}
ID.test(key) || (key = Function("return " + key)());
if (!(dic[key + "."] ^= 1)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.show" id="apidoc.module.livescript.ast.Fun.prototype.show">module livescript.ast.Fun.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.show.show" id="apidoc.element.livescript.ast.Fun.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return [this.name] + [(that = this.bound) ? "~" + that : void 8];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Fun.prototype.traverseChildren" id="apidoc.module.livescript.ast.Fun.prototype.traverseChildren">module livescript.ast.Fun.prototype.traverseChildren</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Fun.prototype.traverseChildren.traverseChildren" id="apidoc.element.livescript.ast.Fun.prototype.traverseChildren.traverseChildren">
        function <span class="apidocSignatureSpan">livescript.ast.Fun.prototype.</span>traverseChildren
        <span class="apidocSignatureSpan">(arg$, xscope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traverseChildren = function (arg$, xscope){
  if (xscope) {
    return superclass.prototype.traverseChildren.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  that.carp('inconvertible statement');
}
fun = Fun([], Block(this));
call = Call();
if (o.inGenerator) {
  fun.generator = true;
}
this.<span class="apidocCodeKeywordSpan">traverseChildren</span>(function(it){
  switch (it.value) {
  case 'this':
    hasThis = true;
    break;
  case 'arguments':
    hasArgs = it.value = 'args$';
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If" id="apidoc.module.livescript.ast.If">module livescript.ast.If</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.If" id="apidoc.element.livescript.ast.If.If">
        function <span class="apidocSignatureSpan">livescript.ast.</span>If
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$['if'] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 116:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
break;
case 117:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true).named($$[$0-5]));
break;
case 118:
this.$ = (yy.L(_$[$0-3],_$[$0-2], yy.<span class="apidocCodeKeywordSpan">If</span>($$[$0-2], $$[$0-1], $$[$0-3] === 'unless
')).addElse($$[$0]));
break;
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === 'unless')));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.superclass" id="apidoc.element.livescript.ast.If.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.If.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.unfoldSoak" id="apidoc.element.livescript.ast.If.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.If.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o, parent, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o, parent, name){
  var that;
  if (that = parent[name].unfoldSoak(o)) {
    parent[name] = that.then;
    return that.cond = parent.cond, that['void'] = parent['void'], that.then = Chain(parent), that;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype" id="apidoc.module.livescript.ast.If.prototype">module livescript.ast.If.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileExpression" id="apidoc.element.livescript.ast.If.prototype.compileExpression">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileExpression
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExpression = function (o){
  var thn, els, code, pad;
  thn = this.then, els = this['else'] || Literal('void');
  this['void'] &amp;&amp; (thn['void'] = els['void'] = true);
  if (!this['else'] &amp;&amp; (this.cond || this['void'])) {
    return Parens(Binary('&amp;&amp;', this['if'], thn)).compile(o);
  }
  code = [sn(this, this['if'].compile(o, LEVEL_COND))];
  pad = els.isComplex() ? '\n' + (o.indent += TAB) : ' ';
  code.push(pad + "", sn(thn, "? "), thn.compile(o, LEVEL_LIST), pad + "", sn(els, ": "), els.compile(o, LEVEL_LIST));
  if (o.level &lt; LEVEL_COND) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, "(", code, ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compileExistence = function(o){
  var x;
  if (this['void'] || !o.level) {
    x = Binary('&amp;&amp;', Existence(this.first, true), this.second);
    return (x['void'] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).<span class="apidocCodeKeywordSpan">compileExpression</span>(o));
};
Binary.prototype.compileAnyInstanceOf = function(o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary('instanceof', sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    item = items[i$];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileNode" id="apidoc.element.livescript.ast.If.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  if (this.un) {
    this['if'] = this['if'].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.compileStatement(o);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileStatement" id="apidoc.element.livescript.ast.If.prototype.compileStatement">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileStatement
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileStatement = function (o){
  var code, els;
  code = [sn(this, "if (", this['if'].compile(o, LEVEL_PAREN), ") ")];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
  if (!(els = this['else'])) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  return sn.apply(null, [null].concat(
    slice$.call(code), [
      sn(els, ' else '), els instanceof constructor
        ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
        : this.compileBlock(o, els)
    ]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this['if'] = this['if'].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.<span class="apidocCodeKeywordSpan">compileStatement</span>(o);
  }
};
If.prototype.compileStatement = function(o){
  var code, els;
  code = [sn(this, "if (", this['if'].compile(o, LEVEL_PAREN), ") ")];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.constructor" id="apidoc.element.livescript.ast.If.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>constructor
        <span class="apidocSignatureSpan">($if, then, un)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function If($if, then, un){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$['if'] = $if;
  this$.then = then;
  this$.un = un;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.getJump" id="apidoc.element.livescript.ast.If.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var ref$;
  return this.then.getJump(it) || ((ref$ = this['else']) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isArray" id="apidoc.element.livescript.ast.If.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isCallable" id="apidoc.element.livescript.ast.If.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isRegex" id="apidoc.element.livescript.ast.If.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isString" id="apidoc.element.livescript.ast.If.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.makeReturn" id="apidoc.element.livescript.ast.If.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
  if (this['else'] != null) {
    this['else'] = (ref$ = this['else']).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.show" id="apidoc.element.livescript.ast.If.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.un &amp;&amp; '!';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.compileExpression" id="apidoc.module.livescript.ast.If.prototype.compileExpression">module livescript.ast.If.prototype.compileExpression</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileExpression.compileExpression" id="apidoc.element.livescript.ast.If.prototype.compileExpression.compileExpression">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileExpression
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileExpression = function (o){
  var thn, els, code, pad;
  thn = this.then, els = this['else'] || Literal('void');
  this['void'] &amp;&amp; (thn['void'] = els['void'] = true);
  if (!this['else'] &amp;&amp; (this.cond || this['void'])) {
    return Parens(Binary('&amp;&amp;', this['if'], thn)).compile(o);
  }
  code = [sn(this, this['if'].compile(o, LEVEL_COND))];
  pad = els.isComplex() ? '\n' + (o.indent += TAB) : ' ';
  code.push(pad + "", sn(thn, "? "), thn.compile(o, LEVEL_LIST), pad + "", sn(els, ": "), els.compile(o, LEVEL_LIST));
  if (o.level &lt; LEVEL_COND) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, "(", code, ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Binary.prototype.compileExistence = function(o){
  var x;
  if (this['void'] || !o.level) {
    x = Binary('&amp;&amp;', Existence(this.first, true), this.second);
    return (x['void'] = true, x).compileNode(o);
  }
  x = this.first.cache(o, true);
  return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).<span class="apidocCodeKeywordSpan">compileExpression</span>(o));
};
Binary.prototype.compileAnyInstanceOf = function(o, items){
  var ref$, sub, ref, test, i$, len$, item;
  ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
  test = Binary('instanceof', sub, items.shift());
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    item = items[i$];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.compileNode" id="apidoc.module.livescript.ast.If.prototype.compileNode">module livescript.ast.If.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.If.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  if (this.un) {
    this['if'] = this['if'].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.compileStatement(o);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.compileStatement" id="apidoc.module.livescript.ast.If.prototype.compileStatement">module livescript.ast.If.prototype.compileStatement</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.compileStatement.compileStatement" id="apidoc.element.livescript.ast.If.prototype.compileStatement.compileStatement">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>compileStatement
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileStatement = function (o){
  var code, els;
  code = [sn(this, "if (", this['if'].compile(o, LEVEL_PAREN), ") ")];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
  if (!(els = this['else'])) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  return sn.apply(null, [null].concat(
    slice$.call(code), [
      sn(els, ' else '), els instanceof constructor
        ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
        : this.compileBlock(o, els)
    ]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this['if'] = this['if'].invert();
  } else {
    this.soak || this.anaphorize();
  }
  if (o.level) {
    return this.compileExpression(o);
  } else {
    return this.<span class="apidocCodeKeywordSpan">compileStatement</span>(o);
  }
};
If.prototype.compileStatement = function(o){
  var code, els;
  code = [sn(this, "if (", this['if'].compile(o, LEVEL_PAREN), ") ")];
  o.indent += TAB;
  code.push(this.compileBlock(o, Block(this.then)));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.getJump" id="apidoc.module.livescript.ast.If.prototype.getJump">module livescript.ast.If.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.getJump.getJump" id="apidoc.element.livescript.ast.If.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var ref$;
  return this.then.getJump(it) || ((ref$ = this['else']) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.isArray" id="apidoc.module.livescript.ast.If.prototype.isArray">module livescript.ast.If.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isArray.isArray" id="apidoc.element.livescript.ast.If.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.isCallable" id="apidoc.module.livescript.ast.If.prototype.isCallable">module livescript.ast.If.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.If.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.isRegex" id="apidoc.module.livescript.ast.If.prototype.isRegex">module livescript.ast.If.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.If.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.isString" id="apidoc.module.livescript.ast.If.prototype.isString">module livescript.ast.If.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.isString.isString" id="apidoc.element.livescript.ast.If.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>isString
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.makeReturn" id="apidoc.module.livescript.ast.If.prototype.makeReturn">module livescript.ast.If.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.If.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
  if (this['else'] != null) {
    this['else'] = (ref$ = this['else']).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.If.prototype.show" id="apidoc.module.livescript.ast.If.prototype.show">module livescript.ast.If.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.If.prototype.show.show" id="apidoc.element.livescript.ast.If.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.If.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.un &amp;&amp; '!';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import" id="apidoc.module.livescript.ast.Import">module livescript.ast.Import</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.Import" id="apidoc.element.livescript.ast.Import.Import">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Import
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &amp;&amp; 'All';
  if (!all &amp;&amp; left instanceof Obj &amp;&amp; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
case 73:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Import</span>(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^'
;, $$[$0-2], {
  prec: 'yy.UNARY'
})), $$[$0], false));
break;
case 74:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^', $$[$0-2], {
  prec: 'yy.UNARY'
})), $$[$0].unwrap(), false));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.superclass" id="apidoc.element.livescript.ast.Import.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Import.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype" id="apidoc.module.livescript.ast.Import.prototype">module livescript.ast.Import.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileAssign" id="apidoc.element.livescript.ast.Import.prototype.compileAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileAssign
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAssign = function (o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
    return this.left.compile(o);
  }
  top = !o.level;
  if (this.proto || (items.length &lt; 2 &amp;&amp; (top || this['void'] || items[0] instanceof Splat))) {
    reft = this.left;
    if (reft.isComplex()) {
      reft = Parens(reft);
    }
  } else {
    ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
  }
  ref$ = top
    ? [';', '\n' + this.tab]
    : [',', ' '], delim = ref$[0], space = ref$[1];
  delim += space;
  code = this.temps
    ? [left.compile(o, LEVEL_PAREN), delim]
    : [];
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = items[i$];
    i &amp;&amp; code.push(com ? space : delim);
    if (com = node.comment) {
      code.push(node.compile(o));
      continue;
    }
    if (node instanceof Splat) {
      code.push(Import(reft, node.it).compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (dyna = node instanceof Parens) {
      ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
    } else if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        if (key instanceof Key) {
          key = JS("'" + key.name + "'");
        }
        code.push("Object.defineProperty(", reft.compile(o, LEVEL_LIST), ", ", key.compile(o, LEVEL_LIST), ", ", node.compileDescriptor
(o), ")");
        continue;
      }
    } else {
      key = val = node;
    }
    dyna || (key = key.maybeKey());
    logic &amp;&amp; (val = (logic.first = val, logic));
    code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
  }
  if (top) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  this['void'] || node instanceof Splat || code.push(com ? ' ' : ', ', reft.compile(o, LEVEL_PAREN));
  if (o.level &lt; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.<span class="apidocCodeKeywordSpan">compileAssign</span>(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util("import" + (this.all || '')), [this.left, right])).compileNode(o);
};
Import.prototype.compileAssign = function(o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileNode" id="apidoc.element.livescript.ast.Import.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.compileAssign(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util("import" + (this.all || '')), [this.left, right])).compileNode(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.constructor" id="apidoc.element.livescript.ast.Import.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>constructor
        <span class="apidocSignatureSpan">(left, right, all)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &amp;&amp; 'All';
  if (!all &amp;&amp; left instanceof Obj &amp;&amp; right.items) {
    return Obj(left.items.concat(right.asObj().items));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isArray" id="apidoc.element.livescript.ast.Import.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isCallable" id="apidoc.element.livescript.ast.Import.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.show" id="apidoc.element.livescript.ast.Import.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.all;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Import.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var left, value, ref$, temps;
  left = this.left;
  if (left instanceof Existence &amp;&amp; !left.negated) {
    if ((left = left.it) instanceof Var) {
      value = (this.left = left).value;
      if (!o.scope.check(value, true)) {
        left = JS("typeof " + value + " != 'undefined' &amp;&amp; " + value);
      }
    } else {
      ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
    }
    return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
  }
  return If.unfoldSoak(o, this, 'left') || (this['void'] || !o.level) &amp;&amp; If.unfoldSoak(o, this, 'right');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.compileAssign" id="apidoc.module.livescript.ast.Import.prototype.compileAssign">module livescript.ast.Import.prototype.compileAssign</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileAssign.compileAssign" id="apidoc.element.livescript.ast.Import.prototype.compileAssign.compileAssign">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileAssign
        <span class="apidocSignatureSpan">(o, items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAssign = function (o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
    return this.left.compile(o);
  }
  top = !o.level;
  if (this.proto || (items.length &lt; 2 &amp;&amp; (top || this['void'] || items[0] instanceof Splat))) {
    reft = this.left;
    if (reft.isComplex()) {
      reft = Parens(reft);
    }
  } else {
    ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
  }
  ref$ = top
    ? [';', '\n' + this.tab]
    : [',', ' '], delim = ref$[0], space = ref$[1];
  delim += space;
  code = this.temps
    ? [left.compile(o, LEVEL_PAREN), delim]
    : [];
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = items[i$];
    i &amp;&amp; code.push(com ? space : delim);
    if (com = node.comment) {
      code.push(node.compile(o));
      continue;
    }
    if (node instanceof Splat) {
      code.push(Import(reft, node.it).compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (dyna = node instanceof Parens) {
      ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
    } else if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        if (key instanceof Key) {
          key = JS("'" + key.name + "'");
        }
        code.push("Object.defineProperty(", reft.compile(o, LEVEL_LIST), ", ", key.compile(o, LEVEL_LIST), ", ", node.compileDescriptor
(o), ")");
        continue;
      }
    } else {
      key = val = node;
    }
    dyna || (key = key.maybeKey());
    logic &amp;&amp; (val = (logic.first = val, logic));
    code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
  }
  if (top) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  }
  this['void'] || node instanceof Splat || code.push(com ? ' ' : ', ', reft.compile(o, LEVEL_PAREN));
  if (o.level &lt; LEVEL_LIST) {
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [null, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.<span class="apidocCodeKeywordSpan">compileAssign</span>(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util("import" + (this.all || '')), [this.left, right])).compileNode(o);
};
Import.prototype.compileAssign = function(o, items){
  var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, logic, dyna, key, val;
  if (!items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.compileNode" id="apidoc.module.livescript.ast.Import.prototype.compileNode">module livescript.ast.Import.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Import.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var right;
  right = this.right;
  if (!this.all) {
    if (right instanceof Chain) {
      right = right.unfoldSoak(o) || right.unfoldAssign(o) || right.expandSlice(o).unwrap();
    }
    if (right instanceof List) {
      return this.compileAssign(o, right.asObj().items);
    }
  }
  return CopyL(this, Call.make(Util("import" + (this.all || '')), [this.left, right])).compileNode(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.isArray" id="apidoc.module.livescript.ast.Import.prototype.isArray">module livescript.ast.Import.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Import.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.isCallable" id="apidoc.module.livescript.ast.Import.prototype.isCallable">module livescript.ast.Import.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Import.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.show" id="apidoc.module.livescript.ast.Import.prototype.show">module livescript.ast.Import.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.show.show" id="apidoc.element.livescript.ast.Import.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.all;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Import.prototype.unfoldSoak" id="apidoc.module.livescript.ast.Import.prototype.unfoldSoak">module livescript.ast.Import.prototype.unfoldSoak</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Import.prototype.unfoldSoak.unfoldSoak" id="apidoc.element.livescript.ast.Import.prototype.unfoldSoak.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Import.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var left, value, ref$, temps;
  left = this.left;
  if (left instanceof Existence &amp;&amp; !left.negated) {
    if ((left = left.it) instanceof Var) {
      value = (this.left = left).value;
      if (!o.scope.check(value, true)) {
        left = JS("typeof " + value + " != 'undefined' &amp;&amp; " + value);
      }
    } else {
      ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
    }
    return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
  }
  return If.unfoldSoak(o, this, 'left') || (this['void'] || !o.level) &amp;&amp; If.unfoldSoak(o, this, 'right');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.In" id="apidoc.module.livescript.ast.In">module livescript.ast.In</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.In.In" id="apidoc.element.livescript.ast.In.In">
        function <span class="apidocSignatureSpan">livescript.ast.</span>In
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.superclass" id="apidoc.element.livescript.ast.In.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.In.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.In.prototype" id="apidoc.module.livescript.ast.In.prototype">module livescript.ast.In.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.compileNode" id="apidoc.element.livescript.ast.In.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var array, items, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
  items = (array = this.array.expandSlice(o).unwrap()).items;
  if (!(array instanceof Arr) || items.length &lt; 2) {
    return sn(this, this.negated ? '!' : '', util('in'), "(", this.item.compile(o, LEVEL_LIST), ", ", array.compile(o, LEVEL_LIST
), ")");
  }
  code = [];
  ref$ = this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
  ref$ = this.negated
    ? [' !== ', ' &amp;&amp; ']
    : [' === ', ' || '], cmp = ref$[0], cnj = ref$[1];
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    test = items[i$];
    if (code.length &gt; 0) {
      code.push(cnj);
    }
    if (test instanceof Splat) {
      code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
      if (!(i || sub === ref)) {
        code = ["(" + sub + ", "].concat(slice$.call(code), [")"]);
      }
    } else {
      code.push(i || sub === ref
        ? ref
        : "(" + sub + ")", cmp, test.compile(o, LEVEL_OP + PREC['==']));
    }
  }
  sub === ref || o.scope.free(ref);
  if (o.level &lt; LEVEL_OP + PREC['||']) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.constructor" id="apidoc.element.livescript.ast.In.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>constructor
        <span class="apidocSignatureSpan">(item, array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function In(item, array){
  this.item = item;
  this.array = array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.invert" id="apidoc.element.livescript.ast.In.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  this.negated = !this.negated;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary('!', this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this['else'] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.show" id="apidoc.element.livescript.ast.In.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.negated &amp;&amp; '!';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.In.prototype.compileNode" id="apidoc.module.livescript.ast.In.prototype.compileNode">module livescript.ast.In.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.In.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.In.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.In.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var array, items, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
  items = (array = this.array.expandSlice(o).unwrap()).items;
  if (!(array instanceof Arr) || items.length &lt; 2) {
    return sn(this, this.negated ? '!' : '', util('in'), "(", this.item.compile(o, LEVEL_LIST), ", ", array.compile(o, LEVEL_LIST
), ")");
  }
  code = [];
  ref$ = this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
  ref$ = this.negated
    ? [' !== ', ' &amp;&amp; ']
    : [' === ', ' || '], cmp = ref$[0], cnj = ref$[1];
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    test = items[i$];
    if (code.length &gt; 0) {
      code.push(cnj);
    }
    if (test instanceof Splat) {
      code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
      if (!(i || sub === ref)) {
        code = ["(" + sub + ", "].concat(slice$.call(code), [")"]);
      }
    } else {
      code.push(i || sub === ref
        ? ref
        : "(" + sub + ")", cmp, test.compile(o, LEVEL_OP + PREC['==']));
    }
  }
  sub === ref || o.scope.free(ref);
  if (o.level &lt; LEVEL_OP + PREC['||']) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index" id="apidoc.module.livescript.ast.Index">module livescript.ast.Index</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.Index" id="apidoc.element.livescript.ast.Index.Index">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Index
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = '.');
  if (init &amp;&amp; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case '[]':
    this$.vivify = Arr;
    break;
  case '{}':
    this$.vivify = Obj;
    break;
  default:
    if ('=' === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.<span class="apidocCodeKeywordSpan">Index</span>($$[$0], $$[$
0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
case 9:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.superclass" id="apidoc.element.livescript.ast.Index.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Index.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype" id="apidoc.module.livescript.ast.Index.prototype">module livescript.ast.Index.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.compile" id="apidoc.element.livescript.ast.Index.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
    return sn(this, "[", code, "]");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.constructor" id="apidoc.element.livescript.ast.Index.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>constructor
        <span class="apidocSignatureSpan">(key, symbol, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Index(key, symbol, init){
  var k, this$ = this instanceof ctor$ ? this : new ctor$;
  symbol || (symbol = '.');
  if (init &amp;&amp; key instanceof Arr) {
    switch (key.items.length) {
    case 1:
      if (!((k = key.items[0]) instanceof Splat)) {
        key = Parens(k);
      }
    }
  }
  switch (symbol) {
  case '[]':
    this$.vivify = Arr;
    break;
  case '{}':
    this$.vivify = Obj;
    break;
  default:
    if ('=' === symbol.slice(-1)) {
      this$.assign = symbol.slice(1);
    }
  }
  this$.key = key;
  this$.symbol = symbol;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.isComplex" id="apidoc.element.livescript.ast.Index.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.key.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.show" id="apidoc.element.livescript.ast.Index.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.soak ? '?' : void 8] + this.symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.varName" id="apidoc.element.livescript.ast.Index.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype.compile" id="apidoc.module.livescript.ast.Index.prototype.compile">module livescript.ast.Index.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.compile.compile" id="apidoc.element.livescript.ast.Index.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
    return sn(this, "[", code, "]");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype.isComplex" id="apidoc.module.livescript.ast.Index.prototype.isComplex">module livescript.ast.Index.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Index.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.key.isComplex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype.show" id="apidoc.module.livescript.ast.Index.prototype.show">module livescript.ast.Index.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.show.show" id="apidoc.element.livescript.ast.Index.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.soak ? '?' : void 8] + this.symbol;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Index.prototype.varName" id="apidoc.module.livescript.ast.Index.prototype.varName">module livescript.ast.Index.prototype.varName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Index.prototype.varName.varName" id="apidoc.element.livescript.ast.Index.prototype.varName.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Index.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.varName();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS" id="apidoc.module.livescript.ast.JS">module livescript.ast.JS</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.JS" id="apidoc.element.livescript.ast.JS.JS">
        function <span class="apidocSignatureSpan">livescript.ast.</span>JS
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 66:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], 'cascade'));
break;
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">JS</span>($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS("Error('unimplemented')"))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.superclass" id="apidoc.element.livescript.ast.JS.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.JS.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS.prototype" id="apidoc.module.livescript.ast.JS.prototype">module livescript.ast.JS.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.compile" id="apidoc.element.livescript.ast.JS.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>compile
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (it){
  return sn(this, snSafe(this.literal
    ? entab(this.code, it.indent)
    : this.code));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.constructor" id="apidoc.element.livescript.ast.JS.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>constructor
        <span class="apidocSignatureSpan">(code, literal, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JS(code, literal, comment){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.code = code;
  this$.literal = literal;
  this$.comment = comment;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.isAssignable" id="apidoc.element.livescript.ast.JS.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAssignable = function (){
  return !this.comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.isCallable" id="apidoc.element.livescript.ast.JS.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  return !this.comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.show" id="apidoc.element.livescript.ast.JS.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.comment) {
    return this.code;
  } else {
    return "`" + this.code + "`";
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS.prototype.compile" id="apidoc.module.livescript.ast.JS.prototype.compile">module livescript.ast.JS.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.compile.compile" id="apidoc.element.livescript.ast.JS.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>compile
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (it){
  return sn(this, snSafe(this.literal
    ? entab(this.code, it.indent)
    : this.code));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS.prototype.isCallable" id="apidoc.module.livescript.ast.JS.prototype.isCallable">module livescript.ast.JS.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.JS.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  return !this.comment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.JS.prototype.show" id="apidoc.module.livescript.ast.JS.prototype.show">module livescript.ast.JS.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.JS.prototype.show.show" id="apidoc.element.livescript.ast.JS.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.JS.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.comment) {
    return this.code;
  } else {
    return "`" + this.code + "`";
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump" id="apidoc.module.livescript.ast.Jump">module livescript.ast.Jump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.Jump" id="apidoc.element.livescript.ast.Jump.Jump">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Jump
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
case 125:
this.$ = yy.L(_$[$0], _$[$0],yy.Jump[$$[$0]]());
break;
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Jump</span>($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.Switch($$[$0-2], $$[$0-1], $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.extended" id="apidoc.element.livescript.ast.Jump.extended">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>extended
        <span class="apidocSignatureSpan">(sub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extended = function (sub){
  sub.prototype.children = ['it'];
  this[sub.displayName.toLowerCase()] = sub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function THIS(){
return this;
}
function VOID(){}
UTILS = {
clone: 'function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}',
extend: 'function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new
fun).constructor = sub;\n  if (typeof sup.extended == \'function\') sup.<span class="apidocCodeKeywordSpan">extended</span>(sub);\n  return sub;\n}',
bind: 'function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}',
'import': 'function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj
[key] = src[key];\n  return obj;\n}',
importAll: 'function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}',
repeatString: 'function(str, n){\n  for (var r = \'\'; n &gt; 0; (n &gt;&gt;= 1) &amp;&amp; (str += str))
if (n &amp; 1) r += str;\n  return r;\n}',
repeatArray: 'function(arr, n){\n  for (var r = []; n &gt; 0; (n &gt;&gt;= 1) &amp;&amp; (arr = arr.concat(arr)))\n
    if (n &amp; 1) r.push.apply(r, arr);\n  return r;\n}',
'in': 'function(x, xs){\n  var i = -1, l = xs.length &gt;&gt;&gt; 0;\n  while (++i &lt; l) if (x === xs[i
]) return true;\n  return false;\n}',
out: 'typeof exports != \'undefined\' &amp;&amp; exports || this',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.return" id="apidoc.element.livescript.ast.Jump.return">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &amp;&amp; it.value !== 'void') {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.superclass" id="apidoc.element.livescript.ast.Jump.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.throw" id="apidoc.element.livescript.ast.Jump.throw">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.</span>throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype" id="apidoc.module.livescript.ast.Jump.prototype">module livescript.ast.Jump.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.compileNode" id="apidoc.element.livescript.ast.Jump.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that, ref$;
  if (that = this.label) {
    in$(that, (ref$ = o.labels) != null
      ? ref$
      : o.labels = []) || this.carp("unknown label \"" + that + "\"");
  } else {
    o[this.verb] || this.carp("stray " + this.verb);
  }
  return sn(this, this.show() + ';');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.constructor" id="apidoc.element.livescript.ast.Jump.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>constructor
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.getJump" id="apidoc.element.livescript.ast.Jump.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var that, ref$;
  ctx || (ctx = {});
  if (!ctx[this.verb]) {
    return this;
  }
  if (that = this.label) {
    return !in$(that, (ref$ = ctx.labels) != null
      ? ref$
      : ctx.labels = []) &amp;&amp; this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.isStatement" id="apidoc.element.livescript.ast.Jump.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn" id="apidoc.element.livescript.ast.Jump.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.show" id="apidoc.element.livescript.ast.Jump.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return (this.verb || '') + ((that = this.label) ? ' ' + that : '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype.compileNode" id="apidoc.module.livescript.ast.Jump.prototype.compileNode">module livescript.ast.Jump.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Jump.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that, ref$;
  if (that = this.label) {
    in$(that, (ref$ = o.labels) != null
      ? ref$
      : o.labels = []) || this.carp("unknown label \"" + that + "\"");
  } else {
    o[this.verb] || this.carp("stray " + this.verb);
  }
  return sn(this, this.show() + ';');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype.getJump" id="apidoc.module.livescript.ast.Jump.prototype.getJump">module livescript.ast.Jump.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Jump.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var that, ref$;
  ctx || (ctx = {});
  if (!ctx[this.verb]) {
    return this;
  }
  if (that = this.label) {
    return !in$(that, (ref$ = ctx.labels) != null
      ? ref$
      : ctx.labels = []) &amp;&amp; this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype.makeReturn" id="apidoc.module.livescript.ast.Jump.prototype.makeReturn">module livescript.ast.Jump.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Jump.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Jump.prototype.show" id="apidoc.module.livescript.ast.Jump.prototype.show">module livescript.ast.Jump.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Jump.prototype.show.show" id="apidoc.element.livescript.ast.Jump.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Jump.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return (this.verb || '') + ((that = this.label) ? ' ' + that : '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key" id="apidoc.module.livescript.ast.Key">module livescript.ast.Key</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.Key" id="apidoc.element.livescript.ast.Key.Key">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Key
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = '' + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
case 47: case 48: case 56: case 59: case 60: case 64: case 65: case 149: case 157: case 170: case 171:

break;
case 49:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Key</span>($$[$0]));
break;
case 50:
this.$ = yy.L(_$[$0], _$[$0],yy.Literal($$[$0]));
break;
case 51: case 164:
this.$ = yy.L(_$[$0], _$[$0],[]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.superclass" id="apidoc.element.livescript.ast.Key.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Key.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype" id="apidoc.module.livescript.ast.Key.prototype">module livescript.ast.Key.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.assigns" id="apidoc.element.livescript.ast.Key.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return it === this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.compile" id="apidoc.element.livescript.ast.Key.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return sn(this, this.show());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.constructor" id="apidoc.element.livescript.ast.Key.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, reserved)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(name, reserved){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.reserved = reserved || name.reserved;
  this$.name = '' + name;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.isComplex" id="apidoc.element.livescript.ast.Key.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.show" id="apidoc.element.livescript.ast.Key.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.reserved) {
    return "'" + this.name + "'";
  } else {
    return this.name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.varName" id="apidoc.element.livescript.ast.Key.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var name;
  name = this.name;
  if (this.reserved || (name === 'arguments' || name === 'eval')) {
    return "$" + name;
  } else {
    return name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype.assigns" id="apidoc.module.livescript.ast.Key.prototype.assigns">module livescript.ast.Key.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Key.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return it === this.name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype.compile" id="apidoc.module.livescript.ast.Key.prototype.compile">module livescript.ast.Key.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.compile.compile" id="apidoc.element.livescript.ast.Key.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return sn(this, this.show());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype.isComplex" id="apidoc.module.livescript.ast.Key.prototype.isComplex">module livescript.ast.Key.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Key.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype.show" id="apidoc.module.livescript.ast.Key.prototype.show">module livescript.ast.Key.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.show.show" id="apidoc.element.livescript.ast.Key.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.reserved) {
    return "'" + this.name + "'";
  } else {
    return this.name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Key.prototype.varName" id="apidoc.module.livescript.ast.Key.prototype.varName">module livescript.ast.Key.prototype.varName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Key.prototype.varName.varName" id="apidoc.element.livescript.ast.Key.prototype.varName.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Key.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  var name;
  name = this.name;
  if (this.reserved || (name === 'arguments' || name === 'eval')) {
    return "$" + name;
  } else {
    return name;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.L" id="apidoc.module.livescript.ast.L">module livescript.ast.L</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.L.L" id="apidoc.element.livescript.ast.L.L">
        function <span class="apidocSignatureSpan">livescript.ast.</span>L
        <span class="apidocSignatureSpan">(a, b, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">L = function (a, b, node){
  if (node &amp;&amp; typeof node === "object") {
    node.first_line = a.first_line + 1;
    node.first_column = a.first_column;
    node.last_line = b.last_line + 1;
    node.last_column = b.last_column;
    node.line = a.first_line + 1;
    node.column = a.first_column;
  }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.<span class="apidocCodeKeywordSpan">L</span>(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label" id="apidoc.module.livescript.ast.Label">module livescript.ast.Label</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.Label" id="apidoc.element.livescript.ast.Label.Label">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Label
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || '_';
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &amp;&amp; it || it.calling &amp;&amp; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        body: $$[$0]
      }));
break;
case 143:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
break;
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Label</span>($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== 'arguments' &amp;&amp; $$[$0] !== &amp;#
x27;eval')), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.superclass" id="apidoc.element.livescript.ast.Label.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Label.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype" id="apidoc.module.livescript.ast.Label.prototype">module livescript.ast.Label.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.compileNode" id="apidoc.element.livescript.ast.Label.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var label, it, labels;
  label = this.label, it = this.it;
  labels = o.labels = slice$.call(o.labels || []);
  if (in$(label, labels)) {
    this.carp("duplicate label \"" + label + "\"");
  }
  labels.push(label);
  it.isStatement() || (it = Block(it));
  return sn(null, sn(this, label, ": "), it instanceof Block
    ? (o.indent += TAB, this.compileBlock(o, it))
    : it.compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.constructor" id="apidoc.element.livescript.ast.Label.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>constructor
        <span class="apidocSignatureSpan">(label, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Label(label, it){
  var fun;
  this.label = label || '_';
  this.it = it;
  if (fun = (it instanceof Fun || it instanceof Class) &amp;&amp; it || it.calling &amp;&amp; it.it.head) {
    fun.name || (fun.name = this.label, fun.labeled = true);
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.getJump" id="apidoc.element.livescript.ast.Label.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var ref$;
  ctx || (ctx = {});
  ((ref$ = ctx.labels) != null
    ? ref$
    : ctx.labels = []).push(this.label);
  return this.it.getJump((ctx['break'] = true, ctx));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isArray" id="apidoc.element.livescript.ast.Label.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isCallable" id="apidoc.element.livescript.ast.Label.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isStatement" id="apidoc.element.livescript.ast.Label.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.makeReturn" id="apidoc.element.livescript.ast.Label.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.show" id="apidoc.element.livescript.ast.Label.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.compileNode" id="apidoc.module.livescript.ast.Label.prototype.compileNode">module livescript.ast.Label.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Label.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var label, it, labels;
  label = this.label, it = this.it;
  labels = o.labels = slice$.call(o.labels || []);
  if (in$(label, labels)) {
    this.carp("duplicate label \"" + label + "\"");
  }
  labels.push(label);
  it.isStatement() || (it = Block(it));
  return sn(null, sn(this, label, ": "), it instanceof Block
    ? (o.indent += TAB, this.compileBlock(o, it))
    : it.compile(o));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.getJump" id="apidoc.module.livescript.ast.Label.prototype.getJump">module livescript.ast.Label.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Label.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var ref$;
  ctx || (ctx = {});
  ((ref$ = ctx.labels) != null
    ? ref$
    : ctx.labels = []).push(this.label);
  return this.it.getJump((ctx['break'] = true, ctx));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.isArray" id="apidoc.module.livescript.ast.Label.prototype.isArray">module livescript.ast.Label.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Label.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.isCallable" id="apidoc.module.livescript.ast.Label.prototype.isCallable">module livescript.ast.Label.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Label.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.makeReturn" id="apidoc.module.livescript.ast.Label.prototype.makeReturn">module livescript.ast.Label.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Label.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Label.prototype.show" id="apidoc.module.livescript.ast.Label.prototype.show">module livescript.ast.Label.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Label.prototype.show.show" id="apidoc.element.livescript.ast.Label.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Label.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal" id="apidoc.module.livescript.ast.Literal">module livescript.ast.Literal</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.Literal" id="apidoc.element.livescript.ast.Literal.Literal">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Literal
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + "", true);
  }
  if (value === 'super') {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Literal</span>($$[$0]))));
break;
case 6: case 7:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add(yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1], true))));
break;
case 8:
this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass" id="apidoc.element.livescript.ast.Literal.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(){
  Atom.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype" id="apidoc.module.livescript.ast.Literal.prototype">module livescript.ast.Literal.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.compile" id="apidoc.element.livescript.ast.Literal.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var val, ref$;
  level == null &amp;&amp; (level = o.level);
  switch (val = this.value + "") {
  case 'this':
    return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
  case 'void':
    if (!level) {
      return sn(this, '');
    }
    val += ' 8';
    // fallthrough
  case 'null':
    if (level === LEVEL_CALL) {
      this.carp('invalid use of ' + this.value);
    }
    break;
  case 'on':
  case 'yes':
    val = 'true';
    break;
  case 'off':
  case 'no':
    val = 'false';
    break;
  case '*':
    this.carp('stray star');
    break;
  case '..':
    if (!(val = o.ref)) {
      this.carp('stray reference');
    }
    this.cascadee || (val.erred = true);
    break;
  case 'debugger':
    if (level) {
      return sn(this, "(function(){ debugger; }())");
    }
  }
  return sn(this, snSafe(val));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.constructor" id="apidoc.element.livescript.ast.Literal.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  if (value.js) {
    return JS(value + "", true);
  }
  if (value === 'super') {
    return new Super;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isCallable" id="apidoc.element.livescript.ast.Literal.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return (ref$ = this.value) === 'this' || ref$ === 'eval' || ref$ === '..';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isComplex" id="apidoc.element.livescript.ast.Literal.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.isRegex() || this.value === 'debugger';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty" id="apidoc.element.livescript.ast.Literal.prototype.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (){
  var ref$;
  return (ref$ = this.value) === 'void' || ref$ === 'null';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + "").charAt() === '/';
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return 'empty';
  case !this.isCallable():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isRegex" id="apidoc.element.livescript.ast.Literal.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (){
  return (this.value + "").charAt() === '/';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isString" id="apidoc.element.livescript.ast.Literal.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  return 0 &lt;= '\'"'.indexOf((this.value + "").charAt());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isWhat" id="apidoc.element.livescript.ast.Literal.prototype.isWhat">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isWhat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isWhat = function (){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.isCallable():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
  default:

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    default:
if (COMPARER.test(this.op)) {
  if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.xorChildren(function(it){
    return it.isRegex();
  })) {
    return this.compileRegexEquals(o, that);
  }
  if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;
;&amp; this.first.<span class="apidocCodeKeywordSpan">isWhat</span>() !== this.second.isWhat()) {
    if (typeof console != 'undefined' &amp;&amp; console !== null) {
      console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + "
; == " + this.second.value);
    }
  }
}
if (COMPARER.test(this.op) &amp;&amp; COMPARER.test(this.second.op)) {
  return this.compileChain(o);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn" id="apidoc.element.livescript.ast.Literal.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (it){
  if (!it &amp;&amp; this.value === 'debugger') {
    return this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey" id="apidoc.element.livescript.ast.Literal.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeKey = function (){
  if (ID.test(this.value)) {
    return Key(this.value);
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.varName" id="apidoc.element.livescript.ast.Literal.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  if (/^\w+$/.test(this.value)) {
    return '$' + this.value;
  } else {
    return '';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.compile" id="apidoc.module.livescript.ast.Literal.prototype.compile">module livescript.ast.Literal.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.compile.compile" id="apidoc.element.livescript.ast.Literal.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var val, ref$;
  level == null &amp;&amp; (level = o.level);
  switch (val = this.value + "") {
  case 'this':
    return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
  case 'void':
    if (!level) {
      return sn(this, '');
    }
    val += ' 8';
    // fallthrough
  case 'null':
    if (level === LEVEL_CALL) {
      this.carp('invalid use of ' + this.value);
    }
    break;
  case 'on':
  case 'yes':
    val = 'true';
    break;
  case 'off':
  case 'no':
    val = 'false';
    break;
  case '*':
    this.carp('stray star');
    break;
  case '..':
    if (!(val = o.ref)) {
      this.carp('stray reference');
    }
    this.cascadee || (val.erred = true);
    break;
  case 'debugger':
    if (level) {
      return sn(this, "(function(){ debugger; }())");
    }
  }
  return sn(this, snSafe(val));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isCallable" id="apidoc.module.livescript.ast.Literal.prototype.isCallable">module livescript.ast.Literal.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Literal.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return (ref$ = this.value) === 'this' || ref$ === 'eval' || ref$ === '..';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isComplex" id="apidoc.module.livescript.ast.Literal.prototype.isComplex">module livescript.ast.Literal.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Literal.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (){
  return this.isRegex() || this.value === 'debugger';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isEmpty" id="apidoc.module.livescript.ast.Literal.prototype.isEmpty">module livescript.ast.Literal.prototype.isEmpty</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isEmpty.isEmpty" id="apidoc.element.livescript.ast.Literal.prototype.isEmpty.isEmpty">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (){
  var ref$;
  return (ref$ = this.value) === 'void' || ref$ === 'null';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return (this.value + "").charAt() === '/';
};
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.<span class="apidocCodeKeywordSpan">isEmpty</span>():
    return 'empty';
  case !this.isCallable():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isRegex" id="apidoc.module.livescript.ast.Literal.prototype.isRegex">module livescript.ast.Literal.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Literal.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isRegex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (){
  return (this.value + "").charAt() === '/';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isString" id="apidoc.module.livescript.ast.Literal.prototype.isString">module livescript.ast.Literal.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isString.isString" id="apidoc.element.livescript.ast.Literal.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  return 0 &lt;= '\'"'.indexOf((this.value + "").charAt());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.isWhat" id="apidoc.module.livescript.ast.Literal.prototype.isWhat">module livescript.ast.Literal.prototype.isWhat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.isWhat.isWhat" id="apidoc.element.livescript.ast.Literal.prototype.isWhat.isWhat">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>isWhat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isWhat = function (){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.isCallable():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
  default:

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    default:
if (COMPARER.test(this.op)) {
  if (that = ((ref$ = this.op) === '===' || ref$ === '!==') &amp;&amp; this.xorChildren(function(it){
    return it.isRegex();
  })) {
    return this.compileRegexEquals(o, that);
  }
  if (this.op === '===' &amp;&amp; (this.first instanceof Literal &amp;&amp; this.second instanceof Literal) &amp;
;&amp; this.first.<span class="apidocCodeKeywordSpan">isWhat</span>() !== this.second.isWhat()) {
    if (typeof console != 'undefined' &amp;&amp; console !== null) {
      console.warn("WARNING: strict comparison of two different types will always be false: " + this.first.value + "
; == " + this.second.value);
    }
  }
}
if (COMPARER.test(this.op) &amp;&amp; COMPARER.test(this.second.op)) {
  return this.compileChain(o);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.makeReturn" id="apidoc.module.livescript.ast.Literal.prototype.makeReturn">module livescript.ast.Literal.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Literal.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (it){
  if (!it &amp;&amp; this.value === 'debugger') {
    return this;
  } else {
    return superclass.prototype.makeReturn.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.maybeKey" id="apidoc.module.livescript.ast.Literal.prototype.maybeKey">module livescript.ast.Literal.prototype.maybeKey</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.maybeKey.maybeKey" id="apidoc.element.livescript.ast.Literal.prototype.maybeKey.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeKey = function (){
  if (ID.test(this.value)) {
    return Key(this.value);
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.prototype.varName" id="apidoc.module.livescript.ast.Literal.prototype.varName">module livescript.ast.Literal.prototype.varName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.prototype.varName.varName" id="apidoc.element.livescript.ast.Literal.prototype.varName.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  if (/^\w+$/.test(this.value)) {
    return '$' + this.value;
  } else {
    return '';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Literal.superclass.prototype" id="apidoc.module.livescript.ast.Literal.superclass.prototype">module livescript.ast.Literal.superclass.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass.prototype.constructor" id="apidoc.element.livescript.ast.Literal.superclass.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(){
  Atom.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass.prototype.isComplex" id="apidoc.element.livescript.ast.Literal.superclass.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>isComplex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NO(){
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Literal.superclass.prototype.show" id="apidoc.element.livescript.ast.Literal.superclass.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Literal.superclass.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Obj" id="apidoc.module.livescript.ast.Obj">module livescript.ast.Obj</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.Obj" id="apidoc.element.livescript.ast.Obj.Obj">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Obj
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ref: true
      }).addBody($$[$0]))));
break;
case 43:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
break;
case 44:
this.$ = yy.L(_$[$0-3], _$[$0],yy.<span class="apidocCodeKeywordSpan">Obj</span>($$[$0-2]));
break;
case 45:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).named($$[$0]));
break;
case 46:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.compile" id="apidoc.element.livescript.ast.Obj.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>compile
        <span class="apidocSignatureSpan">(o, items, deepEq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
  case 0:
    return '';
  case 1:
    return items[0].compile(o, LEVEL_LIST);
  }
  indent = o.indent, level = o.level;
  o.indent = indent + TAB;
  o.level = LEVEL_LIST;
  code = [items[i = 0].compile(o)];
  while (that = items[++i]) {
    code.push(', ');
    target = that;
    if (deepEq) {
      if (target instanceof Var &amp;&amp; target.value === '_') {
        target = Obj([Prop(Key('__placeholder__'), Literal(true))]);
      } else if (target instanceof Obj || target instanceof Arr) {
        target.deepEq = true;
      }
    }
    code.push(target.compile(o));
  }
  if (~code.join("").indexOf('\n')) {
    code = ["\n" + o.indent].concat(slice$.call(code), ["\n" + indent]);
  }
  o.indent = indent;
  o.level = level;
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.superclass" id="apidoc.element.livescript.ast.Obj.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(){
  List.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Obj.prototype" id="apidoc.module.livescript.ast.Obj.prototype">module livescript.ast.Obj.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.asObj" id="apidoc.element.livescript.ast.Obj.prototype.asObj">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>asObj
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prototype = extend$((import$(Import, superclass).displayName = 'Import', Import), superclass).prototype, constructor
 = Import;
function Import(left, right, all){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.left = left;
  this$.right = right;
  this$.all = all &amp;&amp; 'All';
  if (!all &amp;&amp; left instanceof Obj &amp;&amp; right.items) {
    return Obj(left.items.concat(right.<span class="apidocCodeKeywordSpan">asObj</span>().items));
  }
  return this$;
} function ctor$(){} ctor$.prototype = prototype;
Import.prototype.children = ['left', 'right'];
Import.prototype.show = function(){
  return this.all;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.compileNode" id="apidoc.element.livescript.ast.Obj.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var items, code, idt, dic, i$, len$, i, node, logic, rest, ref$, multi, key, val;
  items = this.items;
  if (!items.length) {
    return sn(this, this.front ? '({})' : '{}');
  }
  code = [];
  idt = '\n' + (o.indent += TAB);
  dic = {};
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      code.push(idt, node.compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Splat || (node.key || node) instanceof Parens) {
      rest = items.slice(i);
      break;
    }
    if (logic) {
      if (node instanceof Prop) {
        node.val = (logic.first = node.val, logic);
      } else {
        node = Prop(node, (logic.first = node, logic));
      }
    }
    if (this.deepEq &amp;&amp; node instanceof Prop) {
      if (node.val instanceof Var &amp;&amp; node.val.value === '_') {
        node.val = Obj([Prop(Key('__placeholder__'), Literal(true))]);
      } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
        node.val.deepEq = true;
      }
    }
    if (multi) {
      code.push(',');
    } else {
      multi = true;
    }
    code.push(idt);
    if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        code.push(node.compileAccessor(o, key = key.compile(o)));
      } else {
        val.ripName(key);
        code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
      }
    } else {
      code.push(key = node.compile(o), ": ", key);
    }
    ID.test(key) || (key = Function("return " + key)());
    if (!(dic[key + "."] ^= 1)) {
      node.carp("duplicate property \"" + key + "\"");
    }
  }
  if (code.join("")) {
    code.push('\n' + this.tab);
  }
  code = sn.apply(null, [null, sn(this, "{")].concat(slice$.call(code), [sn(this, "}")]));
  rest &amp;&amp; (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
  if (this.front &amp;&amp; '{' === code.toString().charAt()) {
    return sn(null, "(", code, ")");
  } else {
    return code;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.constructor" id="apidoc.element.livescript.ast.Obj.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>constructor
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Obj(items){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.items = items || [];
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.toSlice" id="apidoc.element.livescript.ast.Obj.prototype.toSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>toSlice
        <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSlice = function (o, base, symbol, assign){
  var items, ref$, ref, temps, i$, len$, i, node, name, chain, logic, key, val;
  items = this.items;
  if (items.length &gt; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      continue;
    }
    if (node instanceof Prop || node instanceof Splat) {
      node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
    } else {
      if (logic = node.getDefault()) {
        node = node.first;
      }
      if (node instanceof Parens) {
        ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
        if (assign) {
          ref$ = [node, key], key = ref$[0], node = ref$[1];
        }
        key = Parens(key);
      } else {
        key = node;
      }
      val = chain = Chain(base, [Index(node.maybeKey(), symbol)]);
      if (logic) {
        val = (logic.first = val, logic);
      }
      items[i] = Prop(key, val);
    }
    base = ref;
  }
  chain || this.carp('empty slice');
  if (temps) {
    (chain.head = Var(temps[0])).temp = true;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &amp;&amp; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp('calling a slice');
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.<span class="apidocCodeKeywordSpan">toSlice</span>(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
};
return Chain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Obj.prototype.compileNode" id="apidoc.module.livescript.ast.Obj.prototype.compileNode">module livescript.ast.Obj.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Obj.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var items, code, idt, dic, i$, len$, i, node, logic, rest, ref$, multi, key, val;
  items = this.items;
  if (!items.length) {
    return sn(this, this.front ? '({})' : '{}');
  }
  code = [];
  idt = '\n' + (o.indent += TAB);
  dic = {};
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      code.push(idt, node.compile(o));
      continue;
    }
    if (logic = node.getDefault()) {
      node = node.first;
    }
    if (node instanceof Splat || (node.key || node) instanceof Parens) {
      rest = items.slice(i);
      break;
    }
    if (logic) {
      if (node instanceof Prop) {
        node.val = (logic.first = node.val, logic);
      } else {
        node = Prop(node, (logic.first = node, logic));
      }
    }
    if (this.deepEq &amp;&amp; node instanceof Prop) {
      if (node.val instanceof Var &amp;&amp; node.val.value === '_') {
        node.val = Obj([Prop(Key('__placeholder__'), Literal(true))]);
      } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
        node.val.deepEq = true;
      }
    }
    if (multi) {
      code.push(',');
    } else {
      multi = true;
    }
    code.push(idt);
    if (node instanceof Prop) {
      key = node.key, val = node.val;
      if (node.accessor) {
        code.push(node.compileAccessor(o, key = key.compile(o)));
      } else {
        val.ripName(key);
        code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
      }
    } else {
      code.push(key = node.compile(o), ": ", key);
    }
    ID.test(key) || (key = Function("return " + key)());
    if (!(dic[key + "."] ^= 1)) {
      node.carp("duplicate property \"" + key + "\"");
    }
  }
  if (code.join("")) {
    code.push('\n' + this.tab);
  }
  code = sn.apply(null, [null, sn(this, "{")].concat(slice$.call(code), [sn(this, "}")]));
  rest &amp;&amp; (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
  if (this.front &amp;&amp; '{' === code.toString().charAt()) {
    return sn(null, "(", code, ")");
  } else {
    return code;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Obj.prototype.toSlice" id="apidoc.module.livescript.ast.Obj.prototype.toSlice">module livescript.ast.Obj.prototype.toSlice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Obj.prototype.toSlice.toSlice" id="apidoc.element.livescript.ast.Obj.prototype.toSlice.toSlice">
        function <span class="apidocSignatureSpan">livescript.ast.Obj.prototype.</span>toSlice
        <span class="apidocSignatureSpan">(o, base, symbol, assign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSlice = function (o, base, symbol, assign){
  var items, ref$, ref, temps, i$, len$, i, node, name, chain, logic, key, val;
  items = this.items;
  if (items.length &gt; 1) {
    ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
  } else {
    ref = base;
  }
  for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
    i = i$;
    node = items[i$];
    if (node.comment) {
      continue;
    }
    if (node instanceof Prop || node instanceof Splat) {
      node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].maybeKey())]);
    } else {
      if (logic = node.getDefault()) {
        node = node.first;
      }
      if (node instanceof Parens) {
        ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
        if (assign) {
          ref$ = [node, key], key = ref$[0], node = ref$[1];
        }
        key = Parens(key);
      } else {
        key = node;
      }
      val = chain = Chain(base, [Index(node.maybeKey(), symbol)]);
      if (logic) {
        val = (logic.first = val, logic);
      }
      items[i] = Prop(key, val);
    }
    base = ref;
  }
  chain || this.carp('empty slice');
  if (temps) {
    (chain.head = Var(temps[0])).temp = true;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i = -1;
  while (tail = tails[++i]) {
    if ((ref$ = tail.key) != null &amp;&amp; ref$.items) {
      if (tails[i + 1] instanceof Call) {
        tail.carp('calling a slice');
      }
      x = tails.splice(0, i + 1);
      x = x.pop().key.<span class="apidocCodeKeywordSpan">toSlice</span>(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
      this.head = (x.front = this.front, x);
      i = -1;
    }
  }
  return this;
};
return Chain;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens" id="apidoc.module.livescript.ast.Parens">module livescript.ast.Parens</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.Parens" id="apidoc.element.livescript.ast.Parens.Parens">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Parens
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 161:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop(yy.L(_$[$0],_$[$0],yy.Key($$[$0], true)), yy.L(_$[$0-1],_$[$0-1],yy.Literal($$[$0-1] === &amp;#
x27;+'))));
break;
case 168:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-2]);
break;
case 169:
this.$ = yy.L(_$[$0-2], _$[$0],yy.<span class="apidocCodeKeywordSpan">Parens</span>($$[$0-1].chomp().unwrap(), false, $$[$0-2] === &amp;#
x27;"', yy.L(_$[$0-2],_$[$0-2],{}), yy.L(_$[$0],_$[$0],{})));
break;
case 173: case 209: case 211:
this.$ = yy.L(_$[$0], _$[$0],null);
break;
case 174: case 208: case 210:
this.$ = yy.L(_$[$0-1], _$[$0],$$[$0]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.superclass" id="apidoc.element.livescript.ast.Parens.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype" id="apidoc.module.livescript.ast.Parens.prototype">module livescript.ast.Parens.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.compile" id="apidoc.element.livescript.ast.Parens.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var it;
  level == null &amp;&amp; (level = o.level);
  it = this.it;
  it.cond || (it.cond = this.cond), it['void'] || (it['void'] = this['void']);
  if (this.calling &amp;&amp; (!level || this['void'])) {
    it.head.hushed = true;
  }
  if (!(this.keep || this.newed || level &gt;= LEVEL_OP + PREC[it.op])) {
    return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
  }
  if (it.isStatement()) {
    return it.compileClosure(o);
  } else {
    return sn(null, sn(this.lb, "("), it.compile(o, LEVEL_PAREN), sn(this.rb, ")"));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.constructor" id="apidoc.element.livescript.ast.Parens.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it, keep, string, lb, rb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parens(it, keep, string, lb, rb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.keep = keep;
  this$.string = string;
  this$.lb = lb;
  this$.rb = rb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isArray" id="apidoc.element.livescript.ast.Parens.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isArray
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isCallable" id="apidoc.element.livescript.ast.Parens.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isComplex" id="apidoc.element.livescript.ast.Parens.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isComplex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isRegex" id="apidoc.element.livescript.ast.Parens.prototype.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isString" id="apidoc.element.livescript.ast.Parens.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  return this.string || this.it.isString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.show" id="apidoc.element.livescript.ast.Parens.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.string &amp;&amp; '""';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.unparen" id="apidoc.element.livescript.ast.Parens.prototype.unparen">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>unparen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unparen = function (){
  if (this.keep) {
    return this;
  } else {
    return this.it.unparen();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Block.prototype.children = ['lines'];
Block.prototype.toJSON = function(){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
};
Block.prototype.add = function(it){
  var that, ref$;
  it = it.<span class="apidocCodeKeywordSpan">unparen</span>();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.compile" id="apidoc.module.livescript.ast.Parens.prototype.compile">module livescript.ast.Parens.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.compile.compile" id="apidoc.element.livescript.ast.Parens.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var it;
  level == null &amp;&amp; (level = o.level);
  it = this.it;
  it.cond || (it.cond = this.cond), it['void'] || (it['void'] = this['void']);
  if (this.calling &amp;&amp; (!level || this['void'])) {
    it.head.hushed = true;
  }
  if (!(this.keep || this.newed || level &gt;= LEVEL_OP + PREC[it.op])) {
    return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
  }
  if (it.isStatement()) {
    return it.compileClosure(o);
  } else {
    return sn(null, sn(this.lb, "("), it.compile(o, LEVEL_PAREN), sn(this.rb, ")"));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.isComplex" id="apidoc.module.livescript.ast.Parens.prototype.isComplex">module livescript.ast.Parens.prototype.isComplex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isComplex.isComplex" id="apidoc.element.livescript.ast.Parens.prototype.isComplex.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isComplex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.isRegex" id="apidoc.module.livescript.ast.Parens.prototype.isRegex">module livescript.ast.Parens.prototype.isRegex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isRegex.isRegex" id="apidoc.element.livescript.ast.Parens.prototype.isRegex.isRegex">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isRegex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.isString() || this.<span class="apidocCodeKeywordSpan">isRegex</span>();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.isString" id="apidoc.module.livescript.ast.Parens.prototype.isString">module livescript.ast.Parens.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.isString.isString" id="apidoc.element.livescript.ast.Parens.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  return this.string || this.it.isString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.show" id="apidoc.module.livescript.ast.Parens.prototype.show">module livescript.ast.Parens.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.show.show" id="apidoc.element.livescript.ast.Parens.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.string &amp;&amp; '""';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Parens.prototype.unparen" id="apidoc.module.livescript.ast.Parens.prototype.unparen">module livescript.ast.Parens.prototype.unparen</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Parens.prototype.unparen.unparen" id="apidoc.element.livescript.ast.Parens.prototype.unparen.unparen">
        function <span class="apidocSignatureSpan">livescript.ast.Parens.prototype.</span>unparen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unparen = function (){
  if (this.keep) {
    return this;
  } else {
    return this.it.unparen();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Block.prototype.children = ['lines'];
Block.prototype.toJSON = function(){
  delete this.back;
  return superclass.prototype.toJSON.call(this);
};
Block.prototype.add = function(it){
  var that, ref$;
  it = it.<span class="apidocCodeKeywordSpan">unparen</span>();
  switch (false) {
  case !(that = this.back):
    that.add(it);
    break;
  case !(that = it.lines):
    (ref$ = this.lines).push.apply(ref$, that);
    break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop" id="apidoc.module.livescript.ast.Prop">module livescript.ast.Prop</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.Prop" id="apidoc.element.livescript.ast.Prop.Prop">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Prop
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === '...') {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
    }
    this$['accessor'] = 'accessor';
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 144: case 145:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
break;
case 146:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
break;
case 150:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Prop</span>(yy.L(_$[$0],_$[$0],yy.Key($$[$0], $$[$0] !== '
;arguments' &amp;&amp; $$[$0] !== 'eval')), yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
case 151:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain($$[$0-2], [yy.L(_$[$0-1],_$[$0], yy.Index($$[$0], $$[$0-1]))])));
break;
case 152:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Prop($$[$0], yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Literal($$[$0-2])), [yy.L(_$[$0-1],_$[$0], yy.
Index($$[$0], $$[$0-1]))])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.superclass" id="apidoc.element.livescript.ast.Prop.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype" id="apidoc.module.livescript.ast.Prop.prototype">module livescript.ast.Prop.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.assigns" id="apidoc.element.livescript.ast.Prop.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  var ref$;
  return typeof (ref$ = this.val).assigns == 'function' ? ref$.assigns(it) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor" id="apidoc.element.livescript.ast.Prop.prototype.compileAccessor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileAccessor
        <span class="apidocSignatureSpan">(o, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAccessor = function (o, key){
  var funs, code, i$, len$, fun;
  funs = this.val;
  if (funs[1] &amp;&amp; funs[0].params.length + funs[1].params.length !== 1) {
    funs[0].carp('invalid accessor parameter');
  }
  code = [];
  for (i$ = 0, len$ = funs.length; i$ &lt; len$; ++i$) {
    fun = funs[i$];
    fun.accessor = true;
    code.push(fun.x, "et ", key, fun.compile(o, LEVEL_LIST).toString().slice(8), ',\n' + o.indent);
  }
  code.pop();
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  multi = true;
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.<span class="apidocCodeKeywordSpan">compileAccessor</span>(o, key = key.compile(o)));
  } else {
    val.ripName(key);
    code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), ": ", key);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor" id="apidoc.element.livescript.ast.Prop.prototype.compileDescriptor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileDescriptor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDescriptor = function (o){
  var obj, i$, ref$, len$, fun;
  obj = Obj();
  for (i$ = 0, len$ = (ref$ = this.val).length; i$ &lt; len$; ++i$) {
    fun = ref$[i$];
    obj.items.push(Prop(Key(fun.x + 'et'), fun));
  }
  obj.items.push(Prop(Key('configurable'), Literal(true)));
  obj.items.push(Prop(Key('enumerable'), Literal(true)));
  return obj.compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
} else if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    if (key instanceof Key) {
      key = JS("'" + key.name + "'");
    }
    code.push("Object.defineProperty(", reft.compile(o, LEVEL_LIST), ", ", key.compile(o, LEVEL_LIST), "
;, ", node.<span class="apidocCodeKeywordSpan">compileDescriptor</span>(o), ")");
    continue;
  }
} else {
  key = val = node;
}
dyna || (key = key.maybeKey());
logic &amp;&amp; (val = (logic.first = val, logic));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.constructor" id="apidoc.element.livescript.ast.Prop.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>constructor
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Prop(key, val){
  var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
  this$.key = key;
  this$.val = val;
  if (key.value === '...') {
    return Splat(this$.val);
  }
  if (that = val.getAccessors()) {
    this$.val = that;
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      fun = that[i$];
      fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
    }
    this$['accessor'] = 'accessor';
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.show" id="apidoc.element.livescript.ast.Prop.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.accessor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype.assigns" id="apidoc.module.livescript.ast.Prop.prototype.assigns">module livescript.ast.Prop.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Prop.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  var ref$;
  return typeof (ref$ = this.val).assigns == 'function' ? ref$.assigns(it) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype.compileAccessor" id="apidoc.module.livescript.ast.Prop.prototype.compileAccessor">module livescript.ast.Prop.prototype.compileAccessor</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileAccessor.compileAccessor" id="apidoc.element.livescript.ast.Prop.prototype.compileAccessor.compileAccessor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileAccessor
        <span class="apidocSignatureSpan">(o, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAccessor = function (o, key){
  var funs, code, i$, len$, fun;
  funs = this.val;
  if (funs[1] &amp;&amp; funs[0].params.length + funs[1].params.length !== 1) {
    funs[0].carp('invalid accessor parameter');
  }
  code = [];
  for (i$ = 0, len$ = funs.length; i$ &lt; len$; ++i$) {
    fun = funs[i$];
    fun.accessor = true;
    code.push(fun.x, "et ", key, fun.compile(o, LEVEL_LIST).toString().slice(8), ',\n' + o.indent);
  }
  code.pop();
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  multi = true;
}
code.push(idt);
if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    code.push(node.<span class="apidocCodeKeywordSpan">compileAccessor</span>(o, key = key.compile(o)));
  } else {
    val.ripName(key);
    code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
  }
} else {
  code.push(key = node.compile(o), ": ", key);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype.compileDescriptor" id="apidoc.module.livescript.ast.Prop.prototype.compileDescriptor">module livescript.ast.Prop.prototype.compileDescriptor</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.compileDescriptor.compileDescriptor" id="apidoc.element.livescript.ast.Prop.prototype.compileDescriptor.compileDescriptor">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>compileDescriptor
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileDescriptor = function (o){
  var obj, i$, ref$, len$, fun;
  obj = Obj();
  for (i$ = 0, len$ = (ref$ = this.val).length; i$ &lt; len$; ++i$) {
    fun = ref$[i$];
    obj.items.push(Prop(Key(fun.x + 'et'), fun));
  }
  obj.items.push(Prop(Key('configurable'), Literal(true)));
  obj.items.push(Prop(Key('enumerable'), Literal(true)));
  return obj.compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ref$ = node.it.cache(o, true), key = ref$[0], val = ref$[1];
} else if (node instanceof Prop) {
  key = node.key, val = node.val;
  if (node.accessor) {
    if (key instanceof Key) {
      key = JS("'" + key.name + "'");
    }
    code.push("Object.defineProperty(", reft.compile(o, LEVEL_LIST), ", ", key.compile(o, LEVEL_LIST), "
;, ", node.<span class="apidocCodeKeywordSpan">compileDescriptor</span>(o), ")");
    continue;
  }
} else {
  key = val = node;
}
dyna || (key = key.maybeKey());
logic &amp;&amp; (val = (logic.first = val, logic));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Prop.prototype.show" id="apidoc.module.livescript.ast.Prop.prototype.show">module livescript.ast.Prop.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Prop.prototype.show.show" id="apidoc.element.livescript.ast.Prop.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Prop.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.accessor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Require" id="apidoc.module.livescript.ast.Require">module livescript.ast.Require</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Require.Require" id="apidoc.element.livescript.ast.Require.Require">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Require
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS("Error('unimplemented')"))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Require</span>($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
case 72:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require.superclass" id="apidoc.element.livescript.ast.Require.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Require.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Require.prototype" id="apidoc.module.livescript.ast.Require.prototype">module livescript.ast.Require.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Require.prototype.compile" id="apidoc.element.livescript.ast.Require.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
  getValue = function(item, throwError){
    switch (false) {
    case !(item instanceof Key):
      return item.name;
    case !(item instanceof Var):
      return item.value;
    case !(item instanceof Literal):
      return item.value;
    default:
      if (throwError) {
        return this$.carp('invalid require! argument');
      } else {
        return item;
      }
    }
  };
  processItem = function(item){
    var ref$, asg, value, asgValue, toAsg, main;
    ref$ = (function(){
      switch (false) {
      case !(item instanceof Prop):
        return [item.val, item.key];
      default:
        return [item, item];
      }
    }()), asg = ref$[0], value = ref$[1];
    asgValue = getValue(asg);
    toAsg = toString$.call(asgValue).slice(8, -1) === 'String' ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
    value = stripString(getValue(value, true));
    main = Chain(CopyL(this, Var('require'))).add(Call([Literal("'" + value + "'")]));
    return sn(item, Assign(toAsg, main).compile(o));
  };
  if (this.body.items != null) {
    code = [];
    for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ &lt; len$; ++i$) {
      item = ref$[i$];
      code.push(processItem(item), ";\n" + o.indent);
    }
    code.pop();
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, processItem(this.body));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Require.prototype.constructor" id="apidoc.element.livescript.ast.Require.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>constructor
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Require(body){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.body = body;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Require.prototype.compile" id="apidoc.module.livescript.ast.Require.prototype.compile">module livescript.ast.Require.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Require.prototype.compile.compile" id="apidoc.element.livescript.ast.Require.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Require.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
  getValue = function(item, throwError){
    switch (false) {
    case !(item instanceof Key):
      return item.name;
    case !(item instanceof Var):
      return item.value;
    case !(item instanceof Literal):
      return item.value;
    default:
      if (throwError) {
        return this$.carp('invalid require! argument');
      } else {
        return item;
      }
    }
  };
  processItem = function(item){
    var ref$, asg, value, asgValue, toAsg, main;
    ref$ = (function(){
      switch (false) {
      case !(item instanceof Prop):
        return [item.val, item.key];
      default:
        return [item, item];
      }
    }()), asg = ref$[0], value = ref$[1];
    asgValue = getValue(asg);
    toAsg = toString$.call(asgValue).slice(8, -1) === 'String' ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
    value = stripString(getValue(value, true));
    main = Chain(CopyL(this, Var('require'))).add(Call([Literal("'" + value + "'")]));
    return sn(item, Assign(toAsg, main).compile(o));
  };
  if (this.body.items != null) {
    code = [];
    for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ &lt; len$; ++i$) {
      item = ref$[i$];
      code.push(processItem(item), ";\n" + o.indent);
    }
    code.pop();
    return sn.apply(null, [null].concat(slice$.call(code)));
  } else {
    return sn(null, processItem(this.body));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Return" id="apidoc.module.livescript.ast.Return">module livescript.ast.Return</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Return.Return" id="apidoc.element.livescript.ast.Return.Return">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Return
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &amp;&amp; it.value !== 'void') {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.extended" id="apidoc.element.livescript.ast.Return.extended">
        function <span class="apidocSignatureSpan">livescript.ast.Return.</span>extended
        <span class="apidocSignatureSpan">(sub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extended = function (sub){
  sub.prototype.children = ['it'];
  this[sub.displayName.toLowerCase()] = sub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function THIS(){
return this;
}
function VOID(){}
UTILS = {
clone: 'function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}',
extend: 'function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new
fun).constructor = sub;\n  if (typeof sup.extended == \'function\') sup.<span class="apidocCodeKeywordSpan">extended</span>(sub);\n  return sub;\n}',
bind: 'function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}',
'import': 'function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj
[key] = src[key];\n  return obj;\n}',
importAll: 'function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}',
repeatString: 'function(str, n){\n  for (var r = \'\'; n &gt; 0; (n &gt;&gt;= 1) &amp;&amp; (str += str))
if (n &amp; 1) r += str;\n  return r;\n}',
repeatArray: 'function(arr, n){\n  for (var r = []; n &gt; 0; (n &gt;&gt;= 1) &amp;&amp; (arr = arr.concat(arr)))\n
    if (n &amp; 1) r.push.apply(r, arr);\n  return r;\n}',
'in': 'function(x, xs){\n  var i = -1, l = xs.length &gt;&gt;&gt; 0;\n  while (++i &lt; l) if (x === xs[i
]) return true;\n  return false;\n}',
out: 'typeof exports != \'undefined\' &amp;&amp; exports || this',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.superclass" id="apidoc.element.livescript.ast.Return.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Return.</span>superclass
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.throw" id="apidoc.element.livescript.ast.Return.throw">
        function <span class="apidocSignatureSpan">livescript.ast.Return.</span>throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Return.prototype" id="apidoc.module.livescript.ast.Return.prototype">module livescript.ast.Return.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.compileNode" id="apidoc.element.livescript.ast.Return.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that;
  return sn.apply(null, [this, "return"].concat(
    (that = this.it)
      ? [' ', that.compile(o, LEVEL_PAREN)]
      : [], [";"]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.constructor" id="apidoc.element.livescript.ast.Return.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Return(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  if (it &amp;&amp; it.value !== 'void') {
    this$.it = it;
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.getJump" id="apidoc.element.livescript.ast.Return.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Return.prototype.compileNode" id="apidoc.module.livescript.ast.Return.prototype.compileNode">module livescript.ast.Return.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Return.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Return.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Return.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that;
  return sn.apply(null, [this, "return"].concat(
    (that = this.it)
      ? [' ', that.compile(o, LEVEL_PAREN)]
      : [], [";"]
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Slice" id="apidoc.module.livescript.ast.Slice">module livescript.ast.Slice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.Slice" id="apidoc.element.livescript.ast.Slice.Slice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Slice
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &amp;&amp; (this$.from = Literal(0));
  if (this$.to &amp;&amp; this$.type === 'to') {
    this$.to = Binary('+', this$.to, Literal('1'));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        target: $$[$0-7],
        from: yy.Literal(0),
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
case 37:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], yy.<span class="apidocCodeKeywordSpan">Slice</span>({
        type: $$[$0-2],
        target: $$[$0-6],
        from: $$[$0-3],
        to: $$[$0-1]
      }))));
break;
case 38:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.superclass" id="apidoc.element.livescript.ast.Slice.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Slice.prototype" id="apidoc.module.livescript.ast.Slice.prototype">module livescript.ast.Slice.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.compileNode" id="apidoc.element.livescript.ast.Slice.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var args;
  if (this.to &amp;&amp; this.type === 'to') {
    this.to = Binary('||', this.to, Literal('9e9'));
  }
  args = [this.target, this.from];
  if (this.to) {
    args.push(this.to);
  }
  return Chain(Var(util('slice'))).add(Index(Key('call'), '.', true)).add(Call(args)).compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.constructor" id="apidoc.element.livescript.ast.Slice.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>constructor
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slice(arg$){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
  this$.from == null &amp;&amp; (this$.from = Literal(0));
  if (this$.to &amp;&amp; this$.type === 'to') {
    this$.to = Binary('+', this$.to, Literal('1'));
  }
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.show" id="apidoc.element.livescript.ast.Slice.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Slice.prototype.compileNode" id="apidoc.module.livescript.ast.Slice.prototype.compileNode">module livescript.ast.Slice.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Slice.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var args;
  if (this.to &amp;&amp; this.type === 'to') {
    this.to = Binary('||', this.to, Literal('9e9'));
  }
  args = [this.target, this.from];
  if (this.to) {
    args.push(this.to);
  }
  return Chain(Var(util('slice'))).add(Index(Key('call'), '.', true)).add(Call(args)).compile(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Slice.prototype.show" id="apidoc.module.livescript.ast.Slice.prototype.show">module livescript.ast.Slice.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Slice.prototype.show.show" id="apidoc.element.livescript.ast.Slice.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Slice.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Splat" id="apidoc.module.livescript.ast.Splat">module livescript.ast.Splat</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.Splat" id="apidoc.element.livescript.ast.Splat.Splat">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Splat
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 54: case 167:
this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat($$[$0]));
break;
case 55:
this.$ = yy.L(_$[$0-5], _$[$0-2],$$[$0-5].concat($$[$0-2]));
break;
case 57: case 162:
this.$ = yy.L(_$[$0-1], _$[$0],yy.<span class="apidocCodeKeywordSpan">Splat</span>($$[$0]));
break;
case 58:
this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
break;
case 61:
this.$ = yy.L(_$[$0], _$[$0],yy.Block());
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.compileArray" id="apidoc.element.livescript.ast.Splat.compileArray">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>compileArray
        <span class="apidocSignatureSpan">(o, list, apply)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileArray = function (o, list, apply){
  var index, i$, len$, node, args, atoms, ref$;
  expand(list);
  index = 0;
  for (i$ = 0, len$ = list.length; i$ &lt; len$; ++i$) {
    node = list[i$];
    if (node instanceof Splat) {
      break;
    }
    ++index;
  }
  if (index &gt;= list.length) {
    return sn(this, '');
  }
  if (!list[1]) {
    return sn(this, (apply ? Object : ensureArray)(list[0].it).compile(o, LEVEL_LIST));
  }
  args = [];
  atoms = [];
  for (i$ = 0, len$ = (ref$ = list.splice(index, 9e9)).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node instanceof Splat) {
      if (atoms.length) {
        args.push(Arr(atoms.splice(0, 9e9)));
      }
      args.push(ensureArray(node.it));
    } else {
      atoms.push(node);
    }
  }
  if (atoms.length) {
    args.push(Arr(atoms));
  }
  return sn(null, (index
    ? Arr(list)
    : args.shift()).compile(o, LEVEL_CALL), sn(this, ".concat("), List.compile(o, args), sn(this, ")"));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
tails = this.tails;
i = -1;
while (call = tails[++i]) {
  if (!(args = call.args)) {
    continue;
  }
  ctx = call.method === '.call' &amp;&amp; (args = args.concat()).shift();
  if (!!snEmpty(args = Splat.<span class="apidocCodeKeywordSpan">compileArray</span>(o, args, true))) {
    continue;
  }
  if (call['new']) {
    this.splattedNewArgs = args;
  } else {
    if (!ctx &amp;&amp; tails[i - 1] instanceof Index) {
      ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.superclass" id="apidoc.element.livescript.ast.Splat.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Splat.prototype" id="apidoc.module.livescript.ast.Splat.prototype">module livescript.ast.Splat.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.assigns" id="apidoc.element.livescript.ast.Splat.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return this.it.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.compile" id="apidoc.element.livescript.ast.Splat.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return this.carp('invalid splat');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.constructor" id="apidoc.element.livescript.ast.Splat.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it, filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Splat(it, filler){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  this$.filler = filler;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.isAssignable" id="apidoc.element.livescript.ast.Splat.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.isComplex" id="apidoc.element.livescript.ast.Splat.prototype.isComplex">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>isComplex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComplex = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return results$;
    }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
  }
  return list.compile(o, LEVEL_PAREN);
},
cache: function(o, once, level){
  var ref$, sub, ref;
  if (!this.<span class="apidocCodeKeywordSpan">isComplex</span>()) {
    return [ref$ = level != null ? this.compile(o, level) : this, ref$];
  }
  sub = Assign(ref = Var(o.scope.temporary()), this);
  if (level != null) {
    sub = sub.compile(o, level);
    if (once) {
      o.scope.free(ref.value);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Splat.prototype.assigns" id="apidoc.module.livescript.ast.Splat.prototype.assigns">module livescript.ast.Splat.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Splat.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return this.it.assigns(it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Splat.prototype.compile" id="apidoc.module.livescript.ast.Splat.prototype.compile">module livescript.ast.Splat.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Splat.prototype.compile.compile" id="apidoc.element.livescript.ast.Splat.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Splat.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return this.carp('invalid splat');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.StepSlice" id="apidoc.module.livescript.ast.StepSlice">module livescript.ast.StepSlice</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.StepSlice" id="apidoc.element.livescript.ast.StepSlice.StepSlice">
        function <span class="apidocSignatureSpan">livescript.ast.</span>StepSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        op: $$[$0-4],
        to: $$[$0-3],
        step: $$[$0-1],
        inComprehension: true
      }))));
break;
case 35:
this.$ = yy.L(_$[$0-8], _$[$0],yy.Chain(yy.L(_$[$0-8],_$[$0], new yy.<span class="apidocCodeKeywordSpan">StepSlice</span>({
        op: $$[$0-4],
        target: $$[$0-8],
        from: $$[$0-5],
        to: $$[$0-3],
        step: $$[$0-1]
      }))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.superclass" id="apidoc.element.livescript.ast.StepSlice.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.</span>superclass
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function For(it){
  var i$, x$, ref$, len$;
  importAll$(this, it);
  if (this.item instanceof Var &amp;&amp; !this.item.value) {
    this.item = null;
  }
  for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ &lt; len$; ++i$) {
    x$ = ref$[i$];
    this[x$] = true;
  }
  if (this.own &amp;&amp; !this.object) {
    this.carp('`for own` requires `of`');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.StepSlice.prototype" id="apidoc.module.livescript.ast.StepSlice.prototype">module livescript.ast.StepSlice.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode" id="apidoc.element.livescript.ast.StepSlice.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var ref$, sub, ref, temps, code;
  this.index = o.scope.temporary('x');
  ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
  this.guard = Binary('&lt;', Literal(this.index), Chain(ref).add(Index(Key('length'))));
  this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
  if (this.makeReturnArg != null) {
    this.makeReturn(this.makeReturnArg);
  }
  code = [];
  if (temps) {
    code.push(sub.compile(o), ';' + '\n' + o.indent);
  }
  code.push(superclass.prototype.compileNode.apply(this, arguments));
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.constructor" id="apidoc.element.livescript.ast.StepSlice.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StepSlice(){
  StepSlice.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn" id="apidoc.element.livescript.ast.StepSlice.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(makeReturnArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (makeReturnArg){
  this.makeReturnArg = makeReturnArg;
  return superclass.prototype.makeReturn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.StepSlice.prototype.compileNode" id="apidoc.module.livescript.ast.StepSlice.prototype.compileNode">module livescript.ast.StepSlice.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.StepSlice.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var ref$, sub, ref, temps, code;
  this.index = o.scope.temporary('x');
  ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
  this.guard = Binary('&lt;', Literal(this.index), Chain(ref).add(Index(Key('length'))));
  this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
  if (this.makeReturnArg != null) {
    this.makeReturn(this.makeReturnArg);
  }
  code = [];
  if (temps) {
    code.push(sub.compile(o), ';' + '\n' + o.indent);
  }
  code.push(superclass.prototype.compileNode.apply(this, arguments));
  return sn.apply(null, [this].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.StepSlice.prototype.makeReturn" id="apidoc.module.livescript.ast.StepSlice.prototype.makeReturn">module livescript.ast.StepSlice.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.StepSlice.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.StepSlice.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.StepSlice.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(makeReturnArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (makeReturnArg){
  this.makeReturnArg = makeReturnArg;
  return superclass.prototype.makeReturn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Super" id="apidoc.module.livescript.ast.Super">module livescript.ast.Super</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Super.Super" id="apidoc.element.livescript.ast.Super.Super">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.superclass" id="apidoc.element.livescript.ast.Super.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Super.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Super.prototype" id="apidoc.module.livescript.ast.Super.prototype">module livescript.ast.Super.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.compile" id="apidoc.element.livescript.ast.Super.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var scope, that, result, ref$;
  scope = o.scope;
  if (!this.sproto) {
    for (; that = !scope.get('superclass') &amp;&amp; scope.fun; scope = scope.parent) {
      result = that;
      if (that = result.meth) {
        return sn(this, 'superclass.prototype', Index(that).compile(o));
      }
      if (that = result.stat) {
        return sn(this, 'superclass', Index(that).compile(o));
      }
      if (that = scope.fun.inClass) {
        return sn(this, that, ".superclass.prototype.", scope.fun.name);
      } else if (that = scope.fun.inClassStatic) {
        return sn(this, that, ".superclass.", scope.fun.name);
      }
    }
    if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
      return sn(this, that, ".superclass");
    }
  }
  return sn(this, 'superclass');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.constructor" id="apidoc.element.livescript.ast.Super.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Super(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.isCallable" id="apidoc.element.livescript.ast.Super.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Super.prototype.compile" id="apidoc.module.livescript.ast.Super.prototype.compile">module livescript.ast.Super.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Super.prototype.compile.compile" id="apidoc.element.livescript.ast.Super.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Super.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  var scope, that, result, ref$;
  scope = o.scope;
  if (!this.sproto) {
    for (; that = !scope.get('superclass') &amp;&amp; scope.fun; scope = scope.parent) {
      result = that;
      if (that = result.meth) {
        return sn(this, 'superclass.prototype', Index(that).compile(o));
      }
      if (that = result.stat) {
        return sn(this, 'superclass', Index(that).compile(o));
      }
      if (that = scope.fun.inClass) {
        return sn(this, that, ".superclass.prototype.", scope.fun.name);
      } else if (that = scope.fun.inClassStatic) {
        return sn(this, that, ".superclass.", scope.fun.name);
      }
    }
    if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
      return sn(this, that, ".superclass");
    }
  }
  return sn(this, 'superclass');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch" id="apidoc.module.livescript.ast.Switch">module livescript.ast.Switch</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.Switch" id="apidoc.element.livescript.ast.Switch.Switch">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Switch
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this['default'] = $default;
  if (type === 'match') {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &gt; 1) {
        throw "can't have more than one topic in switch statement";
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &amp;&amp; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &amp;&amp; last.tests[0] instanceof Var &amp;&amp; last
.tests[0].value === '_') {
    this.cases.pop();
    this['default'] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 126:
this.$ = yy.L(_$[$0], _$[$0],new yy.Jump($$[$0]));
break;
case 127:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
break;
case 128:
this.$ = yy.L(_$[$0-2], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Switch</span>($$[$0-2], $$[$0-1], $$[$0]));
break;
case 129: case 130:
this.$ = yy.L(_$[$0-4], _$[$0],new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]));
break;
case 131:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, $$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.superclass" id="apidoc.element.livescript.ast.Switch.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype" id="apidoc.module.livescript.ast.Switch.prototype">module livescript.ast.Switch.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.compileNode" id="apidoc.element.livescript.ast.Switch.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var tab, ref$, targetNode, target, topic, t, code, stop, i$, len$, i, c, that;
  tab = this.tab;
  if (this.target) {
    ref$ = Chain(this.target).cacheReference(o), targetNode = ref$[0], target = ref$[1];
  }
  topic = this.type === 'match'
    ? (t = target
      ? [targetNode]
      : [], Block(t.concat([Literal('false')])).compile(o, LEVEL_PAREN))
    : !!this.topic &amp;&amp; this.anaphorize().compile(o, LEVEL_PAREN);
  code = [sn(this, "switch (", snSafe(topic), ") {\n")];
  stop = this['default'] || this.cases.length - 1;
  o['break'] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    i = i$;
    c = ref$[i$];
    code.push(c.compileCase(o, tab, i === stop, this.type === 'match' || !topic, this.type, target));
  }
  if (this['default']) {
    o.indent = tab + TAB;
    if (that = this['default'].compile(o, LEVEL_TOP)) {
      code.push(tab + "default:\n", that, "\n");
    }
  }
  return sn.apply(null, [null].concat(slice$.call(code), [tab + '}']));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.constructor" id="apidoc.element.livescript.ast.Switch.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>constructor
        <span class="apidocSignatureSpan">(type, topic, cases, $default)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Switch(type, topic, cases, $default){
  var last, ref$;
  this.type = type;
  this.topic = topic;
  this.cases = cases;
  this['default'] = $default;
  if (type === 'match') {
    if (topic) {
      this.target = Arr(topic);
    }
    this.topic = null;
  } else {
    if (topic) {
      if (topic.length &gt; 1) {
        throw "can't have more than one topic in switch statement";
      }
      this.topic = this.topic[0];
    }
  }
  if (this.cases.length &amp;&amp; (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 &amp;&amp; last.tests[0] instanceof Var &amp;&amp; last
.tests[0].value === '_') {
    this.cases.pop();
    this['default'] = last.body;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.getJump" id="apidoc.element.livescript.ast.Switch.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var i$, ref$, len$, c, that;
  ctx || (ctx = {});
  ctx['break'] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    c = ref$[i$];
    if (that = c.body.getJump(ctx)) {
      return that;
    }
  }
  return (ref$ = this['default']) != null ? ref$.getJump(ctx) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.isCallable" id="apidoc.element.livescript.ast.Switch.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    c = ref$[i$];
    if (!c.isCallable()) {
      return false;
    }
  }
  if (this['default']) {
    return this['default'].isCallable();
  } else {
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.isStatement" id="apidoc.element.livescript.ast.Switch.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn" id="apidoc.element.livescript.ast.Switch.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    c = ref$[i$];
    c.makeReturn.apply(c, arguments);
  }
  if ((ref$ = this['default']) != null) {
    ref$.makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.show" id="apidoc.element.livescript.ast.Switch.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype.compileNode" id="apidoc.module.livescript.ast.Switch.prototype.compileNode">module livescript.ast.Switch.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Switch.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var tab, ref$, targetNode, target, topic, t, code, stop, i$, len$, i, c, that;
  tab = this.tab;
  if (this.target) {
    ref$ = Chain(this.target).cacheReference(o), targetNode = ref$[0], target = ref$[1];
  }
  topic = this.type === 'match'
    ? (t = target
      ? [targetNode]
      : [], Block(t.concat([Literal('false')])).compile(o, LEVEL_PAREN))
    : !!this.topic &amp;&amp; this.anaphorize().compile(o, LEVEL_PAREN);
  code = [sn(this, "switch (", snSafe(topic), ") {\n")];
  stop = this['default'] || this.cases.length - 1;
  o['break'] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    i = i$;
    c = ref$[i$];
    code.push(c.compileCase(o, tab, i === stop, this.type === 'match' || !topic, this.type, target));
  }
  if (this['default']) {
    o.indent = tab + TAB;
    if (that = this['default'].compile(o, LEVEL_TOP)) {
      code.push(tab + "default:\n", that, "\n");
    }
  }
  return sn.apply(null, [null].concat(slice$.call(code), [tab + '}']));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype.getJump" id="apidoc.module.livescript.ast.Switch.prototype.getJump">module livescript.ast.Switch.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Switch.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var i$, ref$, len$, c, that;
  ctx || (ctx = {});
  ctx['break'] = true;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    c = ref$[i$];
    if (that = c.body.getJump(ctx)) {
      return that;
    }
  }
  return (ref$ = this['default']) != null ? ref$.getJump(ctx) : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype.isCallable" id="apidoc.module.livescript.ast.Switch.prototype.isCallable">module livescript.ast.Switch.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Switch.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    c = ref$[i$];
    if (!c.isCallable()) {
      return false;
    }
  }
  if (this['default']) {
    return this['default'].isCallable();
  } else {
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype.makeReturn" id="apidoc.module.livescript.ast.Switch.prototype.makeReturn">module livescript.ast.Switch.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Switch.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var i$, ref$, len$, c;
  for (i$ = 0, len$ = (ref$ = this.cases).length; i$ &lt; len$; ++i$) {
    c = ref$[i$];
    c.makeReturn.apply(c, arguments);
  }
  if ((ref$ = this['default']) != null) {
    ref$.makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Switch.prototype.show" id="apidoc.module.livescript.ast.Switch.prototype.show">module livescript.ast.Switch.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Switch.prototype.show.show" id="apidoc.element.livescript.ast.Switch.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Switch.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Throw" id="apidoc.module.livescript.ast.Throw">module livescript.ast.Throw</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.Throw" id="apidoc.element.livescript.ast.Throw.Throw">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Throw
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 67:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.
test($$[$0-1])));
break;
case 68: case 163:
this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
break;
case 69:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Throw</span>(yy.L(_$[$0],_$[$0],yy.JS("Error('unimplemented
')"))));
break;
case 70:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
break;
case 71:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.extended" id="apidoc.element.livescript.ast.Throw.extended">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>extended
        <span class="apidocSignatureSpan">(sub)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extended = function (sub){
  sub.prototype.children = ['it'];
  this[sub.displayName.toLowerCase()] = sub;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function THIS(){
return this;
}
function VOID(){}
UTILS = {
clone: 'function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}',
extend: 'function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new
fun).constructor = sub;\n  if (typeof sup.extended == \'function\') sup.<span class="apidocCodeKeywordSpan">extended</span>(sub);\n  return sub;\n}',
bind: 'function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}',
'import': 'function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj
[key] = src[key];\n  return obj;\n}',
importAll: 'function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}',
repeatString: 'function(str, n){\n  for (var r = \'\'; n &gt; 0; (n &gt;&gt;= 1) &amp;&amp; (str += str))
if (n &amp; 1) r += str;\n  return r;\n}',
repeatArray: 'function(arr, n){\n  for (var r = []; n &gt; 0; (n &gt;&gt;= 1) &amp;&amp; (arr = arr.concat(arr)))\n
    if (n &amp; 1) r.push.apply(r, arr);\n  return r;\n}',
'in': 'function(x, xs){\n  var i = -1, l = xs.length &gt;&gt;&gt; 0;\n  while (++i &lt; l) if (x === xs[i
]) return true;\n  return false;\n}',
out: 'typeof exports != \'undefined\' &amp;&amp; exports || this',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.superclass" id="apidoc.element.livescript.ast.Throw.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.</span>superclass
        <span class="apidocSignatureSpan">(verb, label)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Jump(verb, label){
  this.verb = verb;
  this.label = label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Throw.prototype" id="apidoc.module.livescript.ast.Throw.prototype">module livescript.ast.Throw.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.compileNode" id="apidoc.element.livescript.ast.Throw.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var ref$;
  return sn(this, "throw ", ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || 'null', ";");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.constructor" id="apidoc.element.livescript.ast.Throw.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>constructor
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Throw(it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.getJump" id="apidoc.element.livescript.ast.Throw.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Throw.prototype.compileNode" id="apidoc.module.livescript.ast.Throw.prototype.compileNode">module livescript.ast.Throw.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Throw.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var ref$;
  return sn(this, "throw ", ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || 'null', ";");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Throw.prototype.getJump" id="apidoc.module.livescript.ast.Throw.prototype.getJump">module livescript.ast.Throw.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Throw.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Throw.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Throw.prototype.</span>getJump
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VOID(){}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try" id="apidoc.module.livescript.ast.Try">module livescript.ast.Try</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.Try" id="apidoc.element.livescript.ast.Try.Try">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Try
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var('e'), Var('e$')));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 132: case 133:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]));
break;
case 134:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, [], $$[$0]));
break;
case 135:
this.$ = yy.L(_$[$0-1], _$[$0],new yy.<span class="apidocCodeKeywordSpan">Try</span>($$[$0]));
break;
case 136:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
case 137:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.Try($$[$0-4], void 8, yy.L(_$[$0-3],_$[$0-3],$$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.superclass" id="apidoc.element.livescript.ast.Try.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Try.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype" id="apidoc.module.livescript.ast.Try.prototype">module livescript.ast.Try.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.compileNode" id="apidoc.element.livescript.ast.Try.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var code, that;
  o.indent += TAB;
  code = [sn(this, 'try '), this.compileBlock(o, this.attempt)];
  if (that = this.recovery || !this.ensure &amp;&amp; JS('')) {
    code.push(sn(that, ' catch (e$) '), this.compileBlock(o, that));
  }
  if (that = this.ensure) {
    code.push(sn(that, ' finally '), this.compileBlock(o, that));
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.constructor" id="apidoc.element.livescript.ast.Try.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>constructor
        <span class="apidocSignatureSpan">(attempt, thrown, recovery, ensure)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Try(attempt, thrown, recovery, ensure){
  var ref$;
  this.attempt = attempt;
  this.thrown = thrown;
  this.recovery = recovery;
  this.ensure = ensure;
  if ((ref$ = this.recovery) != null) {
    ref$.lines.unshift(Assign(this.thrown || Var('e'), Var('e$')));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.getJump" id="apidoc.element.livescript.ast.Try.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var ref$;
  return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.isCallable" id="apidoc.element.livescript.ast.Try.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) &amp;&amp; this.attempt.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.isStatement" id="apidoc.element.livescript.ast.Try.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.makeReturn" id="apidoc.element.livescript.ast.Try.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
  if (this.recovery != null) {
    this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.show" id="apidoc.element.livescript.ast.Try.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.thrown;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype.compileNode" id="apidoc.module.livescript.ast.Try.prototype.compileNode">module livescript.ast.Try.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Try.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var code, that;
  o.indent += TAB;
  code = [sn(this, 'try '), this.compileBlock(o, this.attempt)];
  if (that = this.recovery || !this.ensure &amp;&amp; JS('')) {
    code.push(sn(that, ' catch (e$) '), this.compileBlock(o, that));
  }
  if (that = this.ensure) {
    code.push(sn(that, ' finally '), this.compileBlock(o, that));
  }
  return sn.apply(null, [null].concat(slice$.call(code)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype.getJump" id="apidoc.module.livescript.ast.Try.prototype.getJump">module livescript.ast.Try.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.getJump.getJump" id="apidoc.element.livescript.ast.Try.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>getJump
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (it){
  var ref$;
  return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype.isCallable" id="apidoc.module.livescript.ast.Try.prototype.isCallable">module livescript.ast.Try.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Try.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) &amp;&amp; this.attempt.isCallable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype.makeReturn" id="apidoc.module.livescript.ast.Try.prototype.makeReturn">module livescript.ast.Try.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.Try.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (){
  var ref$;
  this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
  if (this.recovery != null) {
    this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Try.prototype.show" id="apidoc.module.livescript.ast.Try.prototype.show">module livescript.ast.Try.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Try.prototype.show.show" id="apidoc.element.livescript.ast.Try.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Try.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return this.thrown;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary" id="apidoc.module.livescript.ast.Unary">module livescript.ast.Unary</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.Unary" id="apidoc.element.livescript.ast.Unary.Unary">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Unary
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &amp;&amp; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case '!':
      if (flag) {
        break;
      }
      if (it instanceof Fun &amp;&amp; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case '++':
    case '--':
      if (flag) {
        this$.post = true;
      }
      break;
    case 'new':
      if (it instanceof Existence &amp;&amp; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || '').length; i$ &lt; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &amp;&amp; !node['new']) {
          if (node.method === '.call') {
            node.args.shift();
          }
          node['new'] = 'new';
          node.method = '';
          return it;
        }
      }
      break;
    case '~':
      if (it instanceof Fun &amp;&amp; it.statement &amp;&amp; !it.bound) {
        return it.bound = 'this$', it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 21:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-5],yy.Binary($$[$0-5], void 8, $$[$0-3]))));
break;
case 23:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-4]))));
break;
case 24: case 25:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.<span class="apidocCodeKeywordSpan">Unary</span>($$[$0-1]))));
break;
case 26:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
break;
case 27:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.superclass" id="apidoc.element.livescript.ast.Unary.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype" id="apidoc.module.livescript.ast.Unary.prototype">module livescript.ast.Unary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc" id="apidoc.element.livescript.ast.Unary.prototype.compileAsFunc">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileAsFunc
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAsFunc = function (o){
  if (this.op === '!') {
    return sn(this, util('not'));
  } else {
    return sn(this, "(", Fun([], Block(Unary(this.op, Chain(Var('it'))))).compile(o), ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    '++': 'in',
    '--': 'de'
  }[it] + 'crement';
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.<span class="apidocCodeKeywordSpan">compileAsFunc</span>(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case '!':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileNode" id="apidoc.element.livescript.ast.Unary.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case '!':
    it.cond = true;
    break;
  case 'new':
    it.isCallable() || it.carp('invalid constructor');
    break;
  case 'do':
    if (o.level === LEVEL_TOP &amp;&amp; it instanceof Fun &amp;&amp; it.isStatement()) {
      return sn(this, it.compile(o), " ", Unary('do', Var(it.name)).compile(o));
    }
    x = Parens(it instanceof Existence &amp;&amp; !it.negated
      ? Chain(it).add(Call())
      : Call.make(it));
    return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
  case 'delete':
    if (it instanceof Var || !it.isAssignable()) {
      this.carp('invalid delete');
    }
    if (o.level &amp;&amp; !this['void']) {
      return this.compilePluck(o);
    }
    break;
  case '++':
  case '--':
    it.isAssignable() || this.carp('invalid ' + crement(op));
    if (that = it instanceof Var &amp;&amp; o.scope.checkReadOnly(it.value)) {
      this.carp(crement(op) + " of " + that + " \"" + it.value + "\"", ReferenceError);
    }
    if (this.post) {
      it.front = this.front;
    }
    break;
  case '^^':
    return sn(this, util('clone'), "(", it.compile(o, LEVEL_LIST), ")");
  case 'jsdelete':
    return sn(this, "delete ", it.compile(o, LEVEL_LIST));
  case 'classof':
    return sn(this, util('toString'), ".call(", it.compile(o, LEVEL_LIST), ").slice(8, -1)");
  }
  code = [it.compile(o, LEVEL_OP + PREC.unary)];
  if (this.post) {
    code.push(op);
  } else {
    if ((op === 'new' || op === 'typeof' || op === 'delete') || (op === '+' || op === '-') &amp;&amp; op === code.join("").charAt()) {
      op += ' ';
    }
    code.unshift(op);
  }
  if (o.level &lt; LEVEL_CALL) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck" id="apidoc.element.livescript.ast.Unary.prototype.compilePluck">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compilePluck
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePluck = function (o){
  var ref$, get, del, code, ref;
  ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
  code = [ref = o.scope.temporary(), " = ", get.compile(o, LEVEL_LIST), ", delete ", del.compile(o, LEVEL_LIST), ", ", o.scope.free
(ref)];
  if (o.level &lt; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    : Call.make(it));
  return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
case 'delete':
  if (it instanceof Var || !it.isAssignable()) {
    this.carp('invalid delete');
  }
  if (o.level &amp;&amp; !this['void']) {
    return this.<span class="apidocCodeKeywordSpan">compilePluck</span>(o);
  }
  break;
case '++':
case '--':
  it.isAssignable() || this.carp('invalid ' + crement(op));
  if (that = it instanceof Var &amp;&amp; o.scope.checkReadOnly(it.value)) {
    this.carp(crement(op) + " of " + that + " \"" + it.value + "\"", ReferenceError);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread" id="apidoc.element.livescript.ast.Unary.prototype.compileSpread">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileSpread
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpread = function (o){
  var it, ops;
  it = this.it;
  ops = [this];
  for (; it instanceof constructor; it = it.it) {
    ops.push(it);
  }
  if (!(it instanceof Splat &amp;&amp; (it = it.it.expandSlice(o).unwrap()) instanceof List)) {
    return '';
  }
  return this.compileSpreadOver(o, it, function(node){
    var i$, ref$, op;
    for (i$ = (ref$ = ops).length - 1; i$ &gt;= 0; --i$) {
      op = ref$[i$];
      node = constructor(op.op, node, op.post);
    }
    return node;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }[it] + 'crement';
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.<span class="apidocCodeKeywordSpan">compileSpread</span>(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case '!':
    it.cond = true;
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.constructor" id="apidoc.element.livescript.ast.Unary.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>constructor
        <span class="apidocSignatureSpan">(op, it, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Unary(op, it, flag){
  var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
  if (it != null) {
    if (that = !flag &amp;&amp; it.unaries) {
      that.push(op);
      return it;
    }
    switch (op) {
    case '!':
      if (flag) {
        break;
      }
      if (it instanceof Fun &amp;&amp; !it.hushed) {
        return it.hushed = true, it;
      }
      return it.invert();
    case '++':
    case '--':
      if (flag) {
        this$.post = true;
      }
      break;
    case 'new':
      if (it instanceof Existence &amp;&amp; !it.negated) {
        it = Chain(it).add(Call());
      }
      it.newed = true;
      for (i$ = 0, len$ = (ref$ = it.tails || '').length; i$ &lt; len$; ++i$) {
        node = ref$[i$];
        if (node instanceof Call &amp;&amp; !node['new']) {
          if (node.method === '.call') {
            node.args.shift();
          }
          node['new'] = 'new';
          node.method = '';
          return it;
        }
      }
      break;
    case '~':
      if (it instanceof Fun &amp;&amp; it.statement &amp;&amp; !it.bound) {
        return it.bound = 'this$', it;
      }
    }
  }
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors" id="apidoc.element.livescript.ast.Unary.prototype.getAccessors">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>getAccessors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAccessors = function (){
  var items;
  if (this.op !== '~') {
    return;
  }
  if (this.it instanceof Fun) {
    return [this.it];
  }
  if (this.it instanceof Arr) {
    items = this.it.items;
    if (!items[2] &amp;&amp; items[0] instanceof Fun &amp;&amp; items[1] instanceof Fun) {
      return items;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function Prop(key, val){
var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
this$.key = key;
this$.val = val;
if (key.value === '...') {
  return Splat(this$.val);
}
if (that = val.<span class="apidocCodeKeywordSpan">getAccessors</span>()) {
  this$.val = that;
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    fun = that[i$];
    fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
  }
  this$['accessor'] = 'accessor';
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.invert" id="apidoc.element.livescript.ast.Unary.prototype.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  var ref$;
  if (this.op === '!' &amp;&amp; ((ref$ = this.it.op) === '!' || ref$ === '&lt;' || ref$ === '&gt;' || ref$ === '&lt;=' || ref$ === '&gt;=' || ref$ === '
of' || ref$ === 'instanceof')) {
    return this.it;
  }
  return constructor('!', this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary('!', this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this['else'] = $else;
  return this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isArray" id="apidoc.element.livescript.ast.Unary.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  return this.it instanceof Arr &amp;&amp; this.it.items.length || this.it instanceof Chain &amp;&amp; this.it.isArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isCallable" id="apidoc.element.livescript.ast.Unary.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return ((ref$ = this.op) === 'do' || ref$ === 'new' || ref$ === 'delete') || this.it == null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isString" id="apidoc.element.livescript.ast.Unary.prototype.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  var ref$;
  return (ref$ = this.op) === 'typeof' || ref$ === 'classof';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.show" id="apidoc.element.livescript.ast.Unary.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.post ? '@' : void 8] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak" id="apidoc.element.livescript.ast.Unary.prototype.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var ref$;
  return ((ref$ = this.op) === '++' || ref$ === '--' || ref$ === 'delete') &amp;&amp; this.it != null &amp;&amp; If.unfoldSoak(o, this, 'it');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.compileAsFunc" id="apidoc.module.livescript.ast.Unary.prototype.compileAsFunc">module livescript.ast.Unary.prototype.compileAsFunc</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileAsFunc.compileAsFunc" id="apidoc.element.livescript.ast.Unary.prototype.compileAsFunc.compileAsFunc">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileAsFunc
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileAsFunc = function (o){
  if (this.op === '!') {
    return sn(this, util('not'));
  } else {
    return sn(this, "(", Fun([], Block(Unary(this.op, Chain(Var('it'))))).compile(o), ")");
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    '++': 'in',
    '--': 'de'
  }[it] + 'crement';
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.<span class="apidocCodeKeywordSpan">compileAsFunc</span>(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case '!':
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.compileNode" id="apidoc.module.livescript.ast.Unary.prototype.compileNode">module livescript.ast.Unary.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Unary.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.compileSpread(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case '!':
    it.cond = true;
    break;
  case 'new':
    it.isCallable() || it.carp('invalid constructor');
    break;
  case 'do':
    if (o.level === LEVEL_TOP &amp;&amp; it instanceof Fun &amp;&amp; it.isStatement()) {
      return sn(this, it.compile(o), " ", Unary('do', Var(it.name)).compile(o));
    }
    x = Parens(it instanceof Existence &amp;&amp; !it.negated
      ? Chain(it).add(Call())
      : Call.make(it));
    return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
  case 'delete':
    if (it instanceof Var || !it.isAssignable()) {
      this.carp('invalid delete');
    }
    if (o.level &amp;&amp; !this['void']) {
      return this.compilePluck(o);
    }
    break;
  case '++':
  case '--':
    it.isAssignable() || this.carp('invalid ' + crement(op));
    if (that = it instanceof Var &amp;&amp; o.scope.checkReadOnly(it.value)) {
      this.carp(crement(op) + " of " + that + " \"" + it.value + "\"", ReferenceError);
    }
    if (this.post) {
      it.front = this.front;
    }
    break;
  case '^^':
    return sn(this, util('clone'), "(", it.compile(o, LEVEL_LIST), ")");
  case 'jsdelete':
    return sn(this, "delete ", it.compile(o, LEVEL_LIST));
  case 'classof':
    return sn(this, util('toString'), ".call(", it.compile(o, LEVEL_LIST), ").slice(8, -1)");
  }
  code = [it.compile(o, LEVEL_OP + PREC.unary)];
  if (this.post) {
    code.push(op);
  } else {
    if ((op === 'new' || op === 'typeof' || op === 'delete') || (op === '+' || op === '-') &amp;&amp; op === code.join("").charAt()) {
      op += ' ';
    }
    code.unshift(op);
  }
  if (o.level &lt; LEVEL_CALL) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.compilePluck" id="apidoc.module.livescript.ast.Unary.prototype.compilePluck">module livescript.ast.Unary.prototype.compilePluck</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compilePluck.compilePluck" id="apidoc.element.livescript.ast.Unary.prototype.compilePluck.compilePluck">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compilePluck
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compilePluck = function (o){
  var ref$, get, del, code, ref;
  ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
  code = [ref = o.scope.temporary(), " = ", get.compile(o, LEVEL_LIST), ", delete ", del.compile(o, LEVEL_LIST), ", ", o.scope.free
(ref)];
  if (o.level &lt; LEVEL_LIST) {
    return sn.apply(null, [this].concat(slice$.call(code)));
  } else {
    return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    : Call.make(it));
  return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
case 'delete':
  if (it instanceof Var || !it.isAssignable()) {
    this.carp('invalid delete');
  }
  if (o.level &amp;&amp; !this['void']) {
    return this.<span class="apidocCodeKeywordSpan">compilePluck</span>(o);
  }
  break;
case '++':
case '--':
  it.isAssignable() || this.carp('invalid ' + crement(op));
  if (that = it instanceof Var &amp;&amp; o.scope.checkReadOnly(it.value)) {
    this.carp(crement(op) + " of " + that + " \"" + it.value + "\"", ReferenceError);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.compileSpread" id="apidoc.module.livescript.ast.Unary.prototype.compileSpread">module livescript.ast.Unary.prototype.compileSpread</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.compileSpread.compileSpread" id="apidoc.element.livescript.ast.Unary.prototype.compileSpread.compileSpread">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>compileSpread
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileSpread = function (o){
  var it, ops;
  it = this.it;
  ops = [this];
  for (; it instanceof constructor; it = it.it) {
    ops.push(it);
  }
  if (!(it instanceof Splat &amp;&amp; (it = it.it.expandSlice(o).unwrap()) instanceof List)) {
    return '';
  }
  return this.compileSpreadOver(o, it, function(node){
    var i$, ref$, op;
    for (i$ = (ref$ = ops).length - 1; i$ &gt;= 0; --i$) {
      op = ref$[i$];
      node = constructor(op.op, node, op.post);
    }
    return node;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }[it] + 'crement';
}
Unary.prototype.compileNode = function(o){
  var that, op, it, x, code;
  if (this.it == null) {
    return this.compileAsFunc(o);
  }
  if (that = this.<span class="apidocCodeKeywordSpan">compileSpread</span>(o)) {
    return that;
  }
  op = this.op, it = this.it;
  switch (op) {
  case '!':
    it.cond = true;
    break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.getAccessors" id="apidoc.module.livescript.ast.Unary.prototype.getAccessors">module livescript.ast.Unary.prototype.getAccessors</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.getAccessors.getAccessors" id="apidoc.element.livescript.ast.Unary.prototype.getAccessors.getAccessors">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>getAccessors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAccessors = function (){
  var items;
  if (this.op !== '~') {
    return;
  }
  if (this.it instanceof Fun) {
    return [this.it];
  }
  if (this.it instanceof Arr) {
    items = this.it.items;
    if (!items[2] &amp;&amp; items[0] instanceof Fun &amp;&amp; items[1] instanceof Fun) {
      return items;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function Prop(key, val){
var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
this$.key = key;
this$.val = val;
if (key.value === '...') {
  return Splat(this$.val);
}
if (that = val.<span class="apidocCodeKeywordSpan">getAccessors</span>()) {
  this$.val = that;
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    fun = that[i$];
    fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
  }
  this$['accessor'] = 'accessor';
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.invert" id="apidoc.module.livescript.ast.Unary.prototype.invert">module livescript.ast.Unary.prototype.invert</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.invert.invert" id="apidoc.element.livescript.ast.Unary.prototype.invert.invert">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>invert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invert = function (){
  var ref$;
  if (this.op === '!' &amp;&amp; ((ref$ = this.it.op) === '!' || ref$ === '&lt;' || ref$ === '&gt;' || ref$ === '&lt;=' || ref$ === '&gt;=' || ref$ === '
of' || ref$ === 'instanceof')) {
    return this.it;
  }
  return constructor('!', this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
getDefault: VOID,
getJump: VOID,
invert: function(){
  return Unary('!', this, true);
},
invertCheck: function(it){
  if (it.inverted) {
    return this.<span class="apidocCodeKeywordSpan">invert</span>();
  } else {
    return this;
  }
},
addElse: function($else){
  this['else'] = $else;
  return this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.isArray" id="apidoc.module.livescript.ast.Unary.prototype.isArray">module livescript.ast.Unary.prototype.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isArray.isArray" id="apidoc.element.livescript.ast.Unary.prototype.isArray.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArray = function (){
  return this.it instanceof Arr &amp;&amp; this.it.items.length || this.it instanceof Chain &amp;&amp; this.it.isArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.isCallable" id="apidoc.module.livescript.ast.Unary.prototype.isCallable">module livescript.ast.Unary.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Unary.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (){
  var ref$;
  return ((ref$ = this.op) === 'do' || ref$ === 'new' || ref$ === 'delete') || this.it == null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.isString" id="apidoc.module.livescript.ast.Unary.prototype.isString">module livescript.ast.Unary.prototype.isString</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.isString.isString" id="apidoc.element.livescript.ast.Unary.prototype.isString.isString">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>isString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (){
  var ref$;
  return (ref$ = this.op) === 'typeof' || ref$ === 'classof';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
isAssignable: NO,
isCallable: NO,
isEmpty: NO,
isArray: NO,
isString: NO,
isRegex: NO,
isMatcher: function(){
  return this.<span class="apidocCodeKeywordSpan">isString</span>() || this.isRegex();
},
assigns: NO,
ripName: VOID,
unfoldSoak: VOID,
unfoldAssign: VOID,
unparen: THIS,
unwrap: THIS,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.show" id="apidoc.module.livescript.ast.Unary.prototype.show">module livescript.ast.Unary.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.show.show" id="apidoc.element.livescript.ast.Unary.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.post ? '@' : void 8] + this.op;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Unary.prototype.unfoldSoak" id="apidoc.module.livescript.ast.Unary.prototype.unfoldSoak">module livescript.ast.Unary.prototype.unfoldSoak</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Unary.prototype.unfoldSoak.unfoldSoak" id="apidoc.element.livescript.ast.Unary.prototype.unfoldSoak.unfoldSoak">
        function <span class="apidocSignatureSpan">livescript.ast.Unary.prototype.</span>unfoldSoak
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unfoldSoak = function (o){
  var ref$;
  return ((ref$ = this.op) === '++' || ref$ === '--' || ref$ === 'delete') &amp;&amp; this.it != null &amp;&amp; If.unfoldSoak(o, this, 'it');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).prototype = {
compile: function(options, level){
  var o, node, code, that, i$, len$, tmp;
  o = import$({}, options);
  if (level != null) {
    o.level = level;
  }
  node = this.<span class="apidocCodeKeywordSpan">unfoldSoak</span>(o) || this;
  if (o.level &amp;&amp; node.isStatement()) {
    return node.compileClosure(o);
  }
  code = (node.tab = o.indent, node).compileNode(o);
  if (that = node.temps) {
    for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
      tmp = that[i$];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Util" id="apidoc.module.livescript.ast.Util">module livescript.ast.Util</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Util.Util" id="apidoc.element.livescript.ast.Util.Util">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Util
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.Extends" id="apidoc.element.livescript.ast.Util.Extends">
        function <span class="apidocSignatureSpan">livescript.ast.Util.</span>Extends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Extends = function (){
  return Call.make(Util('extend'), [arguments[0], arguments[1]]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(Key("_" + f.name))), Chain(Var(util('
curry'))).add(Call([Chain(Var('prototype')).add(Index(f)), Var('true')]))), Assign(Chain(Literal('
this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal("'_" +
f.name + "'")]))));
}
lines.push(vname);
args = [];
if (that = this.sup) {
  args.push(that);
  imports = Chain(Import(Literal('this'), Var('superclass')));
  fun.proto = Util.<span class="apidocCodeKeywordSpan">Extends</span>(fun.cname ? Block([Assign(imports.add(Index(Key('displayName
'))), Literal("'" + name + "'")), Literal(name)]) : imports, (ref$ = fun.params)[ref$.length] =
Var('superclass'));
}
if (that = this.mixins) {
  res$ = [];
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    args[args.length] = that[i$];
    res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.superclass" id="apidoc.element.livescript.ast.Util.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Util.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Util.prototype" id="apidoc.module.livescript.ast.Util.prototype">module livescript.ast.Util.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.compile" id="apidoc.element.livescript.ast.Util.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return sn(this, util(this.verb));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.constructor" id="apidoc.element.livescript.ast.Util.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>constructor
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Util(verb){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.verb = verb;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.isCallable" id="apidoc.element.livescript.ast.Util.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.show" id="apidoc.element.livescript.ast.Util.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  var that;
  return (this.verb || '') + ((that = this.label) ? ' ' + that : '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Util.prototype.compile" id="apidoc.module.livescript.ast.Util.prototype.compile">module livescript.ast.Util.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Util.prototype.compile.compile" id="apidoc.element.livescript.ast.Util.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Util.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (){
  return sn(this, util(this.verb));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var" id="apidoc.module.livescript.ast.Var">module livescript.ast.Var</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.Var" id="apidoc.element.livescript.ast.Var.Var">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Var
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,1],[3,3],[3,3],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,
4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[
3,3],[3,3],[6,4],[6,4],[6,5],[6,5],[10,1],[10,1],[43,1],[43,1],[12,0],[12,1],[12,3],[12,4],[12,6],[44,1],[44,2],[44,1],[13,0],[13
,1],[49,0],[49,1],[49,3],[49,2],[50,1],[50,2],[50,6],[50,1],[50,1],[50,2],[17,3],[54,2],[19,3],[19,3],[19,5],[19,1],[19,3],[19,3
],[19,6],[19,3],[19,6],[19,2],[19,2],[19,3],[19,2],[19,3],[19,3],[19,3],[19,4],[19,4],[19,4],[19,2],[19,2],[19,2],[19,3],[19,3],[
19,3],[19,6],[19,5],[19,1],[19,2],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,3],[19,2],[19
,6],[19,6],[19,6],[19,4],[19,3],[19,3],[19,4],[19,6],[19,2],[19,5],[19,1],[19,1],[19,2],[19,3],[19,5],[19,5],[19,2],[19,4],[19,4
],[19,2],[19,2],[19,4],[19,6],[19,5],[19,7],[19,4],[19,5],[19,4],[19,3],[19,2],[19,2],[19,5],[86,1],[86,3],[98,1],[98,1],[98,3],[
98,3],[98,5],[98,5],[99,3],[99,6],[99,1],[99,3],[99,3],[99,2],[99,2],[99,2],[99,1],[41,0],[41,1],[41,3],[41,4],[41,4],[5,3],[101
,1],[101,1],[101,3],[77,0],[77,2],[77,5],[79,4],[79,6],[79,6],[79,8],[79,2],[79,4],[79,4],[79,6],[79,4],[79,6],[79,6],[79,8],[79
,6],[79,5],[79,8],[79,7],[79,8],[79,7],[79,10],[79,9],[79,10],[79,9],[79,2],[79,4],[79,4],[79,6],[20,1],[20,2],[20,3],[20,3],[87
,3],[87,4],[94,2],[94,0],[95,2],[95,0],[105,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.<span class="apidocCodeKeywordSpan">Var</span>($$[$0]))));
break;
case 2: case 3:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
break;
case 4: case 5:
this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.superclass" id="apidoc.element.livescript.ast.Var.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Var.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Atom(){
  Atom.superclass.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype" id="apidoc.module.livescript.ast.Var.prototype">module livescript.ast.Var.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.assigns" id="apidoc.element.livescript.ast.Var.prototype.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return it === this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.compile" id="apidoc.element.livescript.ast.Var.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  return sn(this, this.temp
    ? o.scope.free(this.value)
    : this.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.constructor" id="apidoc.element.livescript.ast.Var.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Var(value){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.value = value;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.isAssignable" id="apidoc.element.livescript.ast.Var.prototype.isAssignable">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isAssignable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
  if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
    return this.head.<span class="apidocCodeKeywordSpan">isAssignable</span>();
  }
  if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
    return false;
  }
  for (i$ = 0, len$ = (ref$ = this.tails).length; i$ &lt; len$; ++i$) {
    tail = ref$[i$];
    if (tail.assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.isCallable" id="apidoc.element.livescript.ast.Var.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>isCallable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.maybeKey" id="apidoc.element.livescript.ast.Var.prototype.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeKey = function (){
  var ref$;
  return ref$ = Key(this.value), ref$.line = this.line, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.varName" id="apidoc.element.livescript.ast.Var.prototype.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype.assigns" id="apidoc.module.livescript.ast.Var.prototype.assigns">module livescript.ast.Var.prototype.assigns</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.assigns.assigns" id="apidoc.element.livescript.ast.Var.prototype.assigns.assigns">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>assigns
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assigns = function (it){
  return it === this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
List.prototype.isEmpty = function(){
  return !this.items.length;
};
List.prototype.assigns = function(it){
  var i$, ref$, len$, node;
  for (i$ = 0, len$ = (ref$ = this.items).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.<span class="apidocCodeKeywordSpan">assigns</span>(it)) {
      return true;
    }
  }
};
List.compile = function(o, items, deepEq){
  var indent, level, code, i, that, target;
  switch (items.length) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype.compile" id="apidoc.module.livescript.ast.Var.prototype.compile">module livescript.ast.Var.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.compile.compile" id="apidoc.element.livescript.ast.Var.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>compile
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o){
  return sn(this, this.temp
    ? o.scope.free(this.value)
    : this.value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype.maybeKey" id="apidoc.module.livescript.ast.Var.prototype.maybeKey">module livescript.ast.Var.prototype.maybeKey</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.maybeKey.maybeKey" id="apidoc.element.livescript.ast.Var.prototype.maybeKey.maybeKey">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>maybeKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maybeKey = function (){
  var ref$;
  return ref$ = Key(this.value), ref$.line = this.line, ref$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (i$ = 0, len$ = items.length; i$ &lt; len$; ++i$) {
i = i$;
node = items[i$];
if (node.comment) {
  continue;
}
if (node instanceof Prop || node instanceof Splat) {
  node[name = (ref$ = node.children)[ref$.length - 1]] = chain = Chain(base, [Index(node[name].<span class="apidocCodeKeywordSpan
">maybeKey</span>())]);
} else {
  if (logic = node.getDefault()) {
    node = node.first;
  }
  if (node instanceof Parens) {
    ref$ = node.cache(o, true), key = ref$[0], node = ref$[1];
    if (assign) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Var.prototype.varName" id="apidoc.module.livescript.ast.Var.prototype.varName">module livescript.ast.Var.prototype.varName</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Var.prototype.varName.varName" id="apidoc.element.livescript.ast.Var.prototype.varName.varName">
        function <span class="apidocSignatureSpan">livescript.ast.Var.prototype.</span>varName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">varName = function (){
  return this.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return [this.soak ? '?' : void 8] + this.symbol;
};
Index.prototype.isComplex = function(){
  return this.key.isComplex();
};
Index.prototype.varName = function(){
  var ref$;
  return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) &amp;&amp; this.key.<span class="apidocCodeKeywordSpan">
varName</span>();
};
Index.prototype.compile = function(o){
  var code;
  code = this.key.compile(o, LEVEL_PAREN);
  if (this.key instanceof Key &amp;&amp; '\'' !== code.toString().charAt(0)) {
    return sn(this, ".", code);
  } else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Vars" id="apidoc.module.livescript.ast.Vars">module livescript.ast.Vars</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.Vars" id="apidoc.element.livescript.ast.Vars.Vars">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Vars
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.superclass" id="apidoc.element.livescript.ast.Vars.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Vars.prototype" id="apidoc.module.livescript.ast.Vars.prototype">module livescript.ast.Vars.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.compile" id="apidoc.element.livescript.ast.Vars.prototype.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var i$, ref$, len$, v, value;
  for (i$ = 0, len$ = (ref$ = this.vars).length; i$ &lt; len$; ++i$) {
    v = ref$[i$], value = v.value;
    if (!(v instanceof Var)) {
      v.carp('invalid variable declaration');
    }
    if (o.scope.check(value)) {
      v.carp("redeclaration of \"" + value + "\"");
    }
    o.scope.declare(value, v);
  }
  return sn(this, Literal('void').compile(o, level));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.constructor" id="apidoc.element.livescript.ast.Vars.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>constructor
        <span class="apidocSignatureSpan">(vars)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vars(vars){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.vars = vars;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.makeReturn" id="apidoc.element.livescript.ast.Vars.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function THIS(){
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Vars.prototype.compile" id="apidoc.module.livescript.ast.Vars.prototype.compile">module livescript.ast.Vars.prototype.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Vars.prototype.compile.compile" id="apidoc.element.livescript.ast.Vars.prototype.compile.compile">
        function <span class="apidocSignatureSpan">livescript.ast.Vars.prototype.</span>compile
        <span class="apidocSignatureSpan">(o, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (o, level){
  var i$, ref$, len$, v, value;
  for (i$ = 0, len$ = (ref$ = this.vars).length; i$ &lt; len$; ++i$) {
    v = ref$[i$], value = v.value;
    if (!(v instanceof Var)) {
      v.carp('invalid variable declaration');
    }
    if (o.scope.check(value)) {
      v.carp("redeclaration of \"" + value + "\"");
    }
    o.scope.declare(value, v);
  }
  return sn(this, Literal('void').compile(o, level));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While" id="apidoc.module.livescript.ast.While">module livescript.ast.While</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.While" id="apidoc.element.livescript.ast.While.While">
        function <span class="apidocSignatureSpan">livescript.ast.</span>While
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &amp;&amp; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== '' + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 119:
this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === 'unless')));
break;
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.<span class="apidocCodeKeywordSpan">While</span>($$[$0], $$[$0-1] === 'until', true
).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', true).addGuard($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.superclass" id="apidoc.element.livescript.ast.While.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.While.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype" id="apidoc.module.livescript.ast.While.prototype">module livescript.ast.While.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addBody" id="apidoc.element.livescript.ast.While.prototype.addBody">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBody = function (body){
  var top;
  this.body = body;
  if (this.guard) {
    this.body = Block(If(this.guard, this.body));
  }
  top = this.body.lines[0];
  if ((top != null ? top.verb : void 8) === 'continue' &amp;&amp; !top.label) {
    this.body.lines.length = 0;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
While.prototype.show = function(){
  return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
};
prototype.isStatement = prototype.isArray = YES;
While.prototype.makeComprehension = function(toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().<span class="apidocCodeKeywordSpan">addBody</span>(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
};
While.prototype.getJump = function(ctx){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addGuard" id="apidoc.element.livescript.ast.While.prototype.addGuard">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addGuard
        <span class="apidocSignatureSpan">(guard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addGuard = function (guard){
  this.guard = guard;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0], $$[$0-1] === 'until', true).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', true).<span class="apidocCodeKeywordSpan">
addGuard</span>($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addObjComp" id="apidoc.element.livescript.ast.While.prototype.addObjComp">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addObjComp
        <span class="apidocSignatureSpan">(objComp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addObjComp = function (objComp){
  this.objComp = objComp != null ? objComp : true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].<span class="apidocCodeKeywordSpan">addObjComp</span>().
makeComprehension(yy.L(_$[$0-4],_$[$0-4],yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileBody" id="apidoc.element.livescript.ast.While.prototype.compileBody">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileBody
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileBody = function (o){
  var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ =
this;
  o['break'] = o['continue'] = true;
  lines = this.body.lines, yet = this.yet, tab = this.tab;
  code = [];
  ret = [];
  mid = [];
  empty = this.objComp ? '{}' : '[]';
  getResultName = function(){
    return _resultName != null
      ? _resultName
      : _resultName = o.scope.temporary(this$.objComp ? 'resultObj' : 'results');
  };
  last = lines != null ? lines[lines.length - 1] : void 8;
  if (!(this.isComprehension || this.inComprehension) || (last != null &amp;&amp; last.isComprehension)) {
    hasLoop = false;
    if (last != null) {
      last.traverseChildren(function(it){
        var ref$;
        if (it instanceof Block &amp;&amp; (ref$ = it.lines)[ref$.length - 1] instanceof While) {
          hasLoop = true;
        }
      });
    }
    if (this.returns &amp;&amp; !this.resVar) {
      this.resVar = res = o.scope.assign(getResultName(), empty);
    }
    if (this.resVar &amp;&amp; (last instanceof While || hasLoop)) {
      temp = o.scope.temporary('lresult');
      lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
        ? Obj()
        : Arr(), '='));
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(temp);
      }
      mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key('push'), '.', true)).add(Call([Chain(Var(temp))])).compile(o), ";\n" +
this.tab);
    } else {
      this.hasReturned = true;
      if (this.resVar) {
        this.body.makeReturn(this.resVar);
      }
    }
  }
  if (this.returns) {
    if ((!last instanceof While &amp;&amp; !this.hasReturned) || this.isComprehension || this.inComprehension) {
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
      }
    }
    ret.push("\n" + this.tab + "return ", res || empty, ";");
    if ((ref$ = this['else']) != null) {
      ref$.makeReturn();
    }
  }
  yet &amp;&amp; lines.unshift(JS(yet + " = false;"));
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push("\n", bodyCode, "\n" + tab);
  }
  code.push.apply(code, mid);
  code.push('}');
  if (this.post) {
    code.push(sn(this, " while ("), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, ");"));
  }
  if (yet) {
    code.push(sn(this, " if ("), yet, sn(this, ") "), this.compileBlock(o, Block(this['else'])));
    o.scope.free(yet);
  }
  return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  While.prototype.compileNode = function(o){
var test, ref$, head, that;
o.loop = true;
this.test &amp;&amp; (this.un
  ? this.test = this.test.invert()
  : this.anaphorize());
if (this.post) {
  return sn(null, sn(this, 'do {'), this.<span class="apidocCodeKeywordSpan">compileBody</span>((o.indent += TAB, o)));
}
test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
if (!(this.update || this['else'])) {
  head = !snEmpty(test)
    ? [sn(this, "while ("), test]
    : [sn(this, 'for (;;')];
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileNode" id="apidoc.element.livescript.ast.While.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var test, ref$, head, that;
  o.loop = true;
  this.test &amp;&amp; (this.un
    ? this.test = this.test.invert()
    : this.anaphorize());
  if (this.post) {
    return sn(null, sn(this, 'do {'), this.compileBody((o.indent += TAB, o)));
  }
  test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
  if (!(this.update || this['else'])) {
    head = !snEmpty(test)
      ? [sn(this, "while ("), test]
      : [sn(this, 'for (;;')];
  } else {
    head = [sn(this, 'for (')];
    if (this['else']) {
      head.push(this.yet = o.scope.temporary('yet'), " = true");
    }
    head.push(sn(this, ";"), test.toString() &amp;&amp; ' ', test, sn(this, ";"));
    if (that = this.update) {
      head.push(' ', that.compile(o, LEVEL_PAREN));
    }
  }
  return sn.apply(null, [null].concat(slice$.call(head), [sn(this, ') {'), this.compileBody((o.indent += TAB, o))]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.constructor" id="apidoc.element.livescript.ast.While.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>constructor
        <span class="apidocSignatureSpan">(test, un, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function While(test, un, mode){
  this.un = un;
  mode &amp;&amp; (mode instanceof Node
    ? this.update = mode
    : this.post = true);
  if (this.post || test.value !== '' + !un) {
    this.test = test;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.getJump" id="apidoc.element.livescript.ast.While.prototype.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var i$, ref$, ref1$, len$, node;
  ctx || (ctx = {});
  ctx['continue'] = true;
  ctx['break'] = true;
  for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.getJump(ctx)) {
      return node;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.isArray" id="apidoc.element.livescript.ast.While.prototype.isArray">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
};
Chain.prototype.isArray = function(){
  var that, ref$;
  if (that = (ref$ = this.tails)[ref$.length - 1]) {
    return that.key instanceof Arr;
  } else {
    return this.head.<span class="apidocCodeKeywordSpan">isArray</span>();
  }
};
Chain.prototype.isRegex = function(){
  return this.head.value === 'RegExp' &amp;&amp; !this.tails[1] &amp;&amp; this.tails[0] instanceof Call;
};
Chain.prototype.isAssignable = function(){
  var tail, ref$, i$, len$;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.isStatement" id="apidoc.element.livescript.ast.While.prototype.isStatement">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>isStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function YES(){
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compile: function(options, level){
var o, node, code, that, i$, len$, tmp;
o = import$({}, options);
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.<span class="apidocCodeKeywordSpan">isStatement</span>()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).compileNode(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeComprehension" id="apidoc.element.livescript.ast.While.prototype.makeComprehension">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeComprehension
        <span class="apidocSignatureSpan">(toAdd, loops)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeComprehension = function (toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().addBody(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
function argsSlice(begin, end){
  return new For({
    ref: true,
    from: begin,
    op: 'til',
    to: end
  }).<span class="apidocCodeKeywordSpan">makeComprehension</span>(Chain(Var('arguments')).add(Index(Literal('..&amp;#
x27;))), []);
}
ret = [];
for (i$ = 0, len$ = nodes.length; i$ &lt; len$; ++i$) {
  i = i$;
  node = nodes[i$];
  if (node.isEmpty()) {
    continue;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeReturn" id="apidoc.element.livescript.ast.While.prototype.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (it){
  var last, ref$, ref1$, ref2$;
  if (this.hasReturned) {
    return this;
  }
  if (it) {
    if (this.objComp) {
      this.body = Block(this.body.makeReturn(it, true));
    } else {
      if (!(this.body || this.index)) {
        this.addBody(Block(Var(this.index = 'ridx$')));
      }
      last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
      if ((this.isComprehension || this.inComprehension) &amp;&amp; !(last != null &amp;&amp; last.isComprehension)) {
        (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
        if ((ref1$ = this['else']) != null) {
          ref1$.makeReturn.apply(ref1$, arguments);
        }
        this.hasReturned = true;
      } else {
        this.resVar = it;
        if ((ref2$ = this['else']) != null) {
          ref2$.makeReturn.apply(ref2$, arguments);
        }
      }
    }
  } else {
    this.getJump() || (this.returns = true);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.show" id="apidoc.element.livescript.ast.While.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.addBody" id="apidoc.module.livescript.ast.While.prototype.addBody">module livescript.ast.While.prototype.addBody</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addBody.addBody" id="apidoc.element.livescript.ast.While.prototype.addBody.addBody">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addBody
        <span class="apidocSignatureSpan">(body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBody = function (body){
  var top;
  this.body = body;
  if (this.guard) {
    this.body = Block(If(this.guard, this.body));
  }
  top = this.body.lines[0];
  if ((top != null ? top.verb : void 8) === 'continue' &amp;&amp; !top.label) {
    this.body.lines.length = 0;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
While.prototype.show = function(){
  return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
};
prototype.isStatement = prototype.isArray = YES;
While.prototype.makeComprehension = function(toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().<span class="apidocCodeKeywordSpan">addBody</span>(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
};
While.prototype.getJump = function(ctx){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.addGuard" id="apidoc.module.livescript.ast.While.prototype.addGuard">module livescript.ast.While.prototype.addGuard</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addGuard.addGuard" id="apidoc.element.livescript.ast.While.prototype.addGuard.addGuard">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addGuard
        <span class="apidocSignatureSpan">(guard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addGuard = function (guard){
  this.guard = guard;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 120:
this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].addBody($$[$0-1]).addElse($$[$0]));
break;
case 121:
this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0], $$[$0-1] === 'until', true).addBody($$[$0-2]));
break;
case 122:
this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', true).<span class="apidocCodeKeywordSpan">
addGuard</span>($$[$0]).addBody($$[$0-4]));
break;
case 123:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
break;
case 124:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.addObjComp" id="apidoc.module.livescript.ast.While.prototype.addObjComp">module livescript.ast.While.prototype.addObjComp</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.addObjComp.addObjComp" id="apidoc.element.livescript.ast.While.prototype.addObjComp.addObjComp">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>addObjComp
        <span class="apidocSignatureSpan">(objComp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addObjComp = function (objComp){
  this.objComp = objComp != null ? objComp : true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 11:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
break;
case 12:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
break;
case 13:
this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].<span class="apidocCodeKeywordSpan">addObjComp</span>().
makeComprehension(yy.L(_$[$0-4],_$[$0-4],yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
break;
case 14: case 20: case 22:
this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
break;
case 15:
this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.compileBody" id="apidoc.module.livescript.ast.While.prototype.compileBody">module livescript.ast.While.prototype.compileBody</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileBody.compileBody" id="apidoc.element.livescript.ast.While.prototype.compileBody.compileBody">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileBody
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileBody = function (o){
  var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ =
this;
  o['break'] = o['continue'] = true;
  lines = this.body.lines, yet = this.yet, tab = this.tab;
  code = [];
  ret = [];
  mid = [];
  empty = this.objComp ? '{}' : '[]';
  getResultName = function(){
    return _resultName != null
      ? _resultName
      : _resultName = o.scope.temporary(this$.objComp ? 'resultObj' : 'results');
  };
  last = lines != null ? lines[lines.length - 1] : void 8;
  if (!(this.isComprehension || this.inComprehension) || (last != null &amp;&amp; last.isComprehension)) {
    hasLoop = false;
    if (last != null) {
      last.traverseChildren(function(it){
        var ref$;
        if (it instanceof Block &amp;&amp; (ref$ = it.lines)[ref$.length - 1] instanceof While) {
          hasLoop = true;
        }
      });
    }
    if (this.returns &amp;&amp; !this.resVar) {
      this.resVar = res = o.scope.assign(getResultName(), empty);
    }
    if (this.resVar &amp;&amp; (last instanceof While || hasLoop)) {
      temp = o.scope.temporary('lresult');
      lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
        ? Obj()
        : Arr(), '='));
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(temp);
      }
      mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key('push'), '.', true)).add(Call([Chain(Var(temp))])).compile(o), ";\n" +
this.tab);
    } else {
      this.hasReturned = true;
      if (this.resVar) {
        this.body.makeReturn(this.resVar);
      }
    }
  }
  if (this.returns) {
    if ((!last instanceof While &amp;&amp; !this.hasReturned) || this.isComprehension || this.inComprehension) {
      if (lines[key$ = lines.length - 1] != null) {
        lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
      }
    }
    ret.push("\n" + this.tab + "return ", res || empty, ";");
    if ((ref$ = this['else']) != null) {
      ref$.makeReturn();
    }
  }
  yet &amp;&amp; lines.unshift(JS(yet + " = false;"));
  if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
    code.push("\n", bodyCode, "\n" + tab);
  }
  code.push.apply(code, mid);
  code.push('}');
  if (this.post) {
    code.push(sn(this, " while ("), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, ");"));
  }
  if (yet) {
    code.push(sn(this, " if ("), yet, sn(this, ") "), this.compileBlock(o, Block(this['else'])));
    o.scope.free(yet);
  }
  return sn.apply(null, [null].concat(slice$.call(code), slice$.call(ret)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  While.prototype.compileNode = function(o){
var test, ref$, head, that;
o.loop = true;
this.test &amp;&amp; (this.un
  ? this.test = this.test.invert()
  : this.anaphorize());
if (this.post) {
  return sn(null, sn(this, 'do {'), this.<span class="apidocCodeKeywordSpan">compileBody</span>((o.indent += TAB, o)));
}
test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
if (!(this.update || this['else'])) {
  head = !snEmpty(test)
    ? [sn(this, "while ("), test]
    : [sn(this, 'for (;;')];
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.compileNode" id="apidoc.module.livescript.ast.While.prototype.compileNode">module livescript.ast.While.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.While.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var test, ref$, head, that;
  o.loop = true;
  this.test &amp;&amp; (this.un
    ? this.test = this.test.invert()
    : this.anaphorize());
  if (this.post) {
    return sn(null, sn(this, 'do {'), this.compileBody((o.indent += TAB, o)));
  }
  test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
  if (!(this.update || this['else'])) {
    head = !snEmpty(test)
      ? [sn(this, "while ("), test]
      : [sn(this, 'for (;;')];
  } else {
    head = [sn(this, 'for (')];
    if (this['else']) {
      head.push(this.yet = o.scope.temporary('yet'), " = true");
    }
    head.push(sn(this, ";"), test.toString() &amp;&amp; ' ', test, sn(this, ";"));
    if (that = this.update) {
      head.push(' ', that.compile(o, LEVEL_PAREN));
    }
  }
  return sn.apply(null, [null].concat(slice$.call(head), [sn(this, ') {'), this.compileBody((o.indent += TAB, o))]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.getJump" id="apidoc.module.livescript.ast.While.prototype.getJump">module livescript.ast.While.prototype.getJump</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.getJump.getJump" id="apidoc.element.livescript.ast.While.prototype.getJump.getJump">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>getJump
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJump = function (ctx){
  var i$, ref$, ref1$, len$, node;
  ctx || (ctx = {});
  ctx['continue'] = true;
  ctx['break'] = true;
  for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ &lt; len$; ++i$) {
    node = ref$[i$];
    if (node.getJump(ctx)) {
      return node;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      o.scope.free(tmp);
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.<span class="apidocCodeKeywordSpan">getJump</span>()) {
    that.carp('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.makeComprehension" id="apidoc.module.livescript.ast.While.prototype.makeComprehension">module livescript.ast.While.prototype.makeComprehension</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeComprehension.makeComprehension" id="apidoc.element.livescript.ast.While.prototype.makeComprehension.makeComprehension">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeComprehension
        <span class="apidocSignatureSpan">(toAdd, loops)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeComprehension = function (toAdd, loops){
  this.isComprehension = true;
  while (loops.length) {
    toAdd = loops.pop().addBody(Block(toAdd));
    if (!toAdd.isComprehension) {
      toAdd.inComprehension = true;
    }
  }
  return this.addBody(Block(toAdd));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$, this$ = this;
function argsSlice(begin, end){
  return new For({
    ref: true,
    from: begin,
    op: 'til',
    to: end
  }).<span class="apidocCodeKeywordSpan">makeComprehension</span>(Chain(Var('arguments')).add(Index(Literal('..&amp;#
x27;))), []);
}
ret = [];
for (i$ = 0, len$ = nodes.length; i$ &lt; len$; ++i$) {
  i = i$;
  node = nodes[i$];
  if (node.isEmpty()) {
    continue;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.makeReturn" id="apidoc.module.livescript.ast.While.prototype.makeReturn">module livescript.ast.While.prototype.makeReturn</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.makeReturn.makeReturn" id="apidoc.element.livescript.ast.While.prototype.makeReturn.makeReturn">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>makeReturn
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeReturn = function (it){
  var last, ref$, ref1$, ref2$;
  if (this.hasReturned) {
    return this;
  }
  if (it) {
    if (this.objComp) {
      this.body = Block(this.body.makeReturn(it, true));
    } else {
      if (!(this.body || this.index)) {
        this.addBody(Block(Var(this.index = 'ridx$')));
      }
      last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
      if ((this.isComprehension || this.inComprehension) &amp;&amp; !(last != null &amp;&amp; last.isComprehension)) {
        (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
        if ((ref1$ = this['else']) != null) {
          ref1$.makeReturn.apply(ref1$, arguments);
        }
        this.hasReturned = true;
      } else {
        this.resVar = it;
        if ((ref2$ = this['else']) != null) {
          ref2$.makeReturn.apply(ref2$, arguments);
        }
      }
    }
  } else {
    this.getJump() || (this.returns = true);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (/^\s*(?:[/#]|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
    prefix = this.lines.shift().code + '\n';
  }
  if ((ref1$ = o.eval, delete o.eval, ref1$) &amp;&amp; this.chomp().lines.length) {
    if (bare) {
      this.lines.push(Parens(this.lines.pop()));
    } else {
      this.<span class="apidocCodeKeywordSpan">makeReturn</span>();
    }
  }
  code = [this.compileWithDeclarations(o)];
  bare || (code = ["(function(){\n"].concat(slice$.call(code), ["\n}).call(this);\n"]));
  return result = sn.apply(null, [null, prefix || []].concat(slice$.call(code)));
};
Block.prototype.compileWithDeclarations = function(o){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.While.prototype.show" id="apidoc.module.livescript.ast.While.prototype.show">module livescript.ast.While.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.While.prototype.show.show" id="apidoc.element.livescript.ast.While.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.While.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield" id="apidoc.module.livescript.ast.Yield">module livescript.ast.Yield</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.Yield" id="apidoc.element.livescript.ast.Yield.Yield">
        function <span class="apidocSignatureSpan">livescript.ast.</span>Yield
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 98:
this.$ = yy.L(_$[$0-5], _$[$0],yy.Unary($$[$0-5], yy.Splat(yy.Arr($$[$0-2]))));
break;
case 99:
this.$ = yy.L(_$[$0-4], _$[$0],yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2])));
break;
case 100:
this.$ = yy.L(_$[$0], _$[$0],yy.<span class="apidocCodeKeywordSpan">Yield</span>($$[$0]));
break;
case 101:
this.$ = yy.L(_$[$0-1], _$[$0],yy.Yield($$[$0-1], $$[$0]));
break;
case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 158:
this.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0])));
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.superclass" id="apidoc.element.livescript.ast.Yield.superclass">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.</span>superclass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superclass = function (){
  throw Error('unimplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield.prototype" id="apidoc.module.livescript.ast.Yield.prototype">module livescript.ast.Yield.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.compileNode" id="apidoc.element.livescript.ast.Yield.prototype.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var code;
  code = [];
  if (this.op === 'yieldfrom') {
    code.push('yield*');
  } else {
    code.push('yield');
  }
  if (this.it) {
    code.push(" " + this.it.compile(o, LEVEL_OP + PREC.unary));
  }
  return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.constructor" id="apidoc.element.livescript.ast.Yield.prototype.constructor">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>constructor
        <span class="apidocSignatureSpan">(op, it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Yield(op, it){
  var this$ = this instanceof ctor$ ? this : new ctor$;
  this$.op = op;
  this$.it = it;
  return this$;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return node;
};
exports.Box = function(v){
if (typeof v === "object") {
  return v;
} else {
  return new v.<span class="apidocCodeKeywordSpan">constructor</span>(v);
}
};
exports.Decl = function(type, nodes, lno){
if (!nodes[0]) {
  throw SyntaxError("empty " + type + " on line " + lno);
}
return DECLS[type](nodes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.isCallable" id="apidoc.element.livescript.ast.Yield.prototype.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.show" id="apidoc.element.livescript.ast.Yield.prototype.show">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.op === 'yieldfrom') {
    return 'from';
  } else {
    return '';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield.prototype.compileNode" id="apidoc.module.livescript.ast.Yield.prototype.compileNode">module livescript.ast.Yield.prototype.compileNode</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.compileNode.compileNode" id="apidoc.element.livescript.ast.Yield.prototype.compileNode.compileNode">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>compileNode
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileNode = function (o){
  var code;
  code = [];
  if (this.op === 'yieldfrom') {
    code.push('yield*');
  } else {
    code.push('yield');
  }
  if (this.it) {
    code.push(" " + this.it.compile(o, LEVEL_OP + PREC.unary));
  }
  return sn.apply(null, [this, "("].concat(slice$.call(code), [")"]));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (level != null) {
  o.level = level;
}
node = this.unfoldSoak(o) || this;
if (o.level &amp;&amp; node.isStatement()) {
  return node.compileClosure(o);
}
code = (node.tab = o.indent, node).<span class="apidocCodeKeywordSpan">compileNode</span>(o);
if (that = node.temps) {
  for (i$ = 0, len$ = that.length; i$ &lt; len$; ++i$) {
    tmp = that[i$];
    o.scope.free(tmp);
  }
}
return code;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield.prototype.isCallable" id="apidoc.module.livescript.ast.Yield.prototype.isCallable">module livescript.ast.Yield.prototype.isCallable</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.isCallable.isCallable" id="apidoc.element.livescript.ast.Yield.prototype.isCallable.isCallable">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>isCallable
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCallable = function (it){
  return fn.call(this, name, it);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.isComplex = function(){
  return this.isRegex() || this.value === 'debugger';
};
Literal.prototype.isWhat = function(){
  switch (false) {
  case !this.isEmpty():
    return 'empty';
  case !this.<span class="apidocCodeKeywordSpan">isCallable</span>():
    return 'callable';
  case !this.isString():
    return 'string';
  case !this.isRegex():
    return 'regex';
  case !this.isComplex():
    return 'complex';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.Yield.prototype.show" id="apidoc.module.livescript.ast.Yield.prototype.show">module livescript.ast.Yield.prototype.show</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.Yield.prototype.show.show" id="apidoc.element.livescript.ast.Yield.prototype.show.show">
        function <span class="apidocSignatureSpan">livescript.ast.Yield.prototype.</span>show
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">show = function (){
  if (this.op === 'yieldfrom') {
    return 'from';
  } else {
    return '';
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},
show: String,
toString: function(idt){
  var tree, that;
  idt || (idt = '');
  tree = '\n' + idt + this.constructor.displayName;
  if (that = this.<span class="apidocCodeKeywordSpan">show</span>()) {
    tree += ' ' + that;
  }
  this.eachChild(function(it){
    tree += it.toString(idt + TAB);
  });
  return tree;
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.fromJSON" id="apidoc.module.livescript.ast.fromJSON">module livescript.ast.fromJSON</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.fromJSON.fromJSON" id="apidoc.element.livescript.ast.fromJSON.fromJSON">
        function <span class="apidocSignatureSpan">livescript.ast.</span>fromJSON
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &amp;&amp; typeof it === 'object')) {
    return it;
  }
  if (that = it.type) {
    node = clone$(exports[that].prototype);
    for (key in it) {
      val = it[key];
      node[key] = fromJSON(val);
    }
    return node;
  }
  if (it.length != null) {
    for (i$ = 0, len$ = it.length; i$ &lt; len$; ++i$) {
      v = it[i$];
      results$.push(fromJSON(v));
    }
    return results$;
  } else {
    return it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.<span class="apidocCodeKeywordSpan">fromJSON</span>(JSON.parse(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &amp;&amp; typeof it === 'object')) {
    return it;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.ast.parse" id="apidoc.module.livescript.ast.parse">module livescript.ast.parse</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.ast.parse.parse" id="apidoc.element.livescript.ast.parse.parse">
        function <span class="apidocSignatureSpan">livescript.ast.</span>parse
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (json){
  return exports.fromJSON(JSON.parse(json));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.fromJSON(JSON.<span class="apidocCodeKeywordSpan">parse</span>(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &amp;&amp; typeof it === 'object')) {
    return it;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.command" id="apidoc.module.livescript.command">module livescript.command</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.command.command" id="apidoc.element.livescript.command.command">
        function <span class="apidocSignatureSpan">livescript.</span>command
        <span class="apidocSignatureSpan">(args, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">command = function (args, arg$){
  var ref$, say, sayWithTimestamp, warn, die, p, pp, ppp, fileExists, dasherizeVars, startsWith, o, positional, e, validMapValues
, toInsert, that, filename, jsonCallback;
  ref$ = arg$ != null
    ? arg$
    : {}, say = ref$.say, sayWithTimestamp = ref$.sayWithTimestamp, warn = ref$.warn, die = ref$.die;
  say == null &amp;&amp; (say = console.log);
  sayWithTimestamp == null &amp;&amp; (sayWithTimestamp = util.log);
  warn == null &amp;&amp; (warn = console.error);
  die == null &amp;&amp; (die = function(message){
    console.error(message);
    process.exit(1);
  });
  p = function(){
    var args, res$, i$, to$;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ &lt; to$; ++i$) {
      res$.push(arguments[i$]);
    }
    args = res$;
    each(console.dir, args);
  };
  pp = function(x, showHidden, depth){
    say(util.inspect(x, showHidden, depth, !process.env.NODE_DISABLE_COLORS));
  };
  ppp = function(it){
    pp(it, true, null);
  };
  fileExists = function(path){
    try {
      fs.statSync(path);
      return true;
    } catch (e$) {}
  };
  dasherizeVars = function(str){
    if (/^[a-z]/.exec(str)) {
      return dasherize(str);
    } else {
      return str;
    }
  };
  startsWith = function(str){
    var this$ = this;
    return function(it){
      return it.indexOf(str) === 0;
    };
  };
  try {
    o = parseOptions(args);
    positional = o._;
  } catch (e$) {
    e = e$;
    die(e.message);
  }
  switch (false) {
  case !o.nodejs:
    forkNode();
    break;
  case !o.version:
    say("LiveScript version " + version);
    break;
  case !o.help:
    say(generateHelp({
      interpolate: {
        version: version
      }
    }));
    break;
  default:
    validMapValues = ['none', 'linked', 'linked-src', 'embedded', 'debug'];
    if (!in$(o.map, validMapValues)) {
      die("Option --map must be either: " + validMapValues.join(', '));
    }
    o.run = !(o.compile || (o.compile = o.output));
    if (args === process.argv) {
      process.argv[0] = process.argv[1];
      toInsert = o.stdin
        ? positional
        : o.run
          ? positional.splice(1, 9e9)
          : [];
      (ref$ = process.argv).splice.apply(ref$, [2, 9e9].concat(slice$.call(toInsert)));
    }
    if (that = o.require) {
      filename = module.filename;
      module.filename = '.';
      each(function(it){
        return global[nameFromPath(it)] = require(it);
      })(
      that);
      module.filename = filename;
    }
    switch (false) {
    case !o.eval:
      jsonCallback = function(input){
        if (o.prelude) {
          import$(global, prelude);
        }
        o.runContext = JSON.parse(input.toString());
        compileScript('', o.eval);
      };
      if (positional.length &amp;&amp; (o.json || /\.json$/.test(positional[0]))) {
        o.json = true;
        fshoot('readFile', positional[0], jsonCallback);
      } else if (o.json) {
        getStdin(jsonCallback);
      } else {
        compileScript('', o.eval);
      }
      break;
    case !o.stdin:
      compileStdin();
      break;
    case !positional.length:
      compileScripts();
      break;
    case !require('tty').isatty(0):
      say("LiveScript " + version + " - use 'lsc --help' for more information");
      repl();
      break;
    default:
      compileStdin();
    }
  }
  function fshoot(name, arg, callback){
    fs[name](arg, function(e, result){
      if (e) {
        die(e.stack || e);
      }
      callback(result);
    });
  }
  function compileScripts(){
    positional.forEach(function(it){
      walk(it, path.normalize(it), true);
    });
    function walk(source, base, top){
      function work(){
        fshoot('readFile', source, function(it){
          compileScript(source, it + "", base);
        });
      }
      fs.stat(source, function(e, stats){
        if (e) {
          if (!top || /(?:\.ls|\/)$/.test(source)) {
            die("Can't find: " + source);
          }
          walk(source + ".ls", base);
          return;
        }
        if (stats.isDirectory()) {
          if (!o.run) {
            fshoot('readdir', source, function(it) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.compile" id="apidoc.module.livescript.compile">module livescript.compile</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.compile.compile" id="apidoc.element.livescript.compile.compile">
        function <span class="apidocSignatureSpan">livescript.</span>compile
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (code, options){
  var result, ast, output, filename, outputFilename, ref$, mapPath, e, that;
  options == null &amp;&amp; (options = {});
  options.header == null &amp;&amp; (options.header = true);
  try {
    if (options.json) {
      result = Function(exports.compile(code, {
        bare: true,
        run: true,
        print: true
      }))();
      return JSON.stringify(result, null, 2) + "\n";
    } else {
      ast = parser.parse(lexer.lex(code));
      if (options.run &amp;&amp; options.print) {
        ast.makeReturn();
      }
      output = ast.compileRoot(options);
      if (options.header) {
        output = new SourceNode(null, null, null, ["// Generated by LiveScript " + exports.VERSION + "\n", output]);
      }
      if (options.map &amp;&amp; options.map !== 'none') {
        filename = options.filename, outputFilename = options.outputFilename;
        if (!filename) {
          filename = "unnamed-" + Math.floor(Math.random() * 4294967296).toString(16) + ".ls";
        }
        output.setFile(filename);
        result = output.toStringWithSourceMap();
        if (options.map === 'embedded') {
          result.map.setSourceContent(filename, code);
        }
        if ((ref$ = options.map) === 'linked' || ref$ === 'debug') {
          mapPath = outputFilename + ".map";
          result.code += "\n//# sourceMappingURL=" + mapPath + "\n";
        } else {
          result.code += "\n//# sourceMappingURL=data:application/json;base64," + new Buffer(result.map.toString()).toString('base64
') + "\n";
        }
        return result;
      } else {
        return output.toString();
      }
    }
  } catch (e$) {
    e = e$;
    if (that = options.filename) {
      e.message += "\nat " + that;
    }
    throw e;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    call.args.push(Literal('arguments'));
    fun.params.push(Var('args$'));
  }
  out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
  if (o.inGenerator) {
    out = new Yield('yieldfrom', out);
  }
  return out.<span class="apidocCodeKeywordSpan">compile</span>(o);
},
compileBlock: function(o, node){
  var code;
  if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
    return sn(null, "{\n", code, "\n" + this.tab + "}");
  } else {
    return sn(node, '{}');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.emit" id="apidoc.module.livescript.emit">module livescript.emit</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.emit.emit" id="apidoc.element.livescript.emit.emit">
        function <span class="apidocSignatureSpan">livescript.</span>emit
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError &amp;&amp; events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  if (domain &amp;&amp; this !== process) {
    domain.enter();
    needDomainExit = true;
  }

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i &lt; len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  if (needDomainExit)
    domain.exit();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    rest = this.lines.splice(i, 9e9);
    pre = [this.compile(o), "\n"];
    this.lines = rest;
  }
  if (snEmpty(post = this.compile(o))) {
    return sn(this, pre[0] || []);
  }
  return sn.apply(null, [null].concat(slice$.call(pre), [(that = this.scope) ? that.<span class="apidocCodeKeywordSpan">emit</span>(post, o.indent) : post]));
};
Block.prototype.compileExpressions = function(o, level){
  var lines, i, that, code, last, i$, len$, node;
  lines = this.chomp().lines;
  i = -1;
  while (that = lines[++i]) {
    if (that.comment) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.eventNames" id="apidoc.module.livescript.eventNames">module livescript.eventNames</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.eventNames.eventNames" id="apidoc.element.livescript.eventNames.eventNames">
        function <span class="apidocSignatureSpan">livescript.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  return this._eventsCount &gt; 0 ? Reflect.ownKeys(this._events) : [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.getMaxListeners" id="apidoc.module.livescript.getMaxListeners">module livescript.getMaxListeners</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.getMaxListeners.getMaxListeners" id="apidoc.element.livescript.getMaxListeners.getMaxListeners">
        function <span class="apidocSignatureSpan">livescript.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMaxListeners() {
  return $getMaxListeners(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.go" id="apidoc.module.livescript.go">module livescript.go</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.go.go" id="apidoc.element.livescript.go.go">
        function <span class="apidocSignatureSpan">livescript.</span>go
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">go = function (){
  var type, sink, i$, ref$, len$, script, that;
  type = /^(?:text\/|application\/)?ls$/i;
  sink = function(error){
    error &amp;&amp; setTimeout(function(){
      throw error;
    });
  };
  for (i$ = 0, len$ = (ref$ = document.getElementsByTagName('script')).length; i$ &lt; len$; ++i$) {
    script = ref$[i$];
    if (type.test(script.type)) {
      if (that = script.src) {
        LiveScript.load(that, sink);
      } else {
        LiveScript.stab(script.innerHTML, sink, script.id);
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.lex" id="apidoc.module.livescript.lex">module livescript.lex</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.lex.lex" id="apidoc.element.livescript.lex.lex">
        function <span class="apidocSignatureSpan">livescript.</span>lex
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lex = function (it){
  return lexer.lex(it, {
    raw: true
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    stack.length = stack.length - 2 * n;
    vstack.length = vstack.length - n;
    lstack.length = lstack.length - n;
}
_token_stack:
    var lex = function () {
        var token;
        token = lexer.<span class="apidocCodeKeywordSpan">lex</span>() || EOF;
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    };
var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
while (true) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.lexer" id="apidoc.module.livescript.lexer">module livescript.lexer</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.lexer.able" id="apidoc.element.livescript.lexer.able">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>able
        <span class="apidocSignatureSpan">(call)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">able = function (call){
  return !this.last.spaced &amp;&amp; able(this.tokens, null, call);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case '.&gt;&gt;.':
case '.&gt;&gt;&gt;.':
case '&lt;?':
case '&gt;?':
  tag = 'SHIFT';
  break;
case '(':
  if (!(((ref$ = this.last[0]) === 'FUNCTION' || ref$ === 'GENERATOR' || ref$ === 'LET') || this.&lt;
span class="apidocCodeKeywordSpan"&gt;able(true) || this.last[1] === '.@')) {
    this.token('(', '(');
    this.closes.push(')');
    this.parens.push(this.last);
    return 1;
  }
  tag = 'CALL(';
  this.closes.push(')CALL');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.addInterpolated" id="apidoc.element.livescript.lexer.addInterpolated">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>addInterpolated
        <span class="apidocSignatureSpan">(parts, nlines)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addInterpolated = function (parts, nlines){
  var tokens, last, ref$, left, right, joint, callable, i$, len$, i, t;
  if (!parts[1]) {
    return this.strnum(nlines(this.string('"', parts[0][1])));
  }
  tokens = this.tokens, last = this.last;
  ref$ = !last.spaced &amp;&amp; last[1] === '%'
    ? (--tokens.length, this.last = last = tokens[tokens.length - 1], ['[', ']', [',', ',']])
    : ['(', ')', ['+-', '+']], left = ref$[0], right = ref$[1], joint = ref$[2];
  callable = this.adi();
  tokens.push([left, '"', last[2], last[3]]);
  for (i$ = 0, len$ = parts.length; i$ &lt; len$; ++i$) {
    i = i$;
    t = parts[i$];
    if (t[0] === 'TOKENS') {
      tokens.push.apply(tokens, t[1]);
    } else {
      if (i &gt; 1 &amp;&amp; !t[1]) {
        continue;
      }
      tokens.push(['STRNUM', nlines(this.string('"', t[1])), t[2], t[3]]);
    }
    tokens.push(joint.concat(tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]));
  }
  --tokens.length;
  this.token(right, '', callable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (q === code.charAt(index + 1)) {
    return q === code.charAt(index + 2)
      ? this.doHeredoc(code, index, q)
      : (this.strnum(q + q), 2);
  }
  if (q === '"') {
    parts = this.interpolate(code, index, q);
    this.<span class="apidocCodeKeywordSpan">addInterpolated</span>(parts, unlines);
    return parts.size;
  }
  str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp('unterminated string');
  this.strnum(unlines(this.string(q, str.slice(1, -1))));
  return this.countLines(str).length;
};
exports.doHeredoc = function(code, index, q){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.adi" id="apidoc.element.livescript.lexer.adi">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>adi
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adi = function (){
  if (this.last.spaced) {
    return;
  }
  if (!able(this.tokens)) {
    return;
  }
  return this.token('DOT', '.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Function("var " + id);
  } catch (e$) {
    e = e$;
    this.carp("invalid identifier '" + id + "'");
  }
}
last = this.last;
if (regexMatch[2] || last[0] === 'DOT' || this.<span class="apidocCodeKeywordSpan">adi</span>()) {
  this.token('ID', in$(id, JS_KEYWORDS) ? (ref$ = Object(id), ref$.reserved = true, ref$) : id);
  if (regexMatch[2]) {
    this.token(':', ':');
  }
  return input.length;
}
switch (id) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.carp" id="apidoc.element.livescript.lexer.carp">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>carp
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">carp = function (it){
  carp(it, this.line);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  return code;
},
compileClosure: function(o){
  var that, fun, call, hasArgs, hasThis, out;
  if (that = this.getJump()) {
    that.<span class="apidocCodeKeywordSpan">carp</span>('inconvertible statement');
  }
  fun = Fun([], Block(this));
  call = Call();
  if (o.inGenerator) {
    fun.generator = true;
  }
  this.traverseChildren(function(it){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.checkConsistency" id="apidoc.element.livescript.lexer.checkConsistency">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>checkConsistency
        <span class="apidocSignatureSpan">(camel, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkConsistency = function (camel, id){
  if (this.hasOwn.call(this.identifiers, camel) &amp;&amp; this.identifiers[camel] !== id) {
    throw new ReferenceError("Inconsistent use of " + camel + " as " + id + " on line " + (-~this.line));
  } else {
    return this.identifiers[camel] = id;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var regexMatch, input, id, e, last, ref$, tag, ref1$, that;
input = (regexMatch = (ID.lastIndex = index, ID).exec(code))[0];
if (!input) {
  return 0;
}
id = camelize(regexMatch[1]);
if (/-/.test(regexMatch[1])) {
  this.<span class="apidocCodeKeywordSpan">checkConsistency</span>(id, regexMatch[1]);
}
if (NONASCII.test(id)) {
  try {
    Function("var " + id);
  } catch (e$) {
    e = e$;
    this.carp("invalid identifier '" + id + "'");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.countLines" id="apidoc.element.livescript.lexer.countLines">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>countLines
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">countLines = function (it){
  var pos;
  if (!this.isAtPrefix) {
    this.column += it.length;
  }
  while (pos = 1 + it.indexOf('\n', pos)) {
    if (!this.isAtPrefix) {
      this.column = 0;
    }
    this.column += it.length - pos;
    ++this.line;
    this.isAtPrefix = false;
  }
  this.charsCounted += it.length;
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (q === '"') {
  parts = this.interpolate(code, index, q);
  this.addInterpolated(parts, unlines);
  return parts.size;
}
str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp('unterminated string');
this.strnum(unlines(this.string(q, str.slice(1, -1))));
return this.<span class="apidocCodeKeywordSpan">countLines</span>(str).length;
};
exports.doHeredoc = function(code, index, q){
var end, raw, doc, parts, tabs, i$, len$, i, t;
if (q === '\'') {
  ~(end = code.indexOf(q + q + q, index + 3)) || this.carp('unterminated heredoc');
  raw = code.slice(index + 3, end);
  doc = raw.replace(LASTDENT, '');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.dedent" id="apidoc.element.livescript.lexer.dedent">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>dedent
        <span class="apidocSignatureSpan">(debt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dedent = function (debt){
  var dent;
  this.dent -= debt;
  while (debt &gt; 0 &amp;&amp; (dent = this.dents.pop())) {
    if (debt &lt; dent &amp;&amp; !this.inter) {
      this.carp("unmatched dedent (" + debt + " for " + dent + ")");
    }
    this.pair('DEDENT');
    debt -= typeof dent === 'number' ? this.token('DEDENT', dent) : dent;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      i += this.doLiteral(code, i);
    }
    break;
  default:
    i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
  }
}
this.<span class="apidocCodeKeywordSpan">dedent</span>(this.dent);
if (that = this.closes.pop()) {
  this.carp("missing `" + that + "`");
}
if (this.inter) {
  this.rest == null &amp;&amp; this.carp('unterminated interpolation');
} else {
  this.last.spaced = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doBackslash" id="apidoc.element.livescript.lexer.doBackslash">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doBackslash
        <span class="apidocSignatureSpan">(code, lastIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doBackslash = function (code, lastIndex){
  var ref$, input, word;
  BSTOKEN.lastIndex = lastIndex;
  ref$ = BSTOKEN.exec(code), input = ref$[0], word = ref$[1];
  if (word) {
    this.strnum(this.string('\'', word));
  } else {
    this.countLines(input);
  }
  return input.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case ' ':
  i += this.doSpace(code, i);
  break;
case '\n':
  i += this.doLine(code, i);
  break;
case '\\':
  i += this.<span class="apidocCodeKeywordSpan">doBackslash</span>(code, i);
  break;
case '\'':
case '"':
  i += this.doString(code, i, c);
  break;
case "0":
case "1":
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doCase" id="apidoc.element.livescript.lexer.doCase">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doCase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doCase = function (){
  var ref$, ref1$;
  this.seenFor = false;
  if (((ref$ = this.last[0]) === 'ASSIGN' || ref$ === '-&gt;' || ref$ === ':') || (this.last[0] === 'INDENT' &amp;&amp; ((ref$ = (ref1$ = this
.tokens)[ref1$.length - 2][0]) === 'ASSIGN' || ref$ === '-&gt;' || ref$ === ':'))) {
    this.token('SWITCH', 'switch');
    return this.token('CASE', 'case');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }.call(this));
  break;
case 'when':
  this.fset('for', false);
  tag = 'CASE';
  // fallthrough
case 'case':
  if (this.<span class="apidocCodeKeywordSpan">doCase</span>()) {
    return input.length;
  }
  break;
case 'match':
  tag = 'SWITCH';
  break;
case 'loop':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doComment" id="apidoc.element.livescript.lexer.doComment">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doComment
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doComment = function (code, index){
  var comment, end, ref$;
  comment = ~(end = code.indexOf('*/', index + 2))
    ? code.slice(index, end + 2)
    : code.slice(index) + '*/';
  if ((ref$ = this.last[0]) === 'NEWLINE' || ref$ === 'INDENT' || ref$ === 'THEN') {
    this.token('COMMENT', detab(comment, this.dent));
    this.token('NEWLINE', '\n');
  }
  return this.countLines(comment).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case "8":
case "9":
  i += this.doNumber(code, i);
  break;
case '/':
  switch (code.charAt(i + 1)) {
  case '*':
    i += this.<span class="apidocCodeKeywordSpan">doComment</span>(code, i);
    break;
  case '/':
    i += this.doHeregex(code, i);
    break;
  default:
    i += this.doRegex(code, i) || this.doLiteral(code, i);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doHeredoc" id="apidoc.element.livescript.lexer.doHeredoc">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doHeredoc
        <span class="apidocSignatureSpan">(code, index, q)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doHeredoc = function (code, index, q){
  var end, raw, doc, parts, tabs, i$, len$, i, t;
  if (q === '\'') {
    ~(end = code.indexOf(q + q + q, index + 3)) || this.carp('unterminated heredoc');
    raw = code.slice(index + 3, end);
    doc = raw.replace(LASTDENT, '');
    this.strnum(enlines(this.string(q, lchomp(detab(doc, heretabs(doc))))));
    return this.countLines(raw).length + 6;
  }
  parts = this.interpolate(code, index, q + q + q);
  tabs = heretabs(code.slice(index + 3, index + parts.size - 3).replace(LASTDENT, ''));
  for (i$ = 0, len$ = parts.length; i$ &lt; len$; ++i$) {
    i = i$;
    t = parts[i$];
    if (t[0] === 'S') {
      if (i + 1 === parts.length) {
        t[1] = t[1].replace(LASTDENT, '');
      }
      t[1] = detab(t[1], tabs);
      if (i === 0) {
        t[1] = lchomp(t[1]);
      }
    }
  }
  this.addInterpolated(parts, enlines);
  return parts.size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.strnum(num);
return input.length;
};
exports.doString = function(code, index, q){
var parts, str;
if (q === code.charAt(index + 1)) {
  return q === code.charAt(index + 2)
    ? this.<span class="apidocCodeKeywordSpan">doHeredoc</span>(code, index, q)
    : (this.strnum(q + q), 2);
}
if (q === '"') {
  parts = this.interpolate(code, index, q);
  this.addInterpolated(parts, unlines);
  return parts.size;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doHeregex" id="apidoc.element.livescript.lexer.doHeregex">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doHeregex
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doHeregex = function (code, index){
  var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;
  tokens = this.tokens, last = this.last;
  parts = this.interpolate(code, index, '//');
  rest = code.slice(index + parts.size);
  flag = this.validate(/^(?:[gimy]{1,4}|[?$]?)/.exec(rest)[0]);
  if (parts[1]) {
    if (flag === '$') {
      this.adi();
      this.token('(', '"');
    } else {
      tokens.push(['ID', 'RegExp', last[2], last[3]], ['CALL(', '', last[2], last[3]]);
      if (flag === '?') {
        for (i$ = parts.length - 1; i$ &gt;= 0; --i$) {
          i = i$;
          t = parts[i$];
          if (t[0] === 'TOKENS') {
            dynaflag = parts.splice(i, 1)[0][1];
            break;
          }
        }
      }
    }
    for (i$ = 0, len$ = parts.length; i$ &lt; len$; ++i$) {
      i = i$;
      t = parts[i$];
      if (t[0] === 'TOKENS') {
        tokens.push.apply(tokens, t[1]);
      } else {
        val = deheregex(t[1]);
        if (one &amp;&amp; !val) {
          continue;
        }
        one = tokens.push((t[0] = 'STRNUM', t[1] = this.string('\'', enslash(val)), t));
      }
      tokens.push(['+-', '+', tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]]);
    }
    --tokens.length;
    if (dynaflag || flag &gt;= 'g') {
      this.token(',', ',');
      if (dynaflag) {
        tokens.push.apply(tokens, dynaflag);
      } else {
        this.token('STRNUM', "'" + flag + "'");
      }
    }
    this.token(flag === '$' ? ')' : ')CALL', '');
  } else {
    this.regex(reslash(deheregex(parts[0][1])), flag);
  }
  return parts.size + flag.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case '/':
  switch (code.charAt(i + 1)) {
  case '*':
    i += this.doComment(code, i);
    break;
  case '/':
    i += this.<span class="apidocCodeKeywordSpan">doHeregex</span>(code, i);
    break;
  default:
    i += this.doRegex(code, i) || this.doLiteral(code, i);
  }
  break;
case '`':
  if ('`' === code.charAt(i + 1)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doID" id="apidoc.element.livescript.lexer.doID">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doID
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doID = function (code, index){
  var regexMatch, input, id, e, last, ref$, tag, ref1$, that;
  input = (regexMatch = (ID.lastIndex = index, ID).exec(code))[0];
  if (!input) {
    return 0;
  }
  id = camelize(regexMatch[1]);
  if (/-/.test(regexMatch[1])) {
    this.checkConsistency(id, regexMatch[1]);
  }
  if (NONASCII.test(id)) {
    try {
      Function("var " + id);
    } catch (e$) {
      e = e$;
      this.carp("invalid identifier '" + id + "'");
    }
  }
  last = this.last;
  if (regexMatch[2] || last[0] === 'DOT' || this.adi()) {
    this.token('ID', in$(id, JS_KEYWORDS) ? (ref$ = Object(id), ref$.reserved = true, ref$) : id);
    if (regexMatch[2]) {
      this.token(':', ':');
    }
    return input.length;
  }
  switch (id) {
  case 'true':
  case 'false':
  case 'on':
  case 'off':
  case 'yes':
  case 'no':
  case 'null':
  case 'void':
  case 'arguments':
  case 'debugger':
    tag = 'LITERAL';
    break;
  case 'new':
  case 'do':
  case 'typeof':
  case 'delete':
    tag = 'UNARY';
    break;
  case 'yield':
    tag = 'YIELD';
    break;
  case 'return':
  case 'throw':
    tag = 'HURL';
    break;
  case 'break':
  case 'continue':
    tag = 'JUMP';
    break;
  case 'this':
  case 'eval':
  case 'super':
    return this.token('LITERAL', id, true).length;
  case 'for':
    id = [];
    this.fset('for', true);
    this.fset('to', false);
    this.fset('by', true);
    break;
  case 'then':
    this.fset('for', false);
    this.fset('to', false);
    break;
  case 'catch':
  case 'function':
    id = '';
    break;
  case 'in':
  case 'of':
    if (this.fget('for')) {
      this.fset('for', false);
      if (id === 'in') {
        this.fset('by', true);
        id = '';
        if (last[0] === 'ID' &amp;&amp; ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === ',' || ref$ === ']' || ref$ === '}')) {
          id = this.tokens.pop()[1];
          if ((ref$ = this.tokens)[ref$.length - 1][0] === ',') {
            this.tokens.pop();
          }
        }
      }
      break;
    }
    // fallthrough
  case 'instanceof':
    if (last[1] === '!') {
      id = this.tokens.pop()[1] + id;
    }
    tag = (ref$ = this.tokens)[ref$.length - 1][0] === '(' ? 'BIOPR' : 'RELATION';
    break;
  case 'not':
    if (last.alias &amp;&amp; last[1] === '===') {
      return last[1] = '!==', 3;
    }
    tag = 'UNARY';
    id = '!';
    break;
  case 'and':
  case 'or':
  case 'xor':
  case 'is':
  case 'isnt':
    this.unline();
    tag = id === 'is' || id === 'isnt' ? 'COMPARE' : 'LOGIC';
    if (last[0] === '(') {
      tag = 'BIOP';
    }
    this.token(tag, (function(){
      switch (id) {
      case 'is':
        return '===';
      case 'isnt':
        return '!==';
      case 'or':
        return '||';
      case 'and':
        return '&amp;&amp;';
      case 'xor':
        return 'xor';
      }
    }()));
    this.last.alias = true;
    return id.length;
  case 'unless':
    tag = 'IF';
    break;
  case 'until':
    tag = 'WHILE';
    break;
  case 'import':
    if (last[0] === '(') {
      id = '&lt;&lt;&lt;';
      tag = 'BIOP';
    } else {
      if (able(this.tokens)) {
        id = '&lt;&lt;&lt;';
      } else {
        tag = 'DECL';
      }
    }
    break;
  case 'export':
  case 'const':
  case 'var':
    tag = 'DECL';
    break;
  case 'with':
    tag = (function(){
      switch (false) {
      case !able(this.tokens):
        return 'CLONEPORT';
      case last[0] !== '(':
        return 'BIOP';
      default:
        return 'WITH';
      }
    }.call(this));
    break;
  case 'when':
    this.fset('for', false);
    tag = 'CASE';
    // fallthrough
  case 'case':
    if (this.doCase()) {
      return input.length;
    }
    break;
  case 'match':
    tag = 'SWITCH';
    break;
  case 'loop':
    this.token('WHILE', id);
    this.token('LITERAL', 'true');
    return input.length;
  case 'let':
  case 'own':
    if (last[0] === 'FOR' &amp;&amp; !in$(id, last[1])) {
      last[1].push(id);
      return 3;
    }
    // fallthrough
  default:
    if (in$(id, KEYWORDS_SHARED)) {
      break;
    }
    if (in$(id, KEYWORDS_UNUSED)) {
      this.carp("reserve ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if ('`' === code.charAt(i + 1)) {
      i += this.doJS(code, i);
    } else {
      i += this.doLiteral(code, i);
    }
    break;
  default:
    i += this.<span class="apidocCodeKeywordSpan">doID</span>(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
  }
}
this.dedent(this.dent);
if (that = this.closes.pop()) {
  this.carp("missing `" + that + "`");
}
if (this.inter) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doJS" id="apidoc.element.livescript.lexer.doJS">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doJS
        <span class="apidocSignatureSpan">(code, lastIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doJS = function (code, lastIndex){
  var js, ref$;
  JSTOKEN.lastIndex = lastIndex;
  js = JSTOKEN.exec(code)[0] || this.carp('unterminated JS literal');
  this.token('LITERAL', (ref$ = Object(detab(js.slice(2, -2), this.dent)), ref$.js = true, ref$), true);
  return this.countLines(js).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    break;
  default:
    i += this.doRegex(code, i) || this.doLiteral(code, i);
  }
  break;
case '`':
  if ('`' === code.charAt(i + 1)) {
    i += this.<span class="apidocCodeKeywordSpan">doJS</span>(code, i);
  } else {
    i += this.doLiteral(code, i);
  }
  break;
default:
  i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doLine" id="apidoc.element.livescript.lexer.doLine">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doLine
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doLine = function (code, index){
  var ref$, input, tabs, length, last, that, delta, tag, val;
  ref$ = (MULTIDENT.lastIndex = index, MULTIDENT).exec(code), input = ref$[0], tabs = ref$[1];
  length = this.countLines(input).length;
  last = this.last;
  last.eol = true;
  last.spaced = true;
  if (index + length &gt;= code.length) {
    return length;
  }
  if (that = tabs &amp;&amp; (this.emender || (this.emender = RegExp('[^' + tabs.charAt() + ']'))).exec(tabs)) {
    this.carp("contaminated indent " + escape(that));
  }
  if (0 &gt; (delta = tabs.length - this.dent)) {
    this.dedent(-delta);
    this.newline();
  } else {
    tag = last[0], val = last[1];
    if (tag === 'ASSIGN' &amp;&amp; ((ref$ = val + '') !== '=' &amp;&amp; ref$ !== ':=' &amp;&amp; ref$ !== '+=') || val === '++' &amp;&amp; (ref$ = this.tokens
)[ref$.length - 2].spaced || (tag === '+-' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'DOT' || tag === '
LOGIC' || tag === 'MATH' || tag === 'COMPARE' || tag === 'RELATION' || tag === 'SHIFT' || tag === 'IN' || tag === 'OF' || tag === '
TO' || tag === 'BY' || tag === 'FROM' || tag === 'EXTENDS' || tag === 'IMPLEMENTS')) {
      return length;
    }
    if (delta) {
      this.indent(delta);
    } else {
      this.newline();
    }
  }
  this.fset('for', false);
  this.fset('by', false);
  return length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.column += charsConsumed - this.charsCounted;
this.charsCounted = 0;
switch (c) {
case ' ':
  i += this.doSpace(code, i);
  break;
case '\n':
  i += this.<span class="apidocCodeKeywordSpan">doLine</span>(code, i);
  break;
case '\\':
  i += this.doBackslash(code, i);
  break;
case '\'':
case '"':
  i += this.doString(code, i, c);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doLiteral" id="apidoc.element.livescript.lexer.doLiteral">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doLiteral
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doLiteral = function (code, index){
  var sym, tag, val, ref$, that;
  if (!(sym = (SYMBOL.lastIndex = index, SYMBOL).exec(code)[0])) {
    return 0;
  }
  switch (tag = val = sym) {
  case '|':
    tag = 'CASE';
    if (this.doCase()) {
      return sym.length;
    }
    break;
  case '|&gt;':
    tag = 'PIPE';
    break;
  case '`':
    tag = 'BACKTICK';
    break;
  case '&lt;&lt;':
  case '&gt;&gt;':
    tag = 'COMPOSE';
    break;
  case '&lt;|':
    tag = 'BACKPIPE';
    break;
  case '+':
  case '-':
    tag = '+-';
    break;
  case '&amp;&amp;':
  case '||':
    tag = 'LOGIC';
    break;
  case '.&amp;.':
  case '.|.':
  case '.^.':
    tag = 'BITWISE';
    break;
  case '^^':
    tag = 'CLONE';
    break;
  case '**':
  case '^':
    tag = 'POWER';
    break;
  case '?':
    if (this.last[0] === '(') {
      this.token('PARAM(', '(');
      this.token(')PARAM', ')');
      this.token('-&gt;', '-&gt;');
      this.token('ID', 'it');
    } else {
      if (this.last.spaced) {
        tag = 'LOGIC';
      }
    }
    break;
  case '/':
  case '%':
  case '%%':
    tag = 'MATH';
    break;
  case '++':
  case '--':
    tag = 'CREMENT';
    break;
  case '&lt;&lt;&lt;':
  case '&lt;&lt;&lt;&lt;':
    tag = 'IMPORT';
    break;
  case ';':
    tag = 'NEWLINE';
    this.fset('by', false);
    break;
  case '..':
    this.token('LITERAL', '..', true);
    return 2;
  case '.':
    if (this.last[1] === '?') {
      this.last[0] = '?';
    }
    tag = 'DOT';
    break;
  case ',':
    switch (this.last[0]) {
    case ',':
    case '[':
    case '(':
    case 'CALL(':
      this.token('LITERAL', 'void');
      break;
    case 'FOR':
    case 'OWN':
      this.token('ID', '');
    }
    break;
  case '!=':
  case '~=':
    if (!(able(this.tokens) || ((ref$ = this.last[0]) === '(' || ref$ === 'CREMENT'))) {
      this.tokens.push(val === '!='
        ? ['UNARY', '!', this.line, this.column]
        : ['UNARY', '~', this.line, this.column], ['ASSIGN', '=', this.line, this.column]);
      return 2;
    }
    // fallthrough
  case '!~=':
  case '==':
    val = (function(){
      switch (val) {
      case '~=':
        return '==';
      case '!~=':
        return '!=';
      case '==':
        return '===';
      case '!=':
        return '!==';
      }
    }());
    tag = 'COMPARE';
    break;
  case '===':
  case '!==':
    val += '=';
    // fallthrough
  case '&lt;':
  case '&gt;':
  case '&lt;=':
  case '&gt;=':
  case '&lt;==':
  case '&gt;==':
  case '&gt;&gt;=':
  case '&lt;&lt;=':
    tag = 'COMPARE';
    break;
  case '.&lt;&lt;.':
  case '.&gt;&gt;.':
  case '.&gt;&gt;&gt;.':
  case '&lt;?':
  case '&gt;?':
    tag = 'SHIFT';
    break;
  case '(':
    if (!(((ref$ = this.last[0]) === 'FUNCTION' || ref$ === 'GENERATOR' || ref$ === 'LET') || this.able(true) || this.last[1] === '.@')) {
      this.token('(', '(');
      this.closes.push(')');
      this.parens.push(this.last);
      return 1;
    }
    tag = 'CALL(';
    this.closes.push(')CALL');
    break;
  case '[':
  case '{':
    this.adi();
    this.closes.push(']}'.charAt(val === '{'));
    break;
  case '}':
    if (this.inter &amp;&amp; val !== (ref$ = this.closes)[ref$.length - 1]) {
      this.rest = code.slice(index + 1);
      return 9e9;
    }
    // fallthrough
  case ']':
  case ')':
    if (tag === ')' &amp;&amp; ((ref$ = this.last[0]) === '+-' || ref$ === 'COMPARE' || ref$ === 'LOGIC' || ref$ === 'MATH' || ref$ === '
POWER' || ref$ === 'SHIFT' || ref$ === 'BITWISE' || ref$ === 'CONCAT' || ref$ === 'COMPOSE' || ref$ === 'RELATION' || ref$ === '
PIPE' || ref$ === 'BACKPIPE' || ref$ === 'IMPORT' || ref$ === 'CLONEPORT' || ref$ === 'ASSIGN')) {
      (ref$ = this.tokens)[ref$.length - 1][0] = (function(){
        switch (this.last[0]) {
        case 'RELATION':
          return 'BIOPR';
        case 'PIPE':
          this.parameters(false, -1);
          return 'BIOPP';
        default:
          return 'BIOP';
        }
      }.call(this));
    }
    if (')' === (tag = val = this.pair(val))) {
      this.lpar = this.parens.pop();
    }
    break;
  case '=':
  case ':':
    if (val === ':') {
      switch (this.last[0]) {
      case 'ID':
      case 'STRNUM':
      case ')':
        break; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case '*':
    i += this.doComment(code, i);
    break;
  case '/':
    i += this.doHeregex(code, i);
    break;
  default:
    i += this.doRegex(code, i) || this.<span class="apidocCodeKeywordSpan">doLiteral</span>(code, i);
  }
  break;
case '`':
  if ('`' === code.charAt(i + 1)) {
    i += this.doJS(code, i);
  } else {
    i += this.doLiteral(code, i);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doNumber" id="apidoc.element.livescript.lexer.doNumber">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doNumber
        <span class="apidocSignatureSpan">(code, lastIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doNumber = function (code, lastIndex){
  var input, regexMatch, last, radix, num, rnum, bound, ref$;
  NUMBER.lastIndex = lastIndex;
  if (!(input = (regexMatch = NUMBER.exec(code))[0])) {
    return 0;
  }
  last = this.last;
  if (regexMatch[5] &amp;&amp; (last[0] === 'DOT' || this.adi())) {
    this.token('STRNUM', regexMatch[4].replace(NUMBER_OMIT, ''));
    return regexMatch[4].length;
  }
  if (radix = regexMatch[1]) {
    num = parseInt(rnum = regexMatch[2].replace(NUMBER_OMIT, ''), radix);
    bound = false;
    if (radix &gt; 36 || radix &lt; 2) {
      if (/[0-9]/.exec(rnum)) {
        this.carp("invalid number base " + radix + " (with number " + rnum + "),base must be from 2 to 36");
      } else {
        bound = true;
      }
    }
    if (isNaN(num) || num === parseInt(rnum.slice(0, -1), radix)) {
      this.strnum(regexMatch[1]);
      this.token('DOT', '.~');
      this.token('ID', regexMatch[2]);
      return input.length;
    }
    num += '';
  } else {
    num = (regexMatch[3] || input).replace(NUMBER_OMIT, '');
    if (regexMatch[3] &amp;&amp; num.charAt() === '0' &amp;&amp; ((ref$ = num.charAt(1)) !== '' &amp;&amp; ref$ !== '.')) {
      this.carp("deprecated octal literal " + regexMatch[4]);
    }
  }
  if (!last.spaced &amp;&amp; last[0] === '+-') {
    last[0] = 'STRNUM';
    last[1] += num;
    return input.length;
  }
  this.strnum(num);
  return input.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case "3":
case "4":
case "5":
case "6":
case "7":
case "8":
case "9":
  i += this.<span class="apidocCodeKeywordSpan">doNumber</span>(code, i);
  break;
case '/':
  switch (code.charAt(i + 1)) {
  case '*':
    i += this.doComment(code, i);
    break;
  case '/':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doRegex" id="apidoc.element.livescript.lexer.doRegex">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doRegex
        <span class="apidocSignatureSpan">(code, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doRegex = function (code, index){
  var divisible, ref$, input, body, flag;
  if (divisible = able(this.tokens) || this.last[0] === 'CREMENT') {
    if (!this.last.spaced || ((ref$ = code.charAt(index + 1)) === ' ' || ref$ === '=')) {
      return 0;
    }
  }
  ref$ = (REGEX.lastIndex = index, REGEX).exec(code), input = ref$[0], body = ref$[1], flag = ref$[2];
  if (input) {
    this.regex(body, flag);
  } else if (!divisible &amp;&amp; this.last[0] !== '(') {
    this.carp('unterminated regex');
  }
  return input.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case '*':
    i += this.doComment(code, i);
    break;
  case '/':
    i += this.doHeregex(code, i);
    break;
  default:
    i += this.<span class="apidocCodeKeywordSpan">doRegex</span>(code, i) || this.doLiteral(code, i);
  }
  break;
case '`':
  if ('`' === code.charAt(i + 1)) {
    i += this.doJS(code, i);
  } else {
    i += this.doLiteral(code, i);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doSpace" id="apidoc.element.livescript.lexer.doSpace">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doSpace
        <span class="apidocSignatureSpan">(code, lastIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doSpace = function (code, lastIndex){
  var input;
  SPACE.lastIndex = lastIndex;
  if (input = SPACE.exec(code)[0]) {
    this.last.spaced = true;
  }
  return input.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.charsCounted &gt; charsConsumed) {
  throw new Error('Location information out-of-sync in lexer');
}
this.column += charsConsumed - this.charsCounted;
this.charsCounted = 0;
switch (c) {
case ' ':
  i += this.<span class="apidocCodeKeywordSpan">doSpace</span>(code, i);
  break;
case '\n':
  i += this.doLine(code, i);
  break;
case '\\':
  i += this.doBackslash(code, i);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.doString" id="apidoc.element.livescript.lexer.doString">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>doString
        <span class="apidocSignatureSpan">(code, index, q)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doString = function (code, index, q){
  var parts, str;
  if (q === code.charAt(index + 1)) {
    return q === code.charAt(index + 2)
      ? this.doHeredoc(code, index, q)
      : (this.strnum(q + q), 2);
  }
  if (q === '"') {
    parts = this.interpolate(code, index, q);
    this.addInterpolated(parts, unlines);
    return parts.size;
  }
  str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp('unterminated string');
  this.strnum(unlines(this.string(q, str.slice(1, -1))));
  return this.countLines(str).length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i += this.doLine(code, i);
  break;
case '\\':
  i += this.doBackslash(code, i);
  break;
case '\'':
case '"':
  i += this.<span class="apidocCodeKeywordSpan">doString</span>(code, i, c);
  break;
case "0":
case "1":
case "2":
case "3":
case "4":
case "5":
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.dotcat" id="apidoc.element.livescript.lexer.dotcat">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>dotcat
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dotcat = function (it){
  if (this.last[1] === '.' || this.adi()) {
    return this.last[1] += it;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  tag = 'UNARY';
  break;
case '|':
  tag = 'BITWISE';
  break;
case '~':
  if (this.<span class="apidocCodeKeywordSpan">dotcat</span>(val)) {
    return 1;
  }
  tag = 'UNARY';
  break;
case '::':
  this.adi();
  val = 'prototype';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.fget" id="apidoc.element.livescript.lexer.fget">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>fget
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fget = function (key){
  var ref$;
  return (ref$ = this.flags[this.closes.length]) != null ? ref$[key] : void 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case 'catch':
case 'function':
  id = '';
  break;
case 'in':
case 'of':
  if (this.<span class="apidocCodeKeywordSpan">fget</span>('for')) {
    this.fset('for', false);
    if (id === 'in') {
      this.fset('by', true);
      id = '';
      if (last[0] === 'ID' &amp;&amp; ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === ',' || ref$ === &amp;#
x27;]' || ref$ === '}')) {
        id = this.tokens.pop()[1];
        if ((ref$ = this.tokens)[ref$.length - 1][0] === ',') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.forange" id="apidoc.element.livescript.lexer.forange">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>forange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forange = function (){
  var ref$, ref1$, ref2$;
  if (((ref$ = (ref1$ = this.tokens)[ref1$.length - 2 - ((ref2$ = this.last[0]) === 'NEWLINE' || ref2$ === 'INDENT')]) != null ?
ref$[0] : void 8) === 'FOR' || this.last[0] === 'FOR') {
    this.fset('for', false);
    this.fset('from', true);
    return true;
  } else {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  break;
case 'from':
  if (last[1] === 'yield') {
    last[1] += 'from';
    return 4;
  }
  this.<span class="apidocCodeKeywordSpan">forange</span>() &amp;&amp; (tag = 'FROM');
  break;
case 'to':
case 'til':
  this.forange() &amp;&amp; this.tokens.push(['FROM', '', this.line, this.column], ['STRNUM', &amp;#
x27;0', this.line, this.column]);
  if (this.fget('from')) {
    this.fset('from', false);
    this.fset('by', true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.fset" id="apidoc.element.livescript.lexer.fset">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>fset
        <span class="apidocSignatureSpan">(key, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fset = function (key, val){
  var ref$, key$;
  ((ref$ = this.flags)[key$ = this.closes.length] || (ref$[key$] = {}))[key] = val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case 'this':
case 'eval':
case 'super':
  return this.token('LITERAL', id, true).length;
case 'for':
  id = [];
  this.<span class="apidocCodeKeywordSpan">fset</span>('for', true);
  this.fset('to', false);
  this.fset('by', true);
  break;
case 'then':
  this.fset('for', false);
  this.fset('to', false);
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.hasOwn" id="apidoc.element.livescript.lexer.hasOwn">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>hasOwn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasOwnProperty() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.indent" id="apidoc.element.livescript.lexer.indent">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>indent
        <span class="apidocSignatureSpan">(delta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indent = function (delta){
  this.dent += delta;
  this.dents.push(this.token('INDENT', delta));
  this.closes.push('DEDENT');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.newline();
} else {
  tag = last[0], val = last[1];
  if (tag === 'ASSIGN' &amp;&amp; ((ref$ = val + '') !== '=' &amp;&amp; ref$ !== ':='
; &amp;&amp; ref$ !== '+=') || val === '++' &amp;&amp; (ref$ = this.tokens)[ref$.length - 2].spaced || (
tag === '+-' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === '
;DOT' || tag === 'LOGIC' || tag === 'MATH' || tag === 'COMPARE' || tag === 'RELATION'
; || tag === 'SHIFT' || tag === 'IN' || tag === 'OF' || tag === 'TO' || tag === 'BY
' || tag === 'FROM' || tag === 'EXTENDS' || tag === 'IMPLEMENTS')) {
    return length;
  }
  if (delta) {
    this.<span class="apidocCodeKeywordSpan">indent</span>(delta);
  } else {
    this.newline();
  }
}
this.fset('for', false);
this.fset('by', false);
return length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.interpolate" id="apidoc.element.livescript.lexer.interpolate">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>interpolate
        <span class="apidocSignatureSpan">(str, idx, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interpolate = function (str, idx, end){
  var parts, end0, pos, i, ref$, oldLine, oldColumn, ch, c1, id, stringified, length, tag, e, delta, nested, clone, ref1$;
  parts = [];
  end0 = end.charAt(0);
  pos = 0;
  i = -1;
  str = str.slice(idx + end.length);
  ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];
  this.countLines(end);
  while (ch = str.charAt(++i)) {
    switch (ch) {
    case end0:
      if (end !== str.slice(i, i + end.length)) {
        continue;
      }
      parts.push(['S', this.countLines(str.slice(0, i)), oldLine, oldColumn]);
      this.countLines(end);
      return parts.size = pos + i + end.length * 2, parts;
    case '#':
      c1 = str.charAt(i + 1);
      id = in$(c1, ['@']) &amp;&amp; c1 || (ID.lastIndex = i + 1, ID).exec(str)[1];
      if (!(id || c1 === '{')) {
        continue;
      }
      break;
    case '\\':
      ++i;
      // fallthrough
    default:
      continue;
    }
    if (i || nested &amp;&amp; !stringified) {
      stringified = parts.push(['S', this.countLines(str.slice(0, i)), oldLine, oldColumn]);
      ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];
    }
    if (id) {
      length = id.length;
      if (id === '@') {
        id = 'this';
      }
      if (in$(id, ['this'])) {
        tag = 'LITERAL';
      } else {
        id = camelize(id);
        try {
          Function("'use strict'; var " + id);
        } catch (e$) {
          e = e$;
          this.carp("invalid variable interpolation '" + id + "'");
        }
        tag = 'ID';
      }
      str = str.slice(delta = i + 1 + length);
      parts.push(['TOKENS', nested = [[tag, id, this.line, this.column]]]);
    } else {
      clone = (ref$ = clone$(exports), ref$.inter = true, ref$.emender = this.emender, ref$);
      nested = clone.tokenize(str.slice(i + 2), {
        line: this.line,
        column: this.column + 2,
        raw: true
      });
      delta = str.length - clone.rest.length;
      this.countLines(str.slice(i, delta));
      str = clone.rest;
      while (((ref$ = nested[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
        nested.shift();
      }
      if (nested.length) {
        nested.unshift(['(', '(', oldLine, oldColumn]);
        nested.push([')', ')', this.line, this.column - 1]);
        parts.push(['TOKENS', nested]);
      }
      ref1$ = [this.line, this.column], oldLine = ref1$[0], oldColumn = ref1$[1];
    }
    pos += delta;
    i = -1;
  }
  this.carp("missing `" + end + "`");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var parts, str;
  if (q === code.charAt(index + 1)) {
    return q === code.charAt(index + 2)
      ? this.doHeredoc(code, index, q)
      : (this.strnum(q + q), 2);
  }
  if (q === '"') {
    parts = this.<span class="apidocCodeKeywordSpan">interpolate</span>(code, index, q);
    this.addInterpolated(parts, unlines);
    return parts.size;
  }
  str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp('unterminated string');
  this.strnum(unlines(this.string(q, str.slice(1, -1))));
  return this.countLines(str).length;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.lex" id="apidoc.element.livescript.lexer.lex">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>lex
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lex = function (code, options){
  return clone$(exports).tokenize(code || '', options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    stack.length = stack.length - 2 * n;
    vstack.length = vstack.length - n;
    lstack.length = lstack.length - n;
}
_token_stack:
    var lex = function () {
        var token;
        token = lexer.<span class="apidocCodeKeywordSpan">lex</span>() || EOF;
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    };
var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
while (true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.newline" id="apidoc.element.livescript.lexer.newline">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>newline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newline = function (){
  var ref$;
  this.last[1] === '\n' || this.tokens.push(this.last = (ref$ = ['NEWLINE', '\n', this.line, this.column], ref$.spaced = true, ref
$));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (that = this.closes.pop()) {
    this.carp("missing `" + that + "`");
  }
  if (this.inter) {
    this.rest == null &amp;&amp; this.carp('unterminated interpolation');
  } else {
    this.last.spaced = true;
    this.<span class="apidocCodeKeywordSpan">newline</span>();
  }
  o.raw || this.rewrite();
  return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.hasOwn = Object.prototype.hasOwnProperty;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.pair" id="apidoc.element.livescript.lexer.pair">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>pair
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pair = function (it){
  var wanted, ref$;
  if (!(it === (wanted = (ref$ = this.closes)[ref$.length - 1]) || ')CALL' === wanted &amp;&amp; it === ')')) {
    if ('DEDENT' !== wanted) {
      this.carp("unmatched `" + it + "`");
    }
    this.dedent((ref$ = this.dents)[ref$.length - 1]);
    return this.pair(it);
  }
  this.unline();
  return this.closes.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.parameters(false, -1);
        return 'BIOPP';
      default:
        return 'BIOP';
      }
    }.call(this));
  }
  if (')' === (tag = val = this.<span class="apidocCodeKeywordSpan">pair</span>(val))) {
    this.lpar = this.parens.pop();
  }
  break;
case '=':
case ':':
  if (val === ':') {
    switch (this.last[0]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.parameters" id="apidoc.element.livescript.lexer.parameters">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>parameters
        <span class="apidocSignatureSpan">(arrow, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parameters = function (arrow, offset){
  var i$, ref$, i, t, ref1$;
  if (this.last[0] === ')' &amp;&amp; ')' === this.last[1]) {
    this.lpar[0] = 'PARAM(';
    this.last[0] = ')PARAM';
    return;
  }
  if (arrow === '-&gt;') {
    this.token('PARAM(', '');
  } else {
    for (i$ = (ref$ = this.tokens).length - 1; i$ &gt;= 0; --i$) {
      i = i$;
      t = ref$[i$];
      if ((ref1$ = t[0]) === 'NEWLINE' || ref1$ === 'INDENT' || ref1$ === 'THEN' || ref1$ === '=&gt;' || ref1$ === '(') {
        break;
      }
    }
    this.tokens.splice(i + 1, 0, ['PARAM(', '', t[2], t[3]]);
  }
  if (offset) {
    this.tokens.splice(this.tokens.length + offset, 0, [')PARAM', '', t[2], t[3]]);
  } else {
    this.token(')PARAM', '');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case ')':
if (tag === ')' &amp;&amp; ((ref$ = this.last[0]) === '+-' || ref$ === 'COMPARE' || ref$ === '
;LOGIC' || ref$ === 'MATH' || ref$ === 'POWER' || ref$ === 'SHIFT' || ref$ === 'BITWISE&amp;#
x27; || ref$ === 'CONCAT' || ref$ === 'COMPOSE' || ref$ === 'RELATION' || ref$ === 'PIPE'
; || ref$ === 'BACKPIPE' || ref$ === 'IMPORT' || ref$ === 'CLONEPORT' || ref$ === 'ASSIGN'
;)) {
  (ref$ = this.tokens)[ref$.length - 1][0] = (function(){
    switch (this.last[0]) {
    case 'RELATION':
      return 'BIOPR';
    case 'PIPE':
      this.<span class="apidocCodeKeywordSpan">parameters</span>(false, -1);
      return 'BIOPP';
    default:
      return 'BIOP';
    }
  }.call(this));
}
if (')' === (tag = val = this.pair(val))) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.regex" id="apidoc.element.livescript.lexer.regex">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>regex
        <span class="apidocSignatureSpan">(body, flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regex = function (body, flag){
  var e;
  try {
    RegExp(body);
  } catch (e$) {
    e = e$;
    this.carp(e.message);
  }
  if (flag === '$') {
    return this.strnum(this.string('\'', enslash(body)));
  }
  return this.token('LITERAL', "/" + (body || '(?:)') + "/" + this.validate(flag));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (divisible = able(this.tokens) || this.last[0] === 'CREMENT') {
  if (!this.last.spaced || ((ref$ = code.charAt(index + 1)) === ' ' || ref$ === '=')) {
    return 0;
  }
}
ref$ = (REGEX.lastIndex = index, REGEX).exec(code), input = ref$[0], body = ref$[1], flag = ref$[2];
if (input) {
  this.<span class="apidocCodeKeywordSpan">regex</span>(body, flag);
} else if (!divisible &amp;&amp; this.last[0] !== '(') {
  this.carp('unterminated regex');
}
return input.length;
};
exports.doHeregex = function(code, index){
var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.rewrite" id="apidoc.element.livescript.lexer.rewrite">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>rewrite
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rewrite = function (it){
  var ref$;
  it || (it = this.tokens);
  firstPass(it);
  addImplicitIndentation(it);
  rewriteBlockless(it);
  addImplicitParentheses(it);
  addImplicitBraces(it);
  expandLiterals(it);
  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
    it.shift();
  }
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (this.inter) {
  this.rest == null &amp;&amp; this.carp('unterminated interpolation');
} else {
  this.last.spaced = true;
  this.newline();
}
o.raw || this.<span class="apidocCodeKeywordSpan">rewrite</span>();
return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.hasOwn = Object.prototype.hasOwnProperty;
exports.checkConsistency = function(camel, id){
if (this.hasOwn.call(this.identifiers, camel) &amp;&amp; this.identifiers[camel] !== id) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.string" id="apidoc.element.livescript.lexer.string">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>string
        <span class="apidocSignatureSpan">(q, body)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">string = function (q, body){
  return string(q, body, this.line);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (q === '"') {
  parts = this.interpolate(code, index, q);
  this.addInterpolated(parts, unlines);
  return parts.size;
}
str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp('unterminated string');
this.strnum(unlines(this.<span class="apidocCodeKeywordSpan">string</span>(q, str.slice(1, -1))));
return this.countLines(str).length;
};
exports.doHeredoc = function(code, index, q){
var end, raw, doc, parts, tabs, i$, len$, i, t;
if (q === '\'') {
  ~(end = code.indexOf(q + q + q, index + 3)) || this.carp('unterminated heredoc');
  raw = code.slice(index + 3, end);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.strnum" id="apidoc.element.livescript.lexer.strnum">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>strnum
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">strnum = function (it){
  this.token('STRNUM', it, this.adi() || this.last[0] === 'DOT');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (/[0-9]/.exec(rnum)) {
      this.carp("invalid number base " + radix + " (with number " + rnum + "),base must be from 2 to 36
");
    } else {
      bound = true;
    }
  }
  if (isNaN(num) || num === parseInt(rnum.slice(0, -1), radix)) {
    this.<span class="apidocCodeKeywordSpan">strnum</span>(regexMatch[1]);
    this.token('DOT', '.~');
    this.token('ID', regexMatch[2]);
    return input.length;
  }
  num += '';
} else {
  num = (regexMatch[3] || input).replace(NUMBER_OMIT, '');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.token" id="apidoc.element.livescript.lexer.token">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>token
        <span class="apidocSignatureSpan">(tag, value, callable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">token = function (tag, value, callable){
  this.tokens.push(this.last = [tag, value, this.line, this.column]);
  if (callable) {
    this.last.callable = true;
  }
  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } catch (e$) {
    e = e$;
    this.carp("invalid identifier '" + id + "'");
  }
}
last = this.last;
if (regexMatch[2] || last[0] === 'DOT' || this.adi()) {
  this.<span class="apidocCodeKeywordSpan">token</span>('ID', in$(id, JS_KEYWORDS) ? (ref$ = Object(id), ref$.reserved
 = true, ref$) : id);
  if (regexMatch[2]) {
    this.token(':', ':');
  }
  return input.length;
}
switch (id) {
case 'true':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.tokenize" id="apidoc.element.livescript.lexer.tokenize">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>tokenize
        <span class="apidocSignatureSpan">(code, o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokenize = function (code, o){
  var i, prevIndex, c, charsConsumed, that;
  this.inter || (code = code.replace(/[\r\u2028\u2029\uFEFF]/g, ''));
  code = '\n' + code;
  this.tokens = [this.last = ['NEWLINE', '\n', 0, 0]];
  this.line = ~-o.line;
  this.column = o.column || 0;
  this.dents = [];
  this.closes = [];
  this.parens = [];
  this.flags = [];
  i = 0;
  prevIndex = i;
  this.charsCounted = 0;
  this.isAtPrefix = true;
  while (c = code.charAt(i)) {
    charsConsumed = i - prevIndex;
    prevIndex = i;
    if (this.charsCounted &gt; charsConsumed) {
      throw new Error('Location information out-of-sync in lexer');
    }
    this.column += charsConsumed - this.charsCounted;
    this.charsCounted = 0;
    switch (c) {
    case ' ':
      i += this.doSpace(code, i);
      break;
    case '\n':
      i += this.doLine(code, i);
      break;
    case '\\':
      i += this.doBackslash(code, i);
      break;
    case '\'':
    case '"':
      i += this.doString(code, i, c);
      break;
    case "0":
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      i += this.doNumber(code, i);
      break;
    case '/':
      switch (code.charAt(i + 1)) {
      case '*':
        i += this.doComment(code, i);
        break;
      case '/':
        i += this.doHeregex(code, i);
        break;
      default:
        i += this.doRegex(code, i) || this.doLiteral(code, i);
      }
      break;
    case '`':
      if ('`' === code.charAt(i + 1)) {
        i += this.doJS(code, i);
      } else {
        i += this.doLiteral(code, i);
      }
      break;
    default:
      i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
    }
  }
  this.dedent(this.dent);
  if (that = this.closes.pop()) {
    this.carp("missing `" + that + "`");
  }
  if (this.inter) {
    this.rest == null &amp;&amp; this.carp('unterminated interpolation');
  } else {
    this.last.spaced = true;
    this.newline();
  }
  o.raw || this.rewrite();
  return this.tokens;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...




// Generated by LiveScript 1.5.0
var string, TABS, unlines, enlines, enslash, reslash, camelize, deheregex, character, KEYWORDS_SHARED, KEYWORDS_UNUSED, JS_KEYWORDS
, LS_KEYWORDS, ID, SYMBOL, SPACE, MULTIDENT, SIMPLESTR, JSTOKEN, BSTOKEN, NUMBER, NUMBER_OMIT, REGEX, HEREGEX_OMIT, LASTDENT, INLINEDENT
, NONASCII, OPENERS, CLOSERS, INVERSES, i, o, c, CHAIN, ARG, BLOCK_USERS, this$ = this, slice$ = [].slice;
exports.lex = function(code, options){
return clone$(exports).<span class="apidocCodeKeywordSpan">tokenize</span>(code || '', options || {});
};
exports.rewrite = function(it){
var ref$;
it || (it = this.tokens);
firstPass(it);
addImplicitIndentation(it);
rewriteBlockless(it);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.unline" id="apidoc.element.livescript.lexer.unline">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>unline
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unline = function (){
  var ref$;
  if (!this.tokens[1]) {
    return;
  }
  switch (this.last[0]) {
  case 'INDENT':
    (ref$ = this.dents)[ref$.length - 1] += '';
    // fallthrough
  case 'NEWLINE':
    this.tokens.length--;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  id = '!';
  break;
case 'and':
case 'or':
case 'xor':
case 'is':
case 'isnt':
  this.<span class="apidocCodeKeywordSpan">unline</span>();
  tag = id === 'is' || id === 'isnt' ? 'COMPARE' : 'LOGIC';
  if (last[0] === '(') {
    tag = 'BIOP';
  }
  this.token(tag, (function(){
    switch (id) {
    case 'is':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.lexer.validate" id="apidoc.element.livescript.lexer.validate">
        function <span class="apidocSignatureSpan">livescript.lexer.</span>validate
        <span class="apidocSignatureSpan">(flag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (flag){
  var that;
  if (that = flag &amp;&amp; /(.).*\1/.exec(flag)) {
    this.carp("duplicate regex flag `" + that[1] + "`");
  }
  return flag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return input.length;
};
exports.doHeregex = function(code, index){
var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;
tokens = this.tokens, last = this.last;
parts = this.interpolate(code, index, '//');
rest = code.slice(index + parts.size);
flag = this.<span class="apidocCodeKeywordSpan">validate</span>(/^(?:[gimy]{1,4}|[?$]?)/.exec(rest)[0]);
if (parts[1]) {
  if (flag === '$') {
    this.adi();
    this.token('(', '"');
  } else {
    tokens.push(['ID', 'RegExp', last[2], last[3]], ['CALL(', '', last[2], last[3]]);
    if (flag === '?') {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.listenerCount" id="apidoc.module.livescript.listenerCount">module livescript.listenerCount</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.listenerCount.listenerCount" id="apidoc.element.livescript.listenerCount.listenerCount">
        function <span class="apidocSignatureSpan">livescript.</span>listenerCount
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenerCount(type) {
  const events = this._events;

  if (events) {
    const evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.listeners" id="apidoc.module.livescript.listeners">module livescript.listeners</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.listeners.listeners" id="apidoc.element.livescript.listeners.listeners">
        function <span class="apidocSignatureSpan">livescript.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener];
    else
      ret = arrayClone(evlistener, evlistener.length);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      : t.output.code).trimRight());
  } else {
    writeJS(filename, t.output, t.input, base, json);
  }
} catch (e$) {
  e = e$;
  if (e != null) {
    if (LiveScript.<span class="apidocCodeKeywordSpan">listeners</span>('failure').length) {
      LiveScript.emit('failure', e, t);
    } else {
      if (filename) {
        warn("Failed at: " + filename);
      }
      if (!(e instanceof SyntaxError || /^Parse error /.test(e.message))) {
        e = e.stack || e;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.load" id="apidoc.module.livescript.load">module livescript.load</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.load.load" id="apidoc.element.livescript.load.load">
        function <span class="apidocSignatureSpan">livescript.</span>load
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (url, callback){
  var xhr;
  xhr = new XMLHttpRequest;
  xhr.open('GET', url, true);
  if ('overrideMimeType' in xhr) {
    xhr.overrideMimeType('text/plain');
  }
  xhr.onreadystatechange = function(){
    var ref$;
    if (xhr.readyState === 4) {
      if ((ref$ = xhr.status) === 200 || ref$ === 0) {
        LiveScript.stab(xhr.responseText, callback, url);
      } else {
        if (typeof callback == 'function') {
          callback(Error(url + ": " + xhr.status + " " + xhr.statusText));
        }
      }
    }
  };
  xhr.send(null);
  return xhr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.node" id="apidoc.module.livescript.node">module livescript.node</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.node.node" id="apidoc.element.livescript.node.node">
        function <span class="apidocSignatureSpan">livescript.</span>node
        <span class="apidocSignatureSpan">(LiveScript)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">node = function (LiveScript){
  var fs, path, events;
  fs = require('fs');
  path = require('path');
  events = require('events');
  LiveScript.run = function(code, options, arg$){
    var filename, ref$, js, context, main, dirname, e;
    if (options != null) {
      filename = options.filename;
    }
    ref$ = arg$ != null
      ? arg$
      : {}, js = ref$.js, context = ref$.context;
    main = require.main;
    if (filename) {
      dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));
    } else {
      dirname = filename = '.';
    }
    main.paths = main.constructor._nodeModulePaths(dirname);
    main.filename = filename;
    if (!js) {
      code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
    }
    if (context) {
      global.__runContext = context;
      code = "return (function() {\n" + code + "\n}).call(global.__runContext);";
    }
    try {
      return main._compile(code, filename);
    } catch (e$) {
      e = e$;
      throw hackTrace(e, code, filename);
    }
  };
  importAll$(LiveScript, events.EventEmitter.prototype);
  require.extensions['.ls'] = function(module, filename){
    var file, js, e;
    file = fs.readFileSync(filename, 'utf8');
    js = '.json.ls' === filename.substr(-8)
      ? 'module.exports = ' + LiveScript.compile(file, {
        filename: filename,
        json: true
      })
      : LiveScript.compile(file, {
        filename: filename,
        bare: true,
        map: "embedded"
      }).code;
    try {
      return module._compile(js, filename);
    } catch (e$) {
      e = e$;
      throw hackTrace(e, js, filename);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.once" id="apidoc.module.livescript.once">module livescript.once</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.once.once" id="apidoc.element.livescript.once.once">
        function <span class="apidocSignatureSpan">livescript.</span>once
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.options" id="apidoc.module.livescript.options">module livescript.options</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.options.generateHelp" id="apidoc.element.livescript.options.generateHelp">
        function <span class="apidocSignatureSpan">livescript.options.</span>generateHelp
        <span class="apidocSignatureSpan">(arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateHelp = function (arg$){
  var ref$, showHidden, interpolate, maxWidth, output, out, data, optionCount, totalPreLen, preLens, i$, len$, item, that, pre,
descParts, desc, preLen, sortedPreLens, maxPreLen, preLenMean, x, padAmount, descSepLen, fullWrapCount, partialWrapCount, descLen
, totalLen, initialSpace, wrapAllFull, i, wrap;
  ref$ = arg$ != null
    ? arg$
    : {}, showHidden = ref$.showHidden, interpolate = ref$.interpolate;
  maxWidth = stdout != null &amp;&amp; stdout.isTTY ? stdout.columns - 1 : null;
  output = [];
  out = function(it){
    return output.push(it != null ? it : '');
  };
  if (prepend) {
    out(interpolate ? interp(prepend, interpolate) : prepend);
    out();
  }
  data = [];
  optionCount = 0;
  totalPreLen = 0;
  preLens = [];
  for (i$ = 0, len$ = (ref$ = options).length; i$ &lt; len$; ++i$) {
    item = ref$[i$];
    if (showHidden || !item.hidden) {
      if (that = item.heading) {
        data.push({
          type: 'heading',
          value: that
        });
      } else {
        pre = getPreText(item, helpStyle, maxWidth);
        descParts = [];
        if ((that = item.description) != null) {
          descParts.push(that);
        }
        if (that = item['enum']) {
          descParts.push("either: " + naturalJoin(that));
        }
        if (item['default'] &amp;&amp; !item.negateName) {
          descParts.push("default: " + item['default']);
        }
        desc = descParts.join(' - ');
        data.push({
          type: 'option',
          pre: pre,
          desc: desc,
          descLen: desc.length
        });
        preLen = pre.length;
        optionCount++;
        totalPreLen += preLen;
        preLens.push(preLen);
      }
    }
  }
  sortedPreLens = sort(preLens);
  maxPreLen = sortedPreLens[sortedPreLens.length - 1];
  preLenMean = initialIndent + totalPreLen / optionCount;
  x = optionCount &gt; 2 ? min(preLenMean * maxPadFactor, maxPreLen) : maxPreLen;
  for (i$ = sortedPreLens.length - 1; i$ &gt;= 0; --i$) {
    preLen = sortedPreLens[i$];
    if (preLen &lt;= x) {
      padAmount = preLen;
      break;
    }
  }
  descSepLen = descriptionSeparator.length;
  if (maxWidth != null) {
    fullWrapCount = 0;
    partialWrapCount = 0;
    for (i$ = 0, len$ = data.length; i$ &lt; len$; ++i$) {
      item = data[i$];
      if (item.type === 'option') {
        pre = item.pre, desc = item.desc, descLen = item.descLen;
        if (descLen === 0) {
          item.wrap = 'none';
        } else {
          preLen = max(padAmount, pre.length) + initialIndent + descSepLen;
          totalLen = preLen + descLen;
          if (totalLen &gt; maxWidth) {
            if (descLen / 2.5 &gt; maxWidth - preLen) {
              fullWrapCount++;
              item.wrap = 'full';
            } else {
              partialWrapCount++;
              item.wrap = 'partial';
            }
          } else {
            item.wrap = 'none';
          }
        }
      }
    }
  }
  initialSpace = repeatString$(' ', initialIndent);
  wrapAllFull = optionCount &gt; 1 &amp;&amp; fullWrapCount + partialWrapCount * 0.5 &gt; optionCount * 0.5;
  for (i$ = 0, len$ = data.length; i$ &lt; len$; ++i$) {
    i = i$;
    item = data[i$];
    if (item.type === 'heading') {
      if (i !== 0) {
        out();
      }
      out(item.value + ":");
    } else {
      pre = item.pre, desc = item.desc, descLen = item.descLen, wrap = item.wrap;
      if (maxWidth != null) {
        if (wrapAllFull || wrap === 'full') {
          wrap = wordwrap(initialIndent + secondaryIndent, maxWidth);
          out(initialSpace + "" + pre + "\n" + wrap(desc));
          continue;
        } else if (wrap === 'partial') {
          wrap = wordwrap(initialIndent + descSepLen + max(padAmount, pre.length), maxWidth);
          out(initialSpace + "" + pad(pre, padAmount) + descriptionSeparator + wrap(desc).replace(/^\s+/, ''));
          continue;
        }
      }
      if (descLen === 0) {
        out(initialSpace + "" + pre);
      } else {
        out(initialSpace + "" + pad(pre, padAmount) + descriptionSeparator + desc);
      }
    }
  }
  if (append) {
    out();
    out(interpola ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.options.generateHelpForOption" id="apidoc.element.livescript.options.generateHelpForOption">
        function <span class="apidocSignatureSpan">livescript.options.</span>generateHelpForOption
        <span class="apidocSignatureSpan">(optionName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateHelpForOption = function (optionName){
  var maxWidth, wrap, option, e, pre, defaultString, restPositionalString, description, fullDescription, that, preDescription, descriptionString
, exampleString, examples, seperator;
  maxWidth = stdout != null &amp;&amp; stdout.isTTY ? stdout.columns - 1 : null;
  wrap = maxWidth ? wordwrap(maxWidth) : id;
  try {
    option = getOption(dasherize(optionName));
  } catch (e$) {
    e = e$;
    return e.message;
  }
  pre = getPreText(option, helpStyle);
  defaultString = option['default'] &amp;&amp; !option.negateName ? "\ndefault: " + option['default'] : '';
  restPositionalString = option.restPositional ? 'Everything after this option is considered a positional argument, even if it looks
 like an option.' : '';
  description = option.longDescription || option.description &amp;&amp; sentencize(option.description);
  fullDescription = description &amp;&amp; restPositionalString
    ? description + " " + restPositionalString
    : (that = description || restPositionalString) ? that : '';
  preDescription = 'description:';
  descriptionString = !fullDescription
    ? ''
    : maxWidth &amp;&amp; fullDescription.length - 1 - preDescription.length &gt; maxWidth
      ? "\n" + preDescription + "\n" + wrap(fullDescription)
      : "\n" + preDescription + " " + fullDescription;
  exampleString = (that = option.example) ? (examples = [].concat(that), examples.length &gt; 1
    ? "\nexamples:\n" + unlines(examples)
    : "\nexample: " + examples[0]) : '';
  seperator = defaultString || descriptionString || exampleString ? "\n" + repeatString$('=', pre.length) : '';
  return pre + "" + seperator + defaultString + descriptionString + exampleString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.options.parse" id="apidoc.element.livescript.options.parse">
        function <span class="apidocSignatureSpan">livescript.options.</span>parse
        <span class="apidocSignatureSpan">(input, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (input, arg$){
  var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError
, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result
, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;
  slice = (arg$ != null
    ? arg$
    : {}).slice;
  obj = {};
  positional = [];
  restPositional = false;
  overrideRequired = false;
  prop = null;
  setValue = function(name, value){
    var opt, val, cra, e, currentType;
    opt = getOption(name);
    if (opt.boolean) {
      val = value;
    } else {
      try {
        cra = opt.concatRepeatedArrays;
        if (cra != null &amp;&amp; cra[0] &amp;&amp; cra[1].oneValuePerFlag &amp;&amp; opt.parsedType.length === 1 &amp;&amp; opt.parsedType[0].structure === 'array
') {
          val = [parseLevn(opt.parsedType[0].of, value)];
        } else {
          val = parseLevn(opt.parsedType, value);
        }
      } catch (e$) {
        e = e$;
        throw new Error("Invalid value for option '" + name + "' - expected type " + opt.type + ", received value: " + value + ".");
      }
      if (opt['enum'] &amp;&amp; !any(function(it){
        return deepIs(it, val);
      }, opt.parsedPossibilities)) {
        throw new Error("Option " + name + ": '" + val + "' not one of " + naturalJoin(opt['enum']) + ".");
      }
    }
    currentType = toString$.call(obj[name]).slice(8, -1);
    if (obj[name] != null) {
      if (opt.concatRepeatedArrays != null &amp;&amp; opt.concatRepeatedArrays[0] &amp;&amp; currentType === 'Array') {
        obj[name] = obj[name].concat(val);
      } else if (opt.mergeRepeatedObjects &amp;&amp; currentType === 'Object') {
        import$(obj[name], val);
      } else {
        obj[name] = val;
      }
    } else {
      obj[name] = val;
    }
    if (opt.restPositional) {
      restPositional = true;
    }
    if (opt.overrideRequired) {
      overrideRequired = true;
    }
  };
  setDefaults = function(){
    var name, ref$, value;
    for (name in ref$ = defaults) {
      value = ref$[name];
      if (obj[name] == null) {
        obj[name] = value;
      }
    }
  };
  checkRequired = function(){
    var i$, ref$, len$, name;
    if (overrideRequired) {
      return;
    }
    for (i$ = 0, len$ = (ref$ = required).length; i$ &lt; len$; ++i$) {
      name = ref$[i$];
      if (!obj[name]) {
        throw new Error("Option " + nameToRaw(name) + " is required.");
      }
    }
  };
  mutuallyExclusiveError = function(first, second){
    throw new Error("The options " + nameToRaw(first) + " and " + nameToRaw(second) + " are mutually exclusive - you cannot use
them at the same time.");
  };
  checkMutuallyExclusive = function(){
    var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;
    rules = libOptions.mutuallyExclusive;
    if (!rules) {
      return;
    }
    for (i$ = 0, len$ = rules.length; i$ &lt; len$; ++i$) {
      rule = rules[i$];
      present = null;
      for (j$ = 0, len1$ = rule.length; j$ &lt; len1$; ++j$) {
        element = rule[j$];
        if (toString$.call(element).slice(8, -1) === 'Array') {
          for (k$ = 0, len2$ = element.length; k$ &lt; len2$; ++k$) {
            opt = element[k$];
            if (opt in obj) {
              if (present != null) {
                mutuallyExclusiveError(present, opt);
              } else {
                present = opt;
                break;
              }
            }
          }
        } else {
          if (element in obj) {
            if (present != null) {
              mutuallyExclusiveError(present, element);
            } else {
              present = element;
            }
          }
        }
      }
    }
  };
  checkDependency = function(option){
    var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;
    dependsOn = option.dependsOn;
    if (!dependsOn || option.dependenciesMet) {
      return true;
    }
    type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);
    for (i$ = 0, len$ = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.fromJSON(JSON.<span class="apidocCodeKeywordSpan">parse</span>(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &amp;&amp; typeof it === 'object')) {
    return it;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.options.parseArgv" id="apidoc.element.livescript.options.parseArgv">
        function <span class="apidocSignatureSpan">livescript.options.</span>parseArgv
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseArgv = function (it){
  return parse(it, {
    slice: 2
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.parser" id="apidoc.module.livescript.parser">module livescript.parser</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.parser.Parser" id="apidoc.element.livescript.parser.Parser">
        function <span class="apidocSignatureSpan">livescript.parser.</span>Parser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser() {
  this.yy = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.parser.main" id="apidoc.element.livescript.parser.main">
        function <span class="apidocSignatureSpan">livescript.parser.</span>main
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' &amp;&amp; require.main === module) {
  exports.<span class="apidocCodeKeywordSpan">main</span>(process.argv.slice(1));
}
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.parser.parse" id="apidoc.element.livescript.parser.parse">
        function <span class="apidocSignatureSpan">livescript.parser.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function () { return parser.parse.apply(parser, arguments); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
toJSON: function(){
  return import$({
    type: this.constructor.displayName
  }, this);
}
};
exports.parse = function(json){
return exports.fromJSON(JSON.<span class="apidocCodeKeywordSpan">parse</span>(json));
};
exports.fromJSON = (function(){
function fromJSON(it){
  var that, node, key, val, i$, len$, v, results$ = [];
  if (!(it &amp;&amp; typeof it === 'object')) {
    return it;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.prependListener" id="apidoc.module.livescript.prependListener">module livescript.prependListener</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.prependListener.prependListener" id="apidoc.element.livescript.prependListener.prependListener">
        function <span class="apidocSignatureSpan">livescript.</span>prependListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.prependOnceListener" id="apidoc.module.livescript.prependOnceListener">module livescript.prependOnceListener</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.prependOnceListener.prependOnceListener" id="apidoc.element.livescript.prependOnceListener.prependOnceListener">
        function <span class="apidocSignatureSpan">livescript.</span>prependOnceListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependOnceListener(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.removeAllListeners" id="apidoc.module.livescript.removeAllListeners">module livescript.removeAllListeners</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.removeAllListeners.removeAllListeners" id="apidoc.element.livescript.removeAllListeners.removeAllListeners">
        function <span class="apidocSignatureSpan">livescript.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(type) {
  var listeners, events;

  events = this._events;
  if (!events)
    return this;

  // not listening for removeListener, no need to emit
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i = 0, key; i &lt; keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.removeListener" id="apidoc.module.livescript.removeListener">module livescript.removeListener</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.removeListener.removeListener" id="apidoc.element.livescript.removeListener.removeListener">
        function <span class="apidocSignatureSpan">livescript.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = this._events;
  if (!events)
    return this;

  list = events[type];
  if (!list)
    return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events[type];
      if (events.removeListener)
        this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length; i-- &gt; 0;) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position &lt; 0)
      return this;

    if (list.length === 1) {
      list[0] = undefined;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }

    if (events.removeListener)
      this.emit('removeListener', type, originalListener || listener);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.run" id="apidoc.module.livescript.run">module livescript.run</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.run.run" id="apidoc.element.livescript.run.run">
        function <span class="apidocSignatureSpan">livescript.</span>run
        <span class="apidocSignatureSpan">(code, options, arg$)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (code, options, arg$){
  var filename, ref$, js, context, main, dirname, e;
  if (options != null) {
    filename = options.filename;
  }
  ref$ = arg$ != null
    ? arg$
    : {}, js = ref$.js, context = ref$.context;
  main = require.main;
  if (filename) {
    dirname = path.dirname(fs.realpathSync(filename = process.argv[1] = path.resolve(filename)));
  } else {
    dirname = filename = '.';
  }
  main.paths = main.constructor._nodeModulePaths(dirname);
  main.filename = filename;
  if (!js) {
    code = LiveScript.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
  }
  if (context) {
    global.__runContext = context;
    code = "return (function() {\n" + code + "\n}).call(global.__runContext);";
  }
  try {
    return main._compile(code, filename);
  } catch (e$) {
    e = e$;
    throw hackTrace(e, code, filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
json = o.json || /\.json\.ls$/.test(filename);
run = o.run || o.eval;
if (run) {
  LiveScript.emit('compile', t);
  print = json || o.print;
  t.output = LiveScript.compile(t.input, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$.run = run, ref$.print = print
, ref$));
  LiveScript.emit('run', t);
  t.result = LiveScript.<span class="apidocCodeKeywordSpan">run</span>(o.map === 'none'
    ? t.output
    : t.output.code, options, {
    js: true,
    context: o.runContext
  });
  switch (false) {
  case !json:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.setMaxListeners" id="apidoc.module.livescript.setMaxListeners">module livescript.setMaxListeners</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.setMaxListeners.setMaxListeners" id="apidoc.element.livescript.setMaxListeners.setMaxListeners">
        function <span class="apidocSignatureSpan">livescript.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners(n) {
  if (typeof n !== 'number' || n &lt; 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.stab" id="apidoc.module.livescript.stab">module livescript.stab</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.stab.stab" id="apidoc.element.livescript.stab.stab">
        function <span class="apidocSignatureSpan">livescript.</span>stab
        <span class="apidocSignatureSpan">(code, callback, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stab = function (code, callback, filename){
  var e;
  try {
    LiveScript.run(code, {
      filename: filename,
      map: 'embedded'
    });
  } catch (e$) {
    e = e$;
  }
  if (typeof callback == 'function') {
    callback(e);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.tokens" id="apidoc.module.livescript.tokens">module livescript.tokens</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.tokens.tokens" id="apidoc.element.livescript.tokens.tokens">
        function <span class="apidocSignatureSpan">livescript.</span>tokens
        <span class="apidocSignatureSpan">(code, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tokens = function (code, options){
  return clone$(exports).tokenize(code || '', options || {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
t = {
  input: input,
  options: options
};
try {
  if (o.lex || o.tokens || o.ast) {
    LiveScript.emit('lex', t);
    t.tokens = LiveScript.<span class="apidocCodeKeywordSpan">tokens</span>(t.input, {
      raw: o.lex
    });
    if (o.lex || o.tokens) {
      printTokens(t.tokens);
      throw null;
    }
    LiveScript.emit('parse', t);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.tokens.rewrite" id="apidoc.element.livescript.tokens.rewrite">
        function <span class="apidocSignatureSpan">livescript.tokens.</span>rewrite
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rewrite = function (it){
  var ref$;
  it || (it = this.tokens);
  firstPass(it);
  addImplicitIndentation(it);
  rewriteBlockless(it);
  addImplicitParentheses(it);
  addImplicitBraces(it);
  expandLiterals(it);
  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
    it.shift();
  }
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (this.inter) {
  this.rest == null &amp;&amp; this.carp('unterminated interpolation');
} else {
  this.last.spaced = true;
  this.newline();
}
o.raw || this.<span class="apidocCodeKeywordSpan">rewrite</span>();
return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.hasOwn = Object.prototype.hasOwnProperty;
exports.checkConsistency = function(camel, id){
if (this.hasOwn.call(this.identifiers, camel) &amp;&amp; this.identifiers[camel] !== id) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.tokens.rewrite" id="apidoc.module.livescript.tokens.rewrite">module livescript.tokens.rewrite</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.tokens.rewrite.rewrite" id="apidoc.element.livescript.tokens.rewrite.rewrite">
        function <span class="apidocSignatureSpan">livescript.tokens.</span>rewrite
        <span class="apidocSignatureSpan">(it)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rewrite = function (it){
  var ref$;
  it || (it = this.tokens);
  firstPass(it);
  addImplicitIndentation(it);
  rewriteBlockless(it);
  addImplicitParentheses(it);
  addImplicitBraces(it);
  expandLiterals(it);
  if (((ref$ = it[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
    it.shift();
  }
  return it;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (this.inter) {
  this.rest == null &amp;&amp; this.carp('unterminated interpolation');
} else {
  this.last.spaced = true;
  this.newline();
}
o.raw || this.<span class="apidocCodeKeywordSpan">rewrite</span>();
return this.tokens;
};
exports.dent = 0;
exports.identifiers = {};
exports.hasOwn = Object.prototype.hasOwnProperty;
exports.checkConsistency = function(camel, id){
if (this.hasOwn.call(this.identifiers, camel) &amp;&amp; this.identifiers[camel] !== id) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.livescript.util" id="apidoc.module.livescript.util">module livescript.util</a></h1>


    <h2>
        <a href="#apidoc.element.livescript.util.nameFromPath" id="apidoc.element.livescript.util.nameFromPath">
        function <span class="apidocSignatureSpan">livescript.util.</span>nameFromPath
        <span class="apidocSignatureSpan">(modulePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nameFromPath = function (modulePath){
  return path.basename(stripString(modulePath)).split('.')[0].replace(/-[a-z]/ig, function(it){
    return it.charAt(1).toUpperCase();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.livescript.util.stripString" id="apidoc.element.livescript.util.stripString">
        function <span class="apidocSignatureSpan">livescript.util.</span>stripString
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripString = function (val){
  var that;
  if (that = /^['"](.*)['"]$/.exec(val.trim())) {
    return that[1];
  } else {
    return val;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>